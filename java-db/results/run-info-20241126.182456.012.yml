---
queries:
 -
  pack: codeql/java-queries#0
  relativeQueryPath: Advisory/Declarations/MissingOverrideAnnotation.ql
  relativeBqrsPath: codeql/java-queries/Advisory/Declarations/MissingOverrideAnnotation.bqrs
  metadata:
    name: Missing Override annotation
    description: |-
      A method that overrides a method in a superclass but does not have an 'Override'
                    annotation cannot take advantage of compiler checks, and makes code less readable.
    kind: problem
    problem.severity: recommendation
    precision: high
    id: java/missing-override-annotation
    tags: maintainability
  queryHelp: "# Missing Override annotation\nJava enables you to annotate methods\
    \ that are intended to override a method in a superclass. Compilers are required\
    \ to generate an error if such an annotated method does not override a method\
    \ in a superclass, which provides increased protection from potential defects.\
    \ An annotated method also improves code readability.\n\n\n## Recommendation\n\
    Add an `@Override` annotation to a method that is intended to override a method\
    \ in a superclass.\n\n\n## Example\nIn the following example, `Triangle.getArea`\
    \ overrides `Rectangle.getArea`, so it is annotated with `@Override`.\n\n\n```java\n\
    class Rectangle\n{\n    private int w = 10, h = 10;\n    public int getArea()\
    \ { \n        return w * h; \n    }\n}\n \nclass Triangle extends Rectangle\n\
    {\n    @Override  // Annotation of an overriding method \n    public int getArea()\
    \ { \n        return super.getArea() / 2; \n    }\n}\n```\n\n## References\n*\
    \ J. Bloch, *Effective Java (second edition)*, Item 36. Addison-Wesley, 2008.\n\
    * Help - Eclipse Platform: [Java Compiler Errors/Warnings Preferences](https://help.eclipse.org/2020-12/advanced/content.jsp?topic=/org.eclipse.jdt.doc.user/reference/preferences/java/compiler/ref-preferences-errors-warnings.htm).\n\
    * Java API Specification: [Annotation Type Override](https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/lang/Override.html).\n\
    * The Java Tutorials: [Predefined Annotation Types](https://docs.oracle.com/javase/tutorial/java/annotations/predefined.html).\n"
 -
  pack: codeql/java-queries#0
  relativeQueryPath: Advisory/Declarations/NonFinalImmutableField.ql
  relativeBqrsPath: codeql/java-queries/Advisory/Declarations/NonFinalImmutableField.bqrs
  metadata:
    name: Non-final immutable field
    description: |-
      A field of immutable type that is assigned to only in a constructor or static
                    initializer of its declaring type, but is not declared 'final', may lead to defects
                    and makes code less readable.
    kind: problem
    problem.severity: recommendation
    precision: medium
    id: java/non-final-immutable-field
    tags: reliability
  queryHelp: |
    # Non-final immutable field
    A field of immutable type that is not declared `final`, but is assigned to only in a constructor or static initializer of its declaring type, may lead to defects and makes code less readable. This is because other parts of the code may be based on the assumption that the field has a constant value, and a later modification, which includes an assignment to the field, may invalidate this assumption.


    ## Recommendation
    If a field of immutable type is assigned to only during class or instance initialization, you should usually declare it `final`. This forces the compiler to verify that the field value cannot be changed subsequently, which can help to avoid defects and increase code readability.


    ## References
    * Java Language Specification: [4.12.4 final Variables](https://docs.oracle.com/javase/specs/jls/se11/html/jls-4.html#jls-4.12.4), [8.3.1.2 final Fields](https://docs.oracle.com/javase/specs/jls/se11/html/jls-8.html#jls-8.3.1.2).
 -
  pack: codeql/java-queries#0
  relativeQueryPath: Advisory/Declarations/NonPrivateField.ql
  relativeBqrsPath: codeql/java-queries/Advisory/Declarations/NonPrivateField.bqrs
  metadata:
    name: Non-private field
    description: |-
      A non-constant field that is not declared 'private',
                    but is not accessed outside of its declaring type, may decrease code maintainability.
    kind: problem
    problem.severity: recommendation
    precision: medium
    id: java/non-private-field
    tags: maintainability
  queryHelp: |
    # Non-private field
    A non-final or non-static field that is not declared `private`, but is not accessed outside of its declaring type, may decrease code maintainability. This is because a field that is accessible from outside the class that it is declared in tends to restrict the class to a particular implementation.


    ## Recommendation
    In the spirit of encapsulation, it is generally advisable to choose the most restrictive access modifier (`private`) for a field, unless there is a good reason to increase its visibility.


    ## References
    * J. Bloch, *Effective Java (second edition)*, Item 13. Addison-Wesley, 2008.
    * The Java Tutorials: [Controlling Access to Members of a Class](https://docs.oracle.com/javase/tutorial/java/javaOO/accesscontrol.html).
 -
  pack: codeql/java-queries#0
  relativeQueryPath: Advisory/Deprecated Code/AvoidDeprecatedCallableAccess.ql
  relativeBqrsPath: codeql/java-queries/Advisory/Deprecated Code/AvoidDeprecatedCallableAccess.bqrs
  metadata:
    name: Deprecated method or constructor invocation
    description: |-
      Using a method or constructor that has been marked as deprecated may be dangerous or
                    fail to take advantage of a better method or constructor.
    kind: problem
    problem.severity: recommendation
    precision: high
    id: java/deprecated-call
    tags: |-
      maintainability
             non-attributable
             external/cwe/cwe-477
  queryHelp: |
    # Deprecated method or constructor invocation
    A method (or constructor) can be marked as deprecated using either the `@Deprecated` annotation or the `@deprecated` Javadoc tag. Using a method that has been marked as deprecated is bad practice, typically for one or more of the following reasons:

    * The method is dangerous.
    * There is a better alternative method.
    * Methods that are marked as deprecated are often removed from future versions of an API. So using a deprecated method may cause extra maintenance effort when the API is upgraded.

    ## Recommendation
    Avoid using a method that has been marked as deprecated. Follow any guidance that is provided with the `@deprecated` Javadoc tag, which should explain how to replace the call to the deprecated method.


    ## References
    * Help - Eclipse Platform: [Java Compiler Errors/Warnings Preferences](https://help.eclipse.org/2020-12/advanced/content.jsp?topic=/org.eclipse.jdt.doc.user/reference/preferences/java/compiler/ref-preferences-errors-warnings.htm).
    * Java API Specification: [Annotation Type Deprecated](https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/lang/Deprecated.html).
    * Java SE Documentation: [How and When To Deprecate APIs](https://docs.oracle.com/javase/8/docs/technotes/guides/javadoc/deprecation/deprecation.html).
    * Common Weakness Enumeration: [CWE-477](https://cwe.mitre.org/data/definitions/477.html).
 -
  pack: codeql/java-queries#0
  relativeQueryPath: Advisory/Documentation/ImpossibleJavadocThrows.ql
  relativeBqrsPath: codeql/java-queries/Advisory/Documentation/ImpossibleJavadocThrows.bqrs
  metadata:
    name: Javadoc has impossible 'throws' tag
    description: |-
      Javadoc that incorrectly claims a method or constructor can throw an exception
                    is misleading.
    kind: problem
    problem.severity: recommendation
    precision: high
    id: java/inconsistent-javadoc-throws
    tags: maintainability
  queryHelp: "# Javadoc has impossible 'throws' tag\nA Javadoc `@throws` or `@exception`\
    \ tag that references an exception that cannot be thrown is misleading.\n\n\n\
    ## Recommendation\nEnsure that you only include the `@throws` or `@exception`\
    \ tags in Javadoc when an exception can be thrown.\n\n\n## Example\nThe following\
    \ example shows a method with Javadoc that claims it can throw `Exception`. Since\
    \ `Exception` is a checked exception and the method does not declare that it may\
    \ throw an exception, the Javadoc is wrong and should be updated.\n\n\n```java\n\
    /**\n * Javadoc for method.\n *\n * @throws Exception if a problem occurs.\n */\n\
    public void noThrow() {\n\tSystem.out.println(\"This method does not throw.\"\
    );\n}\n```\nIn the following example the Javadoc has been corrected by removing\
    \ the `@throws` tag.\n\n\n```java\n/**\n * Javadoc for method.\n */\npublic void\
    \ noThrow() {\n\tSystem.out.println(\"This method does not throw.\");\n}\n```\n\
    \n## References\n* Java SE Documentation: [How to Write Doc Comments for the Javadoc\
    \ Tool](https://www.oracle.com/technical-resources/articles/java/javadoc-tool.html#throwstag),\n"
 -
  pack: codeql/java-queries#0
  relativeQueryPath: Advisory/Documentation/MissingJavadocMethods.ql
  relativeBqrsPath: codeql/java-queries/Advisory/Documentation/MissingJavadocMethods.bqrs
  metadata:
    name: Missing Javadoc for public method or constructor
    description: |-
      A public method or constructor that does not have a Javadoc comment affects
                    maintainability.
    kind: problem
    problem.severity: recommendation
    precision: medium
    id: java/undocumented-function
    tags: maintainability
  queryHelp: "# Missing Javadoc for public method or constructor\nA public method\
    \ or constructor that does not have a Javadoc comment makes an API more difficult\
    \ to understand and maintain.\n\n\n## Recommendation\nPublic methods and constructors\
    \ should be documented to make an API usable. For the purpose of code maintainability,\
    \ it is also advisable to document non-public methods and constructors.\n\nThe\
    \ Javadoc comment should describe *what* the method or constructor does rather\
    \ than *how*, to allow for any potential implementation change that is invisible\
    \ to users of an API. It should include the following:\n\n* A description of any\
    \ preconditions or postconditions\n* Javadoc tag elements that describe any parameters,\
    \ return value, and thrown exceptions\n* Any other important aspects such as side-effects\
    \ and thread safety\nDocumentation for users of an API should be written using\
    \ the standard Javadoc format. This can be accessed conveniently by users of an\
    \ API from within standard IDEs, and can be transformed automatically into HTML\
    \ format.\n\n\n## Example\nThe following example shows a good Javadoc comment,\
    \ which clearly explains what the method does, its parameter, return value, and\
    \ thrown exception.\n\n\n```java\n/**\n * Extracts the user's name from the input\
    \ arguments.\n *\n * Precondition: 'args' should contain at least one element,\
    \ the user's name.\n *\n * @param  args            the command-line arguments.\n\
    \ * @return                 the user's name (the first command-line argument).\n\
    \ * @throws NoNameException if 'args' contains no element.\n */\npublic static\
    \ String getName(String[] args) throws NoNameException {\n\tif(args.length ==\
    \ 0) {\n\t\tthrow new NoNameException();\n\t} else {\n\t\treturn args[0];\n\t\
    }\n}\n```\n\n## References\n* J. Bloch, *Effective Java (second edition)*, Item\
    \ 44. Addison-Wesley, 2008.\n* Help - Eclipse Platform: [Java Compiler Javadoc\
    \ Preferences](https://help.eclipse.org/2020-12/advanced/content.jsp?topic=/org.eclipse.jdt.doc.user/reference/preferences/java/compiler/ref-preferences-javadoc.htm).\n\
    * Java SE Documentation: [How to Write Doc Comments for the Javadoc Tool](https://www.oracle.com/technical-resources/articles/java/javadoc-tool.html),\
    \ [Requirements for Writing Java API Specifications](https://www.oracle.com/java/technologies/javase/api-specifications.html).\n"
 -
  pack: codeql/java-queries#0
  relativeQueryPath: Advisory/Documentation/MissingJavadocParameters.ql
  relativeBqrsPath: codeql/java-queries/Advisory/Documentation/MissingJavadocParameters.bqrs
  metadata:
    name: Missing Javadoc for parameter
    description: |-
      A public method or constructor that does not have a Javadoc tag for each parameter
                    affects maintainability.
    kind: problem
    problem.severity: recommendation
    precision: medium
    id: java/undocumented-parameter
    tags: maintainability
  queryHelp: "# Missing Javadoc for parameter\nA public method or constructor that\
    \ does not have a Javadoc tag for each parameter makes an API more difficult to\
    \ understand and maintain.\n\n\n## Recommendation\nThe Javadoc comment for a method\
    \ or constructor should include a Javadoc tag element that describes each parameter.\n\
    \n\n## Example\nThe following example shows a good Javadoc comment, which clearly\
    \ explains the method's parameter.\n\n\n```java\n/**\n * Extracts the user's name\
    \ from the input arguments.\n *\n * Precondition: 'args' should contain at least\
    \ one element, the user's name.\n *\n * @param  args            the command-line\
    \ arguments.\n * @return                 the user's name (the first command-line\
    \ argument).\n * @throws NoNameException if 'args' contains no element.\n */\n\
    public static String getName(String[] args) throws NoNameException {\n\tif(args.length\
    \ == 0) {\n\t\tthrow new NoNameException();\n\t} else {\n\t\treturn args[0];\n\
    \t}\n}\n```\n\n## References\n* J. Bloch, *Effective Java (second edition)*, Item\
    \ 44. Addison-Wesley, 2008.\n* Help - Eclipse Platform: [Java Compiler Javadoc\
    \ Preferences](https://help.eclipse.org/2020-12/advanced/content.jsp?topic=/org.eclipse.jdt.doc.user/reference/preferences/java/compiler/ref-preferences-javadoc.htm).\n\
    * Java SE Documentation: [How to Write Doc Comments for the Javadoc Tool](https://www.oracle.com/technical-resources/articles/java/javadoc-tool.html),\
    \ [Requirements for Writing Java API Specifications](https://www.oracle.com/java/technologies/javase/api-specifications.html).\n"
 -
  pack: codeql/java-queries#0
  relativeQueryPath: Advisory/Documentation/MissingJavadocReturnValues.ql
  relativeBqrsPath: codeql/java-queries/Advisory/Documentation/MissingJavadocReturnValues.bqrs
  metadata:
    name: Missing Javadoc for method return value
    description: |-
      A public method that does not have a Javadoc tag for its return
                    value affects maintainability.
    kind: problem
    problem.severity: recommendation
    precision: medium
    id: java/undocumented-return-value
    tags: maintainability
  queryHelp: "# Missing Javadoc for method return value\nA public method that does\
    \ not have a Javadoc tag for its return value makes an API more difficult to understand\
    \ and maintain.\n\n\n## Recommendation\nThe Javadoc comment for a method should\
    \ include a Javadoc tag element that describes the return value.\n\n\n## Example\n\
    The following example shows a good Javadoc comment, which clearly explains the\
    \ method's return value.\n\n\n```java\n/**\n * Extracts the user's name from the\
    \ input arguments.\n *\n * Precondition: 'args' should contain at least one element,\
    \ the user's name.\n *\n * @param  args            the command-line arguments.\n\
    \ * @return                 the user's name (the first command-line argument).\n\
    \ * @throws NoNameException if 'args' contains no element.\n */\npublic static\
    \ String getName(String[] args) throws NoNameException {\n\tif(args.length ==\
    \ 0) {\n\t\tthrow new NoNameException();\n\t} else {\n\t\treturn args[0];\n\t\
    }\n}\n```\n\n## References\n* J. Bloch, *Effective Java (second edition)*, Item\
    \ 44. Addison-Wesley, 2008.\n* Help - Eclipse Platform: [Java Compiler Javadoc\
    \ Preferences](https://help.eclipse.org/2020-12/advanced/content.jsp?topic=/org.eclipse.jdt.doc.user/reference/preferences/java/compiler/ref-preferences-javadoc.htm).\n\
    * Java SE Documentation: [How to Write Doc Comments for the Javadoc Tool](https://www.oracle.com/technical-resources/articles/java/javadoc-tool.html),\
    \ [Requirements for Writing Java API Specifications](https://www.oracle.com/java/technologies/javase/api-specifications.html).\n"
 -
  pack: codeql/java-queries#0
  relativeQueryPath: Advisory/Documentation/MissingJavadocThrows.ql
  relativeBqrsPath: codeql/java-queries/Advisory/Documentation/MissingJavadocThrows.bqrs
  metadata:
    name: Missing Javadoc for thrown exception
    description: |-
      A public method or constructor that throws an exception but does not have a
                    Javadoc tag for the exception affects maintainability.
    kind: problem
    problem.severity: recommendation
    precision: medium
    id: java/undocumented-exception
    tags: maintainability
  queryHelp: "# Missing Javadoc for thrown exception\nA public method or constructor\
    \ that throws an exception but does not have a Javadoc tag for the exception makes\
    \ an API more difficult to understand and maintain. This includes checked exceptions\
    \ in `throws` clauses and unchecked exceptions that are explicitly thrown in `throw`\
    \ statements.\n\n\n## Recommendation\nThe Javadoc comment for a method or constructor\
    \ should include a Javadoc tag element that describes each thrown exception.\n\
    \n\n## Example\nThe following example shows a good Javadoc comment, which clearly\
    \ explains the method's thrown exception.\n\n\n```java\n/**\n * Extracts the user's\
    \ name from the input arguments.\n *\n * Precondition: 'args' should contain at\
    \ least one element, the user's name.\n *\n * @param  args            the command-line\
    \ arguments.\n * @return                 the user's name (the first command-line\
    \ argument).\n * @throws NoNameException if 'args' contains no element.\n */\n\
    public static String getName(String[] args) throws NoNameException {\n\tif(args.length\
    \ == 0) {\n\t\tthrow new NoNameException();\n\t} else {\n\t\treturn args[0];\n\
    \t}\n}\n```\n\n## References\n* J. Bloch, *Effective Java (second edition)*, Items\
    \ 44 and 62. Addison-Wesley, 2008.\n* Help - Eclipse Platform: [Java Compiler\
    \ Javadoc Preferences](https://help.eclipse.org/2020-12/advanced/content.jsp?topic=/org.eclipse.jdt.doc.user/reference/preferences/java/compiler/ref-preferences-javadoc.htm).\n\
    * Java SE Documentation: [How to Write Doc Comments for the Javadoc Tool](https://www.oracle.com/technical-resources/articles/java/javadoc-tool.html),\
    \ [Requirements for Writing Java API Specifications](https://www.oracle.com/java/technologies/javase/api-specifications.html).\n"
 -
  pack: codeql/java-queries#0
  relativeQueryPath: Advisory/Documentation/MissingJavadocTypes.ql
  relativeBqrsPath: codeql/java-queries/Advisory/Documentation/MissingJavadocTypes.bqrs
  metadata:
    name: Missing Javadoc for public type
    description: |-
      A public class or interface that does not have a Javadoc comment affects
                    maintainability.
    kind: problem
    problem.severity: recommendation
    precision: medium
    id: java/undocumented-type
    tags: maintainability
  queryHelp: "# Missing Javadoc for public type\nA public class or interface that\
    \ does not have a Javadoc comment makes an API more difficult to understand and\
    \ maintain.\n\n\n## Recommendation\nPublic classes and interfaces should be documented\
    \ to make an API usable. For the purpose of code maintainability, it is also advisable\
    \ to document non-public classes and interfaces.\n\nDocumentation for users of\
    \ an API should be written using the standard Javadoc format. This can be accessed\
    \ conveniently by users of an API from within standard IDEs, and can be transformed\
    \ automatically into HTML format.\n\n\n## Example\nThe following example shows\
    \ a good Javadoc comment, which clearly explains what the class does, its author,\
    \ and version.\n\n\n```java\n/**\n * The Stack class represents a last-in-first-out\
    \ stack of objects. \n *\n * @author  Joseph Bergin\n * @version 1.0, May 2000\n\
    \ * Note that this version is not thread safe. \n */\npublic class Stack {\n//\
    \ ...\n```\n\n## References\n* J. Bloch, *Effective Java (second edition)*, Item\
    \ 44. Addison-Wesley, 2008.\n* Help - Eclipse Platform: [Java Compiler Javadoc\
    \ Preferences](https://help.eclipse.org/2020-12/advanced/content.jsp?topic=/org.eclipse.jdt.doc.user/reference/preferences/java/compiler/ref-preferences-javadoc.htm).\n\
    * Java SE Documentation: [How to Write Doc Comments for the Javadoc Tool](https://www.oracle.com/technical-resources/articles/java/javadoc-tool.html),\
    \ [Requirements for Writing Java API Specifications](https://www.oracle.com/java/technologies/javase/api-specifications.html).\n"
 -
  pack: codeql/java-queries#0
  relativeQueryPath: Advisory/Documentation/SpuriousJavadocParam.ql
  relativeBqrsPath: codeql/java-queries/Advisory/Documentation/SpuriousJavadocParam.bqrs
  metadata:
    name: Spurious Javadoc @param tags
    description: |-
      Javadoc @param tags that do not match any parameters in the method or constructor or
                    any type parameters of the annotated class are confusing.
    kind: problem
    problem.severity: recommendation
    precision: very-high
    id: java/unknown-javadoc-parameter
    tags: maintainability
  queryHelp: "# Spurious Javadoc @param tags\nJavadoc comments for public methods,\
    \ constructors and generic classes should use the `@param` tag to describe the\
    \ available parameters and type parameters. If the comment includes any empty,\
    \ incorrect or outdated parameter names then this will make the documentation\
    \ more difficult to read.\n\n\n## Recommendation\nThe Javadoc comment for a method,\
    \ constructor or generic class should always use non-empty `@param` values that\
    \ match actual parameter or type parameter names.\n\n\n## Example\nThe following\
    \ example shows good and bad Javadoc comments that use the `@param` tag.\n\n\n\
    ```java\n/**\n * BAD: The following param tag is empty.\n *\n * @param   \n */\
    \ \npublic void emptyParamTag(int p){ ... }\n\n\n/**\n * BAD: The following param\
    \ tag has a misspelled value.\n *\n * @param prameter The parameter's value.\n\
    \ */ \npublic void typo(int parameter){ ... }\n\n\n/**\n * BAD: The following\
    \ param tag appears to be outdated\n * since the method does not take any parameters.\n\
    \ *\n * @param sign The number's sign.\n */ \npublic void outdated(){ ... }\n\n\
    \n/**\n * BAD: The following param tag uses html within the tag value.\n *\n *\
    \ @param <code>ordinate</code> The value of the y coordinate.\n */ \npublic void\
    \ html(int ordinate){ ... }\n\n\n/**\n * BAD: Invalid syntax for type parameter.\n\
    \ *\n * @param T The type of the parameter.\n * @param parameter The parameter\
    \ value.\n */ \npublic <T> void parameterized(T parameter){ ... }\n\n/**\n * BAD:\
    \ The following param tag refers to a non-existent type parameter.\n * \n * @param\
    \ <X> The type of the elements.\n */\nclass Generic<T> { ... }\n\n/**\n * GOOD:\
    \ A proper Javadoc comment.\n *\n * This method calculates the absolute value\
    \ of a given number.\n *\n * @param <T> The number's type.\n * @param x The number\
    \ to calculate the absolute value of.\n * @return The absolute value of <code>x</code>.\n\
    \ */ \npublic <T extends Number> T abs(T x){ ... }\n\n```\n\n## References\n*\
    \ Help - Eclipse Platform: [Java Compiler Javadoc Preferences](https://help.eclipse.org/2020-12/advanced/content.jsp?topic=/org.eclipse.jdt.doc.user/reference/preferences/java/compiler/ref-preferences-javadoc.htm).\n\
    * Java SE Documentation: [How to Write Doc Comments for the Javadoc Tool](https://www.oracle.com/technical-resources/articles/java/javadoc-tool.html#@param),\
    \ [Documentation Comment Specification for the Standard Doclet](https://docs.oracle.com/en/java/javase/11/docs/specs/doc-comment-spec.html#param)\n"
 -
  pack: codeql/java-queries#0
  relativeQueryPath: Advisory/Java Objects/AvoidCloneMethodAccess.ql
  relativeBqrsPath: codeql/java-queries/Advisory/Java Objects/AvoidCloneMethodAccess.bqrs
  metadata:
    name: Use of clone() method
    description: |-
      Calling a method that overrides 'Object.clone' is bad practice. Copying an object
                    using the 'Cloneable interface' and 'Object.clone' is error-prone.
    kind: problem
    problem.severity: recommendation
    precision: medium
    id: java/use-of-clone-method
    tags: reliability
  queryHelp: |
    # Use of clone() method
    Copying an object using the `Cloneable` interface and the `Object.clone` method is error-prone. This is because the `Cloneable` interface and the `clone` method are unusual:

    * The `Cloneable` interface has no methods. Its only use is to trigger different behavior of `Object.clone`.
    * `Object.clone` is protected.
    * `Object.clone` creates a shallow copy without calling a constructor.
    The first two points mean that a programmer must do two things to get a useful implementation of `clone`: first, make the class implement `Cloneable` to change the behavior of `Object.clone` so that it makes a copy instead of throwing a `CloneNotSupportedException`; second, override `clone` to make it public, to allow it to be called. Another consequence of `Cloneable` not having any methods is that it does not say anything about an object that implements it, which means that you cannot perform a polymorphic clone operation.

    The third point, `Object.clone` creating a shallow copy, is the most serious one. A shallow copy shares internal state with the original object. This includes private fields that the programmer might not be aware of. A change to the internal state of the original object could affect the copy, and conversely the opposite is true, which could easily lead to unexpected behavior.


    ## Recommendation
    Define either a dedicated copy method or a copy constructor (with a parameter whose type is the same as the type that declares the constructor). In most cases, this is at least as good as using the `Cloneable` interface and the `Object.clone` method, without the subtlety involved in implementing and using `clone` correctly.


    ## Example
    In the following example, class `Galaxy` includes a copy constructor. Its parameter is of type `Galaxy`.


    ```java
    public final class Galaxy {

        // This is the original constructor.
        public Galaxy (double aMass, String aName) {
            fMass = aMass;
            fName = aName;
        }

        // This is the copy constructor.
        public Galaxy(Galaxy aGalaxy) {
            this(aGalaxy.getMass(), aGalaxy.getName());
        }

        // ...
    }
    ```

    ## References
    * J. Bloch, *Effective Java (second edition)*, Item 11. Addison-Wesley, 2008.
    * Java API Specification: [Interface Cloneable](https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/lang/Cloneable.html), [Object.clone](https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/lang/Object.html#clone()).
 -
  pack: codeql/java-queries#0
  relativeQueryPath: Advisory/Java Objects/AvoidCloneOverride.ql
  relativeBqrsPath: codeql/java-queries/Advisory/Java Objects/AvoidCloneOverride.bqrs
  metadata:
    name: Overriding definition of clone()
    description: |-
      Overriding 'Object.clone' is bad practice. Copying an object using the 'Cloneable
                    interface' and 'Object.clone' is error-prone.
    kind: problem
    problem.severity: recommendation
    precision: medium
    id: java/override-of-clone-method
    tags: reliability
  queryHelp: |
    # Overriding definition of clone()
    Copying an object using the `Cloneable` interface and the `Object.clone` method is error-prone. This is because the `Cloneable` interface and the `clone` method are unusual:

    * The `Cloneable` interface has no methods. Its only use is to trigger different behavior of `Object.clone`.
    * `Object.clone` is protected.
    * `Object.clone` creates a shallow copy without calling a constructor.
    The first two points mean that a programmer must do two things to get a useful implementation of `clone`: first, make the class implement `Cloneable` to change the behavior of `Object.clone` so that it makes a copy instead of throwing a `CloneNotSupportedException`; second, override `clone` to make it public, to allow it to be called. Another consequence of `Cloneable` not having any methods is that it does not say anything about an object that implements it, which means that you cannot perform a polymorphic clone operation.

    The third point, `Object.clone` creating a shallow copy, is the most serious one. A shallow copy shares internal state with the original object. This includes private fields that the programmer might not be aware of. A change to the internal state of the original object could affect the copy, and conversely the opposite is true, which could easily lead to unexpected behavior.


    ## Recommendation
    Define either a dedicated copy method or a copy constructor (with a parameter whose type is the same as the type that declares the constructor). In most cases, this is at least as good as using the `Cloneable` interface and the `Object.clone` method, without the subtlety involved in implementing and using `clone` correctly.


    ## Example
    In the following example, class `Galaxy` includes a copy constructor. Its parameter is of type `Galaxy`.


    ```java
    public final class Galaxy {

        // This is the original constructor.
        public Galaxy (double aMass, String aName) {
            fMass = aMass;
            fName = aName;
        }

        // This is the copy constructor.
        public Galaxy(Galaxy aGalaxy) {
            this(aGalaxy.getMass(), aGalaxy.getName());
        }

        // ...
    }
    ```

    ## References
    * J. Bloch, *Effective Java (second edition)*, Item 11. Addison-Wesley, 2008.
    * Java API Specification: [Interface Cloneable](https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/lang/Cloneable.html), [Object.clone](https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/lang/Object.html#clone()).
 -
  pack: codeql/java-queries#0
  relativeQueryPath: Advisory/Java Objects/AvoidCloneableInterface.ql
  relativeBqrsPath: codeql/java-queries/Advisory/Java Objects/AvoidCloneableInterface.bqrs
  metadata:
    name: Use of Cloneable interface
    description: |-
      Using the 'Cloneable' interface is bad practice. Copying an object using the
                    'Cloneable interface' and 'Object.clone' is error-prone.
    kind: problem
    problem.severity: recommendation
    precision: medium
    id: java/use-of-cloneable-interface
    tags: reliability
  queryHelp: |
    # Use of Cloneable interface
    Copying an object using the `Cloneable` interface and the `Object.clone` method is error-prone. This is because the `Cloneable` interface and the `clone` method are unusual:

    * The `Cloneable` interface has no methods. Its only use is to trigger different behavior of `Object.clone`.
    * `Object.clone` is protected.
    * `Object.clone` creates a shallow copy without calling a constructor.
    The first two points mean that a programmer must do two things to get a useful implementation of `clone`: first, make the class implement `Cloneable` to change the behavior of `Object.clone` so that it makes a copy instead of throwing a `CloneNotSupportedException`; second, override `clone` to make it public, to allow it to be called. Another consequence of `Cloneable` not having any methods is that it does not say anything about an object that implements it, which means that you cannot perform a polymorphic clone operation.

    The third point, `Object.clone` creating a shallow copy, is the most serious one. A shallow copy shares internal state with the original object. This includes private fields that the programmer might not be aware of. A change to the internal state of the original object could affect the copy, and conversely the opposite is true, which could easily lead to unexpected behavior.


    ## Recommendation
    Define either a dedicated copy method or a copy constructor (with a parameter whose type is the same as the type that declares the constructor). In most cases, this is at least as good as using the `Cloneable` interface and the `Object.clone` method, without the subtlety involved in implementing and using `clone` correctly.


    ## Example
    In the following example, class `Galaxy` includes a copy constructor. Its parameter is of type `Galaxy`.


    ```java
    public final class Galaxy {

        // This is the original constructor.
        public Galaxy (double aMass, String aName) {
            fMass = aMass;
            fName = aName;
        }

        // This is the copy constructor.
        public Galaxy(Galaxy aGalaxy) {
            this(aGalaxy.getMass(), aGalaxy.getName());
        }

        // ...
    }
    ```

    ## References
    * J. Bloch, *Effective Java (second edition)*, Item 11. Addison-Wesley, 2008.
    * Java API Specification: [Interface Cloneable](https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/lang/Cloneable.html), [Object.clone](https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/lang/Object.html#clone()).
 -
  pack: codeql/java-queries#0
  relativeQueryPath: Advisory/Java Objects/AvoidFinalizeOverride.ql
  relativeBqrsPath: codeql/java-queries/Advisory/Java Objects/AvoidFinalizeOverride.bqrs
  metadata:
    name: Overriding definition of finalize()
    description: Overriding 'Object.finalize' is not a reliable way to terminate use
      of resources.
    kind: problem
    problem.severity: recommendation
    precision: medium
    id: java/override-of-finalize-method
    tags: reliability
  queryHelp: |
    # Overriding definition of finalize()
    Overriding the `Object.finalize` method is not a reliable way to terminate use of resources. In particular, there are no guarantees regarding the timeliness of finalizer execution.


    ## Recommendation
    Provide explicit termination methods, which should be called by users of an API.


    ## References
    * J. Bloch, *Effective Java (second edition)*, Item 7. Addison-Wesley, 2008.
    * Java Language Specification: [12.6. Finalization of Class Instances](https://docs.oracle.com/javase/specs/jls/se11/html/jls-12.html#jls-12.6).
 -
  pack: codeql/java-queries#0
  relativeQueryPath: Advisory/Naming/NamingConventionsConstants.ql
  relativeBqrsPath: codeql/java-queries/Advisory/Naming/NamingConventionsConstants.bqrs
  metadata:
    name: Misnamed static final field
    description: "A static, final field name that contains lowercase letters decreases\
      \ readability."
    kind: problem
    problem.severity: recommendation
    precision: medium
    id: java/misnamed-constant
    tags: maintainability
  queryHelp: |
    # Misnamed static final field
    A static, final field name that contains lowercase letters does not follow standard naming conventions, which decreases code readability. For example, `Min_Width`.


    ## Recommendation
    Use uppercase letters throughout a static, final field name, and use underscores to separate words within the field name. For example, `MIN_WIDTH`.


    ## References
    * J. Bloch, *Effective Java (second edition)*, Item 56. Addison-Wesley, 2008.
    * Java Language Specification: [6.1. Declarations](https://docs.oracle.com/javase/specs/jls/se11/html/jls-6.html#jls-6.1).
    * Java SE Documentation: [9 - Naming Conventions](https://www.oracle.com/java/technologies/javase/codeconventions-namingconventions.html).
 -
  pack: codeql/java-queries#0
  relativeQueryPath: Advisory/Naming/NamingConventionsMethods.ql
  relativeBqrsPath: codeql/java-queries/Advisory/Naming/NamingConventionsMethods.bqrs
  metadata:
    name: Misnamed method
    description: A method name that begins with an uppercase letter decreases readability.
    kind: problem
    problem.severity: recommendation
    precision: medium
    id: java/misnamed-function
    tags: maintainability
  queryHelp: |
    # Misnamed method
    A method name that begins with an uppercase letter does not follow standard naming conventions, which decreases code readability. For example, `Getbackground`.


    ## Recommendation
    Begin the method name with a lowercase letter and use camel case: capitalize the first letter of each word within the method name. For example, `getBackground`.


    ## References
    * J. Bloch, *Effective Java (second edition)*, Item 56. Addison-Wesley, 2008.
    * Java Language Specification: [6.1. Declarations](https://docs.oracle.com/javase/specs/jls/se11/html/jls-6.html#jls-6.1).
    * Java SE Documentation: [9 - Naming Conventions](https://www.oracle.com/java/technologies/javase/codeconventions-namingconventions.html).
 -
  pack: codeql/java-queries#0
  relativeQueryPath: Advisory/Naming/NamingConventionsPackages.ql
  relativeBqrsPath: codeql/java-queries/Advisory/Naming/NamingConventionsPackages.bqrs
  metadata:
    name: Misnamed package
    description: A package name that contains uppercase letters decreases readability.
    kind: problem
    problem.severity: recommendation
    precision: medium
    id: java/misnamed-package
    tags: maintainability
  queryHelp: |
    # Misnamed package
    A package name that contains uppercase letters does not follow standard naming conventions, which decreases code readability. For example, `Com.Sun.Eng`.


    ## Recommendation
    Use lowercase letters throughout a package name. For example, `com.sun.eng`.


    ## References
    * J. Bloch, *Effective Java (second edition)*, Item 56. Addison-Wesley, 2008.
    * Java Language Specification: [6.1. Declarations](https://docs.oracle.com/javase/specs/jls/se11/html/jls-6.html#jls-6.1).
    * Java SE Documentation: [9 - Naming Conventions](https://www.oracle.com/java/technologies/javase/codeconventions-namingconventions.html).
 -
  pack: codeql/java-queries#0
  relativeQueryPath: Advisory/Naming/NamingConventionsRefTypes.ql
  relativeBqrsPath: codeql/java-queries/Advisory/Naming/NamingConventionsRefTypes.bqrs
  metadata:
    name: Misnamed class or interface
    description: A class or interface name that begins with a lowercase letter decreases
      readability.
    kind: problem
    problem.severity: recommendation
    precision: medium
    id: java/misnamed-type
    tags: maintainability
  queryHelp: |
    # Misnamed class or interface
    A class or interface name that begins with a lowercase letter does not follow standard naming conventions, which decreases code readability. For example, `hotelbooking`.


    ## Recommendation
    Begin the class name with an uppercase letter and use camel case: capitalize the first letter of each word within the class name. For example, `HotelBooking`.


    ## References
    * J. Bloch, *Effective Java (second edition)*, Item 56. Addison-Wesley, 2008.
    * Java Language Specification: [6.1. Declarations](https://docs.oracle.com/javase/specs/jls/se11/html/jls-6.html#jls-6.1).
    * Java SE Documentation: [9 - Naming Conventions](https://www.oracle.com/java/technologies/javase/codeconventions-namingconventions.html).
 -
  pack: codeql/java-queries#0
  relativeQueryPath: Advisory/Naming/NamingConventionsVariables.ql
  relativeBqrsPath: codeql/java-queries/Advisory/Naming/NamingConventionsVariables.bqrs
  metadata:
    name: Misnamed variable
    description: A variable name that begins with an uppercase letter decreases readability.
    kind: problem
    problem.severity: recommendation
    precision: medium
    id: java/misnamed-variable
    tags: maintainability
  queryHelp: |
    # Misnamed variable
    A variable name that begins with an uppercase letter does not follow standard naming conventions, which decreases code readability. For example, `Numberofguests`. This applies to local variables, parameters, and non-constant fields.


    ## Recommendation
    Begin the variable name with a lowercase letter and use camel case: capitalize the first letter of each word within the variable name. For example, `numberOfGuests`.


    ## References
    * J. Bloch, *Effective Java (second edition)*, Item 56. Addison-Wesley, 2008.
    * Java Language Specification: [6.1. Declarations](https://docs.oracle.com/javase/specs/jls/se11/html/jls-6.html#jls-6.1).
    * Java SE Documentation: [9 - Naming Conventions](https://www.oracle.com/java/technologies/javase/codeconventions-namingconventions.html).
 -
  pack: codeql/java-queries#0
  relativeQueryPath: Advisory/Statements/MissingDefaultInSwitch.ql
  relativeBqrsPath: codeql/java-queries/Advisory/Statements/MissingDefaultInSwitch.bqrs
  metadata:
    name: Missing default case in switch
    description: |-
      A 'switch' statement that is based on a non-enumerated type and that does not have a
                    'default' case may allow execution to 'fall through' silently.
    kind: problem
    problem.severity: recommendation
    precision: medium
    id: java/missing-default-in-switch
    tags: |-
      reliability
             external/cwe/cwe-478
  queryHelp: |
    # Missing default case in switch
    A `switch` statement without a `default` case may allow execution to 'fall through' silently, if no cases are matched.


    ## Recommendation
    In a `switch` statement that is based on a variable of a non-enumerated type, include a `default` case to prevent execution from falling through silently when no cases are matched. If the `default` case is intended to be unreachable code, it is advisable that it throws a `RuntimeException` to alert the user of an internal error.


    ## Example
    In the following example, the `switch` statement outputs the menu choice that the user has made. However, if the user does not choose 1, 2, or 3, execution falls through silently.


    ```java
    int menuChoice;

    // ...

    switch (menuChoice) {
        case 1:
            System.out.println("You chose number 1.");
            break;
        case 2:
            System.out.println("You chose number 2.");
            break;
        case 3:
            System.out.println("You chose number 3.");
            break;
        // BAD: No 'default' case
    }
    ```
    In the following modified example, the `switch` statement includes a `default` case, to allow for the user making an invalid menu choice.


    ```java
    int menuChoice;

    // ...

    switch (menuChoice) {
        case 1:
            System.out.println("You chose number 1.");
            break;
        case 2:
            System.out.println("You chose number 2.");
            break;
        case 3:
            System.out.println("You chose number 3.");
            break;
        default:  // GOOD: 'default' case for invalid choices
            System.out.println("Sorry, you made an invalid choice.");
            break;
    }
    ```

    ## References
    * Java SE Documentation: [7.8 switch Statements](https://www.oracle.com/java/technologies/javase/codeconventions-statements.html#468).
    * Common Weakness Enumeration: [CWE-478](https://cwe.mitre.org/data/definitions/478.html).
 -
  pack: codeql/java-queries#0
  relativeQueryPath: Advisory/Statements/OneStatementPerLine.ql
  relativeBqrsPath: codeql/java-queries/Advisory/Statements/OneStatementPerLine.bqrs
  metadata:
    name: Multiple statements on line
    description: More than one statement per line decreases readability.
    kind: problem
    problem.severity: recommendation
    precision: medium
    id: java/multiple-statements-on-same-line
    tags: maintainability
  queryHelp: |
    # Multiple statements on line
    Code where each statement is defined on a separate line is much easier for programmers to read than code where multiple statements are defined on the same line.


    ## Recommendation
    Separate statements by a newline character.


    ## References
    * Java SE Documentation: [7.1 Simple Statements](https://www.oracle.com/java/technologies/javase/codeconventions-statements.html#431).
 -
  pack: codeql/java-queries#0
  relativeQueryPath: Advisory/Statements/TerminateIfElseIfWithElse.ql
  relativeBqrsPath: codeql/java-queries/Advisory/Statements/TerminateIfElseIfWithElse.bqrs
  metadata:
    name: Non-terminated if-else-if chain
    description: |-
      An 'if-else-if' statement without a terminating 'else' clause may allow execution to
                    'fall through' silently.
    kind: problem
    problem.severity: recommendation
    precision: medium
    id: java/non-terminated-if-else-if-chain
    tags: reliability
  queryHelp: |
    # Non-terminated if-else-if chain
    An `if-else-if` statement without a terminating `else` clause may allow execution to 'fall through' silently, if none of the `if` clauses are matched.


    ## Recommendation
    Include a terminating `else` clause to `if-else-if` statements to prevent execution from falling through silently. If the terminating `else` clause is intended to be unreachable code, it is advisable that it throws a `RuntimeException` to alert the user of an internal error.


    ## Example
    In the following example, the `if` statement outputs the grade that is achieved depending on the test score. However, if the score is less than 60, execution falls through silently.


    ```java
    int score;
    char grade;

    // ...

    if (score >= 90) {
        grade = 'A';
    } else if (score >= 80) {
        grade = 'B';
    } else if (score >= 70) {
        grade = 'C';
    } else if (score >= 60) {
        grade = 'D';
      // BAD: No terminating 'else' clause
    }
    System.out.println("Grade = " + grade);
    ```
    In the following modified example, the `if` statement includes a terminating `else` clause, to allow for scores that are less than 60.


    ```java
    int score;
    char grade;

    // ...

    if (score >= 90) {
        grade = 'A';
    } else if (score >= 80) {
        grade = 'B';
    } else if (score >= 70) {
        grade = 'C';
    } else if (score >= 60) {
        grade = 'D';
    } else {  // GOOD: Terminating 'else' clause for all other scores
        grade = 'F';
    }
    System.out.println("Grade = " + grade);
    ```

    ## References
    * Java SE Documentation: [7.4 if, if-else, if else-if else Statements](https://www.oracle.com/java/technologies/javase/codeconventions-statements.html#449).
 -
  pack: codeql/java-queries#0
  relativeQueryPath: Advisory/Types/GenericsConstructor.ql
  relativeBqrsPath: codeql/java-queries/Advisory/Types/GenericsConstructor.bqrs
  metadata:
    name: Non-parameterized constructor invocation
    description: |-
      Parameterizing a call to a constructor of a generic type increases type safety and
                    code readability.
    kind: problem
    problem.severity: recommendation
    precision: medium
    id: java/raw-constructor-invocation
    tags: maintainability
  queryHelp: |
    # Non-parameterized constructor invocation
    The use of generics in Java improves compile-time type safety and code readability. Users of a class or interface that has been designed using generic types should therefore make use of parameterized instances in variable declarations, method return types, and constructor calls.


    ## Recommendation
    Provide type parameters to generic classes and interfaces where possible.

    Note that converting legacy code to use generics may have to be done carefully in order to preserve the existing functionality of an API; for detailed guidance, see the references.


    ## Example
    The following example is poorly written because it uses raw types. This makes it more error prone because the compiler is less able to perform type checks.


    ```java
    public List constructRawList(Object o) {
        List list;  // Raw variable declaration
        list = new ArrayList();  // Raw constructor call
        list.add(o);
        return list;  // Raw method return type (see signature above)
    }
    ```
    A parameterized version can be easily made and is much safer.


    ```java
    public <T> List<T> constructParameterizedList(T o) {
        List<T> list;  // Parameterized variable declaration
        list = new ArrayList<T>();  // Parameterized constructor call
        list.add(o);
        return list;  // Parameterized method return type (see signature above)
    }
    ```

    ## References
    * J. Bloch, *Effective Java (second edition)*, Item 23. Addison-Wesley, 2008.
    * Help - Eclipse Platform: [Java Compiler Errors/Warnings Preferences](https://help.eclipse.org/2020-12/advanced/content.jsp?topic=/org.eclipse.jdt.doc.user/reference/preferences/java/compiler/ref-preferences-errors-warnings.htm).
    * The Java Tutorials: [Generics](https://docs.oracle.com/javase/tutorial/java/generics/), [Converting Legacy Code to Use Generics](https://docs.oracle.com/javase/tutorial/extra/generics/convert.html).
 -
  pack: codeql/java-queries#0
  relativeQueryPath: Advisory/Types/GenericsReturnType.ql
  relativeBqrsPath: codeql/java-queries/Advisory/Types/GenericsReturnType.bqrs
  metadata:
    name: Non-parameterized method return type
    description: |-
      Using a parameterized instance of a generic type for a method return type increases
                    type safety and code readability.
    kind: problem
    problem.severity: recommendation
    precision: medium
    id: java/raw-return-type
    tags: maintainability
  queryHelp: |
    # Non-parameterized method return type
    The use of generics in Java improves compile-time type safety and code readability. Users of a class or interface that has been designed using generic types should therefore make use of parameterized instances in variable declarations, method return types, and constructor calls.


    ## Recommendation
    Provide type parameters to generic classes and interfaces where possible.

    Note that converting legacy code to use generics may have to be done carefully in order to preserve the existing functionality of an API; for detailed guidance, see the references.


    ## Example
    The following example is poorly written because it uses raw types. This makes it more error prone because the compiler is less able to perform type checks.


    ```java
    public List constructRawList(Object o) {
        List list;  // Raw variable declaration
        list = new ArrayList();  // Raw constructor call
        list.add(o);
        return list;  // Raw method return type (see signature above)
    }
    ```
    A parameterized version can be easily made and is much safer.


    ```java
    public <T> List<T> constructParameterizedList(T o) {
        List<T> list;  // Parameterized variable declaration
        list = new ArrayList<T>();  // Parameterized constructor call
        list.add(o);
        return list;  // Parameterized method return type (see signature above)
    }
    ```

    ## References
    * J. Bloch, *Effective Java (second edition)*, Item 23. Addison-Wesley, 2008.
    * Help - Eclipse Platform: [Java Compiler Errors/Warnings Preferences](https://help.eclipse.org/2020-12/advanced/content.jsp?topic=/org.eclipse.jdt.doc.user/reference/preferences/java/compiler/ref-preferences-errors-warnings.htm).
    * The Java Tutorials: [Generics](https://docs.oracle.com/javase/tutorial/java/generics/), [Converting Legacy Code to Use Generics](https://docs.oracle.com/javase/tutorial/extra/generics/convert.html).
 -
  pack: codeql/java-queries#0
  relativeQueryPath: Advisory/Types/GenericsVariable.ql
  relativeBqrsPath: codeql/java-queries/Advisory/Types/GenericsVariable.bqrs
  metadata:
    name: Non-parameterized variable
    description: |-
      Declaring a field, parameter, or local variable as a parameterized type increases
                    type safety and code readability.
    kind: problem
    problem.severity: recommendation
    precision: medium
    id: java/raw-variable
    tags: maintainability
  queryHelp: |
    # Non-parameterized variable
    The use of generics in Java improves compile-time type safety and code readability. Users of a class or interface that has been designed using generic types should therefore make use of parameterized instances in variable declarations, method return types, and constructor calls.


    ## Recommendation
    Provide type parameters to generic classes and interfaces where possible.

    Note that converting legacy code to use generics may have to be done carefully in order to preserve the existing functionality of an API; for detailed guidance, see the references.


    ## Example
    The following example is poorly written because it uses raw types. This makes it more error prone because the compiler is less able to perform type checks.


    ```java
    public List constructRawList(Object o) {
        List list;  // Raw variable declaration
        list = new ArrayList();  // Raw constructor call
        list.add(o);
        return list;  // Raw method return type (see signature above)
    }
    ```
    A parameterized version can be easily made and is much safer.


    ```java
    public <T> List<T> constructParameterizedList(T o) {
        List<T> list;  // Parameterized variable declaration
        list = new ArrayList<T>();  // Parameterized constructor call
        list.add(o);
        return list;  // Parameterized method return type (see signature above)
    }
    ```

    ## References
    * J. Bloch, *Effective Java (second edition)*, Item 23. Addison-Wesley, 2008.
    * Help - Eclipse Platform: [Java Compiler Errors/Warnings Preferences](https://help.eclipse.org/2020-12/advanced/content.jsp?topic=/org.eclipse.jdt.doc.user/reference/preferences/java/compiler/ref-preferences-errors-warnings.htm).
    * The Java Tutorials: [Generics](https://docs.oracle.com/javase/tutorial/java/generics/), [Converting Legacy Code to Use Generics](https://docs.oracle.com/javase/tutorial/extra/generics/convert.html).
 -
  pack: codeql/java-queries#0
  relativeQueryPath: AlertSuppression.ql
  relativeBqrsPath: codeql/java-queries/AlertSuppression.bqrs
  metadata:
    name: Alert suppression
    description: Generates information about alert suppressions.
    kind: alert-suppression
    id: java/alert-suppression
 -
  pack: codeql/java-queries#0
  relativeQueryPath: AlertSuppressionAnnotations.ql
  relativeBqrsPath: codeql/java-queries/AlertSuppressionAnnotations.bqrs
  metadata:
    name: Alert suppression using annotations
    description: |-
      Generates information about alert suppressions
                    using 'SuppressWarnings' annotations.
    kind: alert-suppression
    id: java/alert-suppression-annotations
 -
  pack: codeql/java-queries#0
  relativeQueryPath: Architecture/Dependencies/MutualDependency.ql
  relativeBqrsPath: codeql/java-queries/Architecture/Dependencies/MutualDependency.bqrs
  metadata:
    name: Mutually-dependent types
    description: Mutual dependency between types makes code difficult to understand
      and test.
    kind: problem
    problem.severity: recommendation
    precision: low
    id: java/mutually-dependent-types
    tags: |-
      testability
             maintainability
             modularity
  queryHelp: "# Mutually-dependent types\nA mutual dependency exists when two code\
    \ entities (for example, types or packages) depend directly on each other. Mutual\
    \ dependencies are caused by unwanted dependencies in one or both directions.\
    \ There are many different kinds of dependency; here are a few examples of how\
    \ an inter-type dependency from `T1` to `T2` can occur:\n\n* `T1` derives from\
    \ a type involving `T2`, for example `T2` itself or `List<T2>`.\n* `T1` declares\
    \ a field of a type involving `T2`.\n* `T1` declares a method whose return type\
    \ involves `T2`.\n* A method of `T1` declares a local variable whose type involves\
    \ `T2`.\n* A method of `T1` catches an exception of a type involving `T2`.\nMutual\
    \ dependencies prevent you from considering either entity in isolation, affecting\
    \ readability and testability. For example, if types `T1` and `T2` depend on each\
    \ other, then it is generally impossible to fully understand `T1` without understanding\
    \ `T2`, and vice-versa. Moreover, neither type can be tested without the other\
    \ being present. Whilst mocking can alleviate this latter problem to some extent,\
    \ breaking the mutual dependency is a better solution. For example, suppose we\
    \ could remove all of the dependencies from `T2` to `T1` - in that case, we would\
    \ be able to test `T2` in isolation, and completely side-step the need to provide\
    \ a `T1`, mocked or otherwise.\n\n\n## Recommendation\nBreaking mutual dependencies\
    \ involves finding ways of removing the unwanted individual dependencies that\
    \ cause them. The way to do this depends on the kind of dependency in question,\
    \ with some kinds (for example, dependencies caused by inheritance) being much\
    \ harder to break than others. A full list of ways to break cycles is beyond the\
    \ scope of this help topic, however, a few high-level techniques for breaking\
    \ a dependency from `T1` to `T2` include:\n\n* Introducing an interface that is\
    \ implemented by `T2`. `T1` can then be refactored to use `T2` only via the interface,\
    \ which breaks the cycle.\n* Moving the depended-on code in `T2` to a third (possibly\
    \ new) entity. `T1` can then depend on this third entity instead of on `T2`, breaking\
    \ the cycle. `T2` is allowed to depend on the third entity as well, although it\
    \ does not have to if there is no need.\n* Merging `T1` and `T2` together (for\
    \ example, if there was an artificial separation between two parts of the same\
    \ concept). This is not a generally-applicable solution, but is sometimes the\
    \ right thing to do. It has the effect of internalizing the cycle, which is sufficient\
    \ to solve the problem.\nFor more information on how to break unwanted dependencies,\
    \ see the references (particularly \\[Lakos\\]).\n\n\n## Example\nIn this example\
    \ `BadModel` and `BadView` are mutually dependent.\n\n\n```java\npublic class\
    \ MutualDependency {\n\t// Violation: BadModel and BadView are mutually dependent\n\
    \tprivate static class BadModel {\n\t\tprivate int i;\n\t\tprivate BadView view;\n\
    \n\t\tpublic int getI() {\n\t\t\treturn i;\n\t\t}\n\n\t\tpublic void setI(int\
    \ i) {\n\t\t\tthis.i = i;\n\t\t\tif(view != null) view.modelChanged();\n\t\t}\n\
    \n\t\tpublic void setView(BadView view) {\n\t\t\tthis.view = view;\n\t\t}\n\t\
    }\n\n\tprivate static class BadView {\n\t\tprivate BadModel model;\n\n\t\tpublic\
    \ BadView(BadModel model) {\n\t\t\tthis.model = model;\n\t\t}\n\n\t\tpublic void\
    \ modelChanged() {\n\t\t\tSystem.out.println(\"Model Changed: \" + model.getI());\n\
    \t\t}\n\t}\n}\n```\nThe interface technique can be used to break the dependency\
    \ between the model and the view. The `ModelListener` interface allows `BetterView`\
    \ to interact with `BetterModel` without dependency.\n\n\n```java\npublic class\
    \ NoMutualDependency {\n\t// Better: A new interface breaks the dependency\n\t\
    // from the model to the view\n\tprivate interface ModelListener {\n\t\tvoid modelChanged();\n\
    \t}\n\n\tprivate static class BetterModel {\n\t\tprivate int i;\n\t\tprivate ModelListener\
    \ listener;\n\n\t\tpublic int getI() {\n\t\t\treturn i;\n\t\t}\n\n\t\tpublic void\
    \ setI(int i) {\n\t\t\tthis.i = i;\n\t\t\tif (listener != null) listener.modelChanged();\n\
    \t\t}\n\n\t\tpublic void setListener(ModelListener listener) {\n\t\t\tthis.listener\
    \ = listener;\n\t\t}\n\t}\n\n\tprivate static class BetterView implements ModelListener\
    \ {\n\t\tprivate BetterModel model;\n\n\t\tpublic BetterView(BetterModel model)\
    \ {\n\t\t\tthis.model = model;\n\t\t}\n\n\t\tpublic void modelChanged() {\n\t\t\
    \tSystem.out.println(\"Model Changed: \" + model.getI());\n\t\t}\n\t}\n\n\tpublic\
    \ static void main(String[] args) {\n\t\tBadModel badModel = new BadModel();\n\
    \t\tBadView badView = new BadView(badModel);\n\t\tbadModel.setView(badView);\n\
    \t\tbadModel.setI(23);\n\t\tbadModel.setI(9);\n\n\t\tBetterModel betterModel =\
    \ new BetterModel();\n\t\tBetterView betterView = new BetterView(betterModel);\n\
    \t\tbetterModel.setListener(betterView);\n\t\tbetterModel.setI(24);\n\t\tbetterModel.setI(12);\n\
    \t}\n}\n```\n\n## References\n* J. Lakos. *Large-Scale C++ Software Design*. Addison-Wesley,\
    \ 1996.\n* M. Fowler. *Refactoring*. Addison-Wesley, 1999.\n"
 -
  pack: codeql/java-queries#0
  relativeQueryPath: Architecture/Dependencies/UnusedMavenDependencyBinary.ql
  relativeBqrsPath: codeql/java-queries/Architecture/Dependencies/UnusedMavenDependencyBinary.bqrs
  metadata:
    name: Unused Maven dependency (binary)
    description: Unnecessary Maven dependencies are a maintenance burden.
    kind: problem
    problem.severity: recommendation
    precision: low
    id: java/unused-maven-binary-dependency
  queryHelp: |
    # Unused Maven dependency (binary)
    For projects that build with Maven, unnecessary dependencies add a variety of maintenance burdens. Most immediately, unnecessary dependencies increase build time, because Maven rebuilds an artifact whenever its declared dependencies are modified. This rule identifies Maven dependencies that are declared in a POM file but are not used by the underlying source code.

    If the dependency's source code is part of the code base being analyzed, then the result is reported by one version of the rule. Otherwise, the dependency is reported by a separate version of the rule. This allows the two types of unused Maven dependencies to be reported separately.


    ## Recommendation
    Try removing the dependency from the POM file. Then run all build and test targets that are relevant for the modified POM file. If all of the relevant build and test targets still succeed, then leave the dependency out permanently. Doing so will make future maintenance of the relevant source code easier.

    In some cases, there may be a true dependency on the code that is not detected by the analysis. If any of the build and test targets fail after the dependency is removed, then the result is a false positive, and the dependency should be restored.


    ## References
    * Apache Maven Project: [Maven POM Reference: Dependencies](http://maven.apache.org/pom.html#Dependencies).
 -
  pack: codeql/java-queries#0
  relativeQueryPath: Architecture/Dependencies/UnusedMavenDependencySource.ql
  relativeBqrsPath: codeql/java-queries/Architecture/Dependencies/UnusedMavenDependencySource.bqrs
  metadata:
    name: Unused Maven dependency (source)
    description: Unnecessary Maven dependencies are a maintenance burden.
    kind: problem
    problem.severity: recommendation
    precision: low
    id: java/unused-maven-source-dependency
  queryHelp: |
    # Unused Maven dependency (source)
    For projects that build with Maven, unnecessary dependencies add a variety of maintenance burdens. Most immediately, unnecessary dependencies increase build time, because Maven rebuilds an artifact whenever its declared dependencies are modified. This rule identifies Maven dependencies that are declared in a POM file but are not used by the underlying source code.

    If the dependency's source code is part of the code base being analyzed, then the result is reported by one version of the rule. Otherwise, the dependency is reported by a separate version of the rule. This allows the two types of unused Maven dependencies to be reported separately.


    ## Recommendation
    Try removing the dependency from the POM file. Then run all build and test targets that are relevant for the modified POM file. If all of the relevant build and test targets still succeed, then leave the dependency out permanently. Doing so will make future maintenance of the relevant source code easier.

    In some cases, there may be a true dependency on the code that is not detected by the analysis. If any of the build and test targets fail after the dependency is removed, then the result is a false positive, and the dependency should be restored.


    ## References
    * Apache Maven Project: [Maven POM Reference: Dependencies](http://maven.apache.org/pom.html#Dependencies).
 -
  pack: codeql/java-queries#0
  relativeQueryPath: Architecture/Refactoring Opportunities/DeeplyNestedClass.ql
  relativeBqrsPath: codeql/java-queries/Architecture/Refactoring Opportunities/DeeplyNestedClass.bqrs
  metadata:
    name: Deeply-nested class
    description: "Deeply-nested classes are difficult to understand, since they have\
      \ access to many scopes"
    kind: problem
    problem.severity: recommendation
    precision: low
    id: java/deeply-nested-class
    tags: testability
  queryHelp: "# Deeply-nested class\nClasses (especially complex ones) that are nested\
    \ multiple levels deep can be difficult to understand because they have access\
    \ to variables from all of the classes that enclose them. Such classes can also\
    \ be difficult to unit test. Specific exceptions are made for:\n\n* Anonymous\
    \ classes - these are generally used as a substitute for closures.\n* Enumerations,\
    \ and simple classes that contain no methods - these are unlikely to hinder readability.\n\
    \n## Recommendation\nThe solution is to move one or more of the nested classes\
    \ into a higher scope, less deeply-nested (see example below). When you move a\
    \ nested class, you must:\n\n* Ensure that the class can still access the required\
    \ variables from its previously enclosing scopes.\n* Consider the dependencies,\
    \ particularly when you move a non-static nested class out of the containing class.\
    \ Generally, a non-static class should be refactored to depend only on the contents\
    \ of the classes that previously enclosed it. This avoids introducing a dependency\
    \ cycle where the non-static class depends on the previously-enclosing classes\
    \ themselves.\n\n## Example\nIn the following example `Z1` is difficult to read\
    \ because it is deeply nested.\n\n\n```java\nclass X1 {\n\tprivate int i;\n\n\t\
    public X1(int i) {\n\t\tthis.i = i;\n\t}\n\n\tpublic Y1 makeY1(float j) {\n\t\t\
    return new Y1(j);\n\t}\n\n\tclass Y1 {\n\t\tprivate float j;\n\n\t\tpublic Y1(float\
    \ j) {\n\t\t\tthis.j = j;\n\t\t}\n\n\t\tpublic Z1 makeZ1(double k) {\n\t\t\treturn\
    \ new Z1(k);\n\t\t}\n\n\t\t// Violation\n\t\tclass Z1 {\n\t\t\tprivate double\
    \ k;\n\n\t\t\tpublic Z1(double k) {\n\t\t\t\tthis.k = k;\n\t\t\t}\n\n\t\t\tpublic\
    \ void foo() {\n\t\t\t\tSystem.out.println(i * j * k);\n\t\t\t}\n\t\t}\n\t}\n\
    }\npublic class DeeplyNestedClass {\n\tpublic static void main(String[] args)\
    \ {\n\t\tnew X1(23).makeY1(9.0f).makeZ1(84.0).foo();\n\t}\n}\n```\nIn this example,\
    \ there are no nested classes and you can clearly see which variables affect which\
    \ class.\n\n\n```java\nclass X2 {\n\tprivate int i;\n\n\tpublic X2(int i) {\n\t\
    \tthis.i = i;\n\t}\n\n\tpublic Y2 makeY2(float j) {\n\t\treturn new Y2(i, j);\n\
    \t}\n}\n\nclass Y2 {\n\tprivate int i;\n\tprivate float j;\n\n\tpublic Y2(int\
    \ i, float j) {\n\t\tthis.i = i;\n\t\tthis.j = j;\n\t}\n\n\tpublic Z2 makeZ2(double\
    \ k) {\n\t\treturn new Z2(i, j, k);\n\t}\n}\n\nclass Z2 {\n\tprivate int i;\n\t\
    private float j;\n\tprivate double k;\n\n\tpublic Z2(int i, float j, double k)\
    \ {\n\t\tthis.i = i;\n\t\tthis.j = j;\n\t\tthis.k = k;\n\t}\n\n\tpublic void foo()\
    \ {\n\t\tSystem.out.println(i * j * k);\n\t}\n}\n\npublic class NotNestedClass\
    \ {\n\tpublic static void main(String[] args) {\n\t\tnew X2(23).makeY2(9.0f).makeZ2(84.0).foo();\n\
    \t}\n}\n```\n\n## References\n* The Java Tutorials: [Nested Classes](https://docs.oracle.com/javase/tutorial/java/javaOO/nested.html).\n"
 -
  pack: codeql/java-queries#0
  relativeQueryPath: Architecture/Refactoring Opportunities/FeatureEnvy.ql
  relativeBqrsPath: codeql/java-queries/Architecture/Refactoring Opportunities/FeatureEnvy.bqrs
  metadata:
    name: Feature envy
    description: |-
      A method that uses more methods or variables from another (unrelated) class than
                    from its own class violates the principle of putting data and behavior in the same
                    place.
    kind: problem
    problem.severity: warning
    precision: low
    id: java/feature-envy
    tags: |-
      maintainability
             modularity
  queryHelp: "# Feature envy\n*Feature envy* refers to situations where a method is\
    \ \"in the wrong place\", because it does not use many methods or variables of\
    \ its own class, but uses a whole range of methods or variables from some other\
    \ class. This violates the principle of putting data and behavior in the same\
    \ place, and exposes internals of the other class to the method.\n\n\n## Recommendation\n\
    For each method that may exhibit feature envy, see if it needs to be declared\
    \ in its present location, or if you can move it to the class it is \"envious\"\
    \ of. A common example is a method that calls a large number of getters on another\
    \ class to perform a calculation that does not rely on anything from its own class.\
    \ In such cases, you should move the method to the class containing the data.\
    \ If the calculation depends on some values from the method's current class, they\
    \ can either be passed as arguments or accessed using getters from the other class.\n\
    \nIf it is inappropriate to move the entire method, see if all the dependencies\
    \ on the other class are concentrated in just one part of the method. If so, you\
    \ can move them into a method of their own. You can then move this method to the\
    \ other class and call it from the original method.\n\nIf a class is envious of\
    \ functionality defined in a superclass, perhaps the superclass needs to be rewritten\
    \ to become more extensible and allow its subtypes to define new behavior without\
    \ them depending so deeply on the superclass's implementation. The *template method*\
    \ pattern may be useful in achieving this.\n\nModern IDEs provide several refactorings\
    \ that may be useful in addressing instances of feature envy, typically under\
    \ the names of \"Move method\" and \"Extract method\".\n\nOccasionally, behavior\
    \ can be misinterpreted as feature envy when in fact it is justified. The most\
    \ common examples are complex design patterns like *visitor* or *strategy*, where\
    \ the goal is to separate data from behavior.\n\n\n## Example\nIn the following\
    \ example, initially the method `getTotalPrice` is in the `Basket` class, but\
    \ it only uses data belonging to the `Item` class. Therefore, it represents an\
    \ instance of feature envy. To refactor it, `getTotalPrice` can be moved to `Item`\
    \ and its parameter can be removed. The resulting code is easier to understand\
    \ and keep consistent.\n\n\n```java\n// Before refactoring:\nclass Item { .. }\n\
    class Basket {\n\t// ..\n\tfloat getTotalPrice(Item i) {\n\t\tfloat price = i.getPrice()\
    \ + i.getTax();\n\t\tif (i.isOnSale())\n\t\t\tprice = price - i.getSaleDiscount()\
    \ * price;\n\t\treturn price;\n\t}\n}\n\n// After refactoring:\nclass Item {\n\
    \t// ..\n\tfloat getTotalPrice() {\n\t\tfloat price = getPrice() + getTax();\n\
    \t\tif (isOnSale())\n\t\t\tprice = price - getSaleDiscount() * price;\n\t\treturn\
    \ price;\n\t}\n}\n```\nThe refactored code is still appropriate, even if some\
    \ data from the `Basket` class is necessary for the computation of the total price.\
    \ For example, if the `Basket` class applies a bulk discount when a sufficient\
    \ number of items are in the basket, an \"additional discount\" parameter can\
    \ be added to `Item.getTotalPrice(..)`. Alternatively, the application of the\
    \ discount can be performed in a method in `Basket` that calls `Item.getTotalPrice`.\n\
    \n\n## References\n* E. Gamma, R. Helm, R. Johnson, J. Vlissides, *Design patterns:\
    \ elements of reusable object-oriented software*. Addison-Wesley Longman Publishing\
    \ Co., Inc., Boston, MA, 1995.\n* W. C. Wake, *Refactoring Workbook*, pp. 93&ndash;94.\
    \ Addison-Wesley Professional, 2004.\n"
 -
  pack: codeql/java-queries#0
  relativeQueryPath: Architecture/Refactoring Opportunities/HubClasses.ql
  relativeBqrsPath: codeql/java-queries/Architecture/Refactoring Opportunities/HubClasses.bqrs
  metadata:
    name: Hub classes
    description: |-
      Hub classes, which are classes that use, and are used by, many other classes, are
                    complex and difficult to change without affecting the rest of the system.
    kind: problem
    problem.severity: recommendation
    precision: low
    id: java/hub-class
    tags: |-
      maintainability
             modularity
  queryHelp: |
    # Hub classes
    A *hub class* is a class that depends on many other classes, and on which many other classes depend.

    For the purposes of this rule, a *dependency* is any use of one class in another. Examples include:

    * Using another class as the declared type of a variable or field
    * Using another class as an argument type for a method
    * Using another class as a superclass in the `extends` declaration
    * Calling a method defined in the class
    A class can be regarded as a hub class when both the incoming dependencies and the outgoing source dependencies are particularly high. (Outgoing source dependencies are dependencies on other source classes, rather than library classes like `java.lang.Object`.)

    It is undesirable to have many hub classes because they are extremely difficult to maintain. This is because many other classes depend on a hub class, and so the other classes have to be tested and possibly adapted after each change to the hub class. Also, when one of a hub class's direct dependencies changes, the behavior of the hub class and all of its dependencies has to be checked and possibly adapted.


    ## Recommendation
    One common reason for a class to be regarded as a hub class is that it tries to do too much, including unrelated functionality that depends on different parts of the code base. If possible, split such classes into several better encapsulated classes.

    Another common reason is that the class is a "struct-like" class that has many fields of different types. Introducing some intermediate grouping containers to make it clearer what fields belong together may be a good option.


    ## References
    * E. Gamma, R. Helm, R. Johnson, J. Vlissides, *Design patterns: elements of reusable object-oriented software*. Addison-Wesley Longman Publishing Co., Inc., Boston, MA, 1995.
    * W. C. Wake, *Refactoring Workbook*. Addison-Wesley Professional, 2004.
 -
  pack: codeql/java-queries#0
  relativeQueryPath: Architecture/Refactoring Opportunities/InappropriateIntimacy.ql
  relativeBqrsPath: codeql/java-queries/Architecture/Refactoring Opportunities/InappropriateIntimacy.bqrs
  metadata:
    name: Inappropriate Intimacy
    description: |-
      Two otherwise unrelated classes that share too much information about each other are
                    difficult to maintain, change and understand.
    kind: problem
    problem.severity: warning
    precision: low
    id: java/coupled-types
    tags: |-
      maintainability
             modularity
  queryHelp: |
    # Inappropriate Intimacy
    *Inappropriate intimacy* is an anti-pattern that describes a pair of otherwise unrelated classes that are too tightly coupled: each class uses a significant number of methods and fields of the other. This makes both classes difficult to maintain, change and understand. Inappropriate intimacy is the same as the "feature envy" anti-pattern but in both directions: each class is "envious" of some functionality or data defined in the other class.


    ## Recommendation
    The solution might be as simple as moving some misplaced methods to their rightful place, or perhaps some tangled bits of code need to be extracted to their own methods first before being moved.

    Sometimes the entangled parts (both fields and methods) indicate a missing object or level of abstraction. It might make sense to combine them into a new type that can be used in both classes. You may need to introduce delegation to hide some implementation details.

    It may be necessary to convert the bidirectional association into a unidirectional relationship, possibly by using dependency inversion.

    Modern IDEs provide refactoring support for this sort of issue, usually with the names "Move method", "Extract method" or "Extract class".


    ## References
    * E. Gamma, R. Helm, R. Johnson, J. Vlissides, *Design patterns: elements of reusable object-oriented software*. Addison-Wesley Longman Publishing Co., Inc., Boston, MA, 1995.
    * W. C. Wake, *Refactoring Workbook*, pp. 95&ndash;96. Addison-Wesley Professional, 2004.
 -
  pack: codeql/java-queries#0
  relativeQueryPath: Compatibility/JDK9/JdkInternalAccess.ql
  relativeBqrsPath: codeql/java-queries/Compatibility/JDK9/JdkInternalAccess.bqrs
  metadata:
    name: Access to unsupported JDK-internal API
    description: |-
      Use of unsupported JDK-internal APIs may cause compatibility issues
                    when upgrading to newer versions of Java, in particular Java 9.
    kind: problem
    problem.severity: recommendation
    precision: high
    id: java/jdk-internal-api-access
    tags: maintainability
  queryHelp: |
    # Access to unsupported JDK-internal API
    Java 9 removes access to various unsupported JDK-internal APIs by default.


    ## Recommendation
    Examine the use of unsupported JDK-internal APIs and consider replacing them with supported APIs as recommended in the references.


    ## References
    * Oracle JDK Documentation: [Oracle JDK 9 Migration Guide](https://docs.oracle.com/javase/9/migrate/toc.htm).
    * OpenJDK Documentation: [Java Dependency Analysis Tool](https://wiki.openjdk.java.net/display/JDK8/Java+Dependency+Analysis+Tool), [JEP 260: Encapsulate Most Internal APIs](https://openjdk.java.net/jeps/260), [JEP 261: Module System](https://openjdk.java.net/jeps/261).
 -
  pack: codeql/java-queries#0
  relativeQueryPath: Compatibility/JDK9/UnderscoreIdentifier.ql
  relativeBqrsPath: codeql/java-queries/Compatibility/JDK9/UnderscoreIdentifier.bqrs
  metadata:
    name: Underscore used as identifier
    description: |-
      Use of a single underscore character as an identifier
                    results in a compiler error with Java source level 9 or later.
    kind: problem
    problem.severity: recommendation
    precision: high
    id: java/underscore-identifier
    tags: maintainability
  queryHelp: |
    # Underscore used as identifier
    The underscore character is a reserved keyword in Java 9 and therefore disallowed as a one-character identifier.


    ## Recommendation
    Rename any identifiers that consist of a one-character underscore.


    ## References
    * Oracle JDK Documentation: [Oracle JDK 9 Migration Guide](https://docs.oracle.com/javase/9/migrate/toc.htm).
    * JDK Bug System: [Disallow _ as a one-character identifier](https://bugs.openjdk.java.net/browse/JDK-8061549).
 -
  pack: codeql/java-queries#0
  relativeQueryPath: Complexity/BlockWithTooManyStatements.ql
  relativeBqrsPath: codeql/java-queries/Complexity/BlockWithTooManyStatements.bqrs
  metadata:
    name: Block with too many statements
    description: |-
      A block that contains too many complex statements becomes unreadable and
                    unmaintainable.
    kind: problem
    problem.severity: recommendation
    precision: low
    id: java/complex-block
    tags: |-
      maintainability
             testability
             complexity
  queryHelp: |
    # Block with too many statements
    Code has a tendency to become more complex over time. A method that is initially simple may need to be extended to accommodate additional functionality or to address defects. Before long it becomes unreadable and unmaintainable, with many complex statements nested within each other.

    This rule applies to a block that contains a significant number of complex statements. Note that this is quite different from just considering the number of statements in a block, because each complex statement is potentially a candidate for being extracted to a new method as part of refactoring. For the purposes of this rule, loops and switch statements are considered to be complex.


    ## Recommendation
    To make the code more understandable and less complex, identify logical units and extract them to new methods. As a result, the top-level logic becomes clearer.


    ## References
    * M. Fowler, *Refactoring: Improving the Design of Existing Code*. Addison-Wesley Professional, 1999.
    * W. C. Wake, *Refactoring Workbook*. Addison-Wesley Professional, 2004.
 -
  pack: codeql/java-queries#0
  relativeQueryPath: Complexity/ComplexCondition.ql
  relativeBqrsPath: codeql/java-queries/Complexity/ComplexCondition.bqrs
  metadata:
    name: Complex condition
    description: Very complex conditions are difficult to read and may include defects.
    kind: problem
    problem.severity: recommendation
    precision: low
    id: java/complex-condition
    tags: |-
      testability
             readability
  queryHelp: "# Complex condition\nIn general, very complex conditions are difficult\
    \ to write and read, and increase the chance of defects.\n\n\n## Recommendation\n\
    Firstly, a condition can often be simplified by changing other parts of the code\
    \ to initialize variables more consistently. For example, is there a semantic\
    \ difference between `id` being `null` and having zero-length? If not, choosing\
    \ one sentinel value and using it consistently simplifies most uses of that variable.\n\
    \nSecondly, extracting part of a condition into a Boolean-valued method can simplify\
    \ the condition and also allow code reuse, with all its benefits.\n\nThirdly,\
    \ assigning each subcondition of the condition to a local variable, and then using\
    \ the variables in the condition instead can simplify the condition.\n\n\n## Example\n\
    The following example shows a complex condition found in a real program used by\
    \ millions of people. The condition is so confusing that even the programmer who\
    \ wrote it is not sure if he got it right (see the `TODO` comment).\n\n\n```java\n\
    public class Dialog\n{\n\t// ...\n\n\tprivate void validate() {\n\t\t// TODO:\
    \ check that this covers all cases\n\t\tif ((id != null && id.length() == 0) ||\n\
    \t\t\t((partner == null || partner.id == -1) &&\n\t\t\t((option == Options.SHORT\
    \ && parameter.length() == 0) ||\n\t\t\t(option == Options.LONG && parameter.length()\
    \ < 8))))\n\t\t{\n\t\t\tdisableOKButton();\n\t\t} else {\n\t\t\tenableOKButton();\n\
    \t\t}\n\t}\n\n\t// ...\n}\n```\nThe condition can be simplified by extracting\
    \ parts of the condition into Boolean-valued methods. These methods are then used\
    \ in the condition.\n\n\n```java\npublic class Dialog\n{\n    // ...\n\n    private\
    \ void validate() {\n      if(idIsEmpty() || (noPartnerId() && parameterLengthInvalid())){\
    \ // GOOD: Condition is simpler\n        disableOKButton();\n      } else {\n\
    \        enableOKButton();\n      }\n    }\n\n    private boolean idIsEmpty(){\n\
    \      return id != null && id.length() == 0;\n    }\n\n    private boolean noPartnerId(){\n\
    \      return partner == null || partner.id == -1;\n    }\n\n    private boolean\
    \ parameterLengthInvalid(){\n      return (option == Options.SHORT && parameter.length()\
    \ == 0) ||\n             (option == Options.LONG && parameter.length() < 8);\n\
    \    }\n\n    // ...\n}    \n```\n\n## References\n* R. C. Martin, *Clean Code:\
    \ A Handbook of Agile Software Craftsmanship*, &sect;17.G28. Prentice Hall, 2008.\n\
    * S. McConnell, *Code Complete: A Practical Handbook of Software Construction*.\
    \ Microsoft Press, 2004.\n"
 -
  pack: codeql/java-queries#0
  relativeQueryPath: DeadCode/DeadClass.ql
  relativeBqrsPath: codeql/java-queries/DeadCode/DeadClass.bqrs
  metadata:
    name: Dead class
    description: Dead classes add unnecessary complexity.
    kind: problem
    problem.severity: recommendation
    precision: medium
    id: java/dead-class
    tags: |-
      maintainability
             useless-code
             external/cwe/cwe-561
  queryHelp: "# Dead class\nClasses that are never used at runtime are redundant and\
    \ should be removed.\n\nRedundant, or \"dead\", code imposes a burden on those\
    \ reading or maintaining the software project. It can make it harder to understand\
    \ the structure of the code, as well as increasing the complexity of adding new\
    \ features or fixing bugs. It can also affect compilation and build times for\
    \ the project, as dead code will still be compiled and built even if it is never\
    \ used. In some cases it may also affect runtime performance - for example, fields\
    \ that are written to but never read from, where the value written to the field\
    \ is expensive to compute. Removing dead code should not change the meaning of\
    \ the program.\n\nClasses are considered dead if at runtime:\n\n* No methods declared\
    \ in the class, or a sub-type, are called.\n* No fields declared in the class,\
    \ or a sub-type, are read.\n* The class is never constructed.\nAny class which\
    \ is not dead is considered to be \"live\". Nested classes are considered and\
    \ listed separately, as a live nested class within a dead outer class can be moved\
    \ to a separate file, allowing the outer class to be deleted.\n\nA special exception\
    \ is made for \"namespace classes\". A namespace class is used only to group static\
    \ fields, methods and nested classes - it is never instantiated, has no public\
    \ constructor and has no instance methods. If a class is considered to be a namespace\
    \ class, then it is live if at least one of the static members of that class is\
    \ live - including static nested classes.\n\nA class, method, or field may be\
    \ dead even if it has dependencies from other parts of the program, if those dependencies\
    \ are from code that is also considered to be dead. We can also consider this\
    \ from the opposite side - an element is live, if and only if there is an entry\
    \ point - such as a `main` method - that eventually calls the method, reads the\
    \ field or constructs the class.\n\nWhen identifying dead code, we make an assumption\
    \ that the snapshot of the project includes all possible callers of the code.\
    \ If the project is a library project, this may not be the case, and code may\
    \ be flagged as dead when it is only used by other projects not included in the\
    \ snapshot.\n\nYou can customize the results by defining additional \"entry points\"\
    \ or by identifying fields that are accessed using reflection. You may also wish\
    \ to \"whitelist\" classes, methods or fields that should be excluded from the\
    \ results. Please refer to the Semmle documentation for more information.\n\n\n\
    ## Recommendation\nBefore making any changes, confirm that the class is not required\
    \ by verifying that the only dependencies on the class are from other dead classes\
    \ and methods. This confirmation is necessary because there may be project-specific\
    \ frameworks or techniques which can introduce hidden dependencies. If this project\
    \ is for a library, then consider whether the class is part of the external API,\
    \ and may be used in external projects that are not included in the snapshot.\n\
    \nAfter confirming that the class is not required, remove the class. You will\
    \ also need to remove any references to this class, which may, in turn, require\
    \ removing other unused classes, methods and fields (see Example 1).\n\nNested\
    \ classes within this type should be moved, either to a new top-level type, or\
    \ to another type, unless they are also marked as dead, in which case they can\
    \ also be removed. Alternatively, if there are some live nested classes within\
    \ the dead class, the class can be retained by converting all live nested classes\
    \ to static members, and removing all instance methods and fields, and all dead\
    \ static members (see Example 2).\n\nIf you observe a large number of false positives,\
    \ you may need to add extra entry points to identify hidden dependencies caused\
    \ by the use of a particular framework or technique, or to identify library project\
    \ entry points. Please refer to the Semmle documentation for more information\
    \ on how to do this.\n\n\n## Example 1\nIn the following example, we have a number\
    \ of classes, and an \"entry point\" in the form of a main method.\n\n\n```java\n\
    public static void main(String[] args) {\n\tString firstName = /*...*/; String\
    \ lastName = /*...*/;\n\t// Construct a customer\n\tCustomer customer = new Customer();\n\
    \t// Set important properties (but not the address)\n\tcustomer.setName(firstName,\
    \ lastName);\n\t// Save the customer\n\tcustomer.save();\n}\n\npublic class Customer\
    \ {\n\tprivate Address address;\n\t// ...\n\n\t// This setter and getter are unused,\
    \ and so may be deleted.\n\tpublic void addAddress(String line1, String line2,\
    \ String line3) {\n\t\taddress = new Address(line1, line2, line3);\n\t}\n\tpublic\
    \ Address getAddress() { return address; }\n}\n\n/*\n * This class is only constructed\
    \ from dead code, and may be deleted.\n */\npublic class Address {\n\t// ...\n\
    \tpublic Address(String line1, String line2, String line3) {\n\t\t// ...\n\t}\n\
    }\n\n```\nThe class `Customer` is constructed in the main method, and is therefore\
    \ live. The class `Address` is constructed in `setAddress`, so we might think\
    \ that it would also be live. However, `setAddress` is never called by the main\
    \ method, so, assuming that this is the entire program, an `Address` is never\
    \ constructed at runtime. Therefore, the `Address` class is dead and can be removed\
    \ without changing the meaning of this program. To delete the `Address` class\
    \ we will also need to delete the `setAddress` and `getAddress` methods, and the\
    \ `address` field, otherwise the program will not compile.\n\n\n## Example 2\n\
    In the next example, we have a `CustomerActions` class containing `Action`s that\
    \ affect customers. For example, this could be a Java Swing application, and the\
    \ `Action`s could be actions that are available in the user interface.\n\n\n```java\n\
    /*\n * This class is dead because it is never constructed, and the instance methods\
    \ are not\n * called.\n */\npublic class CustomerActions {\n\tpublic CustomerActions()\
    \ {\n\t}\n\n\t// This method is never called,\n\tpublic Action createAddCustomerAction\
    \ () {\n\t\treturn new AddCustomerAction();\n\t}\n\n\t// These two are used directly\n\
    \tpublic static class AddCustomerAction extends Action { /* ... */ }\n\tpublic\
    \ static class RemoveCustomerAction extends Action { /* ... */ }\n}\n\npublic\
    \ static void main(String[] args) {\n\t// Construct the actions directly\n\tAction\
    \ action = new CustomerActions.AddCustomerAction();\n\taction.run();\n\tAction\
    \ action = new CustomerActions.RemoveCustomerAction();\n\taction.run();\n}\n\n\
    ```\nThe `CustomerActions` class has a constructor and an instance method, which\
    \ are never called. Instead, actions are instantiated directly. Although this\
    \ makes the nested `Action` classes live, live nested classes do not make the\
    \ outer class live. Therefore, the `CustomerActions` class is marked as dead.\n\
    \nThere are two ways to resolve the dead `CustomerActions` class:\n\n* Move each\
    \ nested static action that is used by the program to a new file, or nest it within\
    \ a different class, then delete the dead `CustomerActions` class.\n* Convert\
    \ the `CustomerActions` class to a *namespace class*. First convert the constructor\
    \ to a *suppressed constructor* by making it private, preventing the class from\
    \ being instantiated, then remove the instance method `createAddCustomerAction`.\n\
    Taking the second approach, this is the final result.\n\n\n```java\n// This class\
    \ is now live - it is used as a namespace class\npublic class CustomerActions\
    \ {\n\t/*\n\t * This constructor is suppressing construction of this class, so\
    \ is not considered\n\t * dead.\n\t */\n\tprivate CustomerActions() { }\n\t//\
    \ These two are used directly\n\tpublic static class AddCustomerAction extends\
    \ Action { /* ... */ }\n\tpublic static class RemoveCustomerAction extends Action\
    \ { /* ... */ }\n}\n\npublic static void main(String[] args) {\n\t// Construct\
    \ the actions directly\n\tAction action = new CustomerActions.AddCustomerAction();\n\
    \taction.run();\n\tAction action = new CustomerActions.RemoveCustomerAction();\n\
    \taction.run();\n}\n\n```\n\n## References\n* Wikipedia: [Redundant code](https://en.wikipedia.org/wiki/Redundant_code).\n\
    * CERT Java Coding Standard: [MSC56-J. Detect and remove superfluous code and\
    \ values](https://www.securecoding.cert.org/confluence/display/java/MSC56-J.+Detect+and+remove+superfluous+code+and+values).\n\
    * Common Weakness Enumeration: [CWE-561](https://cwe.mitre.org/data/definitions/561.html).\n"
 -
  pack: codeql/java-queries#0
  relativeQueryPath: DeadCode/DeadEnumConstant.ql
  relativeBqrsPath: codeql/java-queries/DeadCode/DeadEnumConstant.bqrs
  metadata:
    name: Dead enum constant
    description: Dead enum constants add unnecessary complexity.
    kind: problem
    problem.severity: recommendation
    precision: medium
    id: java/dead-enum-constant
    tags: |-
      maintainability
             useless-code
             external/cwe/cwe-561
  queryHelp: "# Dead enum constant\nEnum constants that are never used at runtime\
    \ are redundant and should be removed.\n\nRedundant, or \"dead\", code imposes\
    \ a burden on those reading or maintaining the software project. It can make it\
    \ harder to understand the structure of the code, as well as increasing the complexity\
    \ of adding new features or fixing bugs. It can also affect compilation and build\
    \ times for the project, as dead code will still be compiled and built even if\
    \ it is never used. In some cases it may also affect runtime performance - for\
    \ example, fields that are written to but never read from, where the value written\
    \ to the field is expensive to compute. Removing dead code should not change the\
    \ meaning of the program.\n\nAn enum constant is considered dead if at runtime\
    \ it is never used, or only used in comparisons. Any enum constant which is not\
    \ dead is considered to be \"live\".\n\nAn enum constant that is only used in\
    \ a comparison is considered dead because the comparison will always produce the\
    \ same result. This is because no variable holds the value of the enum constant,\
    \ so the comparison of any variable against the constant will always return the\
    \ same result.\n\nA class, method, or field may be dead even if it has dependencies\
    \ from other parts of the program, if those dependencies are from code that is\
    \ also considered to be dead. We can also consider this from the opposite side\
    \ - an element is live, if and only if there is an entry point - such as a `main`\
    \ method - that eventually calls the method, reads the field or constructs the\
    \ class.\n\nWhen identifying dead code, we make an assumption that the snapshot\
    \ of the project includes all possible callers of the code. If the project is\
    \ a library project, this may not be the case, and code may be flagged as dead\
    \ when it is only used by other projects not included in the snapshot.\n\nYou\
    \ can customize the results by defining additional \"entry points\" or by identifying\
    \ fields that are accessed using reflection. You may also wish to \"whitelist\"\
    \ classes, methods or fields that should be excluded from the results. Please\
    \ refer to the Semmle documentation for more information.\n\n\n## Recommendation\n\
    Before making any changes, confirm that the enum constant is not required by verifying\
    \ that the enum constant is never used. This confirmation is necessary because\
    \ there may be project-specific frameworks or techniques which can introduce hidden\
    \ dependencies. If this project is for a library, then consider whether the enum\
    \ constant is part of the external API, and may be used in external projects that\
    \ are not included in the snapshot.\n\nAfter confirming that the enum constant\
    \ is not required, remove the enum constant. You will also need to remove any\
    \ references to this enum constant, which may, in turn, require removing other\
    \ dead code.\n\nIf you observe a large number of false positives, you may need\
    \ to add extra entry points to identify hidden dependencies caused by the use\
    \ of a particular framework or technique, or to identify library project entry\
    \ points. Please refer to the Semmle documentation for more information on how\
    \ to do this.\n\n\n## Example\nIn the following example, we have an enum class\
    \ called `Result`, intended to report the result of some operation:\n\n\n```java\n\
    public enum Result {\n\tSUCCESS,\n\tFAILURE,\n\tERROR\n}\n\npublic Result runOperation(String\
    \ value) {\n\tif (value == 1) {\n\t\treturn SUCCESS;\n\t} else {\n\t\treturn FAILURE;\n\
    \t}\n}\n\npublic static void main(String[] args) {\n\tResult operationResult =\
    \ runOperation(args[0]);\n\tif (operationResult == Result.ERROR) {\n\t\texit(1);\n\
    \t} else {\n\t\texit(0);\n\t}\n\n}\n```\nThe method `runOperation` performs some\
    \ operation, and returns a `Result` depending on whether the operation succeeded.\
    \ However, it only returns either `SUCCESS` or `FAILURE`, and never `ERROR`. The\
    \ `main` method calls `runOperation`, and checks whether the returned result is\
    \ the `ERROR`. However, this check will always return the same result - `false`.\
    \ This is because the `operationResult` can never hold `ERROR`, because `ERROR`\
    \ is never stored or returned anywhere in the program. Therefore, `ERROR` is dead\
    \ and can be removed, along with the comparison check, and the `exit(1);`.\n\n\
    \n## References\n* Wikipedia: [Redundant code](https://en.wikipedia.org/wiki/Redundant_code).\n\
    * CERT Java Coding Standard: [MSC56-J. Detect and remove superfluous code and\
    \ values](https://www.securecoding.cert.org/confluence/display/java/MSC56-J.+Detect+and+remove+superfluous+code+and+values).\n\
    * Common Weakness Enumeration: [CWE-561](https://cwe.mitre.org/data/definitions/561.html).\n"
 -
  pack: codeql/java-queries#0
  relativeQueryPath: DeadCode/DeadField.ql
  relativeBqrsPath: codeql/java-queries/DeadCode/DeadField.bqrs
  metadata:
    name: Dead field
    description: Fields that are never read are likely unnecessary.
    kind: problem
    problem.severity: recommendation
    precision: medium
    id: java/dead-field
    tags: |-
      maintainability
             useless-code
             external/cwe/cwe-561
  queryHelp: "# Dead field\nFields that are never read at runtime are unnecessary\
    \ and should be removed.\n\nRedundant, or \"dead\", code imposes a burden on those\
    \ reading or maintaining the software project. It can make it harder to understand\
    \ the structure of the code, as well as increasing the complexity of adding new\
    \ features or fixing bugs. It can also affect compilation and build times for\
    \ the project, as dead code will still be compiled and built even if it is never\
    \ used. In some cases it may also affect runtime performance - for example, fields\
    \ that are written to but never read from, where the value written to the field\
    \ is expensive to compute. Removing dead code should not change the meaning of\
    \ the program.\n\nFields are considered dead if at runtime they are never read\
    \ directly or indirectly, for example through a framework or a use of reflection.\
    \ Any field which is not dead is considered to be \"live\".\n\nFields are considered\
    \ to be dead if they are only written to, and never read.\n\nA class, method,\
    \ or field may be dead even if it has dependencies from other parts of the program,\
    \ if those dependencies are from code that is also considered to be dead. We can\
    \ also consider this from the opposite side - an element is live, if and only\
    \ if there is an entry point - such as a `main` method - that eventually calls\
    \ the method, reads the field or constructs the class.\n\nWhen identifying dead\
    \ code, we make an assumption that the snapshot of the project includes all possible\
    \ callers of the code. If the project is a library project, this may not be the\
    \ case, and code may be flagged as dead when it is only used by other projects\
    \ not included in the snapshot.\n\nYou can customize the results by defining additional\
    \ \"entry points\" or by identifying fields that are accessed using reflection.\
    \ You may also wish to \"whitelist\" classes, methods or fields that should be\
    \ excluded from the results. Please refer to the Semmle documentation for more\
    \ information.\n\n\n## Recommendation\nBefore making any changes, confirm that\
    \ the field is not required by verifying that the field is only read from dead\
    \ methods. This confirmation is necessary because there may be project-specific\
    \ frameworks or techniques which can introduce hidden dependencies. If this project\
    \ is for a library, then consider whether the field is part of the external API,\
    \ and may be used in external projects that are not included in the snapshot.\n\
    \nAfter confirming that the field is not required, remove the field. You will\
    \ also need to remove any references to this field, which may, in turn, require\
    \ removing other unused classes, methods and fields.\n\nIf you observe a large\
    \ number of false positives, you may need to add extra entry points to identify\
    \ hidden dependencies caused by the use of a particular framework or technique,\
    \ or to identify library project entry points. Please refer to the Semmle documentation\
    \ for more information on how to do this.\n\n\n## Example 1\nIn the following\
    \ example, we have a class containing a single field called `deadField`:\n\n\n\
    ```java\npublic class FieldOnlyRead {\n\tprivate int deadField;\n\n\tprivate int\
    \ getDeadField() {\n\t\treturn deadField;\n\t}\n}\n```\nThe field is only read\
    \ from the method `getDeadField`. However, `getDeadField` is never called, so\
    \ the field is never read at runtime. The field is therefore marked as dead.\n\
    \n\n## Example 2\nIn this example, we have another class containing a single field\
    \ called `writtenToField`:\n\n\n```java\npublic class FieldOnlyRead {\n\tprivate\
    \ int writtenToField;\n\n\tpublic void runThing() {\n\t\twrittenToField = 2;\n\
    \t\tcallOtherThing();\n\t}\n\n\tpublic static main(String[] args) {\n\t\trunThing();\n\
    \t}\n}\n```\nThe field is written to in the method `runThing`, which is live because\
    \ it is called by the `main` method. However, the field is never read at runtime,\
    \ only written to. The field is therefore marked as dead.\n\n\n## Example 3\n\
    In this example, we have a class representing something that can be serialized\
    \ to and from XML:\n\n\n```java\n@XmlRootElement\npublic class SerializableClass\
    \ {\n\t@XmlAttribute\n\tprivate String field;\n\n\tpublic void setField(String\
    \ field) {\n\t\tthis.field = field;\n\t}\n}\n```\nThe field `field` is written\
    \ and read by the serialization framework in order to store the contents of the\
    \ object in an XML file, or to construct an instance of the object from an XML\
    \ file. The field is therefore considered to be read at runtime, which makes the\
    \ field live.\n\n\n## References\n* Wikipedia: [Redundant code](https://en.wikipedia.org/wiki/Redundant_code).\n\
    * CERT Java Coding Standard: [MSC56-J. Detect and remove superfluous code and\
    \ values](https://www.securecoding.cert.org/confluence/display/java/MSC56-J.+Detect+and+remove+superfluous+code+and+values).\n\
    * Common Weakness Enumeration: [CWE-561](https://cwe.mitre.org/data/definitions/561.html).\n"
 -
  pack: codeql/java-queries#0
  relativeQueryPath: DeadCode/DeadMethod.ql
  relativeBqrsPath: codeql/java-queries/DeadCode/DeadMethod.bqrs
  metadata:
    name: Dead method
    description: Dead methods add unnecessary complexity.
    kind: problem
    problem.severity: recommendation
    precision: medium
    id: java/dead-function
    tags: |-
      maintainability
             useless-code
             external/cwe/cwe-561
  queryHelp: "# Dead method\nMethods that are never called at runtime are redundant\
    \ and should be removed.\n\nRedundant, or \"dead\", code imposes a burden on those\
    \ reading or maintaining the software project. It can make it harder to understand\
    \ the structure of the code, as well as increasing the complexity of adding new\
    \ features or fixing bugs. It can also affect compilation and build times for\
    \ the project, as dead code will still be compiled and built even if it is never\
    \ used. In some cases it may also affect runtime performance - for example, fields\
    \ that are written to but never read from, where the value written to the field\
    \ is expensive to compute. Removing dead code should not change the meaning of\
    \ the program.\n\nMethods are considered dead if at runtime they are never called,\
    \ either directly, by a method call, or indirectly, through a framework or use\
    \ of reflection. Any method which is not dead is considered to be \"live\".\n\n\
    The results can include methods, constructors and initializers. Initializers come\
    \ in two forms, instance initializers and static initializers. For each class\
    \ there will be at most one dead initializer of each type, representing all the\
    \ initialization of that type in the class.\n\nA class, method, or field may be\
    \ dead even if it has dependencies from other parts of the program, if those dependencies\
    \ are from code that is also considered to be dead. We can also consider this\
    \ from the opposite side - an element is live, if and only if there is an entry\
    \ point - such as a `main` method - that eventually calls the method, reads the\
    \ field or constructs the class.\n\nWhen identifying dead code, we make an assumption\
    \ that the snapshot of the project includes all possible callers of the code.\
    \ If the project is a library project, this may not be the case, and code may\
    \ be flagged as dead when it is only used by other projects not included in the\
    \ snapshot.\n\nYou can customize the results by defining additional \"entry points\"\
    \ or by identifying fields that are accessed using reflection. You may also wish\
    \ to \"whitelist\" classes, methods or fields that should be excluded from the\
    \ results. Please refer to the Semmle documentation for more information.\n\n\n\
    ## Recommendation\nBefore making any changes, confirm that the method is not required\
    \ by verifying that the only dependencies on the method are from other dead methods.\
    \ This confirmation is necessary because there may be project-specific frameworks\
    \ or techniques which can introduce hidden dependencies. If this project is for\
    \ a library, then consider whether the method is part of the external API, and\
    \ may be used in external projects that are not included in the snapshot.\n\n\
    After confirming that the method is not required, remove the method. You will\
    \ also need to remove any references to this method, which may, in turn, require\
    \ removing other unused classes, methods and fields (see Example 1).\n\nIf the\
    \ result is a static initializer, then all `static { ... }` blocks and initializers\
    \ on static fields are dead within that class. In addition, the lack of static\
    \ initialization implies that all static methods and fields are also dead and\
    \ can be removed. These methods and fields will also be reported separately. In\
    \ contrast, static nested classes may still be live, because constructing or accessing\
    \ the nested static class does not trigger static initialization of the outer\
    \ class.\n\nIf the result is an instance initializer, then all instance initializer\
    \ `{ ... }` blocks and initializers on instance fields are dead. In addition,\
    \ the lack of instance initialization implies that the class is never constructed,\
    \ which means that all instance methods and fields are also dead and can be removed.\
    \ These methods and fields will also be reported separately.\n\nIf you observe\
    \ a large number of false positives, you may need to add extra entry points to\
    \ identify hidden dependencies caused by the use of a particular framework or\
    \ technique, or to identify library project entry points. Please refer to the\
    \ Semmle documentation for more information on how to do this.\n\n\n## Example\
    \ 1\nIn the following example, we have a number of methods, and an \"entry point\"\
    \ in the form of a main method.\n\n\n```java\npublic static void main(String[]\
    \ args) {\n\t// Only call the live method\n\tliveMethod();\n}\n\n/** This method\
    \ is live because it is called by main(..) */\npublic static void liveMethod()\
    \ {\n\totherLiveMethod()\n}\n\n/** This method is live because it is called by\
    \ a live method */\npublic static void otherLiveMethod() {\n}\n\n\n/** This method\
    \ is dead because it is never called */\npublic static void deadMethod() {\n\t\
    otherDeadMethod();\n}\n\n/** This method is dead because it is only called by\
    \ dead methods */\npublic static void otherDeadMethod() {\n}\n```\nThe method\
    \ `liveMethod` is called from the main method, and is therefore considered live.\
    \ `liveMethod` calls `otherLiveMethod`, which also makes that live.\n\nIn contrast,\
    \ `deadMethod` is never called, and does not represent an entry point, so is marked\
    \ as dead. Likewise, `otherDeadMethod` is only called from the `deadMethod`, so\
    \ is also marked as dead.\n\n\n## Example 2\nIn this example, we have a test class\
    \ containing a number of methods.\n\n\n```java\npublic class TestClass {\n\n\t\
    @Before\n\tpublic void setUp() {\n\t\t// ...\n\t}\n\n\t@Test\n\tpublic void testCustomer()\
    \ {\n\t\t// ...\n\t}\n}\n```\nIn this case, no methods are called directly. However,\
    \ the annotations on the methods indicate that this is a test class - specifically,\
    \ JUnit - and that the methods will be called by the test framework when running\
    \ the tests. `testCustomer` and `setUp` are therefore considered to be \"live\"\
    .\n\n\n## References\n* Wikipedia: [Redundant code](https://en.wikipedia.org/wiki/Redundant_code).\n\
    * CERT Java Coding Standard: [MSC56-J. Detect and remove superfluous code and\
    \ values](https://www.securecoding.cert.org/confluence/display/java/MSC56-J.+Detect+and+remove+superfluous+code+and+values).\n\
    * Common Weakness Enumeration: [CWE-561](https://cwe.mitre.org/data/definitions/561.html).\n"
 -
  pack: codeql/java-queries#0
  relativeQueryPath: DeadCode/FLinesOfDeadCode.ql
  relativeBqrsPath: codeql/java-queries/DeadCode/FLinesOfDeadCode.bqrs
  metadata:
    name: Lines of dead code in files
    description: The number of lines of dead code in a file.
    kind: treemap
    treemap.warnOn: highValues
    metricType: file
    metricAggregate: avg sum max
    id: java/lines-of-dead-code
    tags: |-
      maintainability
             external/cwe/cwe-561
  queryHelp: |
    # Lines of dead code in files
    Redundant, or "dead", code imposes a burden on those reading or maintaining the software project. It can make it harder to understand the structure of the code, as well as increasing the complexity of adding new features or fixing bugs. It can also affect compilation and build times for the project, as dead code will still be compiled and built even if it is never used. In some cases it may also affect runtime performance - for example, fields that are written to but never read from, where the value written to the field is expensive to compute. Removing dead code should not change the meaning of the program.

    A class, method, or field may be dead even if it has dependencies from other parts of the program, if those dependencies are from code that is also considered to be dead. We can also consider this from the opposite side - an element is live, if and only if there is an entry point - such as a `main` method - that eventually calls the method, reads the field or constructs the class.

    When identifying dead code, we make an assumption that the snapshot of the project includes all possible callers of the code. If the project is a library project, this may not be the case, and code may be flagged as dead when it is only used by other projects not included in the snapshot.

    You can customize the results by defining additional "entry points" or by identifying fields that are accessed using reflection. You may also wish to "whitelist" classes, methods or fields that should be excluded from the results. Please refer to the Semmle documentation for more information.


    ## Recommendation
    Any code that is marked as dead should be reviewed and, if it is genuinely not used, deleted. You can see which classes, methods and fields contribute to this metric using the rules for Dead Code analysis.


    ## References
    * Wikipedia: [Redundant code](https://en.wikipedia.org/wiki/Redundant_code).
    * CERT Java Coding Standard: [MSC56-J. Detect and remove superfluous code and values](https://www.securecoding.cert.org/confluence/display/java/MSC56-J.+Detect+and+remove+superfluous+code+and+values).
    * Common Weakness Enumeration: [CWE-561](https://cwe.mitre.org/data/definitions/561.html).
 -
  pack: codeql/java-queries#0
  relativeQueryPath: DeadCode/UselessParameter.ql
  relativeBqrsPath: codeql/java-queries/DeadCode/UselessParameter.bqrs
  metadata:
    name: Useless parameter
    description: Parameters that are not used add unnecessary complexity to an interface.
    kind: problem
    problem.severity: recommendation
    precision: high
    id: java/unused-parameter
    tags: |-
      maintainability
             useless-code
             external/cwe/cwe-561
  queryHelp: "# Useless parameter\nParameters that are never read in the body of the\
    \ method, and are not required due to overriding, are useless and can be removed.\
    \ Useless parameters unnecessarily complicate the interface for that method, and\
    \ cause a maintenance and development burden.\n\nMethods with useless parameters\
    \ indicate that either the method can be simplified by removing the parameter,\
    \ or that the method is not using a value it should be using. Parameters of methods\
    \ that override other methods will not be marked as useless, because they are\
    \ required. Similarly, parameters of methods that are overridden by other methods\
    \ are not marked as useless if they are used by one of the overriding methods.\n\
    \n\n## Recommendation\nThe method should be inspected to determine whether the\
    \ parameter should be used within the body. If the method is overridden, also\
    \ consider whether any override methods should be using the parameter. If the\
    \ parameter is not required, it should be removed.\n\n\n## Example\nIn the following\
    \ example, we have a method for determining whether a `String` path is an absolute\
    \ path:\n\n\n```java\npublic void isAbsolutePath(String path, String name) {\n\
    \treturn path.startsWith(\"/\") || path.startsWith(\"\\\\\");\n}\n```\nThe method\
    \ uses the parameter `path` to determine the return value. However, the parameter\
    \ `name` is not used within the body of the method. The parameter will be marked\
    \ as useless, and can be removed from the program.\n\n\n## References\n* Wikipedia:\
    \ [Redundant code](https://en.wikipedia.org/wiki/Redundant_code).\n* CERT Java\
    \ Coding Standard: [MSC56-J. Detect and remove superfluous code and values](https://www.securecoding.cert.org/confluence/display/java/MSC56-J.+Detect+and+remove+superfluous+code+and+values).\n\
    * Common Weakness Enumeration: [CWE-561](https://cwe.mitre.org/data/definitions/561.html).\n"
 -
  pack: codeql/java-queries#0
  relativeQueryPath: Diagnostics/ExtractionErrors.ql
  relativeBqrsPath: codeql/java-queries/Diagnostics/ExtractionErrors.bqrs
  metadata:
    name: Extraction errors
    description: A list of extraction errors for files in the source code directory.
    kind: diagnostic
    id: java/diagnostics/extraction-errors
 -
  pack: codeql/java-queries#0
  relativeQueryPath: Diagnostics/ExtractionWarnings.ql
  relativeBqrsPath: codeql/java-queries/Diagnostics/ExtractionWarnings.bqrs
  metadata:
    name: Extraction warnings
    description: A list of extraction warnings for files in the source code directory.
    kind: diagnostic
    id: java/diagnostics/extraction-warnings
 -
  pack: codeql/java-queries#0
  relativeQueryPath: Diagnostics/SuccessfullyExtractedFiles.ql
  relativeBqrsPath: codeql/java-queries/Diagnostics/SuccessfullyExtractedFiles.bqrs
  metadata:
    name: Extracted files
    description: |-
      A list of all files in the source code directory that
                    were extracted.
    kind: diagnostic
    id: java/diagnostics/successfully-extracted-files
    tags: successfully-extracted-files
 -
  pack: codeql/java-queries#0
  relativeQueryPath: Frameworks/JavaEE/EJB/EjbContainerInterference.ql
  relativeBqrsPath: codeql/java-queries/Frameworks/JavaEE/EJB/EjbContainerInterference.bqrs
  metadata:
    name: EJB interferes with container operation
    description: |-
      An EJB should not attempt to create a class loader,
                    obtain the current class loader, set the context class loader,
                    set a security manager, create a new security manager,
                    stop the JVM, or change the input, output or error streams.
                    Such operations could interfere with the EJB container's operation.
    kind: problem
    problem.severity: error
    precision: low
    id: java/ejb/container-interference
    tags: |-
      reliability
             external/cwe/cwe-578
             external/cwe/cwe-382
  queryHelp: |
    # EJB interferes with container operation
    The Enterprise JavaBeans 3.0 core specification, Section 21.1.2, states:

    > The enterprise bean must not attempt to create a class loader; obtain the current class loader; set the context class loader; set security manager; create a new security manager; stop the JVM; or change the input, output, and error streams.

    These functions are reserved for the EJB container. Allowing the enterprise bean to use these functions could compromise security and decrease the container's ability to properly manage the runtime environment.


    ## References
    * [ JSR-220 Enterprise JavaBeans 3.0 Final Release](http://jcp.org/aboutJava/communityprocess/final/jsr220/index.html) (ejbcore), Section 21.1.2 Programming Restrictions
    * Common Weakness Enumeration: [CWE-578](https://cwe.mitre.org/data/definitions/578.html).
    * Common Weakness Enumeration: [CWE-382](https://cwe.mitre.org/data/definitions/382.html).
 -
  pack: codeql/java-queries#0
  relativeQueryPath: Frameworks/JavaEE/EJB/EjbFileIO.ql
  relativeBqrsPath: codeql/java-queries/Frameworks/JavaEE/EJB/EjbFileIO.bqrs
  metadata:
    name: EJB uses file input/output
    description: |-
      An EJB should not attempt to access files or directories in the file system.
                    Such use could compromise security and is not a suitable data access method
                    for enterprise components.
    kind: problem
    problem.severity: error
    precision: low
    id: java/ejb/file-io
    tags: |-
      reliability
             external/cwe/cwe-576
  queryHelp: |
    # EJB uses file input/output
    The Enterprise JavaBeans 3.0 core specification, Section 21.1.2, states:

    > An enterprise bean must not use the `java.io` package to attempt to access files and directories in the file system.

    The file system APIs are not well-suited for business components to access data. Business components should use a resource manager API, such as JDBC, to store data.


    ## References
    * [ JSR-220 Enterprise JavaBeans 3.0 Final Release](http://jcp.org/aboutJava/communityprocess/final/jsr220/index.html) (ejbcore), Section 21.1.2 Programming Restrictions
    * Common Weakness Enumeration: [CWE-576](https://cwe.mitre.org/data/definitions/576.html).
 -
  pack: codeql/java-queries#0
  relativeQueryPath: Frameworks/JavaEE/EJB/EjbGraphics.ql
  relativeBqrsPath: codeql/java-queries/Frameworks/JavaEE/EJB/EjbGraphics.bqrs
  metadata:
    name: EJB uses graphics
    description: |-
      An EJB should not use AWT or other graphics functionality.
                    Such operations are normally performed by an end-user interface
                    that accesses a server but not by the server itself.
    kind: problem
    problem.severity: error
    precision: low
    id: java/ejb/graphics
    tags: |-
      reliability
             external/cwe/cwe-575
  queryHelp: |
    # EJB uses graphics
    The Enterprise JavaBeans 3.0 core specification, Section 21.1.2, states:

    > An enterprise bean must not use the AWT functionality to attempt to output information to a display, or to input information from a keyboard.

    Most servers do not allow direct interaction between an application program and a keyboard/display attached to the server system.


    ## References
    * [ JSR-220 Enterprise JavaBeans 3.0 Final Release](http://jcp.org/aboutJava/communityprocess/final/jsr220/index.html) (ejbcore), Section 21.1.2 Programming Restrictions
    * Common Weakness Enumeration: [CWE-575](https://cwe.mitre.org/data/definitions/575.html).
 -
  pack: codeql/java-queries#0
  relativeQueryPath: Frameworks/JavaEE/EJB/EjbNative.ql
  relativeBqrsPath: codeql/java-queries/Frameworks/JavaEE/EJB/EjbNative.bqrs
  metadata:
    name: EJB uses native code
    description: |-
      An EJB should not attempt to load or execute native code.
                    Such use could compromise security and system stability.
    kind: problem
    problem.severity: error
    precision: low
    id: java/ejb/native-code
    tags: |-
      reliability
             external/cwe/cwe-573
  queryHelp: |
    # EJB uses native code
    The Enterprise JavaBeans 3.0 core specification, Section 21.1.2, states:

    > The enterprise bean must not attempt to load a native library.

    This function is reserved for the EJB container. Allowing the enterprise bean to load native code would create a security hole.


    ## References
    * [ JSR-220 Enterprise JavaBeans 3.0 Final Release](http://jcp.org/aboutJava/communityprocess/final/jsr220/index.html) (ejbcore), Section 21.1.2 Programming Restrictions
    * Common Weakness Enumeration: [CWE-573](https://cwe.mitre.org/data/definitions/573.html).
 -
  pack: codeql/java-queries#0
  relativeQueryPath: Frameworks/JavaEE/EJB/EjbReflection.ql
  relativeBqrsPath: codeql/java-queries/Frameworks/JavaEE/EJB/EjbReflection.bqrs
  metadata:
    name: EJB uses reflection
    description: |-
      An EJB should not attempt to use the Reflection API,
                    as this could compromise security.
    kind: problem
    problem.severity: error
    precision: low
    id: java/ejb/reflection
    tags: external/cwe/cwe-573
  queryHelp: |
    # EJB uses reflection
    The Enterprise JavaBeans 3.0 core specification, Section 21.1.2, states:

    > The enterprise bean must not attempt to query a class to obtain information about the declared members that are not otherwise accessible to the enterprise bean because of the security rules of the Java language. The enterprise bean must not attempt to use the Reflection API to access information that the security rules of the Java programming language make unavailable.

    Allowing the enterprise bean to access information about other classes and to access the classes in a manner that is normally disallowed by the Java programming language could compromise security.


    ## References
    * [ JSR-220 Enterprise JavaBeans 3.0 Final Release](http://jcp.org/aboutJava/communityprocess/final/jsr220/index.html) (ejbcore), Section 21.1.2 Programming Restrictions
    * Common Weakness Enumeration: [CWE-573](https://cwe.mitre.org/data/definitions/573.html).
 -
  pack: codeql/java-queries#0
  relativeQueryPath: Frameworks/JavaEE/EJB/EjbSecurityConfiguration.ql
  relativeBqrsPath: codeql/java-queries/Frameworks/JavaEE/EJB/EjbSecurityConfiguration.bqrs
  metadata:
    name: EJB accesses security configuration
    description: |-
      An EJB should not attempt to access or modify any Java security configuration,
                    including the Policy, Security, Provider, Signer and Identity objects.
                    This functionality is reserved for the EJB container for security reasons.
    kind: problem
    problem.severity: error
    precision: low
    id: java/ejb/security-configuration-access
    tags: external/cwe/cwe-573
  queryHelp: |
    # EJB accesses security configuration
    The Enterprise JavaBeans 3.0 core specification, Section 21.1.2, states:

    > The enterprise bean must not attempt to access or modify the security configuration objects (Policy, Security, Provider, Signer, and Identity).

    These functions are reserved for the EJB container. Allowing the enterprise bean to use these functions could compromise security.


    ## References
    * [ JSR-220 Enterprise JavaBeans 3.0 Final Release](http://jcp.org/aboutJava/communityprocess/final/jsr220/index.html) (ejbcore), Section 21.1.2 Programming Restrictions
    * Common Weakness Enumeration: [CWE-573](https://cwe.mitre.org/data/definitions/573.html).
 -
  pack: codeql/java-queries#0
  relativeQueryPath: Frameworks/JavaEE/EJB/EjbSerialization.ql
  relativeBqrsPath: codeql/java-queries/Frameworks/JavaEE/EJB/EjbSerialization.bqrs
  metadata:
    name: EJB uses substitution in serialization
    description: |-
      An EJB should not use the subclass or object substitution features of
                    the Java serialization protocol, since their use could compromise security.
    kind: problem
    problem.severity: error
    precision: low
    id: java/ejb/substitution-in-serialization
    tags: external/cwe/cwe-573
  queryHelp: |
    # EJB uses substitution in serialization
    The Enterprise JavaBeans 3.0 core specification, Section 21.1.2, states:

    > The enterprise bean must not attempt to use the subclass and object substitution features of the Java Serialization Protocol.

    Allowing the enterprise bean to use these functions could compromise security.


    ## References
    * [ JSR-220 Enterprise JavaBeans 3.0 Final Release](http://jcp.org/aboutJava/communityprocess/final/jsr220/index.html) (ejbcore), Section 21.1.2 Programming Restrictions
    * Common Weakness Enumeration: [CWE-573](https://cwe.mitre.org/data/definitions/573.html).
 -
  pack: codeql/java-queries#0
  relativeQueryPath: Frameworks/JavaEE/EJB/EjbSetSocketOrUrlFactory.ql
  relativeBqrsPath: codeql/java-queries/Frameworks/JavaEE/EJB/EjbSetSocketOrUrlFactory.bqrs
  metadata:
    name: EJB sets socket factory or URL stream handler factory
    description: |-
      An EJB should not set the socket factory used by ServerSocket or Socket,
                    or the stream handler factory used by URL. Such operations could
                    compromise security or interfere with the EJB container's operation.
    kind: problem
    problem.severity: error
    precision: low
    id: java/ejb/socket-or-stream-handler-factory
    tags: |-
      reliability
             external/cwe/cwe-577
  queryHelp: |
    # EJB sets socket factory or URL stream handler factory
    The Enterprise JavaBeans 3.0 core specification, Section 21.1.2, states:

    > The enterprise bean must not attempt to set the socket factory used by ServerSocket, Socket, or the stream handler factory used by URL.

    These networking functions are reserved for the EJB container. Allowing the enterprise bean to use these functions could compromise security and decrease the container's ability to properly manage the runtime environment.


    ## References
    * [ JSR-220 Enterprise JavaBeans 3.0 Final Release](http://jcp.org/aboutJava/communityprocess/final/jsr220/index.html) (ejbcore), Section 21.1.2 Programming Restrictions
    * Common Weakness Enumeration: [CWE-577](https://cwe.mitre.org/data/definitions/577.html).
 -
  pack: codeql/java-queries#0
  relativeQueryPath: Frameworks/JavaEE/EJB/EjbSocketAsServer.ql
  relativeBqrsPath: codeql/java-queries/Frameworks/JavaEE/EJB/EjbSocketAsServer.bqrs
  metadata:
    name: EJB uses server socket
    description: |-
      An EJB should not attempt to listen to or accept connections on a socket,
                    or use a socket for multicast. Functioning as a general network server
                    would conflict with the EJB's purpose to serve EJB clients.
    kind: problem
    problem.severity: error
    precision: low
    id: java/ejb/server-socket
    tags: |-
      reliability
             external/cwe/cwe-577
  queryHelp: |
    # EJB uses server socket
    The Enterprise JavaBeans 3.0 core specification, Section 21.1.2, states:

    > An enterprise bean must not attempt to listen on a socket, accept connections on a socket, or use a socket for multicast.

    The EJB architecture allows an enterprise bean instance to be a network socket client, but it does not allow it to be a network server. Allowing the instance to become a network server would conflict with the basic function of the enterprise bean&mdash;to serve the EJB clients.


    ## References
    * [ JSR-220 Enterprise JavaBeans 3.0 Final Release](http://jcp.org/aboutJava/communityprocess/final/jsr220/index.html) (ejbcore), Section 21.1.2 Programming Restrictions
    * Common Weakness Enumeration: [CWE-577](https://cwe.mitre.org/data/definitions/577.html).
 -
  pack: codeql/java-queries#0
  relativeQueryPath: Frameworks/JavaEE/EJB/EjbStaticFieldNonFinal.ql
  relativeBqrsPath: codeql/java-queries/Frameworks/JavaEE/EJB/EjbStaticFieldNonFinal.bqrs
  metadata:
    name: EJB uses non-final static field
    description: |-
      An EJB should not make use of non-final static fields,
                    since a consistent state of such fields is not guaranteed
                    if an EJB instance is distributed across multiple JVMs.
    kind: problem
    problem.severity: error
    precision: low
    id: java/ejb/non-final-static-field
    tags: |-
      reliability
             external/cwe/cwe-573
  queryHelp: |
    # EJB uses non-final static field
    The Enterprise JavaBeans 3.0 core specification, Section 21.1.2, states:

    > An enterprise bean must not use read/write static fields. Using read-only static fields is allowed. Therefore, it is recommended that all static fields in the enterprise bean class be declared as final.

    This rule is required to ensure consistent runtime semantics because while some EJB containers may use a single JVM to execute all enterprise bean's instances, others may distribute the instances across multiple JVMs.


    ## References
    * [ JSR-220 Enterprise JavaBeans 3.0 Final Release](http://jcp.org/aboutJava/communityprocess/final/jsr220/index.html) (ejbcore), Section 21.1.2 Programming Restrictions
    * Common Weakness Enumeration: [CWE-573](https://cwe.mitre.org/data/definitions/573.html).
 -
  pack: codeql/java-queries#0
  relativeQueryPath: Frameworks/JavaEE/EJB/EjbSynchronization.ql
  relativeBqrsPath: codeql/java-queries/Frameworks/JavaEE/EJB/EjbSynchronization.bqrs
  metadata:
    name: EJB uses synchronization
    description: |-
      An EJB should not use synchronization, since it will not work properly
                    if an EJB is distributed across multiple JVMs.
    kind: problem
    problem.severity: error
    precision: low
    id: java/ejb/synchronization
    tags: |-
      reliability
             external/cwe/cwe-574
  queryHelp: |
    # EJB uses synchronization
    The Enterprise JavaBeans 3.0 core specification, Section 21.1.2, states:

    > An enterprise bean must not use thread synchronization primitives to synchronize execution of multiple instances.

    Synchronization would not work if the EJB container distributed enterprise bean's instances across multiple JVMs.


    ## References
    * [ JSR-220 Enterprise JavaBeans 3.0 Final Release](http://jcp.org/aboutJava/communityprocess/final/jsr220/index.html) (ejbcore), Section 21.1.2 Programming Restrictions
    * Common Weakness Enumeration: [CWE-574](https://cwe.mitre.org/data/definitions/574.html).
 -
  pack: codeql/java-queries#0
  relativeQueryPath: Frameworks/JavaEE/EJB/EjbThis.ql
  relativeBqrsPath: codeql/java-queries/Frameworks/JavaEE/EJB/EjbThis.bqrs
  metadata:
    name: EJB uses 'this' as argument or result
    description: |-
      An EJB should not use 'this' as a method argument or result.
                    Instead, it should use the result of SessionContext.getBusinessObject,
                    SessionContext.getEJBObject, SessionContext.getEJBLocalObject,
                    EntityContext.getEJBObject, or EntityContext.getEJBLocalObject.
    kind: problem
    problem.severity: error
    precision: low
    id: java/ejb/this
    tags: |-
      portability
             external/cwe/cwe-573
  queryHelp: |
    # EJB uses 'this' as argument or result
    The Enterprise JavaBeans 3.0 core specification, Section 21.1.2, states:

    > The enterprise bean must not attempt to pass `this` as an argument or method result. The enterprise bean must pass the result of `SessionContext.getBusinessObject`, `SessionContext.getEJBObject`, `SessionContext.getEJBLocalObject`, `EntityContext.getEJBObject`, or `EntityContext.getEJBLocalObject` instead.


    ## References
    * [ JSR-220 Enterprise JavaBeans 3.0 Final Release](http://jcp.org/aboutJava/communityprocess/final/jsr220/index.html) (ejbcore), Section 21.1.2 Programming Restrictions
    * Common Weakness Enumeration: [CWE-573](https://cwe.mitre.org/data/definitions/573.html).
 -
  pack: codeql/java-queries#0
  relativeQueryPath: Frameworks/JavaEE/EJB/EjbThreads.ql
  relativeBqrsPath: codeql/java-queries/Frameworks/JavaEE/EJB/EjbThreads.bqrs
  metadata:
    name: EJB uses threads
    description: |-
      An EJB should not attempt to manage threads,
                    as it could interfere with the EJB container's operation.
    kind: problem
    problem.severity: error
    precision: low
    id: java/ejb/threads
    tags: |-
      reliability
             external/cwe/cwe-383
             external/cwe/cwe-573
  queryHelp: |
    # EJB uses threads
    The Enterprise JavaBeans 3.0 core specification, Section 21.1.2, states:

    > The enterprise bean must not attempt to manage threads. The enterprise bean must not attempt to start, stop, suspend, or resume a thread, or to change a thread's priority or name. The enterprise bean must not attempt to manage thread groups.

    These functions are reserved for the EJB container. Allowing the enterprise bean to manage threads would decrease the container's ability to properly manage the runtime environment.


    ## References
    * [ JSR-220 Enterprise JavaBeans 3.0 Final Release](https://jcp.org/aboutJava/communityprocess/final/jsr220/index.html) (ejbcore), Section 21.1.2 Programming Restrictions
    * Common Weakness Enumeration: [CWE-383](https://cwe.mitre.org/data/definitions/383.html).
    * Common Weakness Enumeration: [CWE-573](https://cwe.mitre.org/data/definitions/573.html).
 -
  pack: codeql/java-queries#0
  relativeQueryPath: Frameworks/Spring/Architecture/Refactoring Opportunities/MissingParentBean.ql
  relativeBqrsPath: codeql/java-queries/Frameworks/Spring/Architecture/Refactoring
    Opportunities/MissingParentBean.bqrs
  metadata:
    name: Beans sharing similar properties
    description: |-
      Beans that share similar properties exhibit unnecessary repetition in the bean
                    definitions and make the system's architecture more difficult to see.
    kind: problem
    problem.severity: recommendation
    precision: low
    id: java/spring/missing-parent-bean
    tags: |-
      maintainability
             frameworks/spring
  queryHelp: "# Beans sharing similar properties\nBeans that share a considerable\
    \ number of similar properties exhibit unnecessary repetition in the bean definitions\
    \ and make the system's architecture more difficult to see.\n\n\n## Recommendation\n\
    Try to move the properties that the bean definitions share to a common parent\
    \ bean. This reduces repetition in the bean definitions and gives a clearer picture\
    \ of the system's architecture.\n\n\n## Example\nThe following example shows a\
    \ configuration file that contains two beans that share several properties with\
    \ the same values.\n\n\n```xml\n<!--AVOID: 'shippingService' and 'orderService'\
    \ share several properties with the same values-->\n<bean id=\"shippingService\"\
    \ class=\"documentation.examples.spring.ShippingService\">\n\t<property name=\"\
    transactionHelper\">\n\t\t<ref bean=\"transactionHelper\"/>\n\t</property>\n\t\
    <property name=\"dao\">\n\t\t<ref bean=\"dao\"/>\n\t</property>\n\t<property name=\"\
    registry\">\n\t\t<ref bean=\"basicRegistry\"/>\n\t</property>\n\t\n\t<property\
    \ name=\"shippingProvider\" value=\"Federal Parcel Service\"/>\n</bean>\n\n<bean\
    \ id=\"orderService\" class=\"documentation.examples.spring.OrderService\">\n\t\
    <property name=\"transactionHelper\">\n\t\t<ref bean=\"transactionHelper\"/>\n\
    \t</property>\n\t<property name=\"dao\">\n\t\t<ref bean=\"dao\"/>\n\t</property>\n\
    \t<property name=\"registry\">\n\t\t<ref bean=\"basicRegistry\"/>\n\t</property>\n\
    \t\n\t<property name=\"orderReference\" value=\"8675309\"/>\n</bean>\n```\nThe\
    \ following example shows how the shared properties have been moved into a parent\
    \ bean, `baseService`.\n\n\n```xml\n<!--The 'baseService' bean contains common\
    \ property definitions for services.-->\n<bean id=\"baseService\" abstract=\"\
    true\">\n\t<property name=\"transactionHelper\">\n\t\t<ref bean=\"transactionHelper\"\
    />\n\t</property>\n\t<property name=\"dao\">\n\t\t<ref bean=\"dao\"/>\n\t</property>\n\
    \t<property name=\"registry\">\n\t\t<ref bean=\"basicRegistry\"/>\n\t</property>\n\
    </bean>\n\n<bean id=\"shippingService\" \n\t\tclass=\"documentation.examples.spring.ShippingService\"\
    \n\t\tparent=\"baseService\">\n\t<property name=\"shippingProvider\" value=\"\
    Federal Parcel Service\"/>\n</bean>\n\n<bean id=\"orderService\" \n\t\tclass=\"\
    documentation.examples.spring.OrderService\"\n\t\tparent=\"baseService\">\n\t\
    <property name=\"orderReference\" value=\"8675309\"/>\n</bean>\n```\n\n## References\n\
    * Spring Framework Reference Documentation 3.0: [3.4.2.2 References to other beans\
    \ (collaborators)](http://static.springsource.org/spring/docs/3.0.x/spring-framework-reference/html/beans.html#beans-ref-element).\n"
 -
  pack: codeql/java-queries#0
  relativeQueryPath: Frameworks/Spring/Architecture/Refactoring Opportunities/TooManyBeans.ql
  relativeBqrsPath: codeql/java-queries/Frameworks/Spring/Architecture/Refactoring
    Opportunities/TooManyBeans.bqrs
  metadata:
    name: Too many beans in file
    description: Too many beans in a file can make the file difficult to understand
      and maintain.
    kind: problem
    problem.severity: recommendation
    precision: low
    id: java/spring/too-many-beans
    tags: |-
      maintainability
             frameworks/spring
  queryHelp: |
    # Too many beans in file
    Too many bean definitions in a single file can make the file difficult to understand and maintain. It is also an indication that the architecture of the system is too tightly coupled and can be refactored.


    ## Recommendation
    Refactor related bean definitions into separate files, and compose them using the `<import/>` element.


    ## Example
    The following example shows a configuration file that imports two other configuration files. These two files were created by refactoring a file that contained too many bean definitions.


    ```xml
    <beans>
        <!--Compose configuration files by using the 'import' element.-->
        <import resource="services.xml"/>
        <import resource="resources/messageSource.xml"/>

        <bean id="bean1" class="..."/>
        <bean id="bean2" class="..."/>
    </beans>

    ```

    ## References
    * Spring Framework Reference Documentation 3.0: [3.2.2.1 Composing XML-based configuration metadata](http://static.springsource.org/spring/docs/3.0.x/spring-framework-reference/html/beans.html#beans-factory-xml-import).
 -
  pack: codeql/java-queries#0
  relativeQueryPath: Frameworks/Spring/Architecture/Refactoring Opportunities/UnusedBean.ql
  relativeBqrsPath: codeql/java-queries/Frameworks/Spring/Architecture/Refactoring
    Opportunities/UnusedBean.bqrs
  metadata:
    name: Beans that are never used within the code
    description: Beans that are specified but never used are redundant and should
      be removed.
    kind: problem
    problem.severity: recommendation
    precision: low
    id: java/spring/unused-bean
    tags: |-
      maintainability
             frameworks/spring
  queryHelp: "# Beans that are never used within the code\nBean definitions that are\
    \ specified but are never used are redundant and can be removed. Unused beans\
    \ make the program harder to understand.\n\nA bean definition is considered to\
    \ be used if one or more of the following is true:\n\n* The bean is referenced\
    \ or defined in the `<constructor-arg>` or `<property>` element of a live bean.\n\
    * The bean is injected in to a constructor or method of a live bean due to autowiring.\
    \ This includes autowiring by annotation (`@Autowired` or `@Inject`), and autowiring\
    \ configured by the autowired attribute within bean configuration files.\n* The\
    \ bean is explicitly loaded from a factory bean. It is not always possible to\
    \ determine when this occurs, because factory beans are loaded using a `String`\
    \ value, which may contain arbitrary values.\n* The bean is called reflectively\
    \ by the Spring framework. For example, if the class is a Spring MVC framework\
    \ controller, it may be called in response to web requests.\n* The bean has a\
    \ static initializer.\n* The bean is not lazy, and has a constructor or instance\
    \ initializer that modifies state outside of the bean.\nAny bean which is not\
    \ used in one or more ways will be marked as \"dead\".\n\n\n## Recommendation\n\
    First verify that the bean definition is never used at runtime. In some cases\
    \ beans may be used in framework-specific ways, or may be loaded by name from\
    \ a bean factory in a way that is impossible to determine statically.\n\nAfter\
    \ confirming that the bean is not required, remove the bean. You will also need\
    \ remove any references to this bean, which may, in turn, require removing other\
    \ beans or references.\n\n\n## Example\nThe following example shows a configuration\
    \ file that includes two beans:\n\n\n```xml\n<beans>\n    <!-- This bean is referred\
    \ to, so is live. -->\n    <bean id=\"petStore\" class=\"org.sample.PetStoreService\"\
    />\n    <!-- This bean is never referred to, so is dead. -->\n    <bean id=\"\
    clinic\" class=\"org.sample.ClinicService\"/>\n</beans>\n\n```\nThis XML file\
    \ is loaded with the following Java class:\n\n\n```java\nclass Start {\n\tpublic\
    \ static void main(String[] args) {\n\t\t// Create a context from the XML file,\
    \ constructing beans\n\t\tApplicationContext context =\n\t\t    new ClassPathXmlApplicationContext(new\
    \ String[] {\"services.xml\"});\n\n\t\t// Retrieve the petStore from the context\
    \ bean factory.\n\t\tPetStoreService service = context.getBean(\"petStore\", PetStoreService.class);\n\
    \t\t// Use the value\n\t\tList<String> userList = service.getUsernameList();\n\
    \t}\n}\n```\nThis class constructs a Spring `ApplicationContext` using the XML\
    \ file, then loads the \"petStore\" bean. Given these two files, the \"clinic\"\
    \ bean will be marked as dead because it is not used in any context, unlike the\
    \ \"petStore\" bean.\n\n\n## References\n* Spring Framework Reference Documentation\
    \ 4.2: [6.3 Bean overview](http://docs.spring.io/spring/docs/4.2.3.RELEASE/spring-framework-reference/html/beans.html#beans-definition).\n"
 -
  pack: codeql/java-queries#0
  relativeQueryPath: Frameworks/Spring/Architecture/Refactoring Opportunities/UselessPropertyOverride.ql
  relativeBqrsPath: codeql/java-queries/Frameworks/Spring/Architecture/Refactoring
    Opportunities/UselessPropertyOverride.bqrs
  metadata:
    name: Useless property override
    description: |-
      A bean property that overrides the same property in a parent bean, and has the same
                    contents, is useless.
    kind: problem
    problem.severity: warning
    precision: low
    id: java/spring/useless-property-override
    tags: |-
      maintainability
             frameworks/spring
  queryHelp: "# Useless property override\nA property in a child bean that overrides\
    \ a property with the same name in its parent and has the same contents is useless.\
    \ This is because the bean inherits the property from its parent anyway.\n\n\n\
    ## Recommendation\nIf possible, remove the property in the child bean.\n\n\n##\
    \ Example\nIn the following example, `registry` is defined in both the parent\
    \ bean and the child bean. It should be removed from the child bean.\n\n\n```xml\n\
    <beans>\n\t<bean id=\"baseShippingService\" abstract=\"true\">\n\t\t<property\
    \ name=\"transactionHelper\">\n\t\t\t<ref bean=\"transactionHelper\"/>\n\t\t</property>\n\
    \t\t<property name=\"dao\">\n\t\t\t<ref bean=\"dao\"/>\n\t\t</property>\n\t\t\
    <property name=\"registry\">\n\t\t\t<ref bean=\"basicRegistry\"/>\n\t\t</property>\n\
    \t</bean>\n\n\t<bean id=\"shippingService\" \n\t\t\tclass=\"documentation.examples.spring.ShippingService\"\
    \n\t\t\tparent=\"baseShippingService\">\n\t\t<!--AVOID: This property is already\
    \ defined with the same value in the parent bean.-->\n\t\t<property name=\"registry\"\
    >\n\t\t\t<ref bean=\"basicRegistry\"/>\n\t\t</property>\n\t\t<property name=\"\
    shippingProvider\" value=\"Federal Parcel Service\"/>\n\t</bean>\n</beans>\n\n\
    ```\n\n## References\n* Spring Framework Reference Documentation 3.0: [3.7 Bean\
    \ definition inheritance](http://static.springsource.org/spring/docs/3.0.x/spring-framework-reference/html/beans.html#beans-child-bean-definitions).\n"
 -
  pack: codeql/java-queries#0
  relativeQueryPath: Frameworks/Spring/Violations of Best Practice/AvoidAutowiring.ql
  relativeBqrsPath: codeql/java-queries/Frameworks/Spring/Violations of Best Practice/AvoidAutowiring.bqrs
  metadata:
    name: Avoid autowiring
    description: Using autowiring in Spring beans may make it difficult to maintain
      large projects.
    kind: problem
    problem.severity: recommendation
    precision: low
    id: java/spring/autowiring
    tags: |-
      maintainability
             frameworks/spring
  queryHelp: |
    # Avoid autowiring
    Using Spring autowiring can make it difficult to see what beans get passed to constructors or setters. The Spring Framework Reference documentation cites the following disadvantages of autowiring:

    * Explicit dependencies in `property` and `constructor-arg` settings always override autowiring. You cannot autowire so-called *simple* properties such as primitives, `Strings`, and `Classes` (and arrays of such simple properties). This limitation is by design.
    * Autowiring is less exact than explicit wiring. Although ... Spring is careful to avoid guessing in case of ambiguity that might have unexpected results, the relationships between your Spring-managed objects are no longer documented explicitly.
    * Wiring information may not be available to tools that may generate documentation from a Spring container.
    * Multiple bean definitions within the container may match the type specified by the setter method or constructor argument to be autowired. For arrays, collections, or Maps, this is not necessarily a problem. However for dependencies that expect a single value, this ambiguity is not arbitrarily resolved. If no unique bean definition is available, an exception is thrown.

    ## Recommendation
    The Spring Framework Reference documentation suggests the following ways to address problems with autowired beans:

    * Abandon autowiring in favor of explicit wiring.
    * Avoid autowiring for a bean definition by setting its `autowire-candidate` attributes to `false`.
    * Designate a single bean definition as the primary candidate by setting the `primary` attribute of its `<bean/>` element to true.
    * If you are using Java 5 or later, implement the more fine-grained control available with annotation-based configuration.

    ## Example
    The following example shows a bean, `autoWiredOrderService`, that is defined using autowiring, and an improved version of the bean, `orderService`, that is defined using explicit wiring.


    ```xml
    <!--AVOID: Using autowiring makes it difficult to see the dependencies of the bean-->
    <bean id="autoWiredOrderService"
            class="documentation.examples.spring.OrderService"
            autowire="byName"/>

    <!--GOOD: Explicitly specifying the properties of the bean documents its dependencies
        and makes the bean configuration easier to maintain-->
    <bean id="orderService"
            class="documentation.examples.spring.OrderService">
            <property name="DAO">
                <idref bean="dao"/>
            </property>
    </bean>

    ```

    ## References
    * Spring Framework Reference Documentation 3.0: [3.4.5.1 Limitations and disadvantages of autowiring](https://docs.spring.io/spring-framework/docs/3.0.x/spring-framework-reference/html/beans.html#beans-autowired-exceptions).
    * ONJava: [Twelve Best Practices For Spring XML Configurations](http://onjava.com/pub/a/onjava/2006/01/25/spring-xml-configuration-best-practices.html?page=1).
 -
  pack: codeql/java-queries#0
  relativeQueryPath: Frameworks/Spring/Violations of Best Practice/DontUseConstructorArgIndex.ql
  relativeBqrsPath: codeql/java-queries/Frameworks/Spring/Violations of Best Practice/DontUseConstructorArgIndex.bqrs
  metadata:
    name: Use constructor-arg types instead of index
    description: |-
      Using a type name instead of an index number in a Spring 'constructor-arg' element
                    improves readability.
    kind: problem
    problem.severity: recommendation
    precision: low
    id: java/spring/constructor-arg-index
    tags: |-
      maintainability
             frameworks/spring
  queryHelp: |
    # Use constructor-arg types instead of index
    Using type matching instead of index matching in a Spring `constructor-arg` element produces a more readable bean definition and is less vulnerable to being broken by a change to the constructor of the bean's underlying class. Index matching should be used only if type matching is not sufficient to remove ambiguity in the constructor arguments.


    ## Recommendation
    The bean definition's `constructor-arg` elements should use type matching instead of index matching.


    ## Example
    The following example shows a bean, `billingService1`, whose `constructor-arg` elements use index matching, and an improved version of the bean, `billingService2`, whose `constructor-arg` elements use type matching.


    ```xml
    <!--AVOID: Using explicit constructor indices makes the bean configuration
               vulnerable to changes to the constructor-->
    <bean id="billingService1" class="documentation.examples.spring.BillingService">
        <constructor-arg index="0" value="John Doe"/>
        <constructor-arg index="1" ref="dao"/>
    </bean>

    <!--GOOD: Using type matching makes the bean configuration more robust to changes in
        the constructor-->
    <bean id="billingService2" class="documentation.examples.spring.BillingService">
        <constructor-arg ref="dao"/>
        <constructor-arg type="java.lang.String" value="Jane Doe"/>
    </bean>

    ```

    ## References
    * Spring Framework Reference Documentation 3.0: [3.4.1.1 Constructor-based dependency injection](https://docs.spring.io/spring-framework/docs/3.0.x/spring-framework-reference/html/beans.html#beans-constructor-injection).
    * ONJava: [Twelve Best Practices For Spring XML Configurations](http://onjava.com/pub/a/onjava/2006/01/25/spring-xml-configuration-best-practices.html?page=2).
 -
  pack: codeql/java-queries#0
  relativeQueryPath: Frameworks/Spring/Violations of Best Practice/ImportsFirst.ql
  relativeBqrsPath: codeql/java-queries/Frameworks/Spring/Violations of Best Practice/ImportsFirst.bqrs
  metadata:
    name: Imports should come before bean definitions
    description: |-
      Putting 'import' statements before bean definitions in a Spring bean configuration
                    file makes it easier to immediately see all the file's dependencies.
    kind: problem
    problem.severity: recommendation
    precision: low
    id: java/spring/import-location
    tags: |-
      maintainability
             frameworks/spring
  queryHelp: "# Imports should come before bean definitions\nPutting `import` statements\
    \ at the top of Spring XML bean definition files is good practice because they\
    \ give a quick summary of the file's dependencies, and can even be used to document\
    \ the general architecture of a system.\n\n\n## Recommendation\nMake sure that\
    \ all `import` statements are at the top of the `<beans>` section of a Spring\
    \ XML bean definition file.\n\n\n## Example\nThe following example shows a `<beans>`\
    \ section of a Spring XML bean definition file in which an `import` statement\
    \ is in the middle, and a `<beans>` section in which all the `import` statements\
    \ are at the top.\n\n\n```xml\n<beans>\n    <import resource=\"services.xml\"\
    />\n    \n    <bean id=\"bean1\" class=\"...\"/>\n    <bean id=\"bean2\" class=\"\
    ...\"/>\n    \n    <!--AVOID: Imports in the middle of a bean configuration make\
    \ it difficult\n        to immediately determine the dependencies of the configuration-->\n\
    \    <import resource=\"resources/messageSource.xml\"/>\n\n    <bean id=\"bean3\"\
    \ class=\"...\"/>\n    <bean id=\"bean4\" class=\"...\"/>\n</beans>\n\n\n<beans>\n\
    \    <!--GOOD: Having the imports at the top immediately gives an idea of\n  \
    \      what the dependencies of the configuration are-->\n    <import resource=\"\
    services.xml\"/>\n    <import resource=\"resources/messageSource.xml\"/>\n   \
    \ \n    <bean id=\"bean1\" class=\"...\"/>\n    <bean id=\"bean2\" class=\"...\"\
    />\n    <bean id=\"bean3\" class=\"...\"/>\n    <bean id=\"bean4\" class=\"...\"\
    />\n</beans>\n\n```\n\n## References\n* Spring Framework Reference Documentation\
    \ 3.0: [3.2.2.1 Composing XML-based configuration metadata](http://static.springsource.org/spring/docs/3.0.x/spring-framework-reference/html/beans.html#beans-factory-xml-import).\n"
 -
  pack: codeql/java-queries#0
  relativeQueryPath: Frameworks/Spring/Violations of Best Practice/NoBeanDescription.ql
  relativeBqrsPath: codeql/java-queries/Frameworks/Spring/Violations of Best Practice/NoBeanDescription.bqrs
  metadata:
    name: This bean does not have a description element
    description: Adding 'description' elements to a Spring XML bean definition file
      is good practice.
    kind: problem
    problem.severity: recommendation
    precision: low
    id: java/spring/missing-bean-description
    tags: maintainability
  queryHelp: "# This bean does not have a description element\nIn a Spring XML bean\
    \ definition file, adding a `<description>` element to a `<bean>` element or the\
    \ enclosing `<beans>` element to document the purpose of the bean specification\
    \ is good practice. A `description` element also has the advantage of making it\
    \ easier for tools to detect and display the documentation for your bean specifications.\n\
    \n\n## Recommendation\nAdd a `<description>` element either in the `<bean>` element\
    \ or its enclosing `<beans>` element.\n\n\n## Example\nThe following example shows\
    \ a Spring XML bean definition file that includes `<description>` elements.\n\n\
    \n```xml\n<beans>\n\t<!--Using a description element makes it easier for tools\
    \ to pick up\n\t    documentation of the bean configuration-->\n\t<description>\n\
    \tThis file configures the various service beans.\n\t</description>\n\t\n\t<!--You\
    \ can also put a description element in a bean-->\n\t<bean id=\"baseService\"\
    \ abstract=\"true\">\n\t\t<description>\n\t\tThis bean defines base properties\
    \ common to the service beans\n\t\t</description>\n\t\t...\n\t</bean>\n\n\t<bean\
    \ id=\"shippingService\" \n\t\t\tclass=\"documentation.examples.spring.ShippingService\"\
    \n\t\t\tparent=\"baseService\">\n\t\t...\n\t</bean>\n\t\n\t<bean id=\"orderService\"\
    \ \n\t\t\tclass=\"documentation.examples.spring.OrderService\"\n\t\t\tparent=\"\
    baseService\">\n\t\t...\n\t</bean>\n</beans>\n```\n\n## References\n* ONJava:\
    \ [Twelve Best Practices For Spring XML Configurations](http://onjava.com/pub/a/onjava/2006/01/25/spring-xml-configuration-best-practices.html?page=3).\n"
 -
  pack: codeql/java-queries#0
  relativeQueryPath: Frameworks/Spring/Violations of Best Practice/ParentShouldNotUseAbstractClass.ql
  relativeBqrsPath: codeql/java-queries/Frameworks/Spring/Violations of Best Practice/ParentShouldNotUseAbstractClass.bqrs
  metadata:
    name: Non-abstract parent beans should not use an abstract class
    description: |-
      A non-abstract Spring bean that is a parent of other beans and specifies an
                    abstract class causes an error during bean instantiation.
    kind: problem
    problem.severity: error
    precision: low
    id: java/spring/parent-bean-abstract-class
    tags: |-
      reliability
             maintainability
             frameworks/spring
  queryHelp: "# Non-abstract parent beans should not use an abstract class\nA non-abstract\
    \ Spring bean that is a parent of other beans must not specify an abstract class.\
    \ Doing so causes an error during bean instantiation.\n\n\n## Recommendation\n\
    Make sure that a non-abstract bean does not specify an abstract class, by doing\
    \ one of the following:\n\n* Specify that the bean is also abstract by adding\
    \ `abstract=\"true\"` to the bean specification.\n* If possible, update the class\
    \ that is specified by the bean so that it is not abstract.\nYou can also make\
    \ the XML parent bean definition abstract and remove any references from it to\
    \ any class (in which case it becomes a pure bean template). Note that, like an\
    \ abstract class, an abstract bean cannot be used on its own and only provides\
    \ property and constructor definitions to its children.\n\n\n## Example\nIn the\
    \ following example, the bean `wrongConnectionPool` is using an abstract class,\
    \ `ConnectionPool`, which causes an error. Instead, the bean should be declared\
    \ `abstract`, as shown in the definition of `connectionPool`.\n\n\n```xml\n<beans>\n\
    \    <!--BAD: A non-abstract bean should use a concrete class.\n        'ConnectionPool'\
    \ is an abstract class.-->\n    <bean id=\"wrongConnectionPool\" \n          \
    \  class=\"documentation.examples.spring.ConnectionPool\"/>\n    <bean id=\"appReqPool1\"\
    \ class=\"documentation.examples.spring.AppRequestConnectionPool\" \n        \
    \    parent=\"wrongConnectionPool\"/>\n\n    <!--GOOD: A bean that specifies an\
    \ abstract class should be declared 'abstract'.-->\n    <bean id=\"connectionPool\"\
    \ \n            class=\"documentation.examples.spring.ConnectionPool\" abstract=\"\
    true\"/>\n    <bean id=\"appReqPool2\" class=\"documentation.examples.spring.AppRequestConnectionPool\"\
    \ \n            parent=\"connectionPool\"/>\n</beans>\n```\n\n## References\n\
    * Spring Framework Reference Documentation 3.0: [3.7 Bean definition inheritance](http://static.springsource.org/spring/docs/3.0.x/spring-framework-reference/html/beans.html#beans-child-bean-definitions).\n"
 -
  pack: codeql/java-queries#0
  relativeQueryPath: Frameworks/Spring/Violations of Best Practice/UseIdInsteadOfName.ql
  relativeBqrsPath: codeql/java-queries/Frameworks/Spring/Violations of Best Practice/UseIdInsteadOfName.bqrs
  metadata:
    name: Use id instead of name
    description: |-
      Using 'id' instead of 'name' to name a Spring bean enables the XML parser to perform
                    additional checks.
    kind: problem
    problem.severity: recommendation
    precision: low
    id: java/spring/bean-id
    tags: |-
      reliability
             maintainability
             frameworks/spring
  queryHelp: "# Use id instead of name\nTo name a Spring bean, it is best to use the\
    \ `id` attribute instead of the `name` attribute. Using the `id` attribute enables\
    \ the XML parser to perform additional checks (for example, checking if the `id`\
    \ in a `ref` attribute is an actual `id` of an XML element).\n\n\n## Recommendation\n\
    Use the `id` attribute instead of the `name` attribute when naming a bean.\n\n\
    \n## Example\nIn the following example, the `dao` bean is shown using the `name`\
    \ attribute, which allows a typo to go undetected because the XML parser does\
    \ not check `name`. In contrast, using the `id` attribute allows the XML parser\
    \ to catch the typo.\n\n\n```xml\n<!--AVOID: Using the 'name' attribute disables\
    \ checking of bean references at XML parse time-->\n<bean name=\"dao\" class=\"\
    documentation.examples.spring.DAO\"/>\n\n<bean id=\"orderService\" class=\"documentation.examples.spring.OrderService\"\
    >\n\t<!--The XML parser cannot catch this typo-->\n\t<property name=\"dao\" ref=\"\
    da0\"/>\n</bean>\n\n\n<!--GOOD: Using the 'id' attribute enables checking of bean\
    \ references at XML parse time-->\n<bean id=\"dao\" class=\"documentation.examples.spring.DAO\"\
    />\n\n<bean id=\"orderService\" class=\"documentation.examples.spring.OrderService\"\
    >\n\t<!--The XML parser can catch this typo-->\n\t<property name=\"dao\" ref=\"\
    da0\"/>\n</bean>\n```\n\n## References\n* Spring Framework Reference Documentation\
    \ 3.0: [3.3.1 Naming beans](http://static.springsource.org/spring/docs/3.0.x/spring-framework-reference/html/beans.html#beans-beanname).\n\
    * W3C: [3.3.1 Attribute Types](http://www.w3.org/TR/REC-xml/#sec-attribute-types).\n"
 -
  pack: codeql/java-queries#0
  relativeQueryPath: Frameworks/Spring/Violations of Best Practice/UseLocalRef.ql
  relativeBqrsPath: codeql/java-queries/Frameworks/Spring/Violations of Best Practice/UseLocalRef.bqrs
  metadata:
    name: Use local refs when referring to beans in the same file
    description: |-
      Using local references when referring to Spring beans in the same file allows
                    reference errors to be detected during XML parsing.
    kind: problem
    problem.severity: recommendation
    precision: low
    id: java/spring/non-local-reference
    tags: |-
      reliability
             maintainability
             frameworks/spring
  queryHelp: "# Use local refs when referring to beans in the same file\nIf at all\
    \ possible, refer to Spring beans in the same XML file using local references,\
    \ that is `<idref local=\"targetBean\">`. This requires that the bean being referenced\
    \ is in the same XML file, and is named using the `id` attribute. Using local\
    \ references has the advantage of allowing reference errors to be detected during\
    \ XML parsing, instead of during deployment or instantiation.\n\nFrom the Spring\
    \ Framework Reference documentation on `idref` elements:\n\n> \\[Using the `idref`\
    \ tag in a `property` element\\] is preferable to \\[using the bean name in the\
    \ property's `value` attribute\\], because using the `idref` tag allows the container\
    \ to validate at deployment time that the referenced, named bean actually exists.\
    \ In the second variation, no validation is performed on the value that is passed\
    \ to the \\[`name`\\] property of the client bean. Typos are only discovered (with\
    \ most likely fatal results) when the client bean is actually instantiated. If\
    \ the client bean is a prototype bean, this typo and the resulting exception may\
    \ only be discovered long after the container is deployed.\n\nAdditionally, if\
    \ the referenced bean is in the same XML unit, and the bean name is the bean `id`,\
    \ you can use the `local` attribute, which allows the XML parser itself to validate\
    \ the bean `id` earlier, at XML document parse time.\n\n\n## Recommendation\n\
    Use a local `idref` when referring to beans in the same XML file. This allows\
    \ errors to be detected earlier, at XML parse time rather than during instantiation.\n\
    \n\n## Example\nIn the following example, the `shippingService` bean is shown\
    \ using the `ref` element, which cannot be checked by the XML parser. The `orderService`\
    \ bean is shown using the `idref` element, which allows the XML parser to find\
    \ any errors at parse time.\n\n\n```xml\n<beans>\n\t<bean id=\"shippingService\"\
    \ class=\"documentation.examples.spring.ShippingService\">\n\t\t<!--AVOID: This\
    \ form of reference cannot be checked by the XML parser-->\n\t\t<property name=\"\
    dao\">\n\t\t\t<ref bean=\"dao\"/>\n\t\t</property>\n\t</bean>\n\t\n\t<bean id=\"\
    orderService\" class=\"documentation.examples.spring.OrderService\">\n\t\t<!--GOOD:\
    \ This form of reference allows the XML parser to find any errors at parse time-->\n\
    \t\t<property name=\"dao\">\n\t\t\t<idref local=\"dao\"/>\n\t\t</property>\n\t\
    </bean>\n\t\n\t<bean id=\"dao\" class=\"documentation.examples.spring.DAO\"/>\n\
    </beans>\n```\n\n## References\n* Spring Framework Reference Documentation 3.0:\
    \ [3.4.2.1 Straight values (primitives, Strings, and so on)](http://static.springsource.org/spring/docs/3.0.x/spring-framework-reference/html/beans.html#beans-value-element).\n"
 -
  pack: codeql/java-queries#0
  relativeQueryPath: Frameworks/Spring/Violations of Best Practice/UseSetterInjection.ql
  relativeBqrsPath: codeql/java-queries/Frameworks/Spring/Violations of Best Practice/UseSetterInjection.bqrs
  metadata:
    name: Use setter injection instead of constructor injection
    description: |-
      When using the Spring Framework, using setter injection instead of constructor
                    injection is more flexible, especially when several properties are optional.
    kind: problem
    problem.severity: recommendation
    precision: low
    id: java/spring/constructor-injection
    tags: |-
      maintainability
             frameworks/spring
  queryHelp: "# Use setter injection instead of constructor injection\nWhen you use\
    \ the Spring Framework, using setter injection instead of constructor injection\
    \ is more flexible, particularly for Spring beans with a large number of optional\
    \ properties. Constructor injection should be used only on required bean properties;\
    \ using constructor injection on optional bean properties requires a large number\
    \ of constructors to handle different combinations of properties.\n\nAlthough\
    \ the generally accepted best practice is to use constructor injection for mandatory\
    \ dependencies, and setter injection for optional dependencies, the `@Required`\
    \ annotation allows you to forgo constructor injection completely. Using the `@Required`\
    \ annotation on a setter method makes the framework check that a dependency is\
    \ injected using that method.\n\n\n## Recommendation\nUse setter injection in\
    \ bean configurations, marking required properties with the `@Required` annotation.\
    \ It makes it easier to accommodate a large number of optional properties, and\
    \ makes the bean more flexible by allowing for re-injection of dependencies.\n\
    \n\n## Example\nThe following example shows a bean that is defined using constructor\
    \ injection. The bean configuration is followed by the class definition.\n\n\n\
    ```xml\n<!--AVOID: Using constructor args for optional parameters requires one\
    \ constructor per combination\nof properties. This leads to a large number of\
    \ constructors in the bean class.-->\n<bean id=\"chart1\" class=\"documentation.examples.spring.WrongChartMaker\"\
    >\n\t<constructor-arg ref=\"customTrend\"/>\n\t<constructor-arg ref=\"customAxis\"\
    />\n</bean>\n```\n\n```java\n// Class for bean 'chart1'\npublic class WrongChartMaker\
    \ {\n\tprivate AxisRenderer axisRenderer = new DefaultAxisRenderer();\n\tprivate\
    \ TrendRenderer trendRenderer = new DefaultTrendRenderer();\n\t\n\tpublic WrongChartMaker()\
    \ {}\n\n\t// Each combination of the optional parameters must be represented by\
    \ a constructor.\n\tpublic WrongChartMaker(AxisRenderer customAxisRenderer) {\n\
    \t\tthis.axisRenderer = customAxisRenderer;\n\t}\n\t\n\tpublic WrongChartMaker(TrendRenderer\
    \ customTrendRenderer) {\n\t\tthis.trendRenderer = customTrendRenderer;\n\t}\n\
    \t\n\tpublic WrongChartMaker(AxisRenderer customAxisRenderer, \n\t\t\t\t\t\t\t\
    TrendRenderer customTrendRenderer) {\n\t\tthis.axisRenderer = customAxisRenderer;\n\
    \t\tthis.trendRenderer = customTrendRenderer;\n\t}\n}\n```\nThe following example\
    \ shows how the same bean can be defined using setter injection instead. Again,\
    \ the bean configuration is followed by the class definition.\n\n\n```xml\n<!--GOOD:\
    \ Using setter injection requires only one setter for each property.-->\n<bean\
    \ id=\"chart2\" class=\"documentation.examples.spring.ChartMaker\">\n\t<property\
    \ name=\"axisRenderer\" ref=\"customAxis\"/>\n</bean>\n```\n\n```java\n// Class\
    \ for bean 'chart2'\npublic class ChartMaker {\n\tprivate AxisRenderer axisRenderer\
    \ = new DefaultAxisRenderer();\n\tprivate TrendRenderer trendRenderer = new DefaultTrendRenderer();\n\
    \t\n\tpublic ChartMaker() {}\n\t\n\tpublic void setAxisRenderer(AxisRenderer axisRenderer)\
    \ {\n\t\tthis.axisRenderer = axisRenderer;\n\t}\n\t\n\tpublic void setTrendRenderer(TrendRenderer\
    \ trendRenderer) {\n\t\tthis.trendRenderer = trendRenderer;\n\t}\n}\n```\n\n##\
    \ References\n* Martin Fowler: [Inversion of Control Containers and the Dependency\
    \ Injection pattern](https://martinfowler.com/articles/injection.html).\n* ONJava:\
    \ [Twelve Best Practices for Spring XML Configurations](http://www.onjava.com/pub/a/onjava/2006/01/25/spring-xml-configuration-best-practices.html?page=3).\n\
    * Spring Framework Reference Documentation 3.0: [3.4.1.1 Constructor-based dependency\
    \ injection](https://docs.spring.io/spring-framework/docs/3.0.x/spring-framework-reference/html/beans.html#beans-constructor-injection),\
    \ [3.4.1.2 Setter-based dependency injection](https://docs.spring.io/spring-framework/docs/3.0.x/spring-framework-reference/html/beans.html#beans-setter-injection).\n\
    * SpringSource: [Setter injection versus constructor injection and the use of\
    \ @Required](https://spring.io/blog/2007/07/11/setter-injection-versus-constructor-injection-and-the-use-of-required/).\n"
 -
  pack: codeql/java-queries#0
  relativeQueryPath: Frameworks/Spring/Violations of Best Practice/UseShortcutForms.ql
  relativeBqrsPath: codeql/java-queries/Frameworks/Spring/Violations of Best Practice/UseShortcutForms.bqrs
  metadata:
    name: Use shortcut forms for values
    description: Using shortcut forms may make a Spring XML configuration file less
      cluttered.
    kind: problem
    problem.severity: recommendation
    precision: low
    id: java/spring/non-shortcut-form
    tags: |-
      maintainability
             frameworks/spring
  queryHelp: "# Use shortcut forms for values\nShortcut forms, introduced in Spring\
    \ 1.2, allow nested `value` elements to instead be defined as attributes in the\
    \ enclosing `property` entry. This leads to shorter XML bean configurations that\
    \ are easier to read.\n\n\n## Recommendation\nWhen possible, use the shortcut\
    \ form for defining bean property values.\n\nNote that this does *not* apply to\
    \ `idref` elements, which are the preferred form of referring to another bean.\
    \ These do not have a shortcut form that can still be checked by the XML parser.\n\
    \n\n## Example\nThe following example shows how a bean that is defined using shortcut\
    \ forms is more concise than the same bean defined using nested `value` elements.\n\
    \n\n```xml\n<!--AVOID: Using nested 'value' elements can make the configuration\
    \ file difficult to read-->\n<bean id=\"serviceRegistry\" class=\"documentation.examples.spring.ServiceRegistry\"\
    >\n\t<constructor-arg type=\"java.lang.String\">\n\t\t<value>main_service_registry</value>\n\
    \t</constructor-arg>\n\t<property name=\"description\">\n\t\t<value>Top-level\
    \ registry for services</value>\n\t</property>\n\t<property name=\"serviceMap\"\
    >\n\t\t<map>\n\t\t\t<entry>\n\t\t\t\t<key>\n\t\t\t\t\t<value>orderService</value>\n\
    \t\t\t\t</key>\n\t\t\t\t<value>com.foo.bar.OrderService</value>\n\t\t\t</entry>\n\
    \t\t\t<entry>\n\t\t\t\t<key>\n\t\t\t\t\t<value>billingService</value>\n\t\t\t\t\
    </key>\n\t\t\t\t<value>com.foo.bar.BillingService</value>\n\t\t\t</entry>\n\t\t\
    </map>\n\t</property>\n</bean>\n\n\n<!--GOOD: Shortcut forms (Spring 1.2) result\
    \ in more concise bean definitions-->\n<bean id=\"serviceRegistry\" class=\"documentation.examples.spring.ServiceRegistry\"\
    >\n\t<constructor-arg type=\"java.lang.String\" value=\"main_service_registry\"\
    />\n\t<property name=\"description\" value=\"Top-level registry for services\"\
    />\n\t<property name=\"serviceMap\">\n\t\t<map>\n\t\t\t<entry key=\"orderService\"\
    \ value=\"com.foo.bar.OrderService\"/>\n\t\t\t<entry key=\"billingService\" value=\"\
    com.foo.bar.BillingService\"/>\n\t\t</map>\n\t</property>\n</bean>\n\n```\n\n\
    ## References\n* ONJava: [Twelve Best Practices for Spring XML Configurations](http://www.onjava.com/pub/a/onjava/2006/01/25/spring-xml-configuration-best-practices.html?page=1).\n\
    * Spring Framework Reference Documentation 3.0: [3.4.2.1 Straight values (primitives,\
    \ Strings, and so on)](http://static.springsource.org/spring/docs/3.0.x/spring-framework-reference/html/beans.html#beans-value-element).\n"
 -
  pack: codeql/java-queries#0
  relativeQueryPath: Frameworks/Spring/XML Configuration Errors/MissingSetters.ql
  relativeBqrsPath: codeql/java-queries/Frameworks/Spring/XML Configuration Errors/MissingSetters.bqrs
  metadata:
    name: Missing setters for property dependency injection
    description: |-
      Not declaring a setter for a property that is defined in a Spring XML file causes a
                    compilation error.
    kind: problem
    problem.severity: error
    precision: low
    id: java/spring/missing-setter
    tags: |-
      reliability
             maintainability
             frameworks/spring
  queryHelp: "# Missing setters for property dependency injection\nThe absence of\
    \ a matching setter method for a property that is defined in a Spring XML bean\
    \ causes a validation error when the project is compiled.\n\n\n## Recommendation\n\
    Ensure that there is a setter method in the bean file that matches the property\
    \ name.\n\n\n## Example\nThe following example shows a bean file in which there\
    \ is no match for the setter method that is in the class.\n\n\n```xml\n<bean id=\"\
    contentService\" class=\"documentation.examples.spring.ContentService\">\n\t<!--BAD:\
    \ The setter method in the class is 'setHelper', so this property\n\t        \
    \ does not match the setter method.-->\n\t<property name=\"transactionHelper\"\
    >\n\t\t<ref bean=\"transactionHelper\"/>\n\t</property>\n</bean>\n\n```\nThis\
    \ is the bean class.\n\n\n```java\n// bean class\npublic class ContentService\
    \ {\n\tprivate TransactionHelper helper;\n\n\t// This method does not match the\
    \ property in the bean file.\n\tpublic void setHelper(TransactionHelper helper)\
    \ {\n\t\tthis.helper = helper;\n\t}\n}\n\n```\nThe property `transactionHelper`\
    \ should instead have the name `helper`.\n\n\n## References\n* Spring Framework\
    \ Reference Documentation 3.0: [3.4.1.2 Setter-based dependency injection](http://static.springsource.org/spring/docs/3.0.x/spring-framework-reference/html/beans.html#beans-setter-injection).\n"
 -
  pack: codeql/java-queries#0
  relativeQueryPath: Language Abuse/CastThisToTypeParameter.ql
  relativeBqrsPath: codeql/java-queries/Language Abuse/CastThisToTypeParameter.bqrs
  metadata:
    name: Cast of 'this' to a type parameter
    description: Casting 'this' to a type parameter of the current type masks an implicit
      type constraint that should be explicitly stated.
    kind: problem
    problem.severity: warning
    precision: low
    id: java/cast-of-this-to-type-parameter
    tags: |-
      reliability
             maintainability
             language-features
  queryHelp: "# Cast of 'this' to a type parameter\nCasting `this` to a type parameter\
    \ usually suggests that there is an implicit type constraint - the programmer\
    \ probably wanted to express the notion that `this` could be converted to the\
    \ type parameter (when using the enclosing method from derived types). However,\
    \ casting to the desired type, relies on derived types to ensure that the cast\
    \ will succeed without the compiler forcing them to do so.\n\n\n## Recommendation\n\
    The solution is to enforce the constraint by adding an abstract method on the\
    \ base type (see example below). Each derived type must then implement this method,\
    \ which makes the constraint checkable by the compiler and removes the need for\
    \ a cast.\n\n\n## Example\nIn this example `BadBaseNode` relies on derived types\
    \ to use the right pattern.\n\n\n```java\npublic class CastThisToTypeParameter\
    \ {\n\tprivate abstract static class BadBaseNode<T extends BadBaseNode<T>> {\n\
    \t\tpublic abstract T getParent();\n\n\t\tpublic T getRoot() {\n\t\t\t// BAD:\
    \ relies on derived types to use the right pattern\n\t\t\tT cur = (T)this;\n\t\
    \t\twhile(cur.getParent() != null) {\n\t\t\t\tcur = cur.getParent();\n\t\t\t}\n\
    \t\t\treturn cur;\n\t\t}\n\t}\n}\n```\nThis constraint is better enforced by adding\
    \ an abstract method on the base type. Implementing this method makes the constraint\
    \ checkable by the compiler.\n\n\n```java\npublic class CastThisToTypeParameter\
    \ {\n\tprivate abstract static class GoodBaseNode<T extends GoodBaseNode<T>> {\n\
    \t\tpublic abstract T getSelf();\n\t\tpublic abstract T getParent();\n\n\t\tpublic\
    \ T getRoot() {\n\t\t\t// GOOD: introduce an abstract method to enforce the constraint\n\
    \t\t\t// that 'this' can be converted to T for derived types\n\t\t\tT cur = getSelf();\n\
    \t\t\twhile(cur.getParent() != null)\n\t\t\t{\n\t\t\t\tcur = cur.getParent();\n\
    \t\t\t}\n\t\t\treturn cur;\n\t\t}\n\t}\n\n\tprivate static class GoodConcreteNode\
    \ extends GoodBaseNode<GoodConcreteNode> {\n\t\tprivate String name;\n\t\tprivate\
    \ GoodConcreteNode parent;\n\n\t\tpublic GoodConcreteNode(String name, GoodConcreteNode\
    \ parent)\n\t\t{\n\t\t\tthis.name = name;\n\t\t\tthis.parent = parent;\n\t\t}\n\
    \n\t\t@Override\n\t\tpublic GoodConcreteNode getSelf() {\n\t\t\treturn this;\n\
    \t\t}\n\n\t\t@Override\n\t\tpublic GoodConcreteNode getParent() {\n\t\t\treturn\
    \ parent;\n\t\t}\n\n\t\t@Override\n\t\tpublic String toString() {\n\t\t\treturn\
    \ name;\n\t\t}\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tGoodConcreteNode\
    \ a = new GoodConcreteNode(\"a\", null);\n\t\tGoodConcreteNode b = new GoodConcreteNode(\"\
    b\", a);\n\t\tGoodConcreteNode c = new GoodConcreteNode(\"c\", a);\n\t\tGoodConcreteNode\
    \ d = new GoodConcreteNode(\"d\", b);\n\t\tGoodConcreteNode root = d.getRoot();\n\
    \t\tSystem.out.println(a + \" \" + root);\n\t}\n}\n```\n"
 -
  pack: codeql/java-queries#0
  relativeQueryPath: Language Abuse/ChainedInstanceof.ql
  relativeBqrsPath: codeql/java-queries/Language Abuse/ChainedInstanceof.bqrs
  metadata:
    name: Chain of 'instanceof' tests
    description: Long sequences of type tests on a variable are difficult to maintain.
    kind: problem
    problem.severity: recommendation
    precision: high
    id: java/chained-type-tests
    tags: |-
      maintainability
             language-features
  queryHelp: "# Chain of 'instanceof' tests\nLong sequences of type tests are often\
    \ used to dispatch control to different branches of the code based on the type\
    \ of a variable, as shown in the example below. They are often used to simulate\
    \ pattern-matching in languages that do not support it. Whilst this works as a\
    \ dispatch method, there are a number of problems:\n\n* They are difficult to\
    \ maintain. It is easy to add a new subtype and forget to modify all of the type\
    \ test sequences throughout your code.\n* They introduce unwanted dependencies\
    \ on concrete classes. Code cannot be written only in terms of an interface but\
    \ must instead be written considering all of the different special cases.\n* They\
    \ can be error-prone - it is easy to test for a base type before a derived type,\
    \ resulting in a failure to execute the code handling the derived type.\n\n##\
    \ Recommendation\nThere are a number of different possible solutions to this problem:\n\
    \n* **Polymorphism**. You can add a virtual method to the type hierarchy and put\
    \ the segments of code to be called in the relevant override for each concrete\
    \ class. This is a good solution when: (a) you can change the type hierarchy and\
    \ (b) the operation being implemented is core functionality that the types should\
    \ implement. If you implement this solution then you must be careful not to introduce\
    \ unwanted dependencies. If the operation depends on entities that themselves\
    \ depend on the type hierarchy, then you cannot move the operation to the type\
    \ hierarchy without creating a dependency cycle.\n* **The visitor pattern**. You\
    \ can introduce a visitor interface containing a visit method for each type in\
    \ the type hierarchy, and add an `accept` method to each type in the hierarchy\
    \ that takes a visitor as its parameter. The `accept` method calls the visit method\
    \ of the visitor on `this`. Concrete visitors then implement the interface and\
    \ process each specific type as necessary. This is a good solution when: (a) you\
    \ can change the type hierarchy and (b) the type hierarchy should not know about\
    \ the operation being implemented (either to avoid dependency or because it is\
    \ not core functionality for the types in the hierarchy). It is also useful when\
    \ you want to provide multiple operations with the same structure, on the same\
    \ set of types, and you want the types themselves to control the way that the\
    \ operation is structured. For example, \"visit this tree using an in-order walk\
    \ and apply the operation to each node\". The basic visitor pattern is not suitable\
    \ for all situations because it is cyclically-dependent, and the infrastructure\
    \ involved is comparatively heavyweight.\n* **Reflection**. You can look up one\
    \ of a set of overloaded methods based on the type of one of the method parameters\
    \ and invoke the method manually. This results in a loss of type safety and is\
    \ rather untidy, but there are times when it is the best solution. In particular,\
    \ reflection is useful when you cannot change the type hierarchy, for example,\
    \ because it is third-party code.\n\n## Example\nThe following example demonstrates\
    \ the use \"Polymorphism\" and \"The visitor pattern\". More details on reflection\
    \ can be found in \\[Flanagan\\].\n\n\n```java\nimport java.util.*;\n\npublic\
    \ class ChainedInstanceof {\n\tpublic static void main(String[] args) {\n\t\t\
    // BAD: example of a sequence of type tests\n\t\tList<BadAnimal> badAnimals =\
    \ new ArrayList<BadAnimal>();\n\t\tbadAnimals.add(new BadCat());\n\t\tbadAnimals.add(new\
    \ BadDog());\n\t\tfor(BadAnimal a: badAnimals) {\n\t\t\tif(a instanceof BadCat)\
    \      System.out.println(\"Miaow!\");\n\t\t\telse if(a instanceof BadDog) System.out.println(\"\
    Woof!\");\n\t\t\telse                         throw new RuntimeException(\"Oops!\"\
    );\n\t\t}\n\n\t\t// GOOD: solution using polymorphism\n\t\tList<PolymorphicAnimal>\
    \ polymorphicAnimals = new ArrayList<PolymorphicAnimal>();\n\t\tpolymorphicAnimals.add(new\
    \ PolymorphicCat());\n\t\tpolymorphicAnimals.add(new PolymorphicDog());\n\t\t\
    for(PolymorphicAnimal a: polymorphicAnimals) a.speak();\n\n\t\t// GOOD: solution\
    \ using the visitor pattern\n\t\tList<VisitableAnimal> visitableAnimals = new\
    \ ArrayList<VisitableAnimal>();\n\t\tvisitableAnimals.add(new VisitableCat());\n\
    \t\tvisitableAnimals.add(new VisitableDog());\n\t\tfor(VisitableAnimal a: visitableAnimals)\
    \ a.accept(new SpeakVisitor());\n\t}\n\n\t//#################### TYPES FOR BAD\
    \ EXAMPLE ####################\n\n\tprivate interface BadAnimal {}\n\tprivate\
    \ static class BadCat implements BadAnimal {}\n\tprivate static class BadDog implements\
    \ BadAnimal {}\n\n\t//#################### TYPES FOR POLYMORPHIC EXAMPLE ####################\n\
    \n\tprivate interface PolymorphicAnimal {\n\t\tvoid speak();\n\t}\n\tprivate static\
    \ class PolymorphicCat implements PolymorphicAnimal {\n\t\tpublic void speak()\
    \ { System.out.println(\"Miaow!\"); }\n\t}\n\tprivate static class PolymorphicDog\
    \ implements PolymorphicAnimal {\n\t\tpublic void speak() { System.out.println(\"\
    Woof!\"); }\n\t}\n\n\t//#################### TYPES FOR VISITOR EXAMPLE ####################\n\
    \n\tprivate interface Visitor {\n\t\tvoid visit(VisitableCat c);\n\t\tvoid visit(VisitableDog\
    \ d);\n\t}\n\tprivate static class SpeakVisitor implements Visitor {\n\t\tpublic\
    \ void visit(VisitableCat c) { System.out.println(\"Miaow!\"); }\n\t\tpublic void\
    \ visit(VisitableDog d) { System.out.println(\"Woof!\"); }\n\t}\n\tprivate interface\
    \ VisitableAnimal {\n\t\tvoid accept(Visitor v);\n\t}\n\tprivate static class\
    \ VisitableCat implements VisitableAnimal {\n\t\tpublic void accept(Visitor v)\
    \ { v.visit(this); }\n\t}\n\tprivate static class VisitableDog implements VisitableAnimal\
    \ {\n\t\tpublic void accept(Visitor v) { v.visit(this); }\n\t}\n}\n\n```\n\n##\
    \ References\n* D. Flanagan, *Java in a Nutshell: A Desktop Quick Reference*.\
    \ O'Reilly Media, 1997.\n* E. Gamma, R. Helm, R. Johnson, J. Vlissides, *Design\
    \ patterns: elements of reusable object-oriented software*. Addison-Wesley Longman\
    \ Publishing Co., Inc. Boston, MA, 1995.\n"
 -
  pack: codeql/java-queries#0
  relativeQueryPath: Language Abuse/DubiousDowncastOfThis.ql
  relativeBqrsPath: codeql/java-queries/Language Abuse/DubiousDowncastOfThis.bqrs
  metadata:
    name: Dubious downcast of 'this'
    description: |-
      Casting 'this' to a derived type introduces a dependency cycle
                    between the type of 'this' and the target type.
    kind: problem
    problem.severity: warning
    precision: low
    id: java/downcast-of-this
    tags: |-
      testability
             maintainability
             language-features
  queryHelp: "# Dubious downcast of 'this'\nDowncasting `this` to a derived type creates\
    \ a dependency cycle. Derived types already depend on their parent type and the\
    \ cast creates a dependency in the other direction.\n\nDependency cycles should\
    \ be avoided as they make code both difficult to read and difficult to test. In\
    \ addition, a type should not know about its specific descendants, even though\
    \ it may impose some constraints on them as a group (for example, abstract classes\
    \ may require every derived type to implement a method with a specific signature).\n\
    \n\n## Recommendation\nThe base and derived types should be redesigned so that\
    \ there is no need for the base type to depend on the types deriving from it.\n\
    \n\n## Example\nIn this example, `BadBase` introduces a dependency cycle with\
    \ `Derived` by coercing the type of `this` to a derived type.\n\n\n```java\npublic\
    \ class DubiousDowncastOfThis {\n\tprivate static class BadBase {\n\t\tprivate\
    \ Derived d;\n\n\t\tpublic BadBase(Derived d) {\n\t\t\tif(d != null && this instanceof\
    \ Derived)\n\t\t\t\tthis.d = (Derived)this;\t\t// violation\n\t\t\telse\n\t\t\t\
    \tthis.d = d;\n\t\t}\n\t}\n\n\tprivate static class Derived extends BadBase {\n\
    \t\tpublic Derived() {\n\t\t\tsuper(null);\n\t\t}\n\t}\n\n\tpublic static void\
    \ main(String[] args) {}\n}\n```\n"
 -
  pack: codeql/java-queries#0
  relativeQueryPath: Language Abuse/DubiousTypeTestOfThis.ql
  relativeBqrsPath: codeql/java-queries/Language Abuse/DubiousTypeTestOfThis.bqrs
  metadata:
    name: Dubious type test of 'this'
    description: |-
      Testing whether 'this' is an instance of a derived type introduces
                    a dependency cycle between the type of 'this' and the target type.
    kind: problem
    problem.severity: warning
    precision: low
    id: java/type-test-of-this
    tags: |-
      testability
             maintainability
             language-features
  queryHelp: "# Dubious type test of 'this'\nTesting whether `this` is an instance\
    \ of a derived type creates a dependency cycle. Derived types already depend on\
    \ their parent type and the cast creates a dependency in the other direction.\n\
    \nDependency cycles should be avoided as they make code both difficult to read\
    \ and difficult to test. In addition, a type should not know about its specific\
    \ descendants, even though it may impose some constraints on them as a group (for\
    \ example, the need for every derived type to implement a method with a specific\
    \ signature).\n\n\n## Recommendation\nThe base and derived types should be redesigned\
    \ so that there is no need for the base type to depend on the types deriving from\
    \ it.\n\n\n## Example\nIn this example, `BadBase` introduces a dependency cycle\
    \ with `Derived` by testing the type of `this`.\n\n\n```java\npublic class DubiousTypeTestOfThis\
    \ {\n\tprivate static class BadBase {\n\t\tprivate Derived d;\n\n\t\tpublic BadBase(Derived\
    \ d) {\n\t\t\tif(d != null && this instanceof Derived)\t// violation\n\t\t\t\t\
    this.d = (Derived)this;\n\t\t\telse\n\t\t\t\tthis.d = d;\n\t\t}\n\t}\n\n\tprivate\
    \ static class Derived extends BadBase {\n\t\tpublic Derived() {\n\t\t\tsuper(null);\n\
    \t\t}\n\t}\n\n\tpublic static void main(String[] args) {}\n}\n```\n"
 -
  pack: codeql/java-queries#0
  relativeQueryPath: Language Abuse/EmptyStatement.ql
  relativeBqrsPath: codeql/java-queries/Language Abuse/EmptyStatement.bqrs
  metadata:
    name: Empty statement
    description: An empty statement hinders readability.
    kind: problem
    problem.severity: recommendation
    precision: low
    id: java/empty-statement
    tags: |-
      maintainability
             useless-code
  queryHelp: "# Empty statement\nAn *empty statement* is a single semicolon `;` that\
    \ does not terminate another statement. Such a statement hinders readability and\
    \ has no effect on its own.\n\n\n## Recommendation\nAvoid empty statements. If\
    \ a loop is intended to have an empty body, it is better to mark that fact explicitly\
    \ by using a pair of braces `{}` containing an explanatory comment for the body,\
    \ rather than a single semicolon.\n\n\n## Example\nIn the following example, there\
    \ is an empty statement on line 3, where an additional semicolon is used. On line\
    \ 6, the `for` statement has an empty body because the condition is immediately\
    \ followed by a semicolon. In this case, it is better to include a pair of braces\
    \ `{}` containing an explanatory comment for the body instead.\n\n\n```java\n\
    public class Cart {\n\t// AVOID: Empty statement\n\tList<Item> items = new ArrayList<Cart>();;\n\
    \tpublic void applyDiscount(float discount) {\n\t\t// AVOID: Empty statement as\
    \ loop body\n\t\tfor (int i = 0; i < items.size(); items.get(i++).applyDiscount(discount));\n\
    \t}\n}\n```\n\n## References\n* Help - Eclipse Platform: [Java Compiler Errors/Warnings\
    \ Preferences](https://help.eclipse.org/2020-12/advanced/content.jsp?topic=/org.eclipse.jdt.doc.user/reference/preferences/java/compiler/ref-preferences-errors-warnings.htm).\n"
 -
  pack: codeql/java-queries#0
  relativeQueryPath: Language Abuse/EnumIdentifier.ql
  relativeBqrsPath: codeql/java-queries/Language Abuse/EnumIdentifier.bqrs
  metadata:
    name: String 'enum' used as identifier
    description: Using 'enum' as an identifier makes the code incompatible with Java
      5 and later.
    kind: problem
    problem.severity: warning
    precision: low
    id: java/enum-identifier
    tags: |-
      portability
             readability
             naming
  queryHelp: "# String 'enum' used as identifier\nEnumerations, or enums, were introduced\
    \ in Java 5, with the keyword `enum`. Code written before this may use `enum`\
    \ as an identifier. To compile such code, you must compile it with a command such\
    \ as `javac -source 1.4 ...`. However, this means that you cannot use any new\
    \ features that are provided in Java 5 and later.\n\n\n## Recommendation\nTo make\
    \ it easier to compile the code and add code that uses new Java features, rename\
    \ any identifiers that are named `enum` in legacy code.\n\n\n## Example\nIn the\
    \ following example, `enum` is used as the name of a variable. This means that\
    \ the code does not compile unless the compiler's source language is set to 1.4\
    \ or earlier. To avoid this constraint, the variable should be renamed.\n\n\n\
    ```java\nclass Old\n{\n\tpublic static void main(String[] args) {\n\t\tint enum\
    \ = 13;  // AVOID: 'enum' is a variable.\n\t\tSystem.out.println(\"The value of\
    \ enum is \" + enum);\n\t}\n}\n\n```\n\n## References\n* Java Language Specification:\
    \ [8.9 Enum Types](https://docs.oracle.com/javase/specs/jls/se11/html/jls-8.html#jls-8.9).\n"
 -
  pack: codeql/java-queries#0
  relativeQueryPath: Language Abuse/ImplementsAnnotation.ql
  relativeBqrsPath: codeql/java-queries/Language Abuse/ImplementsAnnotation.bqrs
  metadata:
    name: Annotation is extended or implemented
    description: Extending or implementing an annotation is unlikely to be what the
      programmer intends.
    kind: problem
    problem.severity: warning
    precision: low
    id: java/annotation-subtype
    tags: |-
      maintainability
             correctness
             logic
  queryHelp: "# Annotation is extended or implemented\nAlthough an annotation type\
    \ is a special kind of interface that can be implemented by a concrete class,\
    \ this is not its intended use. It is more likely that an annotation type should\
    \ be used to annotate a class.\n\n\n## Recommendation\nEnsure that any annotations\
    \ are used to annotate a class, unless they are really supposed to be extended\
    \ or implemented by the class.\n\n\n## Example\nIn the following example, the\
    \ annotation `Deprecated` is implemented by the class `ImplementsAnnotation`.\n\
    \n\n```java\npublic abstract class ImplementsAnnotation implements Deprecated\
    \ {\n\t// ...\n}\n```\nThe following example shows the intended use of annotations:\
    \ to annotate the class `ImplementsAnnotationFix`.\n\n\n```java\n@Deprecated\n\
    public abstract class ImplementsAnnotationFix {\n\t// ...\n}\n```\n\n## References\n\
    * Java Language Specification: [Annotation Types](https://docs.oracle.com/javase/specs/jls/se11/html/jls-9.html#jls-9.6).\n\
    * The Java Tutorials: [Annotations](https://docs.oracle.com/javase/tutorial/java/annotations/index.html).\n\
    * Help - Eclipse Platform: [Java Compiler Errors/Warnings Preferences](https://help.eclipse.org/2020-12/advanced/content.jsp?topic=/org.eclipse.jdt.doc.user/reference/preferences/java/compiler/ref-preferences-errors-warnings.htm).\n"
 -
  pack: codeql/java-queries#0
  relativeQueryPath: Language Abuse/IterableIterator.ql
  relativeBqrsPath: codeql/java-queries/Language Abuse/IterableIterator.bqrs
  metadata:
    name: Iterator implementing Iterable
    description: |-
      An 'Iterator' that also implements 'Iterable' by returning itself as its 'Iterator'
                    does not support multiple traversals. This can lead to unexpected behavior when
                    it is viewed as an 'Iterable'.
    kind: problem
    problem.severity: warning
    precision: very-high
    id: java/iterator-implements-iterable
    tags: |-
      correctness
             reliability
  queryHelp: |
    # Iterator implementing Iterable
    Java has two interfaces for dealing with iteration, `Iterable<T>` and `Iterator<T>`. An `Iterable<T>` represents a sequence of elements that can be traversed, and an `Iterator<T>` represents the **state** of an ongoing traversal. As an example, all the `Collection<T>` classes in the Java standard library implement `Iterable<T>`. Comparing this to a traditional `for` loop that increments an integer index and iterates over the elements of an array, then the `Iterable<T>` object corresponds to the array, whereas the `Iterator<T>` object corresponds to the index variable.

    Implementations of `Iterable<T>` are generally expected to support multiple traversals of the element sequence they represent, although there can be exceptions if the underlying data somehow makes this undesirable, see for example `DirectoryStream<T>`. If an implementation of `Iterable<T>` does not support multiple iterations, then its `iterator()` method should throw an exception on its second and subsequent calls. This makes bugs easier to find if such an `Iterable<T>` is used more than once, for example in two different for-each loops.


    ## Recommendation
    When working with custom implementations of `Iterator<T>` it is easy to add `implements Iterable<T>` and a simple `return this;` implementation of `iterator()` to support the for-each syntax. This can, however, hide subtle bugs and is therefore not recommended. It is better to separate the two and use a main representation that only implements `Iterable<T>` without containing any iteration state. This object can then return a short-lived `Iterator<T>` each time it needs to be traversed.

    If this refactoring is undesirable for some reason, then the `iterator()` method should at the very least throw an exception if called more than once.


    ## Example
    The following example does not distinguish the iterable from its iterator, and therefore causes the second loop to terminate immediately without any effect.


    ```java
    class ElemIterator implements Iterator<MyElem>, Iterable<MyElem> {
      private MyElem[] data;
      private idx = 0;

      public boolean hasNext() {
        return idx < data.length;
      }
      public MyElem next() {
        return data[idx++];
      }
      public Iterator<MyElem> iterator() {
        return this;
      }
      // ...
    }

    void useMySequence(Iterable<MyElem> s) {
      // do some work by traversing the sequence
      for (MyElem e : s) {
        // ...
      }
      // do some more work by traversing it again
      for (MyElem e : s) {
        // ...
      }
    }

    ```
    The best solution is a refactoring along the following lines where `Iterable` classes are used to pass around references to data. This allows the `Iterator` instances to be short-lived and avoids the sharing of iteration state.


    ```java
    class ElemSequence implements Iterable<MyElem> {
      private MyElem[] data;

      public Iterator<MyElem> iterator() {
        return new Iterator<MyElem>() {
          private idx = 0;
          public boolean hasNext() {
            return idx < data.length;
          }
          public MyElem next() {
            return data[idx++];
          }
        };
      }
      // ...
    }

    ```
    If a refactoring, as described above, is too cumbersome or is otherwise undesirable, then a guard can be inserted, as shown below. Using a guard ensures that multiple iteration fails early, making it easier to find any related bugs. This solution is less ideal than the refactoring above, but nevertheless an improvement over the original.


    ```java
    class ElemIterator implements Iterator<MyElem>, Iterable<MyElem> {
      private MyElem[] data;
      private idx = 0;
      private boolean usedAsIterable = false;

      public boolean hasNext() {
        return idx < data.length;
      }
      public MyElem next() {
        return data[idx++];
      }
      public Iterator<MyElem> iterator() {
        if (usedAsIterable || idx > 0)
          throw new IllegalStateException();
        usedAsIterable = true;
        return this;
      }
      // ...
    }

    ```

    ## References
    * Java Language Specification: [The enhanced for statement](https://docs.oracle.com/javase/specs/jls/se11/html/jls-14.html#jls-14.14.2).
    * Java API Specification: [Interface Iterable&lt;T&gt;](https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/lang/Iterable.html), [Interface Iterator&lt;T&gt;](https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/util/Iterator.html), [Interface DirectoryStream&lt;T&gt;](https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/nio/file/DirectoryStream.html).
 -
  pack: codeql/java-queries#0
  relativeQueryPath: Language Abuse/MissedTernaryOpportunity.ql
  relativeBqrsPath: codeql/java-queries/Language Abuse/MissedTernaryOpportunity.bqrs
  metadata:
    name: Missed ternary opportunity
    description: |-
      An 'if' statement where both branches either
                   (a) return or (b) write to the same variable
                   can often be expressed more clearly using the '?' operator.
    kind: problem
    problem.severity: recommendation
    precision: low
    id: java/missed-ternary-operator
    tags: |-
      maintainability
             language-features
  queryHelp: "# Missed ternary opportunity\nAn `if` statement where both branches\
    \ do nothing but return or write to a variable can be better expressed using the\
    \ ternary `?` operator.\n\n\n\nUse of the ternary operator enhances readability\
    \ in two ways:\n\n* It focuses the reader's attention on the intent of the code\
    \ (to return or write) rather than the testing of a condition.\n* It is more concise,\
    \ reducing the amount of code that needs to be read.\n* You can initialize a variable\
    \ conditionally on the line on which it is declared, rather than assigning to\
    \ it after initialization. This ensures that you initialize the variable as you\
    \ intended.\n\n## Recommendation\nConsider using a ternary operator in this situation.\n\
    \n\n## Example\nThe following code includes two examples of `if` statements, `myAbs1`\
    \ and `1`, which can be simplified using the ternary operator. `myAbs2` and `s2`\
    \ show how the statements can be improved.\n\n\n```java\npublic class MissedTernaryOpportunity\
    \ {\n\tprivate static int myAbs1(int x) {\n\t\t// Violation\n\t\tif(x >= 0)\n\t\
    \t\treturn x;\n\t\telse\n\t\t\treturn -x;\n\t}\n\n\tprivate static int myAbs2(int\
    \ x) {\n\t\t// Better\n\t\treturn x >= 0 ? x : -x;\n\t}\n\n\tpublic static void\
    \ main(String[] args) {\n\t\tint i = 23;\n\n\t\t// Violation\n\t\tString s1;\n\
    \t\tif(i == 23)\n\t\t\ts1 = \"Foo\";\n\t\telse\n\t\t\ts1 = \"Bar\";\n\t\tSystem.out.println(s1);\n\
    \n\t\t// Better\n\t\tString s2 = i == 23 ? \"Foo\" : \"Bar\";\n\t\tSystem.out.println(s2);\n\
    \t}\n}\n```\n"
 -
  pack: codeql/java-queries#0
  relativeQueryPath: Language Abuse/OverridePackagePrivate.ql
  relativeBqrsPath: codeql/java-queries/Language Abuse/OverridePackagePrivate.bqrs
  metadata:
    name: Confusing non-overriding of package-private method
    description: |-
      A method that appears to override another method but does not, because the
                    declaring classes are in different packages, is potentially confusing.
    kind: problem
    problem.severity: warning
    precision: medium
    id: java/non-overriding-package-private
    tags: |-
      maintainability
             readability
  queryHelp: "# Confusing non-overriding of package-private method\nIf a method is\
    \ declared with default access (that is, not private, protected, nor public),\
    \ it can only be overridden by methods in the same package. If a method of the\
    \ same signature is defined in a subclass in a different package, it is a completely\
    \ separate method and no overriding occurs.\n\nCode like this can be confusing\
    \ for other programmers, who have to understand that there is no overriding relation,\
    \ check that the original programmer did not intend one method to override the\
    \ other, and avoid mixing up the two methods by accident.\n\n\n## Recommendation\n\
    In cases where there is intentionally no overriding, the best solution is to rename\
    \ one or both of the methods to clarify their different purposes.\n\nIf one method\
    \ is supposed to override another method that is declared with default access\
    \ in another package, the access of the method must be changed to `public` or\
    \ `protected`. Alternatively, the classes must be moved to the same package.\n\
    \n\n## Example\nIn the following example, `PhotoResizerWidget.width` does not\
    \ override `Widget.width` because one method is in package `gui` and one method\
    \ is in package `gui.extras`.\n\n\n```java\n// File 1\npackage gui;\n\nabstract\
    \ class Widget\n{\n    // ...\n\n    // Return the width (in pixels) of this widget\n\
    \    int width() {\n        // ...\n    }\n\n    // ...\n}\n\n// File 2\npackage\
    \ gui.extras;\n\nclass PhotoResizerWidget extends Widget\n{\n    // ...\n \n \
    \   // Return the new width (of the photo when resized)\n    public int width()\
    \ {\n        // ...\n    }\n   \n    // ...\n}\n```\nAssuming that no overriding\
    \ is intentional, one or both of the methods should be renamed. For example, `PhotoResizerWidget.width`\
    \ would be better named `PhotoResizerWidget.newPhotoWidth`.\n\n\n## References\n\
    * Help - Eclipse Platform: [Java Compiler Errors/Warnings Preferences](https://help.eclipse.org/2020-12/advanced/content.jsp?topic=/org.eclipse.jdt.doc.user/reference/preferences/java/compiler/ref-preferences-errors-warnings.htm).\n\
    * Java Language Specification: [8.4.8.1 Overriding (by Instance Methods)](https://docs.oracle.com/javase/specs/jls/se11/html/jls-8.html#jls-8.4.8.1).\n"
 -
  pack: codeql/java-queries#0
  relativeQueryPath: Language Abuse/TypeVarExtendsFinalType.ql
  relativeBqrsPath: codeql/java-queries/Language Abuse/TypeVarExtendsFinalType.bqrs
  metadata:
    name: Type bound extends a final class
    description: |-
      If 'C' is a final class, a type bound such as '? extends C'
                    is confusing because it implies that 'C' has subclasses, but
                    a final class has no subclasses.
    kind: problem
    problem.severity: warning
    precision: medium
    id: java/type-bound-extends-final
    tags: |-
      maintainability
             readability
             types
  queryHelp: "# Type bound extends a final class\nA type wildcard with an `extends`\
    \ clause (for example `?&nbsp;extends&nbsp;String`) implicitly suggests that a\
    \ type (in this case `String`) has subclasses. If the type in the `extends` clause\
    \ is final, the code is confusing because a final class cannot have any subclasses.\
    \ The only type that satisfies `?&nbsp;extends&nbsp;String` is `String`.\n\n\n\
    ## Recommendation\nTo make the code more readable, omit the wildcard to leave\
    \ just the final type.\n\n\n## Example\nIn the following example, a wildcard is\
    \ used to refer to any type that is a subclass of `String`.\n\n\n```java\nclass\
    \ Printer\n{\n\tvoid print(List<? extends String> strings) {  // Unnecessary wildcard\n\
    \t\tfor (String s : strings)\n\t\t\tSystem.out.println(s);\n\t}\n}\n```\nHowever,\
    \ because `String` is declared `final`, it does not have any subclasses. Therefore,\
    \ it is clearer to replace `?&nbsp;extends&nbsp;String` with `String`.\n\n\n##\
    \ References\n* Help - Eclipse Platform: [Java Compiler Errors/Warnings Preferences](https://help.eclipse.org/2020-12/advanced/content.jsp?topic=/org.eclipse.jdt.doc.user/reference/preferences/java/compiler/ref-preferences-errors-warnings.htm).\n\
    * Java Language Specification: [4.5.1 Type Arguments of Parameterized Types ](https://docs.oracle.com/javase/specs/jls/se11/html/jls-4.html#jls-4.5.1),\
    \ [8.1.1.2 final Classes](https://docs.oracle.com/javase/specs/jls/se11/html/jls-8.html#jls-8.1.1.2).\n"
 -
  pack: codeql/java-queries#0
  relativeQueryPath: Language Abuse/TypeVariableHidesType.ql
  relativeBqrsPath: codeql/java-queries/Language Abuse/TypeVariableHidesType.bqrs
  metadata:
    name: Type variable hides another type
    description: |-
      A type variable with the same name as another type that is in scope can cause
                    the two types to be confused.
    kind: problem
    problem.severity: warning
    precision: medium
    id: java/type-variable-hides-type
    tags: |-
      reliability
             readability
             types
  queryHelp: "# Type variable hides another type\nType shadowing occurs if two types\
    \ have the same name but one is defined within the scope of the other. This can\
    \ arise if you introduce a type variable with the same name as an imported class.\n\
    \nType shadowing may cause the two types to be confused, which can lead to various\
    \ problems.\n\n\n## Recommendation\nName the type variable so that its name does\
    \ not clash with the imported class.\n\n\n## Example\nIn the following example,\
    \ the type `java.util.Map.Entry` is imported at the top of the file, but the class\
    \ `Mapping` is defined with two type variables, `Key` and `Entry`. Uses of `Entry`\
    \ within the `Mapping` class refer to the type variable, and not the imported\
    \ interface. The type variable therefore shadows `Map.Entry`.\n\n\n```java\nimport\
    \ java.util.Map;\nimport java.util.Map.Entry;\n\nclass Mapping<Key, Entry>  //\
    \ The type variable 'Entry' shadows the imported interface 'Entry'.\n{\n\t// ...\n\
    }\n```\nTo fix the code, the type variable `Entry` on line 4 should be renamed.\n\
    \n\n## References\n* Help - Eclipse Platform: [Java Compiler Errors/Warnings Preferences](https://help.eclipse.org/2020-12/advanced/content.jsp?topic=/org.eclipse.jdt.doc.user/reference/preferences/java/compiler/ref-preferences-errors-warnings.htm).\n\
    * Java Language Specification: [6.4 Shadowing and Obscuring](https://docs.oracle.com/javase/specs/jls/se11/html/jls-6.html#jls-6.4).\n"
 -
  pack: codeql/java-queries#0
  relativeQueryPath: Language Abuse/UselessNullCheck.ql
  relativeBqrsPath: codeql/java-queries/Language Abuse/UselessNullCheck.bqrs
  metadata:
    name: Useless null check
    description: |-
      Checking whether an expression is null when that expression cannot
                    possibly be null is useless.
    kind: problem
    problem.severity: warning
    precision: very-high
    id: java/useless-null-check
    tags: |-
      maintainability
             useless-code
             external/cwe/cwe-561
  queryHelp: |
    # Useless null check
    Sometimes you can guarantee that a particular variable will never be null. For example when that variable has just been assigned a newly created object or is the exception caught by a `catch` clause. A null check on such a variable is misleading, and can potentially indicate a logic error.


    ## Recommendation
    Do not check a variable for null if a null value is clearly impossible.


    ## Example
    The following example shows a null check on a newly created object. An object returned by `new` can never be null, so this check is superfluous.


    ```java
    Object o = new Object();
    if (o == null) {
      // this cannot happen!
    }

    ```

    ## References
    * Java Language Specification: [Creation of New Class Instances](https://docs.oracle.com/javase/specs/jls/se11/html/jls-12.html#jls-12.5), [Execution of try-catch](https://docs.oracle.com/javase/specs/jls/se11/html/jls-14.html#jls-14.20.1).
    * Common Weakness Enumeration: [CWE-561](https://cwe.mitre.org/data/definitions/561.html).
 -
  pack: codeql/java-queries#0
  relativeQueryPath: Language Abuse/UselessTypeTest.ql
  relativeBqrsPath: codeql/java-queries/Language Abuse/UselessTypeTest.bqrs
  metadata:
    name: Useless type test
    description: Testing whether a derived type is an instance of its base type is
      unnecessary.
    kind: problem
    problem.severity: warning
    precision: very-high
    id: java/useless-type-test
    tags: |-
      maintainability
             language-features
             external/cwe/cwe-561
  queryHelp: "# Useless type test\nIt is always the case that, for any type `B`, an\
    \ instance of a type derived from `B` is also an instance of `B`. There is no\
    \ need to explicitly test that this relationship exists.\n\n\n## Recommendation\n\
    Remove the unnecessary type test to simplify the code.\n\n\n## Example\nThe following\
    \ example shows an unnecessary type test.\n\n\n```java\npublic class UselessTypeTest\
    \ {\n\tprivate static class B {}\n\tprivate static class D extends B {}\n\n\t\
    public static void main(String[] args) {\n\t\tD d = new D();\n\t\tif(d instanceof\
    \ B) {\t// violation\n\t\t\tSystem.out.println(\"Mon dieu, d is a B!\");\n\t\t\
    }\n\t}\n}\n```\n"
 -
  pack: codeql/java-queries#0
  relativeQueryPath: Language Abuse/UselessUpcast.ql
  relativeBqrsPath: codeql/java-queries/Language Abuse/UselessUpcast.bqrs
  metadata:
    name: Useless upcast
    description: Upcasting a derived type to its base type is usually unnecessary.
    kind: problem
    problem.severity: warning
    precision: low
    id: java/useless-upcast
    tags: |-
      maintainability
             language-features
             external/cwe/cwe-561
  queryHelp: "# Useless upcast\nIn most situations, casting an instance of a derived\
    \ type to a base type serves no purpose, since the conversion can be done implicitly.\
    \ In such cases, the redundant cast can simply be removed. However, an upcast\
    \ is not redundant in the following situations:\n\n* It is being used to force\
    \ a call to an overloaded callable that takes a parameter of the base type rather\
    \ than one of the derived type.\n* It is being used to specify the type to use\
    \ for the operands of a ternary expression.\nBoth of these special cases are illustrated\
    \ in the example below. This rule ignores these special cases and highlights upcasts\
    \ which appear to be redundant.\n\n\n## Recommendation\nRemove the unnecessary\
    \ upcast to simplify the code.\n\n\n## Example\nThe following code includes an\
    \ example of a redundant upcast that would be highlighted by this rule. In addition,\
    \ three examples of upcasts that are required and are ignored by this rule.\n\n\
    \n```java\npublic class UselessUpcast {\n\tprivate static class B {}\n\tprivate\
    \ static class D extends B {}\n\n\tprivate static void Foo(B b) { System.out.println(\"\
    Foo(B)\"); }\n\tprivate static void Foo(D d) { System.out.println(\"Foo(D)\");\
    \ }\n\n\tprivate static class Expr {}\n\tprivate static class AddExpr extends\
    \ Expr {}\n\tprivate static class SubExpr extends Expr {}\n\n\tpublic static void\
    \ main(String[] args) {\n\t\tD d = new D();\n\t\tB b_ = (B)d;\t// violation: redundant\
    \ cast, consider removing\n\n\t\tB b = new D();\n\t\tD d_ = (D)b;\t// non-violation:\
    \ required downcast\n\n\t\tFoo(d);\n\t\tFoo((B)d);\t\t// non-violation: required\
    \ to call Foo(B)\n\n\t\t// Non-violation: required to specify the type of the\
    \ ternary operands.\n\t\tExpr e = d != null ? (Expr)new AddExpr() : new SubExpr();\n\
    \t}\n}\n```\n"
 -
  pack: codeql/java-queries#0
  relativeQueryPath: Language Abuse/WrappedIterator.ql
  relativeBqrsPath: codeql/java-queries/Language Abuse/WrappedIterator.bqrs
  metadata:
    name: Iterable wrapping an iterator
    description: |-
      An 'Iterable' that reuses an 'Iterator' instance does not support multiple traversals
                    and can lead to unexpected behavior.
    kind: problem
    problem.severity: warning
    precision: very-high
    id: java/iterable-wraps-iterator
    tags: |-
      correctness
             reliability
  queryHelp: |
    # Iterable wrapping an iterator
    Java has two interfaces for dealing with iteration, `Iterable<T>` and `Iterator<T>`. An `Iterable<T>` represents a sequence of elements that can be traversed, and an `Iterator<T>` represents the **state** of an ongoing traversal. As an example, all the `Collection<T>` classes in the Java standard library implement `Iterable<T>`. Comparing this to a traditional `for` loop that increments an integer index and iterates over the elements of an array, then the `Iterable<T>` object corresponds to the array, whereas the `Iterator<T>` object corresponds to the index variable.

    Implementations of `Iterable<T>` are generally expected to support multiple traversals of the element sequence they represent, although there can be exceptions if the underlying data somehow makes this undesirable, see for example `DirectoryStream<T>`. If an implementation of `Iterable<T>` does not support multiple iterations, then its `iterator()` method should throw an exception on its second and subsequent calls. This makes bugs easier to find if such an `Iterable<T>` is used more than once, for example in two different for-each loops.


    ## Recommendation
    When writing the `iterator()` method in an `Iterable<T>` then it is important to make sure that each call will result in a fresh `Iterator<T>` instance containing all the necessary state for keeping track of the iteration. If the iterator is stored in the `Iterable<T>`, or somehow refers to iteration state stored in the `Iterable<T>`, then subsequent calls to `iterator()` can result in loops that only traverse a subset of the elements or have no effect at all.


    ## Example
    The following example returns the same iterator on every call, and therefore causes the second loop to terminate immediately without any effect.


    ```java
    class MySequence implements Iterable<MyElem> {
      // ... some reference to data
      final Iterator<MyElem> it = data.iterator();
      // Wrong: reused iterator
      public Iterator<MyElem> iterator() {
        return it;
      }
    }

    void useMySequence(MySequence s) {
      // do some work by traversing the sequence
      for (MyElem e : s) {
        // ...
      }
      // do some more work by traversing it again
      for (MyElem e : s) {
        // ...
      }
    }

    ```
    This second example returns a newly created iterator each time, but still relies on iteration state stored in the surrounding class, and therefore also causes the second loop to terminate immediately.


    ```java
    class MySequence implements Iterable<MyElem> {
      // ... some reference to data
      final Iterator<MyElem> it = data.iterator();
      // Wrong: iteration state outside returned iterator
      public Iterator<MyElem> iterator() {
        return new Iterator<MyElem>() {
          public boolean hasNext() {
            return it.hasNext();
          }
          public MyElem next() {
            return transformElem(it.next());
          }
          public void remove() {
            // ...
          }
        };
      }
    }

    ```
    The code should instead be written like this, such that each call to `iterator()` correctly gives a fresh iterator that starts at the beginning.


    ```java
    class MySequence implements Iterable<MyElem> {
      // ... some reference to data
      public Iterator<MyElem> iterator() {
        return new Iterator<MyElem>() {
          // Correct: iteration state inside returned iterator
          final Iterator<MyElem> it = data.iterator();
          public boolean hasNext() {
            return it.hasNext();
          }
          public MyElem next() {
            return transformElem(it.next());
          }
          public void remove() {
            // ...
          }
        };
      }
    }

    ```

    ## References
    * Java Language Specification: [The enhanced for statement](https://docs.oracle.com/javase/specs/jls/se11/html/jls-14.html#jls-14.14.2).
    * Java API Specification: [Interface Iterable&lt;T&gt;](https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/lang/Iterable.html), [Interface Iterator&lt;T&gt;](https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/util/Iterator.html), [Interface DirectoryStream&lt;T&gt;](https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/nio/file/DirectoryStream.html).
 -
  pack: codeql/java-queries#0
  relativeQueryPath: Likely Bugs/Arithmetic/BadAbsOfRandom.ql
  relativeBqrsPath: codeql/java-queries/Likely Bugs/Arithmetic/BadAbsOfRandom.bqrs
  metadata:
    name: Incorrect absolute value of random number
    description: |-
      Calling 'Math.abs' to find the absolute value of a randomly generated integer is not
                    guaranteed to return a non-negative integer.
    kind: problem
    problem.severity: warning
    precision: medium
    id: java/abs-of-random
    tags: |-
      reliability
             maintainability
  queryHelp: |
    # Incorrect absolute value of random number
    Using `Math.abs` on the result of a call to `Random.nextInt()` (or `Random.nextLong()`) is not guaranteed to return a non-negative number. `Random.nextInt()` can return `Integer.MIN_VALUE`, which when passed to `Math.abs` results in the same value, `Integer.MIN_VALUE`. (Because of the two's-complement representation of integers in Java, the positive equivalent of `Integer.MIN_VALUE` cannot be represented in the same number of bits.) The case for `Random.nextLong()` is similar.


    ## Recommendation
    If a non-negative random integer is required, use `Random.nextInt(int)` instead, and use `Integer.MAX_VALUE` as its parameter. The values that might be returned do not include `Integer.MAX_VALUE` itself, but this solution is likely to be sufficient for most purposes.

    Another solution is to increment the value of `Random.nextInt()` by one, if it is negative, before passing the result to `Math.abs`. This solution has the advantage that `0` has the same probability as other numbers.


    ## Example
    In the following example, `mayBeNegativeInt` is negative if `nextInt` returns `Integer.MIN_VALUE`. The example shows how using the two solutions described above means that `positiveInt` is always assigned a positive number.


    ```java
    public static void main(String args[]) {
        Random r = new Random();

        // BAD: 'mayBeNegativeInt' is negative if
        // 'nextInt()' returns 'Integer.MIN_VALUE'.
        int mayBeNegativeInt = Math.abs(r.nextInt());

        // GOOD: 'nonNegativeInt' is always a value between 0 (inclusive)
        // and Integer.MAX_VALUE (exclusive).
        int nonNegativeInt = r.nextInt(Integer.MAX_VALUE);

        // GOOD: When 'nextInt' returns a negative number increment the returned value.
        int nextInt = r.nextInt();
        if(nextInt < 0)
            nextInt++;
        int nonNegativeInt = Math.abs(nextInt);
    }

    ```

    ## References
    * Java API Specification: [Math.abs(int)](https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/lang/Math.html#abs(int)), [Math.abs(long)](https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/lang/Math.html#abs(long)), [Random](https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/util/Random.html).
    * Java Language Specification: [4.2.1 Integral Types and Values](https://docs.oracle.com/javase/specs/jls/se11/html/jls-4.html#jls-4.2.1).
 -
  pack: codeql/java-queries#0
  relativeQueryPath: Likely Bugs/Arithmetic/BadCheckOdd.ql
  relativeBqrsPath: codeql/java-queries/Likely Bugs/Arithmetic/BadCheckOdd.bqrs
  metadata:
    name: Bad parity check
    description: |-
      Code that uses 'x % 2 == 1' or 'x % 2 > 0' to check whether a number is odd does not
                    work for negative numbers.
    kind: problem
    problem.severity: warning
    precision: low
    id: java/incomplete-parity-check
    tags: |-
      reliability
             correctness
             types
  queryHelp: "# Bad parity check\nAvoid using `x % 2 == 1` or `x % 2 > 0` to check\
    \ whether a number `x` is odd, or `x % 2 != 1` to check whether it is even. Such\
    \ code does not work for negative numbers. For example, `-5 % 2` equals `-1`,\
    \ not `1`.\n\n\n## Recommendation\nConsider using `x % 2 != 0` to check for odd\
    \ and `x % 2 == 0` to check for even.\n\n\n## Example\n-9 is an odd number but\
    \ this example does not detect it as one. This is because `-9 % 2 ` is -1, not\
    \ 1.\n\n\n```java\nclass CheckOdd {\n    private static boolean isOdd(int x) {\n\
    \        return x % 2 == 1;\n    }\n    \n    public static void main(String[]\
    \ args) {\n        System.out.println(isOdd(-9)); // prints false\n    }\n}\n\
    ```\nIt would be better to check if the number is even and then invert that check.\n\
    \n\n```java\nclass CheckOdd {\n    private static boolean isOdd(int x) {\n   \
    \     return x % 2 != 0;\n    }\n    \n    public static void main(String[] args)\
    \ {\n        System.out.println(isOdd(-9)); // prints true\n    }\n}\n```\n\n\
    ## References\n* J. Bloch and N. Gafter, *Java Puzzlers: Traps, Pitfalls, and\
    \ Corner Cases*, Puzzle 1. Addison-Wesley, 2005.\n* Java Language Specification:\
    \ [Remainder Operator %](https://docs.oracle.com/javase/specs/jls/se11/html/jls-15.html#jls-15.17.3).\n"
 -
  pack: codeql/java-queries#0
  relativeQueryPath: Likely Bugs/Arithmetic/CondExprTypes.ql
  relativeBqrsPath: codeql/java-queries/Likely Bugs/Arithmetic/CondExprTypes.bqrs
  metadata:
    name: Type mismatch in conditional expression
    description: |-
      Using the '(p?e1:e2)' operator with different primitive types for the second and
                    third operands may cause unexpected results.
    kind: problem
    problem.severity: warning
    precision: low
    id: java/type-mismatch-in-conditional
    tags: |-
      reliability
             correctness
  queryHelp: |
    # Type mismatch in conditional expression
    Conditional expressions of the form `(p ? e1 : e2)` can yield unexpected results if `e1` and `e2` have distinct primitive types.


    ## Example
    The following example illustrates the most confusing case, which occurs when one branch has type `char` and the other branch does not have type `char`.


    ```java
    int i = 0;
    System.out.print(true ? 'x' : 0); // prints "x"
    System.out.print(true ? 'x' : i); // prints "120"
    ```
    This unexpected result is due to binary numeric promotion of `'x'` from `char` to `int`. For details on the result type of the conditional operator, see the references.


    ## Recommendation
    When using the ternary conditional operator with numeric operands, the second and third operand should have the same numeric type. This avoids potentially unexpected results caused by binary numeric promotion.


    ## References
    * J. Bloch and N. Gafter, *Java Puzzlers: Traps, Pitfalls, and Corner Cases*, Puzzle 8. Addison-Wesley, 2005.
    * Java Language Specification: [Conditional Operator ? :](https://docs.oracle.com/javase/specs/jls/se11/html/jls-15.html#jls-15.25).
 -
  pack: codeql/java-queries#0
  relativeQueryPath: Likely Bugs/Arithmetic/ConstantExpAppearsNonConstant.ql
  relativeBqrsPath: codeql/java-queries/Likely Bugs/Arithmetic/ConstantExpAppearsNonConstant.bqrs
  metadata:
    name: Expression always evaluates to the same value
    description: "An expression that always evaluates to the same value, but which\
      \ has a non-constant subexpression, indicates a mistake."
    kind: problem
    problem.severity: warning
    precision: very-high
    id: java/evaluation-to-constant
    tags: |-
      maintainability
             useless-code
  queryHelp: "# Expression always evaluates to the same value\nSome expressions always\
    \ evaluate to the same result, no matter what their subexpressions are:\n\n* `x\
    \ * 0` always evaluates to `0`.\n* `x % 1` always evaluates to `0`.\n* `x & 0`\
    \ always evaluates to `0`.\n* `x || true` always evaluates to `true`.\n* `x &&\
    \ false` always evaluates to `false`.\nWhenever `x` is not constant, such an expression\
    \ is often a mistake.\n\n\n## Recommendation\nIf the expression is supposed to\
    \ evaluate to the same result every time it is executed, consider replacing the\
    \ entire expression with its result.\n\n\n## Example\nThe following method tries\
    \ to determine whether `x` is even by checking whether `x % 1 == 0`.\n\n\n```java\n\
    public boolean isEven(int x) {\n\treturn x % 1 == 0; //Does not work\n}\n\n```\n\
    However, `x % 1 == 0` is always true when `x` is an integer. The correct check\
    \ is `x % 2 == 0`.\n\n\n```java\npublic boolean isEven(int x) {\n    return x\
    \ % 2 == 0; //Does work\n}\n\n```\n\n## References\n* Java Language Specification:\
    \ [Multiplication Operator \\*](https://docs.oracle.com/javase/specs/jls/se11/html/jls-15.html#jls-15.17.1),\
    \ [Remainder Operator %](https://docs.oracle.com/javase/specs/jls/se11/html/jls-15.html#jls-15.17.3),\
    \ [Integer Bitwise Operators &amp;, ^, and |](https://docs.oracle.com/javase/specs/jls/se11/html/jls-15.html#jls-15.22.1),\
    \ [Conditional-And Operator &amp;&amp;](https://docs.oracle.com/javase/specs/jls/se11/html/jls-15.html#jls-15.23)\
    \ and [Conditional-Or Operator ||](https://docs.oracle.com/javase/specs/jls/se11/html/jls-15.html#jls-15.24).\n"
 -
  pack: codeql/java-queries#0
  relativeQueryPath: Likely Bugs/Arithmetic/InformationLoss.ql
  relativeBqrsPath: codeql/java-queries/Likely Bugs/Arithmetic/InformationLoss.bqrs
  metadata:
    name: Implicit narrowing conversion in compound assignment
    description: |-
      Compound assignment statements (for example 'intvar += longvar') that implicitly
                    cast a value of a wider type to a narrower type may result in information loss and
                    numeric errors such as overflows.
    kind: problem
    problem.severity: warning
    security-severity: 8.1
    precision: very-high
    id: java/implicit-cast-in-compound-assignment
    tags: |-
      reliability
             security
             external/cwe/cwe-190
             external/cwe/cwe-192
             external/cwe/cwe-197
             external/cwe/cwe-681
  queryHelp: |
    # Implicit narrowing conversion in compound assignment
    Compound assignment statements of the form `x += y` or `x *= y` perform an implicit narrowing conversion if the type of `x` is narrower than the type of `y`. For example, `x += y` is equivalent to `x = (T)(x + y)`, where `T` is the type of `x`. This can result in information loss and numeric errors such as overflows.


    ## Recommendation
    Ensure that the type of the left-hand side of the compound assignment statement is at least as wide as the type of the right-hand side.


    ## Example
    If `x` is of type `short` and `y` is of type `int`, the expression `x + y` is of type `int`. However, the expression `x += y` is equivalent to `x = (short) (x + y)`. The expression `x + y` is cast to the type of the left-hand side of the assignment: `short`, possibly leading to information loss.

    To avoid implicitly narrowing the type of `x + y`, change the type of `x` to `int`. Then the types of `x` and `x + y` are both `int` and there is no need for an implicit cast.


    ## References
    * J. Bloch and N. Gafter, *Java Puzzlers: Traps, Pitfalls, and Corner Cases*, Puzzle 9. Addison-Wesley, 2005.
    * Java Language Specification: [Compound Assignment Operators](https://docs.oracle.com/javase/specs/jls/se11/html/jls-15.html#jls-15.26.2), [Narrowing Primitive Conversion](https://docs.oracle.com/javase/specs/jls/se11/html/jls-5.html#jls-5.1.3).
    * SEI CERT Oracle Coding Standard for Java: [NUM00-J. Detect or prevent integer overflow](https://wiki.sei.cmu.edu/confluence/display/java/NUM00-J.+Detect+or+prevent+integer+overflow).
    * Common Weakness Enumeration: [CWE-190](https://cwe.mitre.org/data/definitions/190.html).
    * Common Weakness Enumeration: [CWE-192](https://cwe.mitre.org/data/definitions/192.html).
    * Common Weakness Enumeration: [CWE-197](https://cwe.mitre.org/data/definitions/197.html).
    * Common Weakness Enumeration: [CWE-681](https://cwe.mitre.org/data/definitions/681.html).
 -
  pack: codeql/java-queries#0
  relativeQueryPath: Likely Bugs/Arithmetic/IntMultToLong.ql
  relativeBqrsPath: codeql/java-queries/Likely Bugs/Arithmetic/IntMultToLong.bqrs
  metadata:
    name: Result of multiplication cast to wider type
    description: |-
      Casting the result of a multiplication to a wider type instead of casting
                    before the multiplication may cause overflow.
    kind: problem
    problem.severity: warning
    precision: very-high
    id: java/integer-multiplication-cast-to-long
    tags: |-
      reliability
             correctness
             types
             external/cwe/cwe-190
             external/cwe/cwe-192
             external/cwe/cwe-197
             external/cwe/cwe-681
  queryHelp: |
    # Result of multiplication cast to wider type
    An integer multiplication that is assigned to a variable of type `long` or returned from a method with return type `long` may cause unexpected arithmetic overflow.


    ## Recommendation
    Casting to type `long` before multiplying reduces the risk of arithmetic overflow.


    ## Example
    In the following example, the multiplication expression assigned to `j` causes overflow and results in the value `-1651507200` instead of `4000000000000000000`.


    ```java
    int i = 2000000000;
    long j = i*i; // causes overflow
    ```
    In the following example, the assignment to `k` correctly avoids overflow by casting one of the operands to type `long`.


    ```java
    int i = 2000000000;
    long k = i*(long)i; // avoids overflow
    ```

    ## References
    * J. Bloch and N. Gafter, *Java Puzzlers: Traps, Pitfalls, and Corner Cases*, Puzzle 3. Addison-Wesley, 2005.
    * Java Language Specification: [Multiplication Operator](https://docs.oracle.com/javase/specs/jls/se11/html/jls-15.html#jls-15.17.1).
    * SEI CERT Oracle Coding Standard for Java: [NUM00-J. Detect or prevent integer overflow](https://wiki.sei.cmu.edu/confluence/display/java/NUM00-J.+Detect+or+prevent+integer+overflow).
    * Common Weakness Enumeration: [CWE-190](https://cwe.mitre.org/data/definitions/190.html).
    * Common Weakness Enumeration: [CWE-192](https://cwe.mitre.org/data/definitions/192.html).
    * Common Weakness Enumeration: [CWE-197](https://cwe.mitre.org/data/definitions/197.html).
    * Common Weakness Enumeration: [CWE-681](https://cwe.mitre.org/data/definitions/681.html).
 -
  pack: codeql/java-queries#0
  relativeQueryPath: Likely Bugs/Arithmetic/LShiftLargerThanTypeWidth.ql
  relativeBqrsPath: codeql/java-queries/Likely Bugs/Arithmetic/LShiftLargerThanTypeWidth.bqrs
  metadata:
    name: Left shift by more than the type width
    description: Left-shifting an integer by more than its type width indicates a
      mistake.
    kind: problem
    problem.severity: warning
    precision: very-high
    id: java/lshift-larger-than-type-width
    tags: correctness
  queryHelp: |
    # Left shift by more than the type width
    The maximum shift distance used for left-shift operations is determined by the promoted type of its left-hand side. When the promoted type is `int` only the lowest 5 bits of the right-hand side are used as the shift distance. When the promoted type is `long` the lowest 6 bits of the right-hand side are used.


    ## Recommendation
    Restrict the amount that you shift any `int` to the range 0-31, or cast it to `long` before applying the left shift.


    ## Example
    The following line tries to left-shift an `int` by 32 bits.


    ```java
    long longVal = intVal << 32; // BAD
    ```
    However, left-shifting an `int` by 32 bits is equivalent to left-shifting it by 0 bits, that is, no shift is applied. Instead the value should be cast to `long` before the shift is applied. Then the left-shift of 32 bits will work.


    ```java
    long longVal = ((long)intVal) << 32; // GOOD
    ```

    ## References
    * Java Language Specification: [Shift Operators](https://docs.oracle.com/javase/specs/jls/se11/html/jls-15.html#jls-15.19).
 -
  pack: codeql/java-queries#0
  relativeQueryPath: Likely Bugs/Arithmetic/MultiplyRemainder.ql
  relativeBqrsPath: codeql/java-queries/Likely Bugs/Arithmetic/MultiplyRemainder.bqrs
  metadata:
    name: Multiplication of remainder
    description: |-
      Using the remainder operator with the multiplication operator without adding
                    parentheses to clarify precedence may cause confusion.
    kind: problem
    problem.severity: warning
    precision: medium
    id: java/multiplication-of-remainder
    tags: |-
      maintainability
             correctness
  queryHelp: |
    # Multiplication of remainder
    Using the remainder operator `%` with the multiplication operator may not give you the result that you expect unless you use parentheses. This is because the remainder operator has the same precedence as the multiplication operator, and the operators are left-associative.


    ## Recommendation
    When you use the remainder operator with the multiplication operator, ensure that the expression is evaluated as you expect. If necessary, add parentheses.


    ## Example
    Consider a time in milliseconds, represented by `t`. To calculate the number of milliseconds remaining after the time has been converted to whole minutes, you might write `t % 60 * 1000`. However, this is equal to `(t % 60) * 1000`, which gives the wrong result. Instead, the expression should be `t % (60 * 1000)`.


    ## References
    * J. Bloch and N. Gafter, *Java Puzzlers: Traps, Pitfalls, and Corner Cases*, Puzzle 35. Addison-Wesley, 2005.
    * The Java Tutorials: [Operators](https://docs.oracle.com/javase/tutorial/java/nutsandbolts/operators.html).
 -
  pack: codeql/java-queries#0
  relativeQueryPath: Likely Bugs/Arithmetic/OctalLiteral.ql
  relativeBqrsPath: codeql/java-queries/Likely Bugs/Arithmetic/OctalLiteral.bqrs
  metadata:
    name: Use of octal values
    description: |-
      An integer literal that starts with '0' may cause a problem. If the '0' is
                    intentional, a programmer may misread the literal as a decimal literal. If the '0'
                    is unintentional and a decimal literal is intended, the compiler treats the
                    literal as an octal literal.
    kind: problem
    problem.severity: warning
    precision: low
    id: java/octal-literal
    tags: |-
      maintainability
             correctness
  queryHelp: |
    # Use of octal values
    An integer literal consisting of a leading `0` digit followed by one or more digits in the range `0-7` is an octal literal. This can lead to two problems:

    * An octal literal can be misread by a programmer as a decimal literal.
    * A programmer might accidentally start a decimal literal with a zero, so that the compiler treats the decimal literal as an octal literal. For example, `010` is equal to `8`, not `10`.

    ## Recommendation
    To avoid these problems:

    * Avoid using octal literals so that programmers do not confuse them with decimal literals. However, if you need to use octal literals, you should add a comment to each octal literal indicating the intention to use octal literals.
    * When typing decimal literals, be careful not to begin them with a zero accidentally.

    ## References
    * J. Bloch and N. Gafter, *Java Puzzlers: Traps, Pitfalls, and Corner Cases*, Puzzle 59. Addison-Wesley, 2005.
    * Java Language Specification: [Integer Literals](https://docs.oracle.com/javase/specs/jls/se11/html/jls-3.html#jls-3.10.1).
 -
  pack: codeql/java-queries#0
  relativeQueryPath: Likely Bugs/Arithmetic/RandomUsedOnce.ql
  relativeBqrsPath: codeql/java-queries/Likely Bugs/Arithmetic/RandomUsedOnce.bqrs
  metadata:
    name: Random used only once
    description: |-
      Creating an instance of 'Random' for each pseudo-random number required does not
                    guarantee an evenly distributed sequence of random numbers.
    kind: problem
    problem.severity: warning
    precision: medium
    id: java/random-used-once
    tags: |-
      reliability
             maintainability
             external/cwe/cwe-335
  queryHelp: "# Random used only once\nA program that uses `java.util.Random` to generate\
    \ a sequence of pseudo-random numbers *should not* create a new instance of `Random`\
    \ every time a new pseudo-random number is required (for example, `new Random().nextInt()`).\n\
    \nAccording to the Java API Specification:\n\n> If two instances of `Random` are\
    \ created with the same seed, and the same sequence of method calls is made for\
    \ each, they will generate and return identical sequences of numbers.\n\nThe sequence\
    \ of pseudo-random numbers returned by these calls depends only on the value of\
    \ the seed. If you construct a new `Random` object each time a pseudo-random number\
    \ is needed, this does not generate a good distribution of pseudo-random numbers,\
    \ even though the parameterless `Random()` constructor tries to initialize itself\
    \ with a unique seed.\n\n\n## Recommendation\nCreate a `Random` object once and\
    \ use the same instance when generating sequences of pseudo-random numbers (by\
    \ calling `nextInt`, `nextLong`, and so on).\n\n\n## Example\nIn the following\
    \ example, generating a series of pseudo-random numbers, such as `notReallyRandom`\
    \ and `notReallyRandom2`, by creating a new instance of `Random` each time is\
    \ unlikely to result in a good distribution of pseudo-random numbers. In contrast,\
    \ generating a series of pseudo-random numbers, such as `random1` and `random2`,\
    \ by calling `nextInt` each time *is* likely to result in a good distribution.\
    \ This is because the numbers are based on only one `Random` object.\n\n\n```java\n\
    public static void main(String args[]) {\n\t// BAD: A new 'Random' object is created\
    \ every time\n\t// a pseudo-random integer is required.\n\tint notReallyRandom\
    \ = new Random().nextInt();\n\tint notReallyRandom2 = new Random().nextInt();\n\
    \t\n\t// GOOD: The same 'Random' object is used to generate \n\t// two pseudo-random\
    \ integers.\n\tRandom r = new Random();\n\tint random1 = r.nextInt();\n\tint random2\
    \ = r.nextInt();\n}\n```\n\n## References\n* Java API Specification: [Random](https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/util/Random.html).\n\
    * Common Weakness Enumeration: [CWE-335](https://cwe.mitre.org/data/definitions/335.html).\n"
 -
  pack: codeql/java-queries#0
  relativeQueryPath: Likely Bugs/Arithmetic/WhitespaceContradictsPrecedence.ql
  relativeBqrsPath: codeql/java-queries/Likely Bugs/Arithmetic/WhitespaceContradictsPrecedence.bqrs
  metadata:
    name: Whitespace contradicts operator precedence
    description: |-
      Nested expressions where the formatting contradicts the grouping enforced by operator precedence
                    are difficult to read and may even indicate a bug.
    kind: problem
    problem.severity: warning
    precision: very-high
    id: java/whitespace-contradicts-precedence
    tags: |-
      maintainability
             readability
             external/cwe/cwe-783
  queryHelp: |
    # Whitespace contradicts operator precedence
    Nested expressions where the spacing around operators suggests a different grouping than that imposed by the Java operator precedence rules are problematic: they could indicate a bug where the author of the code misunderstood the precedence rules. Even if there is no a bug, the spacing could be confusing to people who read the code.


    ## Recommendation
    Make sure that the spacing around operators reflects operator precedence, or use parentheses to clarify grouping.


    ## Example
    Consider the following piece of code for allocating an array:

    ```

        int[] buf = new int[capacity + capacity>>1];

    ```
    Here, the spacing around `+` and `>>` suggests the grouping `capacity + (capacity>>1)`, that is, the allocated array should be 50% larger than the given capacity.

    In fact, however, `+` has higher precedence than `>>`, so this code allocates an array of size `(capacity + capacity) >> 1`, which is the same as `capacity`.


    ## References
    * J. Bloch and N. Gafter, *Java Puzzlers: Traps, Pitfalls, and Corner Cases*, Puzzle 35. Addison-Wesley, 2005.
    * Common Weakness Enumeration: [CWE-783](https://cwe.mitre.org/data/definitions/783.html).
 -
  pack: codeql/java-queries#0
  relativeQueryPath: Likely Bugs/Cloning/MissingCallToSuperClone.ql
  relativeBqrsPath: codeql/java-queries/Likely Bugs/Cloning/MissingCallToSuperClone.bqrs
  metadata:
    name: Missing super clone
    description: |-
      A 'clone' method that is overridden in a subclass, and that does not itself call
                    'super.clone', causes calls to the subclass's 'clone' method to return an object of
                    the wrong type.
    kind: problem
    problem.severity: error
    precision: medium
    id: java/missing-call-to-super-clone
    tags: |-
      reliability
             maintainability
             external/cwe/cwe-580
  queryHelp: "# Missing super clone\nA `clone` method that is overridden in a subclass\
    \ should call `super.clone`. Not doing so causes the subclass `clone` to return\
    \ an object of the wrong type, which violates the contract for `Cloneable`.\n\n\
    The Java API Specification states that, for an object `x`, the general intent\
    \ of the `clone` method is for it to satisfy the following three properties:\n\
    \n* `x.clone() != x` (the cloned object is a different object instance)\n* `x.clone().getClass()\
    \ == x.getClass()` (the cloned object is the same type as the source object)\n\
    * `x.clone().equals(x)` (the cloned object has the same 'contents' as the source\
    \ object)\nFor the cloned object to be of the same type as the source object,\
    \ non-final classes must call `super.clone` and that call must eventually reach\
    \ `Object.clone`, which creates an instance of the right type. If it were to create\
    \ a new object using a constructor, a subclass that does not implement the `clone`\
    \ method returns an object of the wrong type. In addition, all of the class's\
    \ supertypes that also override `clone` must call `super.clone`. Otherwise, it\
    \ never reaches `Object.clone` and creates an object of the incorrect type.\n\n\
    However, as `Object.clone` only does a shallow copy of the fields of an object,\
    \ any `Cloneable` objects that have a \"deep structure\" (for example, objects\
    \ that use an array or `Collection`) must take the clone that results from the\
    \ call to `super.clone` and assign explicitly created copies of the structure\
    \ to the clone's fields. This means that the cloned instance does not share its\
    \ internal state with the source object. If it *did* share its internal state,\
    \ any changes made in the cloned object would also affect the internal state of\
    \ the source object, probably causing unintended behavior.\n\nOne added complication\
    \ is that `clone` cannot modify values in final fields, which would be already\
    \ set by the call to `super.clone`. Some fields must be made non-final to correctly\
    \ implement the `clone` method.\n\n\n## Recommendation\nEvery clone method should\
    \ always use `super.clone` to construct the cloned object. This ensures that the\
    \ cloned object is ultimately constructed by `Object.clone`, which uses reflection\
    \ to ensure that an object of the correct runtime type is created.\n\n\n## Example\n\
    In the following example, the attempt to clone `WrongEmployee` fails because `super.clone`\
    \ is implemented incorrectly in its superclass `WrongPerson`.\n\n\n```java\nclass\
    \ WrongPerson implements Cloneable {\n    private String name;\n    public WrongPerson(String\
    \ name) { this.name = name; }\n    // BAD: 'clone' does not call 'super.clone'.\n\
    \    public WrongPerson clone() {\n        return new WrongPerson(this.name);\n\
    \    }\n}\n\nclass WrongEmployee extends WrongPerson {\n    public WrongEmployee(String\
    \ name) {\n        super(name);\n    }\n    // ALMOST RIGHT: 'clone' correctly\
    \ calls 'super.clone',\n    // but 'super.clone' is implemented incorrectly.\n\
    \    public WrongEmployee clone() {\n    \treturn (WrongEmployee)super.clone();\n\
    \    }\n}\n\npublic class MissingCallToSuperClone {\n    public static void main(String[]\
    \ args) {\n        WrongEmployee e = new WrongEmployee(\"John Doe\");\n      \
    \  WrongEmployee eclone = e.clone(); // Causes a ClassCastException\n    }\n}\n\
    \n```\nHowever, in the following modified example, the attempt to clone `Employee`\
    \ succeeds because `super.clone` is implemented correctly in its superclass `Person`.\n\
    \n\n```java\nclass Person implements Cloneable {\n    private String name;\n \
    \   public Person(String name) { this.name = name; }\n    // GOOD: 'clone' correctly\
    \ calls 'super.clone'\n    public Person clone() {\n        try {\n          \
    \  return (Person)super.clone();\n        } catch (CloneNotSupportedException\
    \ e) {\n            throw new AssertionError(\"Should never happen\");\n     \
    \   }\n    }\n}\n\nclass Employee extends Person {\n    public Employee(String\
    \ name) {\n        super(name);\n    }\n    // GOOD: 'clone' correctly calls 'super.clone'\n\
    \    public Employee clone() {\n    \treturn (Employee)super.clone();\n    }\n\
    }\n\npublic class MissingCallToSuperClone {\n    public static void main(String[]\
    \ args) {\n        Employee e2 = new Employee(\"Jane Doe\");\n        Employee\
    \ e2clone = e2.clone(); // 'clone' correctly returns an object of type 'Employee'\n\
    \    }\n}\n\n```\n\n## References\n* J. Bloch, *Effective Java (second edition)*,\
    \ Item 11. Addison-Wesley, 2008.\n* Java API Specification: [Object.clone()](https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/lang/Object.html#clone()).\n\
    * Common Weakness Enumeration: [CWE-580](https://cwe.mitre.org/data/definitions/580.html).\n"
 -
  pack: codeql/java-queries#0
  relativeQueryPath: Likely Bugs/Cloning/MissingMethodClone.ql
  relativeBqrsPath: codeql/java-queries/Likely Bugs/Cloning/MissingMethodClone.bqrs
  metadata:
    name: No clone method
    description: |-
      A class that implements 'Cloneable' but does not override the 'clone' method will
                    have undesired behavior.
    kind: problem
    problem.severity: error
    precision: medium
    id: java/missing-clone-method
    tags: |-
      reliability
             maintainability
  queryHelp: |
    # No clone method
    A class that implements `Cloneable` should override `Object.clone`. For non-trivial objects, the `Cloneable` contract requires a deep copy of the object's internal state. A class that does not have a `clone` method indicates that the class is breaking the contract and will have undesired behavior.

    The Java API Specification states that, for an object `x`, the general intent of the `clone` method is for it to satisfy the following three properties:

    * `x.clone() != x` (the cloned object is a different object instance)
    * `x.clone().getClass() == x.getClass()` (the cloned object is the same type as the source object)
    * `x.clone().equals(x)` (the cloned object has the same 'contents' as the source object)
    For the cloned object to be of the same type as the source object, non-final classes must call `super.clone` and that call must eventually reach `Object.clone`, which creates an instance of the right type. If it were to create a new object using a constructor, a subclass that does not implement the `clone` method returns an object of the wrong type. In addition, all of the class's supertypes that also override `clone` must call `super.clone`. Otherwise, it never reaches `Object.clone` and creates an object of the incorrect type.

    However, as `Object.clone` only does a shallow copy of the fields of an object, any `Cloneable` objects that have a "deep structure" (for example, objects that use an array or `Collection`) must take the clone that results from the call to `super.clone` and assign explicitly created copies of the structure to the clone's fields. This means that the cloned instance does not share its internal state with the source object. If it *did* share its internal state, any changes made in the cloned object would also affect the internal state of the source object, probably causing unintended behavior.

    One added complication is that `clone` cannot modify values in final fields, which would be already set by the call to `super.clone`. Some fields must be made non-final to correctly implement the `clone` method.


    ## Recommendation
    The necessity of creating a deep copy of an object's internal state means that, for most objects, `clone` must be overridden to satisfy the `Cloneable` contract. Implement a `clone` method that properly creates the internal state of the cloned object.

    Notable exceptions to this recommendation are:

    * Classes that contain only primitive types (which will be properly cloned by `Object.clone` as long as its `Cloneable` supertypes all call `super.clone`).
    * Subclasses of `Cloneable` classes that do not introduce new state.

    ## Example
    In the following example, `WrongStack` does not implement `clone`. This means that when `ws1clone` is cloned from `ws1`, the default `clone` implementation is used. This results in operations on the `ws1clone` stack affecting the `ws1` stack.


    ```java
    abstract class AbstractStack implements Cloneable {
        public AbstractStack clone() {
            try {
                return (AbstractStack) super.clone();
            } catch (CloneNotSupportedException e) {
                throw new AssertionError("Should not happen");
            }
        }
    }

    class WrongStack extends AbstractStack {
        private static final int MAX_STACK = 10;
        int[] elements = new int[MAX_STACK];
        int top = -1;

        void push(int newInt) {
            elements[++top] = newInt;
        }
        int pop() {
            return elements[top--];
        }
        // BAD: No 'clone' method to create a copy of the elements.
        // Therefore, the default 'clone' implementation (shallow copy) is used, which
        // is equivalent to:
        //
        //  public WrongStack clone() {
        //      WrongStack cloned = (WrongStack) super.clone();
        //      cloned.elements = elements;  // Both 'this' and 'cloned' now use the same elements.
        //      return cloned;
        //  }
    }

    public class MissingMethodClone {
        public static void main(String[] args) {
            WrongStack ws1 = new WrongStack();              // ws1: {}
            ws1.push(1);                                    // ws1: {1}
            ws1.push(2);                                    // ws1: {1,2}
            WrongStack ws1clone = (WrongStack) ws1.clone(); // ws1clone: {1,2}
            ws1clone.pop();                                 // ws1clone: {1}
            ws1clone.push(3);                               // ws1clone: {1,3}
            System.out.println(ws1.pop());                  // Because ws1 and ws1clone have the same
                                                            // elements, this prints 3 instead of 2
        }
    }



    ```
    In the following modified example, `RightStack` *does* implement `clone`. This means that when `rs1clone` is cloned from `rs1`, operations on the `rs1clone` stack do not affect the `rs1` stack.


    ```java
    abstract class AbstractStack implements Cloneable {
        public AbstractStack clone() {
            try {
                return (AbstractStack) super.clone();
            } catch (CloneNotSupportedException e) {
                throw new AssertionError("Should not happen");
            }
        }
    }

    class RightStack extends AbstractStack {
        private static final int MAX_STACK = 10;
        int[] elements = new int[MAX_STACK];
        int top = -1;

        void push(int newInt) {
            elements[++top] = newInt;
        }
        int pop() {
            return elements[top--];
        }

        // GOOD: 'clone' method to create a copy of the elements.
        public RightStack clone() {
            RightStack cloned = (RightStack) super.clone();
            cloned.elements = elements.clone();  // 'cloned' has its own elements.
            return cloned;
        }
    }

    public class MissingMethodClone {
        public static void main(String[] args) {
            RightStack rs1 = new RightStack();              // rs1: {}
            rs1.push(1);                                    // rs1: {1}
            rs1.push(2);                                    // rs1: {1,2}
            RightStack rs1clone = rs1.clone();              // rs1clone: {1,2}
            rs1clone.pop();                                 // rs1clone: {1}
            rs1clone.push(3);                               // rs1clone: {1,3}
            System.out.println(rs1.pop());                  // Correctly prints 2
        }
    }



    ```

    ## References
    * J. Bloch, *Effective Java (second edition)*, Item 11. Addison-Wesley, 2008.
    * Java API Specification: [Object.clone()](https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/lang/Object.html#clone()).
 -
  pack: codeql/java-queries#0
  relativeQueryPath: Likely Bugs/Collections/ArrayIndexOutOfBounds.ql
  relativeBqrsPath: codeql/java-queries/Likely Bugs/Collections/ArrayIndexOutOfBounds.bqrs
  metadata:
    name: Array index out of bounds
    description: |-
      Accessing an array with an index that is greater than or equal to the
                    length of the array causes an 'ArrayIndexOutOfBoundsException'.
    kind: problem
    problem.severity: error
    precision: high
    id: java/index-out-of-bounds
    tags: |-
      reliability
             correctness
             exceptions
             external/cwe/cwe-193
  queryHelp: |
    # Array index out of bounds
    When accessing an array element, one must ensure that the index is less than the length of the array. Using an index that is greater than or equal to the array length causes an `ArrayIndexOutOfBoundsException`.


    ## Recommendation
    Ensure that the index is less than the array length.


    ## Example
    The following example causes an `ArrayIndexOutOfBoundsException` in the final loop iteration.


    ```java
    for (int i = 0; i <= a.length; i++) { // BAD
      sum += a[i];
    }

    ```
    The condition should be changed as follows to correctly guard the array access.


    ```java
    for (int i = 0; i < a.length; i++) { // GOOD
      sum += a[i];
    }

    ```

    ## References
    * Java API Specification: [ArrayIndexOutOfBoundsException](https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/lang/ArrayIndexOutOfBoundsException.html).
    * Common Weakness Enumeration: [CWE-193](https://cwe.mitre.org/data/definitions/193.html).
 -
  pack: codeql/java-queries#0
  relativeQueryPath: Likely Bugs/Collections/ContainsTypeMismatch.ql
  relativeBqrsPath: codeql/java-queries/Likely Bugs/Collections/ContainsTypeMismatch.bqrs
  metadata:
    name: Type mismatch on container access
    description: |-
      Calling container access methods such as 'Collection.contains'
                    or 'Map.get' with an object of a type that is incompatible with
                    the corresponding container element type is unlikely to return 'true'.
    kind: problem
    problem.severity: error
    precision: very-high
    id: java/type-mismatch-access
    tags: |-
      reliability
             correctness
             logic
  queryHelp: "# Type mismatch on container access\nThe `contains` method of the `Collection`\
    \ interface has an argument of type `Object`. Therefore, you can try to check\
    \ if an object of any type is a member of a collection, regardless of the collection's\
    \ element type. However, although you can call `contains` with an argument of\
    \ a different type than that of the collection, it is unlikely that the collection\
    \ actually contains an object of this type.\n\nSimilar considerations apply to\
    \ other container access methods, such as `Map.get`, where the argument may also\
    \ have type `Object`.\n\n\n## Recommendation\nEnsure that you use the correct\
    \ argument with a call to `contains`.\n\n\n## Example\nIn the following example,\
    \ although the argument to `contains` is an integer, the code does not result\
    \ in a type error because the argument does not have to match the type of the\
    \ elements of `list`. However, the argument is unlikely to be found (and the body\
    \ of the `if` statement is therefore not executed), so it is probably a typographical\
    \ error: the argument should be enclosed in quotation marks.\n\n\n```java\nvoid\
    \ m(List<String> list) {\n\tif (list.contains(123)) {  // Call 'contains' with\
    \ non-string argument (without quotation marks)\n\t\t// ...\n\t}\n}\n```\nNote\
    \ that you must take particular care when working with collections over boxed\
    \ types, as illustrated in the following example. The first call to `contains`\
    \ returns `false` because you cannot compare two boxed numeric primitives of different\
    \ types, in this case `Short(1)` (in `set`) and `Integer(1)` (the argument). The\
    \ second call to `contains` returns `true` because you can compare `Short(1)`\
    \ and `Short(1)`.\n\n\n```java\nHashSet<Short> set = new HashSet<Short>();\nshort\
    \ s = 1;\nset.add(s);\n// Following statement prints 'false', because the argument\
    \ is a literal int, which is auto-boxed\n// to an Integer\nSystem.out.println(set.contains(1));\n\
    // Following statement prints 'true', because the argument is a literal int that\
    \ is cast to a short, \n// which is auto-boxed to a Short\nSystem.out.println(set.contains((short)1));\n\
    \n```\n\n## References\n* Java API Specification: [Collection.contains](https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/util/Collection.html#contains(java.lang.Object)).\n"
 -
  pack: codeql/java-queries#0
  relativeQueryPath: Likely Bugs/Collections/IteratorRemoveMayFail.ql
  relativeBqrsPath: codeql/java-queries/Likely Bugs/Collections/IteratorRemoveMayFail.bqrs
  metadata:
    name: Call to Iterator.remove may fail
    description: |-
      Attempting to invoke 'Iterator.remove' on an iterator over a collection that does not
                    support element removal causes a runtime exception.
    kind: problem
    problem.severity: warning
    precision: medium
    id: java/iterator-remove-failure
    tags: |-
      reliability
             correctness
             logic
  queryHelp: "# Call to Iterator.remove may fail\nThe `remove` method of the `Iterator`\
    \ interface is an optional operation. It is not supported by iterators on unmodifiable\
    \ collections, or iterators on lists constructed by the `Arrays.asList` method.\
    \ Invoking `remove` on such an iterator will lead to an `UnsupportedOperationException`.\n\
    \n\n## Recommendation\nIf a collection is meant to be modified after construction,\
    \ use a modifiable collection type such as `ArrayList` or `HashSet`.\n\n\n## Example\n\
    In the following example, the constructor `A(Integer...)` initializes the field\
    \ `A.l` to `Arrays.asList(is)`. While the type of lists returned by `Arrays.asList`\
    \ supports element updates through the `set` method, it does not support element\
    \ removal. Hence the call to `iter.remove` on line 20 must fail at runtime.\n\n\
    \n```java\nimport java.util.Arrays;\nimport java.util.Iterator;\nimport java.util.List;\n\
    \npublic class A {\n\tprivate List<Integer> l;\n\t\n\tpublic A(Integer... is)\
    \ {\n\t\tthis.l = Arrays.asList(is);\n\t}\n\t\n\tpublic List<Integer> getList()\
    \ {\n\t\treturn l;\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tA a\
    \ = new A(23, 42);\n\t\tfor (Iterator<Integer> iter = a.getList().iterator();\
    \ iter.hasNext();)\n\t\t\tif (iter.next()%2 != 0)\n\t\t\t\titer.remove();\n\t\
    }\n}\n\n```\nTo avoid this failure, copy the list returned by `Arrays.asList`\
    \ into a newly created `ArrayList` like this:\n\n\n```java\nimport java.util.Arrays;\n\
    import java.util.Iterator;\nimport java.util.List;\nimport java.util.ArrayList;\n\
    \npublic class A {\n\tprivate List<Integer> l;\n\t\n\tpublic A(Integer... is)\
    \ {\n\t\tthis.l = new ArrayList<Integer>(Arrays.asList(is));\n\t}\n\t\n\tpublic\
    \ List<Integer> getList() {\n\t\treturn l;\n\t}\n\n\tpublic static void main(String[]\
    \ args) {\n\t\tA a = new A(23, 42);\n\t\tfor (Iterator<Integer> iter = a.getList().iterator();\
    \ iter.hasNext();)\n\t\t\tif (iter.next()%2 != 0)\n\t\t\t\titer.remove();\n\t\
    }\n}\n\n```\n\n## References\n* Mark Needham: [Java: Fooled by java.util.Arrays.asList](https://dzone.com/articles/java-fooled).\n"
 -
  pack: codeql/java-queries#0
  relativeQueryPath: Likely Bugs/Collections/ReadOnlyContainer.ql
  relativeBqrsPath: codeql/java-queries/Likely Bugs/Collections/ReadOnlyContainer.bqrs
  metadata:
    name: Container contents are never initialized
    description: Querying the contents of a collection or map that is never initialized
      is not normally useful.
    kind: problem
    problem.severity: error
    precision: very-high
    id: java/empty-container
    tags: |-
      reliability
             maintainability
             useless-code
             external/cwe/cwe-561
  queryHelp: "# Container contents are never initialized\nA method that queries the\
    \ contents of a collection or map (such as `containsKey` or `isEmpty`) is invoked\
    \ on an object that is known to be empty. Such method calls do not return interesting\
    \ results, and may indicate missing code or a logic error.\n\n\n## Recommendation\n\
    Either remove the collection/map if it is unnecessary, or ensure that it contains\
    \ the elements it was meant to contain.\n\n\n## Example\nThe following example\
    \ code iterates over an array of objects to determine whether it contains duplicate\
    \ elements. It maintains a collection `seen`, which is intended to contain all\
    \ the elements seen so far in traversing the array. If the current element is\
    \ already contained in that collection then the method returns `true`, indicating\
    \ that a duplicate has been found.\n\nNote, however, that no elements are ever\
    \ actually added to `seen`, so the method always returns `false`.\n\n\n```java\n\
    boolean containsDuplicates(Object[] array) {\n\tjava.util.Set<Object> seen = new\
    \ java.util.HashSet<Object>();\n\tfor (Object o : array) {\n\t\tif (seen.contains(o))\n\
    \t\t\treturn true;\n\t}\n\treturn false;\n}\n```\nTo fix this problem, a statement\
    \ `seen.add(o);` should be added to the end of the loop body to ensure that `seen`\
    \ is correctly maintained.\n\n\n## References\n* Java API Specification: [Collection](https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/util/Collection.html),\
    \ [Map](https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/util/Map.html).\n\
    * Common Weakness Enumeration: [CWE-561](https://cwe.mitre.org/data/definitions/561.html).\n"
 -
  pack: codeql/java-queries#0
  relativeQueryPath: Likely Bugs/Collections/RemoveTypeMismatch.ql
  relativeBqrsPath: codeql/java-queries/Likely Bugs/Collections/RemoveTypeMismatch.bqrs
  metadata:
    name: Type mismatch on container modification
    description: |-
      Calling container modification methods such as 'Collection.remove'
                    or 'Map.remove' with an object of a type that is incompatible with
                    the corresponding container element type is unlikely to have any effect.
    kind: problem
    problem.severity: error
    precision: very-high
    id: java/type-mismatch-modification
    tags: |-
      reliability
             correctness
             logic
  queryHelp: "# Type mismatch on container modification\nThe `remove` method of the\
    \ `Collection` interface has an argument of type `Object`. Therefore, you can\
    \ try to remove an object of any type from a collection, regardless of the collection's\
    \ element type. However, although you can call `remove` with an argument of a\
    \ different type than that of the collection, it is unlikely that the collection\
    \ actually contains an object of this type.\n\nSimilar considerations apply to\
    \ other container modification methods, such as `Map.remove`, where the argument\
    \ may also have type `Object`.\n\n\n## Recommendation\nEnsure that you use the\
    \ correct argument with a call to `remove`.\n\n\n## Example\nIn the following\
    \ example, although the argument to `contains` is an integer, the code does not\
    \ result in a type error because the argument to `remove` does not have to match\
    \ the type of the elements of `list`. However, the argument is unlikely to be\
    \ found and removed (and the body of the `if` statement is therefore not executed),\
    \ so it is probably a typographical error: the argument should be enclosed in\
    \ quotation marks.\n\n\n```java\nvoid m(List<String> list) {\n\tif (list.remove(123))\
    \ {  // Call 'remove' with non-string argument (without quotation marks)\n\t\t\
    // ...\n\t}\n}\n```\nNote that you must take particular care when working with\
    \ collections over boxed types, as illustrated in the following example. The first\
    \ call to `remove` fails because you cannot compare two boxed numeric primitives\
    \ of different types, in this case `Short(1)` (in `set`) and `Integer(1)` (the\
    \ argument). Therefore, `remove` cannot find the item to remove. The second call\
    \ to `remove` succeeds because you can compare `Short(1)` and `Short(1)`. Therefore,\
    \ `remove` can find the item to remove.\n\n\n```java\nHashSet<Short> set = new\
    \ HashSet<Short>();\nshort s = 1;\nset.add(s);\n// Following statement fails,\
    \ because the argument is a literal int, which is auto-boxed \n// to an Integer\n\
    set.remove(1);\nSystem.out.println(set); // Prints [1]\n// Following statement\
    \ succeeds, because the argument is a literal int that is cast to a short, \n\
    // which is auto-boxed to a Short\nset.remove((short)1);\nSystem.out.println(set);\
    \ // Prints []\n```\n\n## References\n* Java API Specification: [Collection.remove](https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/util/Collection.html#remove(java.lang.Object)).\n"
 -
  pack: codeql/java-queries#0
  relativeQueryPath: Likely Bugs/Collections/WriteOnlyContainer.ql
  relativeBqrsPath: codeql/java-queries/Likely Bugs/Collections/WriteOnlyContainer.bqrs
  metadata:
    name: Container contents are never accessed
    description: A collection or map whose contents are never queried or accessed
      is useless.
    kind: problem
    problem.severity: error
    precision: very-high
    id: java/unused-container
    tags: |-
      maintainability
             useless-code
             external/cwe/cwe-561
  queryHelp: "# Container contents are never accessed\nIf the contents of a collection\
    \ or map are never accessed in any way, then it is useless and the code that updates\
    \ it is effectively dead code. Often, such objects are left over from an incomplete\
    \ refactoring, or they indicate an underlying logic error.\n\n\n## Recommendation\n\
    Either remove the collection/map if it is genuinely unnecessary, or ensure that\
    \ its elements are accessed.\n\n\n## Example\nIn the following example code, the\
    \ `reachable` method determines whether a node in a tree is reachable from `ROOT`.\
    \ It maintains a set `reachableNodes`, which contains all nodes that have previously\
    \ been found to be reachable. Most likely, this set is meant to act as a cache\
    \ to avoid spurious recomputation, but as it stands the code never checks whether\
    \ any node is contained in the set.\n\n\n```java\nprivate Set<Node> reachableNodes\
    \ = new HashSet<Node>();\n\nboolean reachable(Node n) {\n\tboolean reachable;\n\
    \tif (n == ROOT)\n\t\treachable = true;\n\telse\n\t\treachable = reachable(n.getParent());\n\
    \tif (reachable)\n\t\treachableNodes.add(n);\n\treturn reachable;\n}\n```\nIn\
    \ the following modification of the above example, `reachable` checks the cache\
    \ to see whether the node has already been considered.\n\n\n```java\nprivate Set<Node>\
    \ reachableNodes = new HashSet<Node>();\n\nboolean reachable(Node n) {\n\tif (reachableNodes.contains(n))\n\
    \t\t  return true;\n\t\n\tboolean reachable;\n\tif (n == ROOT)\n\t\treachable\
    \ = true;\n\telse\n\t\treachable = reachable(n.getParent());\n\tif (reachable)\n\
    \t\treachableNodes.add(n);\n\treturn reachable;\n}\n```\n\n## References\n* Java\
    \ API Specification: [Collection](https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/util/Collection.html),\
    \ [Map](https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/util/Map.html).\n\
    * Common Weakness Enumeration: [CWE-561](https://cwe.mitre.org/data/definitions/561.html).\n"
 -
  pack: codeql/java-queries#0
  relativeQueryPath: Likely Bugs/Comparison/BitwiseSignCheck.ql
  relativeBqrsPath: codeql/java-queries/Likely Bugs/Comparison/BitwiseSignCheck.bqrs
  metadata:
    name: Sign check of bitwise operation
    description: Checking the sign of the result of a bitwise operation may yield
      unexpected results.
    kind: problem
    problem.severity: recommendation
    precision: low
    id: java/bitwise-sign-check
    tags: |-
      reliability
             correctness
  queryHelp: |
    # Sign check of bitwise operation
    Checking whether the result of a bitwise operation is greater than zero may yield unexpected results.


    ## Recommendation
    It is more robust to check whether the result of the bitwise operation is *non-zero*.


    ## Example
    In the following example, the expression assigned to variable `bad` is *not* a robust way to check that the `n`th bit of `x` is set. With the given values of `x` (all bits are set) and `n`, the expression `x & (1<<n)` has the value `-2147483648`, and the variable `bad` is assigned `false`, even though the 31st bit of `x` is, in fact, set.


    ```java
    int x = -1;
    int n = 31;

    boolean bad = (x & (1<<n)) > 0;
    ```
    In the following example, the expression assigned to variable `good` is a robust way to check that the `n`th bit of `x` is set. With the given values of `x` and `n`, the variable `good` is assigned `true`.


    ```java
    int x = -1;
    int n = 31;

    boolean good = (x & (1<<n)) != 0;
    ```

    ## References
    * Java Language Specification: [Integer Bitwise Operators &amp;, ^, and |](https://docs.oracle.com/javase/specs/jls/se11/html/jls-15.html#jls-15.22.1).
 -
  pack: codeql/java-queries#0
  relativeQueryPath: Likely Bugs/Comparison/CompareIdenticalValues.ql
  relativeBqrsPath: codeql/java-queries/Likely Bugs/Comparison/CompareIdenticalValues.bqrs
  metadata:
    name: Comparison of identical values
    description: |-
      If the same expression occurs on both sides of a comparison
                    operator, the operator is redundant, and probably indicates a mistake.
    kind: problem
    problem.severity: error
    precision: very-high
    id: java/comparison-of-identical-expressions
    tags: |-
      reliability
             correctness
             logic
  queryHelp: "# Comparison of identical values\nIf two identical expressions are compared\
    \ (that is, checked for equality or inequality), this is typically an indication\
    \ of a mistake, because the Boolean value of the comparison is always the same.\
    \ Often, it indicates that the wrong qualifier has been used on a field access.\n\
    \nAn exception applies to inequality (`!=`) and equality (`==`) tests of a floating\
    \ point variable with itself: the special floating point value `NaN` (\"not-a-number\"\
    ) is the only value that is not considered to be equal to itself. Thus, the test\
    \ `x != x` where `x` is a `float` or `double` variable is equivalent to checking\
    \ whether `x` is `NaN`, and similarly for `x == x`.\n\n\n## Recommendation\nIt\
    \ is never good practice to compare a value with itself. If you require constant\
    \ behavior, use the Boolean literals `true` and `false`, rather than encoding\
    \ them obscurely as `1 == 1` or similar.\n\nIf an inequality test (using `!=`)\
    \ of a floating point variable with itself is intentional, it should be replaced\
    \ by `Double.isNaN(...)` or `Float.isNaN(...)` for readability. Similarly, if\
    \ an equality test (using `==`) of a floating point variable with itself is intentional,\
    \ it should be replaced by `!Double.isNaN(...)` or `!Float.isNaN(...)`.\n\n\n\
    ## Example\nIn the example below, the original version of `Customer` compares\
    \ `id` with `id`, which always returns `true`. The corrected version of `Customer`\
    \ includes the missing qualifier `o` in the comparison of `id` with `o.id`.\n\n\
    \n```java\nclass Customer {\n\t...\n\tpublic boolean equals(Object o) {\n\t\t\
    if (o == null) return false;\n\t\tif (Customer.class != o.getClass()) return false;\n\
    \t\tCustomer other = (Customer)o;\n\t\tif (!name.equals(o.name)) return false;\n\
    \t\tif (id != id) return false;  // Comparison of identical values\n\t\treturn\
    \ true;\n\t}\n}\n\nclass Customer {\n\t...\n\tpublic boolean equals(Object o)\
    \ {\n\t\tif (o == null) return false;\n\t\tif (Customer.class != o.getClass())\
    \ return false;\n\t\tCustomer other = (Customer)o;\n\t\tif (!name.equals(o.name))\
    \ return false;\n\t\tif (id != o.id) return false;  // Comparison corrected\n\t\
    \treturn true;\n\t}\n}\n```\n\n## References\n* Help - Eclipse Platform: [Java\
    \ Compiler Errors/Warnings Preferences](https://help.eclipse.org/2020-12/advanced/content.jsp?topic=/org.eclipse.jdt.doc.user/reference/preferences/java/compiler/ref-preferences-errors-warnings.htm).\n\
    * Java Language Specification: [15.21.1. Numerical Equality Operators](https://docs.oracle.com/javase/specs/jls/se11/html/jls-15.html#jls-15.21.1).\n"
 -
  pack: codeql/java-queries#0
  relativeQueryPath: Likely Bugs/Comparison/CovariantCompareTo.ql
  relativeBqrsPath: codeql/java-queries/Likely Bugs/Comparison/CovariantCompareTo.bqrs
  metadata:
    name: Overloaded compareTo
    description: |-
      Defining 'Comparable.compareTo', where the parameter of 'compareTo' is not of the
                    appropriate type, overloads 'compareTo' instead of overriding it.
    kind: problem
    problem.severity: error
    precision: medium
    id: java/wrong-compareto-signature
    tags: |-
      reliability
             correctness
  queryHelp: "# Overloaded compareTo\nClasses that implement `Comparable<T>` and define\
    \ a `compareTo` method whose parameter type is not `T` *overload* the `compareTo`\
    \ method instead of *overriding* it. This may not be intended.\n\n\n## Example\n\
    In the following example, the call to `compareTo` on line 17 calls the method\
    \ defined in class `Super`, instead of the method defined in class `Sub`, because\
    \ the type of `a` and `b` is `Super`. This may not be the method that the programmer\
    \ intended.\n\n\n```java\npublic class CovariantCompareTo {\n\tstatic class Super\
    \ implements Comparable<Super> {\n\t\tpublic int compareTo(Super rhs) {\n\t\t\t\
    return -1;\n\t\t}\n\t}\n\t\n\tstatic class Sub extends Super {\n\t\tpublic int\
    \ compareTo(Sub rhs) {  // Definition of compareTo uses a different parameter\
    \ type\n\t\t\treturn 0;\n\t\t}\n\t}\n\t\n\tpublic static void main(String[] args)\
    \ {\n\t\tSuper a = new Sub();\n\t\tSuper b = new Sub();\n\t\tSystem.out.println(a.compareTo(b));\n\
    \t}\n}\n```\n\n## Recommendation\nTo *override* the `Comparable<T>.compareTo`\
    \ method, the parameter of `compareTo` must have type `T`.\n\nIn the example above,\
    \ this means that the type of the parameter of `Sub.compareTo` should be changed\
    \ to `Super`.\n\n\n## References\n* J. Bloch, *Effective Java (second edition)*,\
    \ Item 12. Addison-Wesley, 2008.\n* Java Language Specification: [Overriding (by\
    \ Instance Methods)](https://docs.oracle.com/javase/specs/jls/se11/html/jls-8.html#jls-8.4.8.1),\
    \ [Overloading](https://docs.oracle.com/javase/specs/jls/se11/html/jls-8.html#jls-8.4.9).\n\
    * The Java Tutorials: [Overriding and Hiding Methods](https://docs.oracle.com/javase/tutorial/java/IandI/override.html).\n"
 -
  pack: codeql/java-queries#0
  relativeQueryPath: Likely Bugs/Comparison/CovariantEquals.ql
  relativeBqrsPath: codeql/java-queries/Likely Bugs/Comparison/CovariantEquals.bqrs
  metadata:
    name: Overloaded equals
    description: |-
      Defining 'Object.equals', where the parameter of 'equals' is not of the
                    appropriate type, overloads 'equals' instead of overriding it.
    kind: problem
    problem.severity: error
    precision: medium
    id: java/wrong-equals-signature
    tags: |-
      reliability
             correctness
  queryHelp: |
    # Overloaded equals
    Classes that define an `equals` method whose parameter type is not `Object` *overload* the `Object.equals` method instead of *overriding* it. This may not be intended.


    ## Recommendation
    To *override* the `Object.equals` method, the parameter of the `equals` method must have type `Object`.


    ## Example
    In the following example, the definition of class `BadPoint` does not override the `Object.equals` method. This means that `p.equals(q)` resolves to the default definition of `Object.equals` and returns `false`. Class `GoodPoint` correctly overrides `Object.equals`, so that `r.equals(s)` returns `true`.


    ```java
    class BadPoint {
        int x;
        int y;

        BadPoint(int x, int y) {
            this.x = x;
            this.y = y;
        }

        // overloaded equals method -- should be avoided
        public boolean equals(BadPoint q) {
            return x == q.x && y == q.y;
        }
    }

    BadPoint p = new BadPoint(1, 2);
    Object q = new BadPoint(1, 2);
    boolean badEquals = p.equals(q); // evaluates to false

    class GoodPoint {
        int x;
        int y;

        GoodPoint(int x, int y) {
            this.x = x;
            this.y = y;
        }

        // correctly overrides Object.equals(Object)
        public boolean equals(Object obj) {
            if (obj != null && getClass() == obj.getClass()) {
                GoodPoint q = (GoodPoint)obj;
                return x == q.x && y == q.y;
            }
            return false;
        }
    }

    GoodPoint r = new GoodPoint(1, 2);
    Object s = new GoodPoint(1, 2);
    boolean goodEquals = r.equals(s); // evaluates to true

    ```

    ## References
    * J. Bloch, *Effective Java (second edition)*, Item 8. Addison-Wesley, 2008.
    * Java Language Specification: [Overriding (by Instance Methods)](https://docs.oracle.com/javase/specs/jls/se11/html/jls-8.html#jls-8.4.8.1), [Overloading](https://docs.oracle.com/javase/specs/jls/se11/html/jls-8.html#jls-8.4.9).
    * The Java Tutorials: [Overriding and Hiding Methods](https://docs.oracle.com/javase/tutorial/java/IandI/override.html).
 -
  pack: codeql/java-queries#0
  relativeQueryPath: Likely Bugs/Comparison/DefineEqualsWhenAddingFields.ql
  relativeBqrsPath: codeql/java-queries/Likely Bugs/Comparison/DefineEqualsWhenAddingFields.bqrs
  metadata:
    name: Inherited equals() in subclass with added fields
    description: |-
      If a class overrides 'Object.equals', and a subclass defines additional fields
                    to those it inherits but does not re-define 'equals', the results of 'equals'
                    may be wrong.
    kind: problem
    problem.severity: warning
    precision: low
    id: java/inherited-equals-with-added-fields
    tags: |-
      reliability
             correctness
  queryHelp: |
    # Inherited equals() in subclass with added fields
    If a class overrides the default implementation of equality defined by the `Object.equals` method, and a subclass of that class declares additional fields to the ones that it inherits, the results of `equals` may be wrong, unless that subclass also redefines `equals`.


    ## Recommendation
    See if the subclass should provide its own implementation of `equals` to take into account the additional fields that it declares.

    If the subclass cannot provide its own implementation of `equals` because the inherited `equals` method is `final`, consider replacing inheritance by composition; instead of class `B` extending class `A`, class `B` could define a field of type `A`.


    ## Example
    In the following example, rectangles `r1` and `r2` are calculated to be equal, even though they have different dimensions. This is because the class `Rectangle` does not override `Square.equals`, so it uses a test for equality that is only applicable to squares, not rectangles. (Note that, in practice, the example should also include an implementation of `hashCode`.)


    ```java
    public class DefineEqualsWhenAddingFields {
        static class Square {
            protected int width = 0;
            public Square(int width) {
                this.width = width;
            }
            @Override
            public boolean equals(Object thatO) {  // This method works only for squares.
                if(thatO != null && getClass() == thatO.getClass() ) {
                    Square that = (Square)thatO;
                    return width == that.width;
                }
                return false;
            }
        }

        static class Rectangle extends Square {
            private int height = 0;
            public Rectangle(int width, int height) {
                super(width);
                this.height = height;
            }
        }

        public static void main(String[] args) {
            Rectangle r1 = new Rectangle(4, 3);
            Rectangle r2 = new Rectangle(4, 5);
            System.out.println(r1.equals(r2));  // Outputs 'true'
        }
    }

    ```
    To get the correct result, you must override `Square.equals` in class `Rectangle`.


    ## References
    * Java API Specification: [Object.equals()](https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/lang/Object.html#equals(java.lang.Object)).
 -
  pack: codeql/java-queries#0
  relativeQueryPath: Likely Bugs/Comparison/EqualsArray.ql
  relativeBqrsPath: codeql/java-queries/Likely Bugs/Comparison/EqualsArray.bqrs
  metadata:
    name: Equals or hashCode on arrays
    description: |-
      The 'equals' and 'hashCode' methods on arrays only consider object identity, not
                    array contents, which is unlikely to be what is intended.
    kind: problem
    problem.severity: error
    precision: very-high
    id: java/equals-on-arrays
    tags: |-
      reliability
             correctness
  queryHelp: "# Equals or hashCode on arrays\nThe `equals` and `hashCode` methods\
    \ on arrays only consider object identity, not array contents, which is unlikely\
    \ to be what is intended.\n\n\n## Recommendation\nTo compare the lengths of the\
    \ arrays and the corresponding pairs of elements in the arrays, use one of the\
    \ comparison methods from `java.util.Arrays`:\n\n* The method `Arrays.equals`\
    \ performs a shallow comparison. That is, array elements are compared using `equals`.\n\
    * The method `Arrays.deepEquals` performs a deep comparison, which is appropriate\
    \ for comparisons of nested arrays.\nSimilarly, `Arrays.hashCode` and `Arrays.deepHashCode`\
    \ can be used to compute shallow and deep hash codes based on the hash codes of\
    \ individual array elements.\n\n\n## Example\nIn the following example, the two\
    \ arrays are first compared using the `Object.equals` method. Because this checks\
    \ only reference equality and the two arrays are different objects, `Object.equals`\
    \ returns `false`. The two arrays are then compared using the `Arrays.equals`\
    \ method. Because this compares the length and contents of the arrays, `Arrays.equals`\
    \ returns `true`.\n\n\n```java\npublic void arrayExample(){\n    String[] array1\
    \ = new String[]{\"a\", \"b\", \"c\"};\n    String[] array2 = new String[]{\"\
    a\", \"b\", \"c\"};\n\n    // Reference equality tested: prints 'false'\n    System.out.println(array1.equals(array2));\n\
    \    \n    // Equality of array elements tested: prints 'true'\n    System.out.println(Arrays.equals(array1,\
    \ array2));\n}\n```\n\n## References\n* Java API Specification: [Arrays.equals](https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/util/Arrays.html#equals(java.lang.Object[],java.lang.Object[])),\
    \ [Arrays.deepEquals](https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/util/Arrays.html#deepEquals(java.lang.Object[],java.lang.Object[])),\
    \ [Objects.deepEquals](https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/util/Objects.html#deepEquals(java.lang.Object,java.lang.Object)),\
    \ [Object.equals](https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/lang/Object.html#equals(java.lang.Object)),\
    \ [Arrays.hashCode](https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/util/Arrays.html#hashCode(java.lang.Object[])),\
    \ [Arrays.deepHashCode](https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/util/Arrays.html#deepHashCode(java.lang.Object[])),\
    \ [Object.hashCode](https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/lang/Object.html#hashCode()).\n"
 -
  pack: codeql/java-queries#0
  relativeQueryPath: Likely Bugs/Comparison/EqualsUsesInstanceOf.ql
  relativeBqrsPath: codeql/java-queries/Likely Bugs/Comparison/EqualsUsesInstanceOf.bqrs
  metadata:
    name: Possible inconsistency due to instanceof in equals
    description: |-
      Implementations of 'equals' that use 'instanceof'
                    to test the type of the argument and are further overridden in a subclass
                    are likely to violate the 'equals' contract.
    kind: problem
    problem.severity: warning
    precision: low
    id: java/instanceof-in-equals
    tags: |-
      reliability
             correctness
  queryHelp: |
    # Possible inconsistency due to instanceof in equals
    Implementations of `equals` that use `instanceof` to check the type of their argument are likely to lead to non-symmetric definitions of `equals`, if they are further overridden in subclasses that add fields and redefine `equals`. A definition of the `equals` method should be reflexive, symmetric, and transitive, and a violation of the `equals` contract may lead to unexpected behavior.


    ## Recommendation
    Consider using one of the following options:

    * Check the type of the argument using `getClass` instead of `instanceof`.
    * Declare the class or the `equals` method `final`. This prevents the creation of subclasses that would otherwise violate the `equals` contract.
    * Replace inheritance by composition. Instead of a class `B` extending a class `A`, class `B` can declare a field of type `A` in addition to any other fields.
    The first option has the disadvantage of violating the substitution principle of object-oriented languages, which says that an instance of a subclass of `A` can be provided whenever an instance of class `A` is required.


    ## Example
    The first option is illustrated in the following example:


    ```java
    class BadPoint {
        int x;
        int y;

        BadPoint(int x, int y) {
            this.x = x;
            this.y = y;
        }

        public boolean equals(Object o) {
            if(!(o instanceof BadPoint))
                return false;
            BadPoint q = (BadPoint)o;
            return x == q.x && y == q.y;
        }
    }

    class BadPointExt extends BadPoint {
        String s;

        BadPointExt(int x, int y, String s) {
            super(x, y);
            this.s = s;
        }

        // violates symmetry of equals contract
        public boolean equals(Object o) {
            if(!(o instanceof BadPointExt)) return false;
            BadPointExt q = (BadPointExt)o;
            return super.equals(o) && (q.s==null ? s==null : q.s.equals(s));
        }
    }

    class GoodPoint {
        int x;
        int y;

        GoodPoint(int x, int y) {
            this.x = x;
            this.y = y;
        }

        public boolean equals(Object o) {
            if (o != null && getClass() == o.getClass()) {
                GoodPoint q = (GoodPoint)o;
                return x == q.x && y == q.y;
            }
            return false;
        }
    }

    class GoodPointExt extends GoodPoint {
        String s;

        GoodPointExt(int x, int y, String s) {
            super(x, y);
            this.s = s;
        }

        public boolean equals(Object o) {
            if (o != null && getClass() == o.getClass()) {
                GoodPointExt q = (GoodPointExt)o;
                return super.equals(o) && (q.s==null ? s==null : q.s.equals(s));
            }
            return false;
        }
    }

    BadPoint p = new BadPoint(1, 2);
    BadPointExt q = new BadPointExt(1, 2, "info");

    ```
    Given the definitions in the example, `p.equals(q)` returns `true` whereas `q.equals(p)` returns `false`, which violates the symmetry requirement of the `equals` contract.

    Attempting to enforce symmetry by modifying the `BadPointExt.equals` method to ignore the field `s` when its parameter is an instance of type `BadPoint` results in violating the transitivity requirement of the `equals` contract.

    The classes `GoodPoint` and `GoodPointExt` avoid violating the `equals` contract by using `getClass` rather than `instanceof`.


    ## References
    * J. Bloch, *Effective Java (second edition)*, Items 8 and 16. Addison-Wesley, 2008.
    * Java API Specification: [Object.equals()](https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/lang/Object.html#equals(java.lang.Object)).
    * Java Language Specification: [Type Comparison Operator instanceof](https://docs.oracle.com/javase/specs/jls/se11/html/jls-15.html#jls-15.20.2).
    * Artima Developer: [How to Write an Equality Method in Java](https://www.artima.com/lejava/articles/equality.html).
    * JavaSolutions, April 2002: [Secrets of equals()](http://www.angelikalanger.com/Articles/JavaSolutions/SecretsOfEquals/Equals.html).
 -
  pack: codeql/java-queries#0
  relativeQueryPath: Likely Bugs/Comparison/HashedButNoHash.ql
  relativeBqrsPath: codeql/java-queries/Likely Bugs/Comparison/HashedButNoHash.bqrs
  metadata:
    name: Hashed value without hashCode definition
    description: |-
      Classes that define an 'equals' method but no 'hashCode' method, and whose instances
                    are stored in a hashing data structure, can lead to unexpected results.
    kind: problem
    problem.severity: error
    precision: very-high
    id: java/hashing-without-hashcode
    tags: |-
      reliability
             correctness
  queryHelp: "# Hashed value without hashCode definition\nClasses that define an `equals`\
    \ method but no `hashCode` method can lead to unexpected results if instances\
    \ of those classes are stored in a hashing data structure. Hashing data structures\
    \ expect that hash codes fulfill the contract that two objects that `equals` considers\
    \ equal should have the same hash code. This contract is likely to be violated\
    \ by such classes.\n\n\n## Recommendation\nEvery class that implements a custom\
    \ `equals` method should also provide an implementation of `hashCode`.\n\n\n##\
    \ Example\nIn the following example, class `Point` has no implementation of `hashCode`.\
    \ Calling `hashCode` on two distinct `Point` objects with the same coordinates\
    \ would probably result in different hash codes. This would violate the contract\
    \ of the `hashCode` method, in which case objects of type `Point` should not be\
    \ stored in hashing data structures.\n\n\n```java\nclass Point {\n    int x;\n\
    \    int y;\n\n    Point(int x, int y) {\n        this.x = x;\n        this.y\
    \ = y;\n    }\n\n    public boolean equals(Object o) {\n    \tif (!(o instanceof\
    \ Point)) return false;\n    \tPoint q = (Point)o;\n    \treturn x == q.x && y\
    \ == q.y;\n    }\n}\n```\nIn the modification of the above example, the implementation\
    \ of `hashCode` for class `Point` is suitable because the hash code is computed\
    \ from exactly the same fields that are considered in the `equals` method. Therefore,\
    \ the contract of the `hashCode` method is fulfilled.\n\n\n```java\nclass Point\
    \ {\n    int x;\n    int y;\n\n    Point(int x, int y) {\n        this.x = x;\n\
    \        this.y = y;\n    }\n\n    public boolean equals(Object o) {\n       \
    \ if (!(o instanceof Point)) return false;\n        Point q = (Point)o;\n    \
    \    return x == q.x && y == q.y;\n    }\n\n    // Implement hashCode so that\
    \ equivalent points (with the same values of x and y) have the\n    // same hash\
    \ code\n    public int hashCode() {\n        int hash = 7;\n        hash = 31*hash\
    \ + x;\n        hash = 31*hash + y;\n        return hash;\n    }\n}\n\n```\n\n\
    ## References\n* J. Bloch, *Effective Java (second edition)*, Item 9. Addison-Wesley,\
    \ 2008.\n* Java API Specification: [Object.equals](https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/lang/Object.html#equals(java.lang.Object)),\
    \ [Object.hashCode](https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/lang/Object.html#hashCode()).\n\
    * IBM developerWorks: [Java theory and practice: Hashing it out](https://www.ibm.com/developerworks/java/library/j-jtp05273/index.html).\n"
 -
  pack: codeql/java-queries#0
  relativeQueryPath: Likely Bugs/Comparison/IncomparableEquals.ql
  relativeBqrsPath: codeql/java-queries/Likely Bugs/Comparison/IncomparableEquals.bqrs
  metadata:
    name: Equals on incomparable types
    description: |-
      Calls of the form 'x.equals(y)', where the types of 'x' and 'y' are incomparable,
                    should always return 'false'.
    kind: problem
    problem.severity: error
    precision: very-high
    id: java/equals-on-unrelated-types
    tags: |-
      reliability
             correctness
  queryHelp: |
    # Equals on incomparable types
    Calls of the form `x.equals(y)`, where `x` and `y` have incomparable types, should always return `false` because the runtime types of `x` and `y` will be different. Two types are incomparable if they are distinct and do not have a common subtype.


    ## Recommendation
    Ensure that such comparisons use comparable types.


    ## Example
    In the following example, the call to `equals` on line 5 refers to the whole array by mistake, instead of a specific element. Therefore, "Value not found" is returned.


    ```java
    String[] anArray = new String[]{"a","b","c"}
    String valueToFind = "b";

    for(int i=0; i<anArray.length; i++){
      if(anArray.equals(valueToFind){    // anArray[i].equals(valueToFind) was intended
        return "Found value at index " + i;
      }
    }

    return "Value not found";
    ```

    ## References
    * Java API Specification: [Object.equals()](https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/lang/Object.html#equals(java.lang.Object)).
 -
  pack: codeql/java-queries#0
  relativeQueryPath: Likely Bugs/Comparison/InconsistentCompareTo.ql
  relativeBqrsPath: codeql/java-queries/Likely Bugs/Comparison/InconsistentCompareTo.bqrs
  metadata:
    name: Inconsistent compareTo
    description: |-
      If a class overrides 'compareTo' but not 'equals', it may mean that 'compareTo'
                    and 'equals' are inconsistent.
    kind: problem
    problem.severity: warning
    precision: medium
    id: java/inconsistent-compareto-and-equals
    tags: |-
      reliability
             correctness
  queryHelp: "# Inconsistent compareTo\nA class that overrides `compareTo` but not\
    \ `equals` may not implement a natural ordering that is consistent with `equals`.\n\
    \n\n## Recommendation\nAlthough this consistency is not strictly required by the\
    \ `compareTo` contract, usually both methods should be overridden to ensure that\
    \ they are consistent, that is, that `x.compareTo(y)==0` is `true` if and only\
    \ if `x.equals(y)` is `true`, for any non-null `x` and `y`.\n\n\n## Example\n\
    In the following example, the class `InconsistentCompareTo` overrides `compareTo`\
    \ but not `equals`.\n\n\n```java\npublic class InconsistentCompareTo implements\
    \ Comparable<InconsistentCompareTo> {\n\tprivate int i = 0;\n\tpublic InconsistentCompareTo(int\
    \ i) {\n\t\tthis.i = i;\n\t}\n\t\n\tpublic int compareTo(InconsistentCompareTo\
    \ rhs) {\n\t\treturn i - rhs.i;\n\t}\n}\n```\nIn the following example, the class\
    \ `InconsistentCompareToFix` overrides both `compareTo` and `equals`.\n\n\n```java\n\
    public class InconsistentCompareToFix implements Comparable<InconsistentCompareToFix>\
    \ {\n\tprivate int i = 0;\n\tpublic InconsistentCompareToFix(int i) {\n\t\tthis.i\
    \ = i;\n\t}\n\t\n\tpublic int compareTo(InconsistentCompareToFix rhs) {\n\t\t\
    return i - rhs.i;\n\t}\n\n\tpublic boolean equals(InconsistentCompareToFix rhs)\
    \ {\n\t\treturn i == rhs.i;\n\t}\n}\n```\nIf you require a natural ordering that\
    \ is inconsistent with `equals`, you should document it clearly.\n\n\n## References\n\
    * J. Bloch, *Effective Java (second edition)*, Item 12. Addison-Wesley, 2008.\n\
    * Java API Specification: [Comparable.compareTo](https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/lang/Comparable.html#compareTo(T)),\
    \ [Object.equals](https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/lang/Object.html#equals(java.lang.Object)).\n"
 -
  pack: codeql/java-queries#0
  relativeQueryPath: Likely Bugs/Comparison/InconsistentEqualsHashCode.ql
  relativeBqrsPath: codeql/java-queries/Likely Bugs/Comparison/InconsistentEqualsHashCode.bqrs
  metadata:
    name: Inconsistent equals and hashCode
    description: |-
      If a class overrides only one of 'equals' and 'hashCode', it may mean that
                    'equals' and 'hashCode' are inconsistent.
    kind: problem
    problem.severity: error
    precision: very-high
    id: java/inconsistent-equals-and-hashcode
    tags: |-
      reliability
             correctness
             external/cwe/cwe-581
  queryHelp: "# Inconsistent equals and hashCode\nA class that overrides only one\
    \ of `equals` and `hashCode` is likely to violate the contract of the `hashCode`\
    \ method. The contract requires that `hashCode` gives the same integer result\
    \ for any two equal objects. Not enforcing this property may cause unexpected\
    \ results when storing and retrieving objects of such a class in a hashing data\
    \ structure.\n\n\n## Recommendation\nUsually, both methods should be overridden\
    \ to ensure that they are consistent.\n\n\n## Example\nIn the following example,\
    \ the class `InconsistentEqualsHashCode` overrides `hashCode` but not `equals`.\n\
    \n\n```java\npublic class InconsistentEqualsHashCode {\n\tprivate int i = 0;\n\
    \tpublic InconsistentEqualsHashCode(int i) {\n\t\tthis.i = i;\n\t}\n\n\tpublic\
    \ int hashCode() {\n\t\treturn i;\n\t}\n}\n```\nIn the following example, the\
    \ class `InconsistentEqualsHashCodeFix` overrides both `hashCode` and `equals`.\n\
    \n\n```java\npublic class InconsistentEqualsHashCodeFix {\n\tprivate int i = 0;\n\
    \tpublic InconsistentEqualsHashCodeFix(int i) {\n\t\tthis.i = i;\n\t}\n\n\t@Override\n\
    \tpublic int hashCode() {\n\t\treturn i;\n\t}\n\n\t@Override\n\tpublic boolean\
    \ equals(Object obj) {\n\t\tif (obj == null)\n\t\t\treturn false;\n\t\tif (getClass()\
    \ != obj.getClass())\n\t\t\treturn false;\n\t\tInconsistentEqualsHashCodeFix that\
    \ = (InconsistentEqualsHashCodeFix) obj;\n\t\treturn this.i == that.i;\n\t}\n\
    }\n```\n\n## References\n* J. Bloch, *Effective Java (second edition)*, Item 9.\
    \ Addison-Wesley, 2008.\n* Java API Specification: [Object.equals](https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/lang/Object.html#equals(java.lang.Object)),\
    \ [Object.hashCode](https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/lang/Object.html#hashCode()).\n\
    * IBM developerWorks: [Java theory and practice: Hashing it out](https://www.ibm.com/developerworks/java/library/j-jtp05273/index.html).\n\
    * Help - Eclipse Platform: [Java Compiler Errors/Warnings Preferences](https://help.eclipse.org/2020-12/advanced/content.jsp?topic=/org.eclipse.jdt.doc.user/reference/preferences/java/compiler/ref-preferences-errors-warnings.htm).\n\
    * Common Weakness Enumeration: [CWE-581](https://cwe.mitre.org/data/definitions/581.html).\n"
 -
  pack: codeql/java-queries#0
  relativeQueryPath: Likely Bugs/Comparison/MissingInstanceofInEquals.ql
  relativeBqrsPath: codeql/java-queries/Likely Bugs/Comparison/MissingInstanceofInEquals.bqrs
  metadata:
    name: Equals method does not inspect argument type
    description: |-
      An implementation of 'equals' that does not check the type
                    of its argument may lead to failing casts.
    kind: problem
    problem.severity: error
    precision: high
    id: java/unchecked-cast-in-equals
    tags: |-
      reliability
             correctness
  queryHelp: "# Equals method does not inspect argument type\nAn implementation of\
    \ `equals` must be able to handle an argument of any type, to avoid failing casts.\
    \ Therefore, the implementation should inspect the type of its argument to see\
    \ if the argument can be safely cast to the class in which the `equals` method\
    \ is declared.\n\n\n## Recommendation\nUsually, an implementation of `equals`\
    \ should check the type of its argument using `instanceof`, following the general\
    \ pattern below.\n\n\n```java\nclass A {\n    // ...\n    public final boolean\
    \ equals(Object obj) {\n        if (!(obj instanceof A)) {\n        \treturn false;\n\
    \        }\n        A a = (A)obj;\n        // ...further checks...\n    }\n  \
    \  // ...\n}\n```\nUsing `instanceof` in this way has the added benefit that it\
    \ includes a guard against null pointer exceptions: if `obj` is `null`, the check\
    \ fails and `false` is returned. Therefore, after the check, it is guaranteed\
    \ that `obj` is not `null`, and its fields can be safely accessed.\n\nWhenever\
    \ you use `instanceof` to check the type of the argument, you should declare the\
    \ `equals` method `final`, so that subclasses are unable to cause a violation\
    \ of the symmetry requirement of the `equals` contract by further overriding `equals`.\n\
    \nIf you want subclasses to redefine the notion of equality by overriding `equals`,\
    \ use `getClass` instead of `instanceof` to check the type of the argument. However,\
    \ note that the use of `getClass` prevents any equality relationship between instances\
    \ of a class and its subclasses, even when no additional state is added in a subclass.\n\
    \n\n## References\n* J. Bloch, *Effective Java (second edition)*, Item 8. Addison-Wesley,\
    \ 2008.\n* Java API Specification: [Object.equals()](https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/lang/Object.html#equals(java.lang.Object)).\n\
    * Java Language Specification: [Type Comparison Operator instanceof](https://docs.oracle.com/javase/specs/jls/se11/html/jls-15.html#jls-15.20.2).\n"
 -
  pack: codeql/java-queries#0
  relativeQueryPath: Likely Bugs/Comparison/NoAssignInBooleanExprs.ql
  relativeBqrsPath: codeql/java-queries/Likely Bugs/Comparison/NoAssignInBooleanExprs.bqrs
  metadata:
    name: Assignment in Boolean expression
    description: |-
      Assignments in Boolean conditions can be confused with equality tests and make the
                    condition more difficult to understand.
    kind: problem
    problem.severity: warning
    precision: low
    id: java/assignment-in-boolean-expression
    tags: |-
      reliability
             readability
             external/cwe/cwe-481
  queryHelp: |
    # Assignment in Boolean expression
    The assignment operator (`=`) can easily be confused with the equality operator (`==`), and can make a Boolean expression more difficult to understand. Consequently, assignments in Boolean expressions should be avoided.

    Some useful idioms are an exception to this rule, such as checking that some bytes have been read from an input-stream, as shown in the `readConfiguration` method in the example below. More precisely, an assignment is allowed in a Boolean expression if the result of the assignment is compared to another value.


    ## Recommendation
    Consider structuring the condition so that the side-effects are moved outside of the condition, possibly splitting the condition into several separate tests.


    ## Example
    In the following example, consider the rather confusing assignment to `restart` in the `notify` method. The assignment should be performed outside of the condition instead.


    ```java
    public class ScreenView
    {
        private static int BUF_SIZE = 1024;
        private Screen screen;

        public void notify(Change change) {
            boolean restart = false;
            if (change.equals(Change.MOVE)
                || v.equals(Change.REPAINT)
                || (restart = v.equals(Change.RESTART))  // AVOID: Confusing assignment in condition
                || v.equals(Change.FLIP))
            {
                if (restart)
                    WindowManager.restart();
                screen.update();
            }
        }

        // ...

        public void readConfiguration(InputStream config) {
            byte[] buf = new byte[BUF_SIZE];
            int read;
            while ((read = config.read(buf)) > 0) {  // OK: Assignment whose result is compared to
                                                     // another value
                // ...
            }
            // ...
        }
    }

    ```

    ## References
    * Help - Eclipse Platform: [Java Compiler Errors/Warnings Preferences](https://help.eclipse.org/2020-12/advanced/content.jsp?topic=/org.eclipse.jdt.doc.user/reference/preferences/java/compiler/ref-preferences-errors-warnings.htm).
    * Java Language Specification: [15.21 Equality Operators](https://docs.oracle.com/javase/specs/jls/se11/html/jls-15.html#jls-15.21), [15.26 Assignment Operators](https://docs.oracle.com/javase/specs/jls/se11/html/jls-15.html#jls-15.26).
    * Common Weakness Enumeration: [CWE-481](https://cwe.mitre.org/data/definitions/481.html).
 -
  pack: codeql/java-queries#0
  relativeQueryPath: Likely Bugs/Comparison/NoComparisonOnFloats.ql
  relativeBqrsPath: codeql/java-queries/Likely Bugs/Comparison/NoComparisonOnFloats.bqrs
  metadata:
    name: Equality test on floating point values
    description: Equality tests on floating point values may lead to unexpected results.
    kind: problem
    problem.severity: warning
    precision: low
    id: java/equality-test-on-floating-point
    tags: |-
      reliability
             correctness
  queryHelp: |
    # Equality test on floating point values
    Equality tests on floating point values may lead to unexpected results because of arithmetic imprecision. For example, the expression `23.42f==23.42` evaluates to `false`.


    ## Recommendation
    Instead of testing for *exact equality* between floating point values, check that the difference between the values is within an appropriate error margin.

    Alternatively, if you do not want any inaccuracy when testing for equality, use one of the following instead of floating point values:

    * `BigDecimal` class. This can store decimal values with higher precision.
    * `long` type. Because this is an integer type, you must convert any decimal values to whole values. For example, represent $1.43 as 143 cents.

    ## Example
    In the following example, `(0.1 + 0.2) == 0.3` evaluates to `false`, even though you would expect it to evaluate to `true`. This is because of the imprecision of floating point data types.


    ```java
    class NoComparisonOnFloats
    {
        public static void main(String[] args)
        {
            System.out.println((0.1 + 0.2) == 0.3);
        }
    }
    ```
    In the following improved example, the test for equality is performed by calculating the difference between the two values, and checking if the difference is within the error margin, `EPSILON`.


    ```java
    class NoComparisonOnFloats
    {
        public static void main(String[] args)
        {
            final double EPSILON = 0.001;
            System.out.println(Math.abs((0.1 + 0.2) - 0.3) < EPSILON);
        }
    }
    ```

    ## References
    * J. Bloch, *Effective Java (second edition)*, Item 48. Addison-Wesley, 2008.
    * Numerical Computation Guide: [What Every Computer Scientist Should Know About Floating-Point Arithmetic](https://docs.oracle.com/cd/E19957-01/806-3568/ncg_goldberg.html).
 -
  pack: codeql/java-queries#0
  relativeQueryPath: Likely Bugs/Comparison/ObjectComparison.ql
  relativeBqrsPath: codeql/java-queries/Likely Bugs/Comparison/ObjectComparison.bqrs
  metadata:
    name: Reference equality test on java.lang.Object
    description: |-
      Reference comparisons (== or !=) with operands where the static type is 'Object' may
                    not work as intended.
    kind: problem
    problem.severity: warning
    precision: low
    id: java/reference-equality-with-object
    tags: |-
      reliability
             correctness
             external/cwe/cwe-595
  queryHelp: |
    # Reference equality test on java.lang.Object
    Reference comparisons (`==` or `!=`) with operands where the static type is `Object` may not work as intended. Reference comparisons check if two objects are *identical*. To check if two objects are *equivalent*, use `Object.equals` instead.


    ## Recommendation
    Use `Object.equals` instead of `==` or `!=`, and override the default behavior of the method in a subclass, so that it uses the appropriate notion of equality.


    ## References
    * Java API Specification: [Object.equals()](https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/lang/Object.html#equals(java.lang.Object)).
    * Common Weakness Enumeration: [CWE-595](https://cwe.mitre.org/data/definitions/595.html).
 -
  pack: codeql/java-queries#0
  relativeQueryPath: Likely Bugs/Comparison/RefEqBoxed.ql
  relativeBqrsPath: codeql/java-queries/Likely Bugs/Comparison/RefEqBoxed.bqrs
  metadata:
    name: Reference equality test of boxed types
    description: |-
      Comparing two boxed primitive values using the == or != operator
                    compares object identity, which may not be intended.
    kind: problem
    problem.severity: error
    precision: very-high
    id: java/reference-equality-of-boxed-types
    tags: |-
      reliability
             correctness
             external/cwe/cwe-595
  queryHelp: "# Reference equality test of boxed types\nComparing two boxed primitive\
    \ values using `==` or `!=` compares object identity, which may not be intended.\n\
    \n\n## Recommendation\nUsually, you should compare non-primitive objects, for\
    \ example boxed primitive values, by using their `equals` methods.\n\n\n## Example\n\
    With the following definition, the method call `refEq(new Integer(2), new Integer(2))`\
    \ returns `false` because the objects are not identical.\n\n\n```java\nboolean\
    \ refEq(Integer i, Integer j) {\n\treturn i == j;\n}\n```\nWith the following\
    \ definition, the method call `realEq(new Integer(2), new Integer(2))` returns\
    \ `true` because the objects contain equal values.\n\n\n```java\nboolean realEq(Integer\
    \ i, Integer j) {\n\treturn i.equals(j);\n}\n```\n\n## References\n* J. Bloch\
    \ and N. Gafter, *Java Puzzlers: Traps, Pitfalls, and Corner Cases*, Puzzle 32.\
    \ Addison-Wesley, 2005.\n* Java API Specification: [Object.equals()](https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/lang/Object.html#equals(java.lang.Object)),\
    \ [Integer.equals()](https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/lang/Integer.html#equals(java.lang.Object)).\n\
    * Common Weakness Enumeration: [CWE-595](https://cwe.mitre.org/data/definitions/595.html).\n"
 -
  pack: codeql/java-queries#0
  relativeQueryPath: Likely Bugs/Comparison/StringComparison.ql
  relativeBqrsPath: codeql/java-queries/Likely Bugs/Comparison/StringComparison.bqrs
  metadata:
    name: Reference equality test on strings
    description: |-
      Comparing two strings using the == or != operator
                    compares object identity, which may not be intended.
    kind: problem
    problem.severity: warning
    precision: medium
    id: java/reference-equality-on-strings
    tags: |-
      reliability
             external/cwe/cwe-597
  queryHelp: "# Reference equality test on strings\nComparing two `String` objects\
    \ using `==` or `!=` compares object identity, which may not be intended. The\
    \ same sequence of characters can be represented by two distinct `String` objects.\n\
    \n\n## Recommendation\nTo see if two `String` objects represent the same sequence\
    \ of characters, you should usually compare the objects by using their `equals`\
    \ methods.\n\n\n## Example\nWith the following definition, `headerStyle` is compared\
    \ to the empty string using `==`. This comparison can yield `false` even if `headerStyle`\
    \ is the empty string, because it compares the identity of the two string objects\
    \ rather than their contents. For example, if `headerStyle` was initialized by\
    \ an XML parser or a JSON parser, then it might have been created with code like\
    \ `String.valueOf(buf,start,len)`. Such code will produce a new string object\
    \ every time it is called.\n\n\n```java\nvoid printHeader(String headerStyle)\
    \ {\n\tif (headerStyle == null || headerStyle == \"\") {\n\t\t// No header\n\t\
    \treturn;\n\t}\n\t// ... print the header\n}\n\n```\nWith the following definition,\
    \ `headerStyle` is tested using the `equals` method. This version will reliably\
    \ detect whenever `headerStyle` is the empty string.\n\n\n```java\nvoid printHeader(String\
    \ headerStyle) {\n\tif (headerStyle == null || headerStyle.equals(\"\")) {\n\t\
    \t// No header\n\t\treturn;\n\t}\n\t// ... print the header\n}\n\n```\n\n## References\n\
    * Java API Specification: [String.equals()](https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/lang/String.html#equals(java.lang.Object)),\
    \ [String.intern()](https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/lang/String.html#intern()).\n\
    * Java Language Specification: [15.21.3 Reference Equality Operators == and !=](https://docs.oracle.com/javase/specs/jls/se11/html/jls-15.html#jls-15.21.3),\
    \ [3.10.5 String Literals ](https://docs.oracle.com/javase/specs/jls/se11/html/jls-3.html#jls-3.10.5),\
    \ [15.28 Constant Expressions](https://docs.oracle.com/javase/specs/jls/se11/html/jls-15.html#jls-15.28).\n\
    * Common Weakness Enumeration: [CWE-597](https://cwe.mitre.org/data/definitions/597.html).\n"
 -
  pack: codeql/java-queries#0
  relativeQueryPath: Likely Bugs/Comparison/UselessComparisonTest.ql
  relativeBqrsPath: codeql/java-queries/Likely Bugs/Comparison/UselessComparisonTest.bqrs
  metadata:
    name: Useless comparison test
    description: |-
      A comparison operation that always evaluates to true or always
                    evaluates to false may indicate faulty logic and may result in
                    dead code.
    kind: problem
    problem.severity: warning
    precision: very-high
    id: java/constant-comparison
    tags: |-
      correctness
             logic
             external/cwe/cwe-570
             external/cwe/cwe-571
  queryHelp: "# Useless comparison test\nThe result of certain comparison tests can\
    \ sometimes be inferred from their context and the results of other comparisons.\
    \ This can be an indication of faulty logic and may result in dead code or infinite\
    \ loops if, for example, a loop condition never changes its value.\n\n\n## Recommendation\n\
    Inspect the code to check whether the logic is correct, and consider simplifying\
    \ the logical expression.\n\n\n## Example\nIn the following example the final\
    \ test on `x` will always be `true`, and thus the condition is redundant and potentially\
    \ wrong. If the \"do more stuff\" part is intended to always execute after the\
    \ loop then the condition should be removed to make this clear.\n\n\n```java\n\
    void method(int x) {\n\twhile(x >= 0) {\n\t\t// do stuff\n\t\tx--;\n\t}\n\tif\
    \ (x < 0) { // BAD: always true\n\t\t// do more stuff\n\t}\n}\n```\n\n## References\n\
    * Java Language Specification: [The if Statement](https://docs.oracle.com/javase/specs/jls/se11/html/jls-14.html#jls-14.9).\n\
    * Common Weakness Enumeration: [CWE-570](https://cwe.mitre.org/data/definitions/570.html).\n\
    * Common Weakness Enumeration: [CWE-571](https://cwe.mitre.org/data/definitions/571.html).\n"
 -
  pack: codeql/java-queries#0
  relativeQueryPath: Likely Bugs/Comparison/WrongNanComparison.ql
  relativeBqrsPath: codeql/java-queries/Likely Bugs/Comparison/WrongNanComparison.bqrs
  metadata:
    name: Wrong NaN comparison
    description: |-
      A comparison with 'NaN' using '==' or '!=' will always yield the same result
                    and is unlikely to be intended.
    kind: problem
    problem.severity: error
    precision: very-high
    id: java/comparison-with-nan
    tags: correctness
  queryHelp: |
    # Wrong NaN comparison
    The special floating-point number `NaN` is defined to be different from all other floating-point numbers, including itself, when compared using the equality operators, `==` and `!=`.


    ## Recommendation
    To check whether a variable `x` is `NaN` use the method `isNaN` that is defined on both `java.lang.Float` and `java.lang.Double`.


    ## Example
    The expression `x == Double.NaN` is always false. This expression should be replaced by `Double.isNaN(x)`, which accurately identifies whether `x` is equal to `Double.NaN`.


    ## References
    * Java Language Specification: [Numerical Equality Operators == and !=](https://docs.oracle.com/javase/specs/jls/se11/html/jls-15.html#jls-15.21.1).
 -
  pack: codeql/java-queries#0
  relativeQueryPath: Likely Bugs/Concurrency/BusyWait.ql
  relativeBqrsPath: codeql/java-queries/Likely Bugs/Concurrency/BusyWait.bqrs
  metadata:
    name: Busy wait
    description: |-
      Calling 'Thread.sleep' to control thread interaction is
                    less effective than waiting for a notification and may also
                    result in race conditions. Merely synchronizing over shared
                    variables in a loop to control thread interaction
                    may waste system resources and cause performance problems.
    kind: problem
    problem.severity: warning
    precision: low
    id: java/busy-wait
    tags: |-
      reliability
             correctness
             concurrency
  queryHelp: |
    # Busy wait
    Trying to control thread interaction by periodically calling `Thread.sleep` within a loop while waiting for a condition to be satisfied is less effective than waiting for a notification. This is because the waiting thread may either sleep for an unnecessarily long time or wake up too frequently. This approach may also result in race conditions and, therefore, incorrect code.

    Trying to control thread interaction by repeatedly checking a synchronized data structure without calling `Thread.sleep` or waiting for a notification may waste a lot of system resources and cause noticeable performance problems.


    ## Recommendation
    See if communication between threads can be improved by using either of the following solutions:

    * The `java.util.concurrent` library, preferably
    * The `Object.wait` and `Object.notifyAll` methods
    If following one of these recommendations is not feasible, ensure that race conditions cannot occur and precise timing is not required for program correctness.


    ## Example
    In the following example, the `Receiver` thread sleeps for an unnecessarily long time (up to five seconds) until it has received the message.


    ```java
    class Message {
        public String text = "";
    }

    class Receiver implements Runnable {
        private Message message;
        public Receiver(Message msg) {
            this.message = msg;
        }
        public void run() {
            while(message.text.isEmpty()) {
                try {
                    Thread.sleep(5000);  // Sleep while waiting for condition to be satisfied
                } catch (InterruptedException e) { }
            }
            System.out.println("Message Received at " + (System.currentTimeMillis()/1000));
            System.out.println(message.text);
        }
    }

    class Sender implements Runnable {
        private Message message;
        public Sender(Message msg) {
            this.message = msg;
        }
        public void run() {
            System.out.println("Message sent at " + (System.currentTimeMillis()/1000));
            message.text = "Hello World";
        }
    }

    public class BusyWait {
        public static void main(String[] args) {
            Message msg = new Message();
            new Thread(new Receiver(msg)).start();
            new Thread(new Sender(msg)).start();
        }
    }

    ```
    In the following modification of the above example, the `Receiver` thread uses the recommended approach of waiting for a notification that the message has been sent. This means that the thread can respond immediately instead of sleeping.


    ```java
    class Message {
        public String text = "";
    }

    class Receiver implements Runnable {
        private Message message;
        public Receiver(Message msg) {
            this.message = msg;
        }
        public void run() {
            synchronized(message) {
                while(message.text.isEmpty()) {
                    try {
                        message.wait();  // Wait for a notification
                    } catch (InterruptedException e) { }
                }
            }
            System.out.println("Message Received at " + (System.currentTimeMillis()/1000));
            System.out.println(message.text);
        }
    }

    class Sender implements Runnable {
        private Message message;
        public Sender(Message msg) {
            this.message = msg;
        }
        public void run() {
            System.out.println("Message sent at " + (System.currentTimeMillis()/1000));
            synchronized(message) {
                message.text = "Hello World";
                message.notifyAll();  // Send notification
            }
        }
    }

    public class BusyWait {
        public static void main(String[] args) {
            Message msg = new Message();
            new Thread(new Receiver(msg)).start();
            new Thread(new Sender(msg)).start();
        }
    }

    ```

    ## References
    * J. Bloch, *Effective Java (second edition)*, Item 72. Addison-Wesley, 2008.
    * Java API Specification: [Object.wait()](https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/lang/Object.html#wait()), [Object.notifyAll()](https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/lang/Object.html#notifyAll()), [java.util.concurrent](https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/util/concurrent/package-summary.html).
    * The Java Tutorials: [Guarded Blocks](https://docs.oracle.com/javase/tutorial/essential/concurrency/guardmeth.html), [High Level Concurrency Objects](https://docs.oracle.com/javase/tutorial/essential/concurrency/highlevel.html).
 -
  pack: codeql/java-queries#0
  relativeQueryPath: Likely Bugs/Concurrency/CallsToConditionWait.ql
  relativeBqrsPath: codeql/java-queries/Likely Bugs/Concurrency/CallsToConditionWait.bqrs
  metadata:
    name: Wait on condition
    description: |-
      Calling 'wait' on a 'Condition' interface may result in unexpected behavior and is
                    probably a typographical error.
    kind: problem
    problem.severity: error
    precision: medium
    id: java/wait-on-condition-interface
    tags: |-
      reliability
             correctness
             concurrency
             external/cwe/cwe-662
  queryHelp: |
    # Wait on condition
    Calling `wait` on an object of type `java.util.concurrent.locks.Condition` may result in unexpected behavior because `wait` is a method of the `Object` class, not the `Condition` interface itself. Such a call is probably a typographical error: typing "wait" instead of "await".


    ## Recommendation
    Instead of `Object.wait`, use one of the `Condition.await` methods.


    ## References
    * Java API Specification: [java.util.concurrent.Condition](https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/util/concurrent/locks/Condition.html).
    * Common Weakness Enumeration: [CWE-662](https://cwe.mitre.org/data/definitions/662.html).
 -
  pack: codeql/java-queries#0
  relativeQueryPath: Likely Bugs/Concurrency/CallsToRunnableRun.ql
  relativeBqrsPath: codeql/java-queries/Likely Bugs/Concurrency/CallsToRunnableRun.bqrs
  metadata:
    name: Direct call to a run() method
    description: |-
      Directly calling a 'Thread' object's 'run' method does not start a separate thread
                    but executes the method within the current thread.
    kind: problem
    problem.severity: recommendation
    precision: high
    id: java/call-to-thread-run
    tags: |-
      reliability
             correctness
             concurrency
             external/cwe/cwe-572
  queryHelp: "# Direct call to a run() method\nA direct call of a `Thread` object's\
    \ `run` method does not start a separate thread. The method is executed within\
    \ the current thread. This is an unusual use because `Thread.run()` is normally\
    \ intended to be called from within a separate thread.\n\n\n## Recommendation\n\
    To execute `Runnable.run` from within a separate thread, do one of the following:\n\
    \n* Construct a `Thread` object using the `Runnable` object, and call `start`\
    \ on the `Thread` object.\n* Define a subclass of a `Thread` object, and override\
    \ the definition of its `run` method. Then construct an instance of this subclass\
    \ and call `start` on that instance directly.\n\n## Example\nIn the following\
    \ example, the main thread, `ThreadDemo`, calls the child thread, `NewThread`,\
    \ using `run`. This causes the child thread to run to completion before the rest\
    \ of the main thread is executed, so that \"Child thread activity\" is printed\
    \ before \"Main thread activity\".\n\n\n```java\npublic class ThreadDemo {\n \
    \   public static void main(String args[]) {\n        NewThread runnable = new\
    \ NewThread();\n\n        runnable.run();    // Call to 'run' does not start a\
    \ separate thread\n\n        System.out.println(\"Main thread activity.\");\n\
    \    }\n}\n\nclass NewThread extends Thread {\n    public void run() {\n     \
    \   try {\n            Thread.sleep(10000);\n        }\n        catch (InterruptedException\
    \ e) {\n            System.out.println(\"Child interrupted.\");\n        }\n \
    \       System.out.println(\"Child thread activity.\");\n    }\n}\n```\nTo enable\
    \ the two threads to run concurrently, create the child thread and call `start`,\
    \ as shown below. This causes the main thread to continue while the child thread\
    \ is waiting, so that \"Main thread activity\" is printed before \"Child thread\
    \ activity\".\n\n\n```java\npublic class ThreadDemo {\n    public static void\
    \ main(String args[]) {\n    \tNewThread runnable = new NewThread();\n    \t\n\
    \        runnable.start();                                         // Call 'start'\
    \ method\n        \n        System.out.println(\"Main thread activity.\");\n \
    \   }\n}\n```\n\n## References\n* The Java Tutorials: [Defining and Starting a\
    \ Thread](https://docs.oracle.com/javase/tutorial/essential/concurrency/runthread.html).\n\
    * Common Weakness Enumeration: [CWE-572](https://cwe.mitre.org/data/definitions/572.html).\n"
 -
  pack: codeql/java-queries#0
  relativeQueryPath: Likely Bugs/Concurrency/DateFormatThreadUnsafe.ql
  relativeBqrsPath: codeql/java-queries/Likely Bugs/Concurrency/DateFormatThreadUnsafe.bqrs
  metadata:
    name: Thread-unsafe use of DateFormat
    description: |-
      Static fields of type 'DateFormat' (or its descendants) should be avoided
                    because the class 'DateFormat' is not thread-safe.
    kind: problem
    problem.severity: warning
    precision: medium
    id: java/thread-unsafe-dateformat
    tags: |-
      reliability
             correctness
             concurrency
  queryHelp: "# Thread-unsafe use of DateFormat\nStatic fields of type `java.text.DateFormat`\
    \ or its descendants should be avoided because the class `DateFormat` is not thread-safe.\n\
    \n\n## Recommendation\nUse instance fields instead and synchronize access where\
    \ necessary.\n\n\n## Example\nIn the following example, `DateFormattingThread`\
    \ declares a static field `dateF` of type `DateFormat`. When instances of `DateFormattingThread`\
    \ are created and run by `DateFormatThreadUnsafe`, erroneous results are output\
    \ because `dateF` is shared by all instances of `DateFormattingThread`.\n\n\n\
    ```java\nclass DateFormattingThread implements Runnable {\n    public static DateFormat\
    \ dateF = new SimpleDateFormat(\"yyyyMMdd\");  // Static field declared\n\n  \
    \  public void run() {\n        for(int i=0; i < 10; i++){\n            try {\n\
    \                Date d = dateF.parse(\"20121221\");\n                System.out.println(d);\n\
    \            } catch (ParseException e) { }\n        }\n    }\n}\n\npublic class\
    \ DateFormatThreadUnsafe {\n    \n    public static void main(String[] args) {\n\
    \        for(int i=0; i<100; i++){\n            new Thread(new DateFormattingThread()).start();\n\
    \        }\n    }\n\n}\n```\nIn the following modification of the above example,\
    \ `DateFormattingThread` declares an *instance* field `dateF` of type `DateFormat`.\
    \ When instances of `DateFormattingThread` are created and run by `DateFormatThreadUnsafeFix`,\
    \ correct results are output because there is a separate instance of `dateF` for\
    \ each instance of `DateFormattingThread`.\n\n\n```java\nclass DateFormattingThread\
    \ implements Runnable {\n    private DateFormat dateF = new SimpleDateFormat(\"\
    yyyyMMdd\");  // Instance field declared\n\n    public void run() {\n        for(int\
    \ i=0; i < 10; i++){\n            try {\n                Date d = dateF.parse(\"\
    20121221\");\n                System.out.println(d);\n            } catch (ParseException\
    \ e) { }\n        }\n    }\n}\n\npublic class DateFormatThreadUnsafeFix {\n  \
    \  \n    public static void main(String[] args) {\n        for(int i=0; i<100;\
    \ i++){\n            new Thread(new DateFormattingThread()).start();\n       \
    \ }\n    }\n\n}\n```\n\n## References\n* Java API Specification: [java.text.DateFormat\
    \ synchronization](https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/text/DateFormat.html#synchronization).\n"
 -
  pack: codeql/java-queries#0
  relativeQueryPath: Likely Bugs/Concurrency/DoubleCheckedLocking.ql
  relativeBqrsPath: codeql/java-queries/Likely Bugs/Concurrency/DoubleCheckedLocking.bqrs
  metadata:
    name: Double-checked locking is not thread-safe
    description: |-
      A repeated check on a non-volatile field is not thread-safe, and
                    could result in unexpected behavior.
    kind: problem
    problem.severity: error
    precision: high
    id: java/unsafe-double-checked-locking
    tags: |-
      reliability
             correctness
             concurrency
             external/cwe/cwe-609
  queryHelp: |
    # Double-checked locking is not thread-safe
    Double-checked locking is a common pattern for lazy initialization of a field accessed by multiple threads. Depending on the memory model of the underlying runtime, it can, however, be quite difficult to implement correctly, since reorderings performed by compiler, runtime, or CPU might expose un-initialized or half-way initialized objects to other threads. Java has since version 5 improved its memory model to support double-checked locking if the underlying field is marked `volatile` and if all initialization happens before the volatile write.


    ## Recommendation
    First, it should be considered whether the getter that performs the lazy initialization is performance critical. If not, a much simpler solution is to completely avoid double-checked locking and simply mark the entire getter as `synchronized`. This is much easier to get right and guards against hard-to-find concurrency bugs.

    If double-checked locking is used, it is important that the underlying field is `volatile` and that the update to the field is the last thing that happens in the synchronized region, that is, all initialization must be done before the field is assigned. Furthermore, the Java version must be 5 or newer. Reading a `volatile` field has a slight overhead, so it is also useful to use a local variable to minimize the number of volatile reads.


    ## Example
    The following code lazily initializes `f` to `new MyObject()`.


    ```java
    private Object lock = new Object();
    private MyObject f = null;

    public MyObject getMyObject() {
      if (f == null) {
        synchronized(lock) {
          if (f == null) {
            f = new MyObject(); // BAD
          }
        }
      }
      return f;
    }

    ```
    This code is not thread-safe as another thread might see the assignment to `f` before the constructor finishes evaluating, for example if the compiler inlines the memory allocation and the constructor and reorders the assignment to `f` to occur just after the memory allocation.

    Another example that also is not thread-safe, even when `volatile` is used, is if additional initialization happens after the assignment to `f`, since then other threads may access the constructed object before it is fully initialized, even without any reorderings by the compiler or runtime.


    ```java
    private Object lock = new Object();
    private volatile MyObject f = null;

    public MyObject getMyObject() {
      if (f == null) {
        synchronized(lock) {
          if (f == null) {
            f = new MyObject();
            f.init(); // BAD
          }
        }
      }
      return f;
    }

    ```
    The code above should be rewritten to both use `volatile` and finish all initialization before `f` is updated. Additionally, a local variable can be used to avoid reading the field more times than necessary.


    ```java
    private Object lock = new Object();
    private volatile MyObject f = null;

    public MyObject getMyObject() {
      MyObject result = f;
      if (result == null) {
        synchronized(lock) {
          result = f;
          if (result == null) {
            result = new MyObject();
            result.init();
            f = result; // GOOD
          }
        }
      }
      return result;
    }

    ```
    As a final note, it is possible to use double-checked locking correctly without `volatile` if the object you construct is immutable (that is, the object declares all fields as `final`), and the double-checked field is read exactly once outside the synchronized block.

    Given that all fields in `MyImmutableObject` are declared `final` then the following example is protected against exposing uninitialized fields to another thread. However, since there are two reads of `f` without synchronization, it is possible that these are reordered, which means that this method can return `null`.


    ```java
    private Object lock = new Object();
    private MyImmutableObject f = null;

    public MyImmutableObject getMyImmutableObject() {
      if (f == null) {
        synchronized(lock) {
          if (f == null) {
            f = new MyImmutableObject();
          }
        }
      }
      return f; // BAD
    }

    ```
    In this case, using a local variable to minimize the number of field reads is no longer a performance improvement, but rather a crucial detail that is necessary for correctness.


    ## References
    * [The "Double-Checked Locking is Broken" Declaration](https://www.cs.umd.edu/~pugh/java/memoryModel/DoubleCheckedLocking.html).
    * Java Language Specification: [17.4. Memory Model](https://docs.oracle.com/javase/specs/jls/se11/html/jls-17.html#jls-17.4).
    * Wikipedia: [Double-checked locking](https://en.wikipedia.org/wiki/Double-checked_locking).
    * Aleksey Shipilv: [Safe Publication and Safe Initialization in Java](https://shipilev.net/blog/2014/safe-public-construction/).
    * Aleksey Shipilv: [Close Encounters of The Java Memory Model Kind](https://shipilev.net/blog/2016/close-encounters-of-jmm-kind/).
    * Common Weakness Enumeration: [CWE-609](https://cwe.mitre.org/data/definitions/609.html).
 -
  pack: codeql/java-queries#0
  relativeQueryPath: Likely Bugs/Concurrency/DoubleCheckedLockingWithInitRace.ql
  relativeBqrsPath: codeql/java-queries/Likely Bugs/Concurrency/DoubleCheckedLockingWithInitRace.bqrs
  metadata:
    name: Race condition in double-checked locking object initialization
    description: |-
      Performing additional initialization on an object after
                    assignment to a shared variable guarded by double-checked
                    locking is not thread-safe, and could result in unexpected
                    behavior.
    kind: problem
    problem.severity: warning
    precision: high
    id: java/unsafe-double-checked-locking-init-order
    tags: |-
      reliability
             correctness
             concurrency
             external/cwe/cwe-609
  queryHelp: |
    # Race condition in double-checked locking object initialization
    Double-checked locking is a common pattern for lazy initialization of a field accessed by multiple threads. Depending on the memory model of the underlying runtime, it can, however, be quite difficult to implement correctly, since reorderings performed by compiler, runtime, or CPU might expose un-initialized or half-way initialized objects to other threads. Java has since version 5 improved its memory model to support double-checked locking if the underlying field is marked `volatile` and if all initialization happens before the volatile write.


    ## Recommendation
    First, it should be considered whether the getter that performs the lazy initialization is performance critical. If not, a much simpler solution is to completely avoid double-checked locking and simply mark the entire getter as `synchronized`. This is much easier to get right and guards against hard-to-find concurrency bugs.

    If double-checked locking is used, it is important that the underlying field is `volatile` and that the update to the field is the last thing that happens in the synchronized region, that is, all initialization must be done before the field is assigned. Furthermore, the Java version must be 5 or newer. Reading a `volatile` field has a slight overhead, so it is also useful to use a local variable to minimize the number of volatile reads.


    ## Example
    The following code lazily initializes `f` to `new MyObject()`.


    ```java
    private Object lock = new Object();
    private MyObject f = null;

    public MyObject getMyObject() {
      if (f == null) {
        synchronized(lock) {
          if (f == null) {
            f = new MyObject(); // BAD
          }
        }
      }
      return f;
    }

    ```
    This code is not thread-safe as another thread might see the assignment to `f` before the constructor finishes evaluating, for example if the compiler inlines the memory allocation and the constructor and reorders the assignment to `f` to occur just after the memory allocation.

    Another example that also is not thread-safe, even when `volatile` is used, is if additional initialization happens after the assignment to `f`, since then other threads may access the constructed object before it is fully initialized, even without any reorderings by the compiler or runtime.


    ```java
    private Object lock = new Object();
    private volatile MyObject f = null;

    public MyObject getMyObject() {
      if (f == null) {
        synchronized(lock) {
          if (f == null) {
            f = new MyObject();
            f.init(); // BAD
          }
        }
      }
      return f;
    }

    ```
    The code above should be rewritten to both use `volatile` and finish all initialization before `f` is updated. Additionally, a local variable can be used to avoid reading the field more times than necessary.


    ```java
    private Object lock = new Object();
    private volatile MyObject f = null;

    public MyObject getMyObject() {
      MyObject result = f;
      if (result == null) {
        synchronized(lock) {
          result = f;
          if (result == null) {
            result = new MyObject();
            result.init();
            f = result; // GOOD
          }
        }
      }
      return result;
    }

    ```
    As a final note, it is possible to use double-checked locking correctly without `volatile` if the object you construct is immutable (that is, the object declares all fields as `final`), and the double-checked field is read exactly once outside the synchronized block.

    Given that all fields in `MyImmutableObject` are declared `final` then the following example is protected against exposing uninitialized fields to another thread. However, since there are two reads of `f` without synchronization, it is possible that these are reordered, which means that this method can return `null`.


    ```java
    private Object lock = new Object();
    private MyImmutableObject f = null;

    public MyImmutableObject getMyImmutableObject() {
      if (f == null) {
        synchronized(lock) {
          if (f == null) {
            f = new MyImmutableObject();
          }
        }
      }
      return f; // BAD
    }

    ```
    In this case, using a local variable to minimize the number of field reads is no longer a performance improvement, but rather a crucial detail that is necessary for correctness.


    ## References
    * [The "Double-Checked Locking is Broken" Declaration](https://www.cs.umd.edu/~pugh/java/memoryModel/DoubleCheckedLocking.html).
    * Java Language Specification: [17.4. Memory Model](https://docs.oracle.com/javase/specs/jls/se11/html/jls-17.html#jls-17.4).
    * Wikipedia: [Double-checked locking](https://en.wikipedia.org/wiki/Double-checked_locking).
    * Aleksey Shipilv: [Safe Publication and Safe Initialization in Java](https://shipilev.net/blog/2014/safe-public-construction/).
    * Aleksey Shipilv: [Close Encounters of The Java Memory Model Kind](https://shipilev.net/blog/2016/close-encounters-of-jmm-kind/).
    * Common Weakness Enumeration: [CWE-609](https://cwe.mitre.org/data/definitions/609.html).
 -
  pack: codeql/java-queries#0
  relativeQueryPath: Likely Bugs/Concurrency/EmptyRunMethodInThread.ql
  relativeBqrsPath: codeql/java-queries/Likely Bugs/Concurrency/EmptyRunMethodInThread.bqrs
  metadata:
    name: Useless run() method in thread
    description: |-
      Thread instances that neither get an argument of type 'Runnable' passed to their
                    constructor nor override the 'Thread.run' method are likely to have no effect.
    kind: problem
    problem.severity: warning
    precision: low
    id: java/empty-run-method-in-thread
    tags: |-
      reliability
             correctness
             concurrency
  queryHelp: |
    # Useless run() method in thread
    New threads can be defined using one of the following alternatives:

    * By extending the `Thread` class and overriding its `run` method.
    * By passing an argument of type `Runnable` to the constructor of the `Thread` class.
    Thread instances that are defined using another approach are likely to have no effect.


    ## Recommendation
    To avoid empty thread instances, define new threads using one of the following alternatives:

    * By extending the `Thread` class and overriding its `run` method.
    * By passing an argument of type `Runnable` to the constructor of the `Thread` class.

    ## Example
    In the following example, class `Bad` shows the definition of a thread that has no effect.


    ```java
    class Bad{

      public void runInThread(){
        Thread thread = new Thread();
        thread.start();
      }

    }
    ```
    In the following example, class `GoodWithOverride` shows how to extend the `Thread` class and override its `run` method, and class `GoodWithRunnable` shows how to pass an argument of type `Runnable` to the constructor of the `Thread` class.


    ```java
    class GoodWithOverride{

      public void runInThread(){
        Thread thread = new Thread(){
          @Override
          public void run(){
            System.out.println("Doing something");
          }
        };
        thread.start;
      }

    }

    class GoodWithRunnable{

      public void runInThread(){
        Runnable thingToRun = new Runnable(){
          @Override
          public void run(){
            System.out.println("Doing something");
          }
        };

        Thread thread = new Thread(thingToRun());
        thread.start();
      }

    }
    ```

    ## References
    * Java API Specification: [Thread](https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/lang/Thread.html).
    * The Java Tutorials: [Defining and Starting a Thread](https://docs.oracle.com/javase/tutorial/essential/concurrency/runthread.html).
 -
  pack: codeql/java-queries#0
  relativeQueryPath: Likely Bugs/Concurrency/FutileSynchOnField.ql
  relativeBqrsPath: codeql/java-queries/Likely Bugs/Concurrency/FutileSynchOnField.bqrs
  metadata:
    name: Futile synchronization on field
    description: |-
      Synchronizing on a field and updating that field while the lock is held is unlikely
                    to provide the desired thread safety.
    kind: problem
    problem.severity: error
    precision: medium
    id: java/unsafe-sync-on-field
    tags: |-
      reliability
             correctness
             concurrency
             language-features
             external/cwe/cwe-662
  queryHelp: "# Futile synchronization on field\nA block of code that synchronizes\
    \ on a field and updates that field while the lock is held is unlikely to provide\
    \ the desired thread safety. Such a synchronized block does not prevent multiple\
    \ unsynchronized assignments to that field because it obtains a lock on the object\
    \ stored *in* the field rather than the field itself.\n\n\n## Recommendation\n\
    Instead of synchronizing on the field itself, consider synchronizing on a separate\
    \ lock object when you want to avoid simultaneous updates to the field. You can\
    \ do this by declaring a synchronized method and using it for any field updates.\n\
    \n\n## Example\nIn the following example, in class A, synchronization takes place\
    \ on the field that is updated in the body of the `setField` method.\n\n\n```java\n\
    public class A {\n    private Object field;  \n    \n    public void setField(Object\
    \ o){\n        synchronized (field){    // BAD: synchronize on the field to be\
    \ updated\n            field = o;\n            // ... more code ...          \n\
    \        }\n    }\n}\n```\nIn class B, the recommended approach is shown, where\
    \ synchronization takes place on a separate lock object.\n\n\n```java\npublic\
    \ class B {\n   private final Object lock = new Object();\n   private Object field;\n\
    \n   public void setField(Object o){\n       synchronized (lock){      // GOOD:\
    \ synchronize on a separate lock object\n           field = o;\n           //\
    \ ... more code ...\n       }\n   }\n}\n```\n\n## References\n* Java Language\
    \ Specification: [The synchronized Statement](https://docs.oracle.com/javase/specs/jls/se11/html/jls-14.html#jls-14.19),\
    \ [synchronized Methods](https://docs.oracle.com/javase/specs/jls/se11/html/jls-8.html#jls-8.4.3.6).\n\
    * The Java Tutorials: [Lock Objects](https://docs.oracle.com/javase/tutorial/essential/concurrency/newlocks.html).\n\
    * Common Weakness Enumeration: [CWE-662](https://cwe.mitre.org/data/definitions/662.html).\n"
 -
  pack: codeql/java-queries#0
  relativeQueryPath: Likely Bugs/Concurrency/InconsistentAccess.ql
  relativeBqrsPath: codeql/java-queries/Likely Bugs/Concurrency/InconsistentAccess.bqrs
  metadata:
    name: Inconsistent synchronization for field
    description: |-
      If a field is mostly accessed in a synchronized context, but occasionally accessed
                    in a non-synchronized way, the non-synchronized accesses may lead to race
                    conditions.
    kind: problem
    problem.severity: error
    precision: low
    id: java/inconsistent-field-synchronization
    tags: |-
      reliability
             correctness
             concurrency
             language-features
             external/cwe/cwe-662
             statistical
             non-attributable
  queryHelp: |
    # Inconsistent synchronization for field
    If a field is mostly accessed in a synchronized context, but occasionally accessed in a non-synchronized way, the non-synchronized accesses may lead to race conditions.


    ## Recommendation
    Ensure that the non-synchronized field accesses are made synchronized, if required.


    ## Example
    In the following example, `counter` is accessed in a synchronized way in *all but one* cases. If `modifyCounter` is called by a large number of threads that are running concurrently, the value of `counter` at the end of each call may not be zero. This is because the non-synchronized statement could be interleaved with updates to the counter that are performed by the other threads.


    ```java
    class MultiThreadCounter {
        public int counter = 0;

        public void modifyCounter() {
            synchronized(this) {
                counter--;
            }
            synchronized(this) {
                counter--;
            }
            synchronized(this) {
                counter--;
            }
            counter = counter + 3;  // No synchronization
        }
    }

    ```
    To correct this, the last statement of `modifyCounter` should be enclosed in a `synchronized` statement.


    ## References
    * Java Language Specification: [Synchronization](https://docs.oracle.com/javase/specs/jls/se11/html/jls-17.html#jls-17.1).
    * Common Weakness Enumeration: [CWE-662](https://cwe.mitre.org/data/definitions/662.html).
 -
  pack: codeql/java-queries#0
  relativeQueryPath: Likely Bugs/Concurrency/LazyInitStaticField.ql
  relativeBqrsPath: codeql/java-queries/Likely Bugs/Concurrency/LazyInitStaticField.bqrs
  metadata:
    name: Incorrect lazy initialization of a static field
    description: |-
      Initializing a static field without synchronization can be problematic
                    in a multi-threaded context.
    kind: problem
    problem.severity: warning
    precision: low
    id: java/lazy-initialization
    tags: |-
      reliability
             correctness
             concurrency
             external/cwe/cwe-543
             external/cwe/cwe-609
  queryHelp: "# Incorrect lazy initialization of a static field\nThe tactic of initializing\
    \ a static field the first time it is used, known as \"lazy initialization\",\
    \ can be problematic in a multi-threaded context when used without proper synchronization.\
    \ If a separate thread starts executing before the field is initialized, the thread\
    \ may see an incompletely initialized object.\n\n\n## Recommendation\nIf lazy\
    \ initialization is desirable for performance reasons, the best solution is usually\
    \ to declare the enclosing method `synchronized`. Otherwise, avoid lazy initialization\
    \ and initialize static fields using static initializers. A third possibility\
    \ is to declare the field `volatile` and use the double-checked locking idiom\
    \ as explained in the article referenced below. As the article points out, it\
    \ is crucial to declare the field `volatile`: double-checked locking by itself\
    \ is *not* correct under the Java memory model.\n\n\n## Example\nIn the following\
    \ example, the static field `resource` is initialized without synchronization.\n\
    \n\n```java\nclass Singleton {\n    private static Resource resource;\n\n    public\
    \ Resource getResource() {\n        if(resource == null)\n            resource\
    \ = new Resource();  // Lazily initialize \"resource\"\n        return resource;\n\
    \    }\n}\n```\nIn the following modification of the above example, `Singleton`\
    \ uses the recommended approach of using a static initializer to initialize `resource`.\n\
    \n\n```java\nclass Singleton {\n    private static Resource resource;\n\n    static\
    \ {\n        resource = new Resource();  // Initialize \"resource\" only once\n\
    \    }\n \n    public Resource getResource() {\n        return resource;\n   \
    \ }\n}\n```\n\n## References\n* University of Maryland Department of Computer\
    \ Science: [The \"Double-Checked Locking is Broken\" Declaration](http://www.cs.umd.edu/~pugh/java/memoryModel/DoubleCheckedLocking.html).\n\
    * Common Weakness Enumeration: [CWE-543](https://cwe.mitre.org/data/definitions/543.html).\n\
    * Common Weakness Enumeration: [CWE-609](https://cwe.mitre.org/data/definitions/609.html).\n"
 -
  pack: codeql/java-queries#0
  relativeQueryPath: Likely Bugs/Concurrency/NonSynchronizedOverride.ql
  relativeBqrsPath: codeql/java-queries/Likely Bugs/Concurrency/NonSynchronizedOverride.bqrs
  metadata:
    name: Non-synchronized override of synchronized method
    description: |-
      If a synchronized method is overridden in a subclass, and the overriding method is
                    not synchronized, the thread-safety of the subclass may be broken.
    kind: problem
    problem.severity: warning
    precision: very-high
    id: java/non-sync-override
    tags: |-
      reliability
             correctness
             concurrency
             language-features
             external/cwe/cwe-820
  queryHelp: |
    # Non-synchronized override of synchronized method
    If a synchronized method is overridden in a subclass, the compiler does not require the overriding method to be synchronized. However, if the overriding method is not synchronized, the thread-safety of the subclass may be broken.


    ## Recommendation
    Ensure that the overriding method is synchronized, if necessary.


    ## References
    * Java Language Specification: [Synchronization](https://docs.oracle.com/javase/specs/jls/se11/html/jls-17.html#jls-17.1).
    * Help - Eclipse Platform: [Java Compiler Errors/Warnings Preferences](https://help.eclipse.org/2020-12/advanced/content.jsp?topic=/org.eclipse.jdt.doc.user/reference/preferences/java/compiler/ref-preferences-errors-warnings.htm).
    * Common Weakness Enumeration: [CWE-820](https://cwe.mitre.org/data/definitions/820.html).
 -
  pack: codeql/java-queries#0
  relativeQueryPath: Likely Bugs/Concurrency/NotifyNotNotifyAll.ql
  relativeBqrsPath: codeql/java-queries/Likely Bugs/Concurrency/NotifyNotNotifyAll.bqrs
  metadata:
    name: notify instead of notifyAll
    description: |-
      Calling 'notify' instead of 'notifyAll' may fail to wake up the correct thread and
                    cannot wake up multiple threads.
    kind: problem
    problem.severity: warning
    precision: medium
    id: java/notify-instead-of-notify-all
    tags: |-
      reliability
             correctness
             concurrency
             external/cwe/cwe-662
  queryHelp: |
    # notify instead of notifyAll
    Calls to the `notify` method rather than `notifyAll` may fail to wake up the correct thread if an object's monitor (intrinsic lock) is used for multiple conditions. `notify` only wakes up a single arbitrary thread that is waiting on the object's monitor, whereas `notifyAll` wakes up all such threads.


    ## Recommendation
    Ensure that the call to `notify` instead of `notifyAll` is a correct and desirable optimization. If not, call `notifyAll` instead.


    ## Example
    In the following example, the methods `produce` and `consume` both use `notify` to tell any waiting threads that an object has been added or removed from the buffer. However, this means that only *one* thread is notified. The woken-up thread might not be able to proceed due to its condition being false, immediately going back to the waiting state. As a result no progress is made.


    ```java
    class ProducerConsumer {
        private static final int MAX_SIZE=3;
        private List<Object> buf = new ArrayList<Object>();

        public synchronized void produce(Object o) {
            while (buf.size()==MAX_SIZE) {
                try {
                    wait();
                }
                catch (InterruptedException e) {
                   ...
                }
            }
            buf.add(o);
            notify(); // 'notify' is used
        }

        public synchronized Object consume() {

            while (buf.size()==0) {
                try {
                    wait();
                }
                catch (InterruptedException e) {
                    ...
                }
            }
            Object o = buf.remove(0);
            notify(); // 'notify' is used
            return o;
        }
    }

    ```
    When using `notifyAll` instead of `notify`, *all* threads are notified, and if there are any threads that could proceed, we can be sure that at least one of them will do so.


    ## References
    * J. Bloch. *Effective Java (second edition)*, p. 277. Addison-Wesley, 2008.
    * Java API Specification: [Object.notify()](https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/lang/Object.html#notify()), [Object.notifyAll()](https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/lang/Object.html#notifyAll()).
    * Common Weakness Enumeration: [CWE-662](https://cwe.mitre.org/data/definitions/662.html).
 -
  pack: codeql/java-queries#0
  relativeQueryPath: Likely Bugs/Concurrency/NotifyWithoutSynch.ql
  relativeBqrsPath: codeql/java-queries/Likely Bugs/Concurrency/NotifyWithoutSynch.bqrs
  metadata:
    name: Notify on unlocked object
    description: |-
      Calling 'wait', 'notify', or 'notifyAll' on an object which has not
                    been locked (with a synchronized method or statement) will throw.
    kind: problem
    problem.severity: error
    precision: low
    id: java/notify-without-sync
    tags: |-
      correctness
             concurrency
             language-features
  queryHelp: |
    # Notify on unlocked object
    The methods `notify`, `notifyAll`, and `wait` should only be called by a thread that is the owner of the object's monitor (intrinsic lock). In other words, the methods should only be called from within a synchronized statement or method. Otherwise the method call will throw `IllegalMonitorStateException`.


    ## Recommendation
    Ensure that calls to `notify`, `notifyAll`, or `wait` are called from within a synchronized statement or method.


    ## Example
    In the following example, the methods `produce` and `consume` use `wait` and `notifyAll` to communicate. However, the `consume` method is not synchronized, so the calls to `wait` and `notifyAll` will always throw an exception.


    ```java
    class ProducerConsumer {
        private static final int MAX_SIZE=3;
        private List<Object> buf = new ArrayList<Object>();

        public synchronized void produce(Object o) {
            while (buf.size()==MAX_SIZE) {
                try {
                    wait();
                }
                catch (InterruptedException e) {
                   ...
                }
            }
            buf.add(o);
            notifyAll();
        }

        public Object consume() {
            while (buf.size()==0) {
                try {
                    wait();
                }
                catch (InterruptedException e) {
                    ...
                }
            }
            Object o = buf.remove(0);
            notifyAll();
            return o;
        }
    }

    ```
    To fix this example, add the `synchronized` keyword to the declaration of the `consume` method.


    ## References
    * J. Bloch. *Effective Java (second edition)*, p. 276. Addison-Wesley, 2008.
    * Java API Specification: [Object.notify()](https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/lang/Object.html#notify()), [Object.notifyAll()](https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/lang/Object.html#notifyAll()), [Object.wait()](https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/lang/Object.html#wait()), [Object.wait(long)](https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/lang/Object.html#wait(long)).
 -
  pack: codeql/java-queries#0
  relativeQueryPath: Likely Bugs/Concurrency/PriorityCalls.ql
  relativeBqrsPath: codeql/java-queries/Likely Bugs/Concurrency/PriorityCalls.bqrs
  metadata:
    name: Explicit thread priority
    description: |-
      Setting thread priorities to control interactions between threads is not portable,
                    and may not have the desired effect.
    kind: problem
    problem.severity: warning
    precision: low
    id: java/thread-priority
    tags: |-
      portability
             correctness
             concurrency
  queryHelp: |
    # Explicit thread priority
    Specifying thread priorities using calls to `Thread.setPriority` and `Thread.getPriority` is not portable and may have adverse consequences such as starvation.


    ## Recommendation
    Avoid setting thread priorities to control interactions between threads. Using the default thread priority should be sufficient for most applications.

    However, if you need to enforce a specific synchronization order, use one of the following alternatives:

    * Waiting for a notification using the `wait` and `notifyAll` methods
    * Using the `java.util.concurrent` library
    In some cases, calls to `Thread.sleep` may be appropriate to temporarily stop execution (provided that there is no possibility for race conditions), but this is not generally recommended.


    ## References
    * J. Bloch, *Effective Java (second edition)*, Item 72. Addison-Wesley, 2008.
    * Inform IT: [Adding Multithreading Capability to Your Java Applications](http://www.informit.com/articles/article.aspx?p=26326&seqNum=5).
 -
  pack: codeql/java-queries#0
  relativeQueryPath: Likely Bugs/Concurrency/SleepWithLock.ql
  relativeBqrsPath: codeql/java-queries/Likely Bugs/Concurrency/SleepWithLock.bqrs
  metadata:
    name: Sleep with lock held
    description: |-
      Calling 'Thread.sleep' with a lock held may lead to very poor
                    performance or even deadlock.
    kind: problem
    problem.severity: error
    precision: medium
    id: java/sleep-with-lock-held
    tags: |-
      reliability
             correctness
             concurrency
             external/cwe/cwe-833
  queryHelp: |
    # Sleep with lock held
    Calling `Thread.sleep` with a lock held may lead to very poor performance or even deadlock. This is because `Thread.sleep` does not cause a thread to release its locks.


    ## Recommendation
    `Thread.sleep` should be called only outside of a `synchronized` block. However, a better way for threads to yield execution time to other threads may be to use either of the following solutions:

    * The `java.util.concurrent` library
    * The `wait` and `notifyAll` methods

    ## Example
    In the following example of the problem, two threads, `StorageThread` and `OtherThread`, are started. Both threads output a message to show that they have started but then `StorageThread` locks `counter` and goes to sleep. The lock prevents `OtherThread` from locking `counter`, so it has to wait until `StorageThread` has woken up and unlocked `counter` before it can continue.


    ```java
    class StorageThread implements Runnable{
        public static Integer counter = 0;
        private static final Object LOCK = new Object();

        public void run() {
            System.out.println("StorageThread started.");
            synchronized(LOCK) {  // "LOCK" is locked just before the thread goes to sleep
                try {
                    Thread.sleep(5000);
                } catch (InterruptedException e) { ... }
            }
            System.out.println("StorageThread exited.");
        }
    }

    class OtherThread implements Runnable{
        public void run() {
            System.out.println("OtherThread started.");
            synchronized(StorageThread.LOCK) {
                StorageThread.counter++;
            }
            System.out.println("OtherThread exited.");
        }
    }

    public class SleepWithLock {
        public static void main(String[] args) {
            new Thread(new StorageThread()).start();
            new Thread(new OtherThread()).start();
        }
    }

    ```
    To avoid this problem, `StorageThread` should call `Thread.sleep` outside the `synchronized` block instead, so that `counter` is unlocked.


    ## References
    * Java API Specification: [Thread.sleep()](https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/lang/Thread.html#sleep(long)), [Object.wait()](https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/lang/Object.html#wait()), [Object.notifyAll()](https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/lang/Object.html#notifyAll()), [java.util.concurrent](https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/util/concurrent/package-summary.html).
    * Common Weakness Enumeration: [CWE-833](https://cwe.mitre.org/data/definitions/833.html).
 -
  pack: codeql/java-queries#0
  relativeQueryPath: Likely Bugs/Concurrency/StartInConstructor.ql
  relativeBqrsPath: codeql/java-queries/Likely Bugs/Concurrency/StartInConstructor.bqrs
  metadata:
    name: Start of thread in constructor
    description: |-
      Starting a thread within a constructor may cause the thread to start before
                    any subclass constructor has completed its initialization, causing unexpected
                    results.
    kind: problem
    problem.severity: warning
    precision: medium
    id: java/thread-start-in-constructor
    tags: |-
      reliability
             correctness
             concurrency
  queryHelp: "# Start of thread in constructor\nStarting a thread within a constructor\
    \ may cause unexpected results. If the class is extended, the thread may start\
    \ before the subclass constructor has completed its initialization, which may\
    \ not be intended.\n\n\n## Recommendation\nAvoid starting threads in constructors.\
    \ Typically, the constructor of a class only *constructs* the thread object, and\
    \ a separate `start` method should be provided to *start* the thread object created\
    \ by the constructor.\n\n\n## Example\nIn the following example, because the `Test`\
    \ constructor implicitly calls the `Super` constructor, the thread created in\
    \ the `Super` constructor may start before `this.name` has been initialized. Therefore,\
    \ the program may output \"hello \" followed by a null string.\n\n\n```java\n\
    class Super {\n    public Super() {\n        new Thread() {\n            public\
    \ void run() {\n                System.out.println(Super.this.toString());\n \
    \           }\n        }.start(); // BAD: The thread is started in the constructor\
    \ of 'Super'.\n    }\n\n    public String toString() {\n        return \"hello\"\
    ;\n    }\n}\n\nclass Test extends Super {\n    private String name;\n    public\
    \ Test(String nm) {\n        // The thread is started before\n        // this\
    \ line is run\n        this.name = nm;\n    }\n\n    public String toString()\
    \ {\n        return super.toString() + \" \" + name;\n    }\n\n    public static\
    \ void main(String[] args) {\n        new Test(\"my friend\");\n    }\n}\n```\n\
    In the following modified example, the thread created in the `Super` constructor\
    \ is not started within the constructor; `main` starts the thread after `this.name`\
    \ has been initialized. This results in the program outputting \"hello my friend\"\
    .\n\n\n```java\nclass Super {\n    Thread thread;\n    public Super() {\n    \
    \    thread = new Thread() {\n            public void run() {\n              \
    \  System.out.println(Super.this.toString());\n            }\n        };\n   \
    \ }\n\n    public void start() {  // good\n        thread.start();\n    }\n  \
    \  \n    public String toString() {\n        return \"hello\";\n    }\n}\n\nclass\
    \ Test extends Super {\n    private String name;\n    public Test(String nm) {\n\
    \        this.name = nm;\n    }\n\n    public String toString() {\n        return\
    \ super.toString() + \" \" + name;\n    }\n\n    public static void main(String[]\
    \ args) {\n        Test t = new Test(\"my friend\");\n        t.start();\n   \
    \ }\n}\n```\n\n## References\n* IBM developerWorks: [Don't start threads from\
    \ within constructors](https://web.archive.org/web/20200417101823/http://www.ibm.com/developerworks/java/library/j-jtp0618/index.html#4).\n"
 -
  pack: codeql/java-queries#0
  relativeQueryPath: Likely Bugs/Concurrency/SynchOnBoxedType.ql
  relativeBqrsPath: codeql/java-queries/Likely Bugs/Concurrency/SynchOnBoxedType.bqrs
  metadata:
    name: Synchronization on boxed types or strings
    description: |-
      Synchronizing on boxed types or strings may lead to
                    deadlock since an instance of that type is likely to
                    be shared between many parts of the program.
    kind: problem
    problem.severity: error
    precision: very-high
    id: java/sync-on-boxed-types
    tags: |-
      reliability
             correctness
             concurrency
             language-features
             external/cwe/cwe-662
  queryHelp: "# Synchronization on boxed types or strings\nCode should not synchronize\
    \ on a variable or field of a boxed type (for example `Integer`, `Boolean`) or\
    \ of type `String` since it is likely to contain an object that is used throughout\
    \ the program. For example, `Boolean.TRUE` holds a single instance that will be\
    \ used in many places throughout the program: whenever `true` is autoboxed or\
    \ a call to `Boolean.valueOf` is made with `true` as an argument the same instance\
    \ of `Boolean` is returned. It is therefore likely that two classes synchronizing\
    \ on a field of type `Boolean` will end up synchronizing on the same object. This\
    \ may lead to deadlock or threads being blocked unnecessarily.\n\n\n## Recommendation\n\
    Synchronize on a specific lock object instead of using an object with a boxed\
    \ type.\n\n\n## Example\nIn the following example, the intention is to allow `ThreadA`\
    \ and `ThreadB` to run at the same time. Unfortunately, `ThreadA.lock` and `ThreadB.lock`\
    \ both refer to the same object (that is, the interned value of the `String` `\"\
    lock\"`) so the synchronized blocks in their run methods can not be executed concurrently.\n\
    \n\n```java\nclass BadSynchronize{\n\t\t\n\tclass ThreadA extends Thread{\n\t\t\
    private String value = \"lock\"\n\t\t\n\t\tpublic void run(){\n\t\t\tsynchronized(value){\n\
    \t\t\t\t//...\n\t\t\t}\n\t\t}\n\t}\n\t\n\tclass ThreadB extends Thread{\n\t\t\
    private String value = \"lock\"\n\t\t\n\t\tpublic void run(){\n\t\t\tsynchronized(value){\n\
    \t\t\t\t//...\n\t\t\t}\n\t\t}\n\t}\n\t\n\tpublic void run(){\n\t\tnew ThreadA().start();\n\
    \t\tnew ThreadB().start();\n\t}\n\t\t\n}\n```\nIn the following example, the approach\
    \ recommended above is shown. A separate lock object is created for each thread\
    \ allowing them to execute concurrently.\n\n\n```java\nclass GoodSynchronize{\n\
    \t\t\n\tclass ThreadA extends Thread{\n\t\tprivate Object lock = new Object();\n\
    \t\t\n\t\tpublic void run(){\n\t\t\tsynchronized(lock){\n\t\t\t\t//...\n\t\t\t\
    }\n\t\t}\n\t}\n\t\n\tclass ThreadB extends Thread{\n\t\tprivate Object lock =\
    \ new Object();\n\t\t\t\t\n\t\tpublic void run(){\n\t\t\tsynchronized(lock){\n\
    \t\t\t\t//...\n\t\t\t}\n\t\t}\n\t}\n\t\n\tpublic void run(){\n\t\tnew ThreadA().start();\n\
    \t\tnew ThreadB().start();\n\t}\n\t\t\n}\n```\n\n## References\n* SEI CERT Oracle\
    \ Coding Standard for Java: [LCK01-J. Do not synchronize on objects that may be\
    \ reused](https://wiki.sei.cmu.edu/confluence/display/java/LCK01-J.+Do+not+synchronize+on+objects+that+may+be+reused),\n\
    * Common Weakness Enumeration: [CWE-662](https://cwe.mitre.org/data/definitions/662.html).\n"
 -
  pack: codeql/java-queries#0
  relativeQueryPath: Likely Bugs/Concurrency/SynchSetUnsynchGet.ql
  relativeBqrsPath: codeql/java-queries/Likely Bugs/Concurrency/SynchSetUnsynchGet.bqrs
  metadata:
    name: Inconsistent synchronization of getter and setter
    description: |-
      If a class has a synchronized 'set' method, and a similarly-named 'get' method is
                    not also synchronized, calls to the 'get' method may not return a consistent state
                    for the object.
    kind: problem
    problem.severity: error
    precision: very-high
    id: java/unsynchronized-getter
    tags: |-
      reliability
             correctness
             concurrency
             language-features
             external/cwe/cwe-413
             external/cwe/cwe-662
  queryHelp: |
    # Inconsistent synchronization of getter and setter
    If a class has a synchronized `set` method and a similarly-named `get` method is not also synchronized, calls to the `get` method may not return a consistent state for the object.


    ## Recommendation
    Synchronize read operations as well as write operations. You should usually synchronize the `get` method.


    ## References
    * Java Language Specification: [Synchronization](https://docs.oracle.com/javase/specs/jls/se11/html/jls-17.html#jls-17.1).
    * Common Weakness Enumeration: [CWE-413](https://cwe.mitre.org/data/definitions/413.html).
    * Common Weakness Enumeration: [CWE-662](https://cwe.mitre.org/data/definitions/662.html).
 -
  pack: codeql/java-queries#0
  relativeQueryPath: Likely Bugs/Concurrency/SynchWriteObject.ql
  relativeBqrsPath: codeql/java-queries/Likely Bugs/Concurrency/SynchWriteObject.bqrs
  metadata:
    name: Inconsistent synchronization for writeObject()
    description: |-
      Classes with a synchronized 'writeObject' method but no other
                    synchronized methods usually lack a sufficient level of synchronization.
    kind: problem
    problem.severity: warning
    precision: medium
    id: java/inconsistent-sync-writeobject
    tags: |-
      reliability
             correctness
             concurrency
             language-features
             external/cwe/cwe-662
  queryHelp: |
    # Inconsistent synchronization for writeObject()
    Classes with a synchronized `writeObject` method but no other synchronized methods usually lack a sufficient level of synchronization. If any mutable state of this class can be modified without proper synchronization, the serialization using the `writeObject` method may result in an inconsistent state.


    ## Recommendation
    See if synchronization is necessary on methods other than `writeOject` to make the class thread-safe. Any methods that access or modify the state of an object of this class should usually be synchronized as well.


    ## References
    * Java Language Specification: [Synchronization](https://docs.oracle.com/javase/specs/jls/se11/html/jls-17.html#jls-17.1).
    * Common Weakness Enumeration: [CWE-662](https://cwe.mitre.org/data/definitions/662.html).
 -
  pack: codeql/java-queries#0
  relativeQueryPath: Likely Bugs/Concurrency/UnreleasedLock.ql
  relativeBqrsPath: codeql/java-queries/Likely Bugs/Concurrency/UnreleasedLock.bqrs
  metadata:
    name: Unreleased lock
    description: |-
      A lock that is acquired one or more times without a matching number of unlocks
                    may cause a deadlock.
    kind: problem
    problem.severity: error
    security-severity: 5.0
    precision: medium
    id: java/unreleased-lock
    tags: |-
      reliability
             security
             external/cwe/cwe-764
             external/cwe/cwe-833
  queryHelp: |
    # Unreleased lock
    When a thread acquires a lock it must make sure to unlock it again; failing to do so can lead to deadlocks. If a lock allows a thread to acquire it multiple times, for example `java.util.concurrent.locks.ReentrantLock`, then the number of locks must match the number of unlocks in order to fully release the lock.


    ## Recommendation
    It is recommended practice always to immediately follow a call to `lock` with a `try` block and place the call to `unlock` inside the `finally` block. Beware of calls inside the `finally` block that could cause exceptions, as this may result in skipping the call to `unlock`.


    ## Example
    The typical pattern for using locks safely looks like this:


    ```java
    public void m() {
       lock.lock();
       // A
       try {
          // ... method body
       } finally {
          // B
          lock.unlock();
       }
    }
    ```
    If any code that can cause a premature method exit (for example by throwing an exception) is inserted at either point `A` or `B` then the method might not unlock, so this should be avoided.


    ## References
    * Java API Specification: [java.util.concurrent.locks.Lock](https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/util/concurrent/locks/Lock.html), [java.util.concurrent.locks.ReentrantLock](https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/util/concurrent/locks/ReentrantLock.html).
    * Common Weakness Enumeration: [CWE-764](https://cwe.mitre.org/data/definitions/764.html).
    * Common Weakness Enumeration: [CWE-833](https://cwe.mitre.org/data/definitions/833.html).
 -
  pack: codeql/java-queries#0
  relativeQueryPath: Likely Bugs/Concurrency/WaitOutsideLoop.ql
  relativeBqrsPath: codeql/java-queries/Likely Bugs/Concurrency/WaitOutsideLoop.bqrs
  metadata:
    name: Wait outside loop
    description: |-
      Calling 'wait' outside a loop may result in the program continuing before the
                    expected condition is met.
    kind: problem
    problem.severity: error
    precision: low
    id: java/wait-outside-loop
    tags: |-
      reliability
             correctness
             concurrency
  queryHelp: |
    # Wait outside loop
    Calling `Object.wait` outside of a loop may cause problems because the thread does not go back to sleep after a spurious wake-up call. This results in the program continuing before the expected condition is met.


    ## Recommendation
    Ensure that `wait` is called within a loop that tests for the condition that the thread is waiting for. This ensures that the program only proceeds to execute when the relevant condition is true. Note that the thread that calls `wait` on an object must be the owner of that object's monitor.


    ## Example
    In the following example, `obj.wait` is called within a `while` loop until the condition is true, at which point the program continues with the next statement after the loop:


    ```java
    synchronized (obj) {
        while (<condition is false>) obj.wait();
        // condition is true, perform appropriate action ...
    }
    ```

    ## References
    * J. Bloch, *Effective Java (second edition)*, p. 276. Addison-Wesley, 2008.
    * Java API Specification: [Object.wait()](https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/lang/Object.html#wait()).
    * The Java Tutorials: [Guarded Blocks](https://docs.oracle.com/javase/tutorial/essential/concurrency/guardmeth.html).
 -
  pack: codeql/java-queries#0
  relativeQueryPath: Likely Bugs/Concurrency/WaitWithTwoLocks.ql
  relativeBqrsPath: codeql/java-queries/Likely Bugs/Concurrency/WaitWithTwoLocks.bqrs
  metadata:
    name: Wait with two locks held
    description: Calling 'Object.wait' while two locks are held may cause deadlock.
    kind: problem
    problem.severity: error
    precision: low
    id: java/wait-with-two-locks
    tags: |-
      reliability
             correctness
             concurrency
             external/cwe/cwe-833
  queryHelp: |
    # Wait with two locks held
    Calling `Object.wait` while two locks are held may cause deadlock, because only one lock is released by `wait`.


    ## Recommendation
    See if one of the locks should continue to be held while waiting for a condition on the other lock. If not, release one of the locks before calling `Object.wait`.


    ## Example
    In the following example of the problem, `printText` locks both `idLock` and `textLock` before it reads the value of `text`. It then calls `textLock.wait`, which releases the lock on `textLock`. However, `setText` needs to lock `idLock` but it cannot because `idLock` is still locked by `printText`. Thus, deadlock is caused.


    ```java
    class WaitWithTwoLocks {

        private final Object idLock = new Object();
        private int id = 0;

        private final Object textLock = new Object();
        private String text = null;

        public void printText() {
            synchronized (idLock) {
                synchronized (textLock) {
                    while(text == null)
                        try {
                            textLock.wait();  // The lock on "textLock" is released but not the
                                              // lock on "idLock".
                        }
                        catch (InterruptedException e) { ... }
                    System.out.println(id + ":" + text);
                    text = null;
                    textLock.notifyAll();
                }
            }
        }

        public void setText(String mesg) {
            synchronized (idLock) { // "setText" needs a lock on "idLock" but "printText" already
                                    // holds a lock on "idLock", leading to deadlock
                synchronized (textLock) {
                    id++;
                    text = mesg;
                    idLock.notifyAll();
                    textLock.notifyAll();
                }
            }
        }
     }

    ```
    In the following modification of the above example, `id` and `text` are included in the class `Message`. The method `printText` synchronizes on the field `message` before it reads the value of `message.text`. It then calls `message.wait`, which releases the lock on `message`. This enables `setText` to lock `message` so that it can proceed.


    ```java
    class WaitWithTwoLocksGood {

        private static class Message {
            public int id = 0;
            public String text = null;
        }

        private final Message message = new Message();

        public void printText() {
            synchronized (message) {
                while(message.txt == null)
                    try {
                        message.wait();
                    }
                    catch (InterruptedException e) { ... }
                System.out.println(message.id + ":" + message.text);
                message.text = null;
                message.notifyAll();
            }
        }

        public void setText(String mesg) {
            synchronized (message) {
                message.id++;
                message.text = mesg;
                message.notifyAll();
            }
        }
     }

    ```

    ## References
    * Java API Specification: [Object.wait()](https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/lang/Object.html#wait()).
    * Common Weakness Enumeration: [CWE-833](https://cwe.mitre.org/data/definitions/833.html).
 -
  pack: codeql/java-queries#0
  relativeQueryPath: Likely Bugs/Concurrency/YieldCalls.ql
  relativeBqrsPath: codeql/java-queries/Likely Bugs/Concurrency/YieldCalls.bqrs
  metadata:
    name: Call to Thread.yield()
    description: |-
      Calling 'Thread.yield' may have no effect, and is not a reliable way to prevent a
                    thread from taking up too much execution time.
    kind: problem
    problem.severity: warning
    precision: low
    id: java/thread-yield-call
    tags: |-
      reliability
             correctness
             concurrency
  queryHelp: |
    # Call to Thread.yield()
    The method `Thread.yield` is a non-portable and underspecified operation. It may have no effect, and is not a reliable way to prevent a thread from taking up too much execution time.


    ## Recommendation
    Use alternative ways of preventing a thread from taking up too much execution time. Communication between threads should normally be implemented using some form of waiting for a notification using the `wait` and `notifyAll` methods or by using the `java.util.concurrent` library.

    In some cases, calls to `Thread.sleep` may be appropriate to temporarily cease execution (provided there is no possibility for race conditions), but this is not generally recommended.


    ## References
    * J. Bloch, *Effective Java (second edition)*, Item 72. Addison-Wesley, 2008.
    * Java API Specification: [Thread.yield()](https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/lang/Thread.html#yield()), [Object.wait()](https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/lang/Object.html#wait()), [Object.notifyAll()](https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/lang/Object.html#notifyAll()), [java.util.concurrent](https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/util/concurrent/package-summary.html), [Thread.sleep()](https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/lang/Thread.html#sleep(long)).
 -
  pack: codeql/java-queries#0
  relativeQueryPath: Likely Bugs/Finalization/NullifiedSuperFinalize.ql
  relativeBqrsPath: codeql/java-queries/Likely Bugs/Finalization/NullifiedSuperFinalize.bqrs
  metadata:
    name: Finalizer inconsistency
    description: |-
      A 'finalize' method that does not call 'super.finalize' may leave
                    cleanup actions undone.
    kind: problem
    problem.severity: error
    precision: medium
    id: java/missing-super-finalize
    tags: |-
      reliability
             maintainability
             external/cwe/cwe-568
  queryHelp: "# Finalizer inconsistency\nA `finalize` method that overrides the finalizer\
    \ of a superclass but does not call `super.finalize` may leave system resources\
    \ undisposed of or cause other cleanup actions to be left undone.\n\n\n## Recommendation\n\
    Make sure that all `finalize` methods call `super.finalize` to ensure that the\
    \ finalizer of its superclass is executed. Finalizer chaining is not automatic\
    \ in Java.\n\nIt is also possible to defend against subclasses that do not call\
    \ `super.finalize` by putting the cleanup code into a *finalizer guardian* instead\
    \ of the `finalize` method. A finalizer guardian is an anonymous object instance\
    \ that contains the cleanup code for the enclosing object in its `finalize` method.\
    \ The only reference to the finalizer guardian is stored in a private field of\
    \ the enclosing instance, which means that both the guardian and the enclosing\
    \ instance can be finalized at the same time. This way, a subclass cannot block\
    \ the execution of the cleanup code by not calling `super.finalize`.\n\n\n## Example\n\
    In the following example, `WrongCache.finalize` does not call `super.finalize`,\
    \ which means that native resources are not disposed of. However, `RightCache.finalize`\
    \ *does* call `super.finalize`, which means that native resources *are* disposed\
    \ of.\n\n\n```java\nclass LocalCache {\n    private Collection<NativeResource>\
    \ localResources;\n\n    //...\n\n    protected void finalize() throws Throwable\
    \ {\n        for (NativeResource r : localResources) {\n            r.dispose();\n\
    \        }\n    };\n}\n\nclass WrongCache extends LocalCache {\n    //...\n  \
    \  @Override\n    protected void finalize() throws Throwable {\n        // BAD:\
    \ Empty 'finalize', which does not call 'super.finalize'.\n        //        Native\
    \ resources in LocalCache are not disposed of.\n    }\n}\n\nclass RightCache extends\
    \ LocalCache {\n    //...\n    @Override\n    protected void finalize() throws\
    \ Throwable {\n        // GOOD: 'finalize' calls 'super.finalize'.\n        //\
    \        Native resources in LocalCache are disposed of.\n        super.finalize();\n\
    \    }\n}\n\n```\nThe following example shows a finalizer guardian.\n\n\n```java\n\
    class GuardedLocalCache {\n\tprivate Collection<NativeResource> localResources;\n\
    \t// A finalizer guardian, which performs the finalize actions for 'GuardedLocalCache'\n\
    \t// even if a subclass does not call 'super.finalize' in its 'finalize' method\n\
    \tprivate Object finalizerGuardian = new Object() {\n\t\tprotected void finalize()\
    \ throws Throwable {\n\t\t\tfor (NativeResource r : localResources) {\n\t\t\t\t\
    r.dispose();\n\t\t\t}\n\t\t};\n\t};\n}\n```\n\n## References\n* Java API Specification:\
    \ [Object.finalize()](https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/lang/Object.html#finalize()).\n\
    * J. Bloch, *Effective Java (second edition)*, Item 7. Addison-Wesley, 2008.\n\
    * Common Weakness Enumeration: [CWE-568](https://cwe.mitre.org/data/definitions/568.html).\n"
 -
  pack: codeql/java-queries#0
  relativeQueryPath: Likely Bugs/Frameworks/JUnit/BadSuiteMethod.ql
  relativeBqrsPath: codeql/java-queries/Likely Bugs/Frameworks/JUnit/BadSuiteMethod.bqrs
  metadata:
    name: Bad suite method
    description: |-
      A 'suite' method in a JUnit 3.8 test that does not match the expected signature is not
                    detected by JUnit.
    kind: problem
    problem.severity: warning
    precision: medium
    id: java/wrong-junit-suite-signature
    tags: |-
      testability
             maintainability
             frameworks/junit
  queryHelp: "# Bad suite method\nJUnit 3.8 requires that a `suite` method for defining\
    \ a `TestSuite` that will be used by a `TestRunner` has a specific signature.\
    \ If the `suite` method does not have the expected signature, JUnit does not detect\
    \ the method as a `suite` method.\n\n\n## Recommendation\nMake sure that `suite`\
    \ methods in junit `TestCase` classes are declared both `public` and `static`,\
    \ and that they have a return type of `junit.framework.Test` or one of its subtypes.\n\
    \n\n## Example\nIn the following example, `BadSuiteMethod.suite` is not detected\
    \ by JUnit because it is not declared `public`. However, `CorrectSuiteMethod.suite`\
    \ *is* detected by JUnit because it has the expected signature.\n\n\n```java\n\
    public class BadSuiteMethod extends TestCase {\n\t// BAD: JUnit 3.8 does not detect\
    \ the following method as a 'suite' method.\n\t// The method should be public,\
    \ static, and return 'junit.framework.Test' \n\t// or one of its subtypes.\n\t\
    static Test suite() {\n\t\tTestSuite suite = new TestSuite();\n\t\tsuite.addTest(new\
    \ MyTests(\"testEquals\"));\n\t\tsuite.addTest(new MyTests(\"testNotEquals\"));\n\
    \t\treturn suite;\n\t}\n}\n\npublic class CorrectSuiteMethod extends TestCase\
    \ {\n\t// GOOD: JUnit 3.8 correctly detects the following method as a 'suite'\
    \ method.\n\tpublic static Test suite() {\n\t\tTestSuite suite = new TestSuite();\n\
    \t\tsuite.addTest(new MyTests(\"testEquals\"));\n\t\tsuite.addTest(new MyTests(\"\
    testNotEquals\"));\n\t\treturn suite;\n\t}\n}\n```\n\n## References\n* JUnit:\
    \ [JUnit Cookbook](http://junit.sourceforge.net/junit3.8.1/doc/cookbook/cookbook.htm).\n"
 -
  pack: codeql/java-queries#0
  relativeQueryPath: Likely Bugs/Frameworks/JUnit/TearDownNoSuper.ql
  relativeBqrsPath: codeql/java-queries/Likely Bugs/Frameworks/JUnit/TearDownNoSuper.bqrs
  metadata:
    name: TestCase implements tearDown but doesn't call super.tearDown()
    description: |-
      A JUnit 3.8 test method that overrides 'tearDown' but does not call 'super.tearDown'
                    may result in subsequent tests failing, or allow the current state to persist and
                    affect subsequent tests.
    kind: problem
    problem.severity: warning
    precision: low
    id: java/junit-teardown-without-super
    tags: |-
      testability
             maintainability
             frameworks/junit
  queryHelp: "# TestCase implements tearDown but doesn't call super.tearDown()\nA\
    \ JUnit 3.8 test method that overrides a non-empty `tearDown` method should call\
    \ `super.tearDown` to make sure that the superclass performs its de-initialization\
    \ routines. Not calling `tearDown` may result in test failures in subsequent tests,\
    \ or allow the current state to persist and affect any following tests.\n\n\n\
    ## Recommendation\nCall `super.tearDown` at the end of the overriding `tearDown`\
    \ method.\n\n\n## Example\nIn the following example, `TearDownNoSuper.tearDown`\
    \ does not call `super.tearDown`, which may cause subsequent tests to fail, or\
    \ allow the internal state to be maintained. However, `TearDownSuper.tearDown`\
    \ *does* call `super.tearDown`, at the end of the method, to enable `FrameworkTestCase.tearDown`\
    \ to perform de-initialization.\n\n\n```java\n// Abstract class that initializes\
    \ then shuts down the\n// framework after each set of tests\nabstract class FrameworkTestCase\
    \ extends TestCase {\n\t@Override\n\tprotected void setUp() throws Exception {\n\
    \t\tsuper.setUp();\n\t\tFramework.init();\n\t}\n\t\n\t@Override\n\tprotected void\
    \ tearDown() throws Exception {\n\t\tsuper.tearDown();\n\t\tFramework.shutdown();\n\
    \t}\n}\n\n// The following classes extend 'FrameworkTestCase' to reuse the\n//\
    \ 'setUp' and 'tearDown' methods of the framework.\n\npublic class TearDownNoSuper\
    \ extends FrameworkTestCase {\n\t@Override\n\tprotected void setUp() throws Exception\
    \ {\n\t\tsuper.setUp();\n\t}\n\t\n\tpublic void testFramework() {\n\t\t//...\n\
    \t}\n\t\n\tpublic void testFramework2() {\n\t\t//...\n\t}\n\t\n\t@Override\n\t\
    protected void tearDown() throws Exception {\n\t\t// BAD: Does not call 'super.tearDown'.\
    \ May cause later tests to fail\n\t\t// when they try to re-initialize an already\
    \ initialized framework.\n\t\t// Even if the framework allows re-initialization,\
    \ it may maintain the\n\t\t// internal state, which could affect the results of\
    \ succeeding tests.\n\t\tSystem.out.println(\"Tests complete\");\n\t}\n}\n\npublic\
    \ class TearDownSuper extends FrameworkTestCase {\n\t@Override\n\tprotected void\
    \ setUp() throws Exception {\n\t\tsuper.setUp();\n\t}\n\t\n\tpublic void testFramework()\
    \ {\n\t\t//...\n\t}\n\t\n\tpublic void testFramework2() {\n\t\t//...\n\t}\n\t\n\
    \t@Override\n\tprotected void tearDown() throws Exception {\n\t\t// GOOD: Correctly\
    \ calls 'super.tearDown' to shut down the\n\t\t// framework.\n\t\tSystem.out.println(\"\
    Tests complete\");\n\t\tsuper.tearDown();\n\t}\n}\n```\n\n## References\n* JUnit:\
    \ [JUnit Cookbook](http://junit.sourceforge.net/junit3.8.1/doc/cookbook/cookbook.htm).\n"
 -
  pack: codeql/java-queries#0
  relativeQueryPath: Likely Bugs/Frameworks/JUnit/TestCaseNoTests.ql
  relativeBqrsPath: codeql/java-queries/Likely Bugs/Frameworks/JUnit/TestCaseNoTests.bqrs
  metadata:
    name: Test case has no tests
    description: |-
      A test case class whose test methods are not recognized by JUnit 3.8 as valid
                    declarations is not used.
    kind: problem
    problem.severity: recommendation
    precision: low
    id: java/test-case-without-tests
    tags: |-
      testability
             maintainability
             frameworks/junit
  queryHelp: "# Test case has no tests\nA JUnit 3.8 test case class (that is, a non-abstract\
    \ class that is a subtype of `junit.framework.TestCase`) should contain test methods,\
    \ and each method must have the correct signature to be used by JUnit. Otherwise,\
    \ the JUnit test runner will fail with an error message.\n\n\n## Recommendation\n\
    Ensure that the test case class contains some test methods, and that each method\
    \ is of the form:\n\n```\n\npublic void testXXX() {\n  // ...\n}\n\n```\nNote\
    \ that the method name must start with `test` and the method must not take any\
    \ parameters.\n\nIf the test case class is intended strictly for subclassing by\
    \ other test case classes, consider making it abstract to document this intention.\
    \ It will then no longer be flagged by this query.\n\nThis rule applies only to\
    \ JUnit 3.8-style test case classes. In JUnit 4, it is no longer required to extend\
    \ `junit.framework.TestCase` to mark test methods.\n\n\n## Example\nIn the following\
    \ example, `TestCaseNoTests38` does not contain any valid JUnit test methods.\
    \ However, `MyTests` contains two valid JUnit test methods.\n\n\n```java\n// BAD:\
    \ This test case class does not have any valid JUnit 3.8 test methods.\npublic\
    \ class TestCaseNoTests38 extends TestCase {\n\t// This is not a test case because\
    \ it does not start with 'test'.\n\tpublic void simpleTest() {\n\t\t//...\n\t\
    }\n\n\t// This is not a test case because it takes two parameters.\n\tpublic void\
    \ testNotEquals(int i, int j) {\n\t\tassertEquals(i != j, true);\n\t}\n\n\t//\
    \ This is recognized as a test, but causes JUnit to fail\n\t// when run because\
    \ it is not public.\n\tvoid testEquals() {\n\t\t//...\n\t}\n}\n\n// GOOD: This\
    \ test case class correctly declares test methods.\npublic class MyTests extends\
    \ TestCase {\n\tpublic void testEquals() {\n\t\tassertEquals(1, 1);\n\t}\n\tpublic\
    \ void testNotEquals() {\n\t\tassertFalse(1 == 2);\n\t}\n}\n```\n\n## References\n\
    * JUnit: [JUnit Cookbook](http://junit.sourceforge.net/junit3.8.1/doc/cookbook/cookbook.htm).\n"
 -
  pack: codeql/java-queries#0
  relativeQueryPath: Likely Bugs/Frameworks/Swing/BadlyOverriddenAdapter.ql
  relativeBqrsPath: codeql/java-queries/Likely Bugs/Frameworks/Swing/BadlyOverriddenAdapter.bqrs
  metadata:
    name: Bad implementation of an event Adapter
    description: |-
      In a class that extends a Swing or Abstract Window Toolkit event adapter, an
                    event handler that does not have exactly the same name as the event handler that it
                    overrides means that the overridden event handler is not called.
    kind: problem
    problem.severity: warning
    precision: medium
    id: java/wrong-swing-event-adapter-signature
    tags: |-
      reliability
             maintainability
             frameworks/swing
  queryHelp: |
    # Bad implementation of an event Adapter
    Event adapters in Swing (and Abstract Window Toolkit) provide a convenient way for programmers to implement event listeners. However, care must be taken to get the names of the overridden methods right, or the event handlers will not be called.


    ## In Depth
    The event listener interfaces in Swing (and Abstract Window Toolkit) have many methods. For example, `java.awt.event.MouseListener` is defined as follows:

    ```java
    public interface MouseListener extends EventListener {
        public abstract void mouseClicked(MouseEvent);
        public abstract void mousePressed(MouseEvent);
        public abstract void mouseReleased(MouseEvent);
        public abstract void mouseEntered(MouseEvent);
        public abstract void mouseExited(MouseEvent);
    }
    ```
    The large number of methods can make such interfaces lengthy and tedious to implement, especially because it is rare that all of the methods need to be overridden. It is much more common that you need to override only one method, for example the `mouseClicked` event.

    For this reason, Swing supplies *adapter* classes that provide default, blank implementations of interface methods. An example is `MouseAdapter`, which provides default implementations for the methods in `MouseListener`, `MouseWheelListener` and `MouseMotionListener`. (Note that an adapter often implements multiple interfaces to avoid a large number of small adapter classes.) This makes it easy for programmers to implement just the methods they need from a given interface.

    Unfortunately, adapter classes are also a source of potential defects. Because the `@Override` annotation is not compulsory, it is very easy for programmers not to use it and then mistype the name of the method. This introduces a new method rather than implementing the relevant event handler.


    ## Recommendation
    Ensure that any overriding methods have exactly the same name as the overridden method.


    ## Example
    In the following example, the programmer has tried to implement the `mouseClicked` function but has misspelled the function name. This makes the function inoperable but the programmer gets no warning about this from the compiler.


    ```java
    add(new MouseAdapter() {
        public void mouseClickd(MouseEvent e) {
            // ...
        }
    });
    ```
    In the following modified example, the function name is spelled correctly. It is also preceded by the `@Override` annotation, which will cause the compiler to display an error if there is not a function of the same name to be overridden.


    ```java
    add(new MouseAdapter() {
        @Override
        public void mouseClicked(MouseEvent e) {
            // ...
        }
    });
    ```

    ## References
    * D. Flanagan, *Java Foundation Classes in a Nutshell*, Chapter 26. O'Reilly, 1999.
    * Java API Specification: [Annotation Type Override](https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/lang/Override.html).
    * The Java Tutorials: [Event Adapters](https://docs.oracle.com/javase/tutorial/uiswing/events/generalrules.html#eventAdapters).
 -
  pack: codeql/java-queries#0
  relativeQueryPath: Likely Bugs/Frameworks/Swing/ThreadSafety.ql
  relativeBqrsPath: codeql/java-queries/Likely Bugs/Frameworks/Swing/ThreadSafety.bqrs
  metadata:
    name: Thread safety
    description: |-
      Calling Swing methods from a thread other than the event-dispatching thread may
                    result in multi-threading errors.
    kind: problem
    problem.severity: warning
    precision: low
    id: java/swing-thread-safety
    tags: |-
      reliability
             maintainability
             frameworks/swing
  queryHelp: |
    # Thread safety
    Because Swing components are not thread-safe (that is, they do not support concurrent access from multiple threads), Swing has a rule that states that method calls on Swing components that have been *realized* (see below) must be made from a special thread known as the *event-dispatching thread*. Failure to observe this rule may result in multiple threads accessing a Swing component concurrently, with the potential for deadlocks, race conditions and other errors related to multi-threading.

    A component is considered *realized* if its `paint` method has been, or could be, called at this point. Realization is triggered according to the following rules:

    * A top-level window is realized if `setVisible(true)`, `show` or `pack` is called on it.
    * Realizing a container realizes the components it contains.
    There are a few exceptions to the rule. These are documented more fully in \[The Swing Connection\] but the key exceptions are:

    * It is safe to call the `repaint`, `revalidate` and `invalidate` methods on a Swing component from any thread.
    * It is safe to add and remove listeners from any thread. Therefore, any method of the form `add*Listener` or `remove*Listener` is thread-safe.

    ## Recommendation
    Ensure that method calls on Swing components are made from the event-dispatching thread. If you need to call a method on a Swing component from another thread, you must do so using the event-dispatching thread. Swing provides a `SwingUtilities` class that you can use to ask the event-dispatching thread to run arbitrary code on your components, by calling one of two methods. Each method takes a `Runnable` as its only argument:

    * `SwingUtilities.invokeLater` asks the event-dispatching thread to run some code and then immediately returns (that is, it is non-blocking). The code is run at some indeterminate time in the future, but the thread that calls `invokeLater` does not wait for it.
    * `SwingUtilities.invokeAndWait` asks the event-dispatching thread to run some code and then waits for it to complete (that is, it is blocking).

    ## Example
    In the following example, there is a call from the main thread to a method, `setTitle`, on the `MyFrame` object after the object has been realized by the `setVisible(true)` call. This represents an unsafe call to a Swing method from a thread other than the event-dispatching thread.


    ```java
    class MyFrame extends JFrame {
        public MyFrame() {
            setSize(640, 480);
            setTitle("BrokenSwing");
        }
    }

    public class BrokenSwing {
        private static void doStuff(MyFrame frame) {
            // BAD: Direct call to a Swing component after it has been realized
            frame.setTitle("Title");
        }

        public static void main(String[] args) {
            MyFrame frame = new MyFrame();
            frame.setVisible(true);
            doStuff(frame);
        }
    }
    ```
    In the following modified example, the call to `setTitle` is instead called from within a call to `invokeLater`.


    ```java
    class MyFrame extends JFrame {
        public MyFrame() {
            setSize(640, 480);
            setTitle("BrokenSwing");
        }
    }

    public class GoodSwing {
        private static void doStuff(final MyFrame frame) {
            SwingUtilities.invokeLater(new Runnable() {
                public void run() {
                    // GOOD: Call to Swing component made via the
                    // event-dispatching thread using 'invokeLater'
                    frame.setTitle("Title");
                }
            });
        }

        public static void main(String[] args) {
            MyFrame frame = new MyFrame();
            frame.setVisible(true);
            doStuff(frame);
        }
    }

    ```

    ## References
    * D. Flanagan, *Java Foundation Classes in a Nutshell*, p.28. O'Reilly, 1999.
    * Java Developer's Journal: [Building Thread-Safe GUIs with Swing](http://www.comscigate.com/JDJ/archives/0605/ford/index.html).
    * The Java Tutorials: [Concurrency in Swing](https://docs.oracle.com/javase/tutorial/uiswing/concurrency/index.html).
    * The Swing Connection: [Threads and Swing](https://www.comp.nus.edu.sg/~cs3283/ftp/Java/swingConnect/archive/tech_topics_arch/threads/threads.html).
 -
  pack: codeql/java-queries#0
  relativeQueryPath: Likely Bugs/I18N/MissingLocaleArgument.ql
  relativeBqrsPath: codeql/java-queries/Likely Bugs/I18N/MissingLocaleArgument.bqrs
  metadata:
    name: Missing Locale parameter to toUpperCase() or toLowerCase()
    description: |-
      Calling 'String.toUpperCase()' or 'String.toLowerCase()' without specifying the
                    locale may cause unexpected results for certain default locales.
    kind: problem
    problem.severity: recommendation
    precision: low
    id: java/missing-locale-argument
    tags: |-
      reliability
             maintainability
  queryHelp: |
    # Missing Locale parameter to toUpperCase() or toLowerCase()
    The parameterless versions of `String.toUpperCase()` and `String.toLowerCase()` use the default locale of the Java Virtual Machine when transforming strings. This can cause unexpected behavior for certain locales.


    ## Recommendation
    Use the corresponding methods with explicit locale parameters to ensure that the results are consistent across all locales. For example:

    `System.out.println("I".toLowerCase(java.util.Locale.ENGLISH));`

    prints `i`, regardless of the default locale.


    ## Example
    In the following example, the calls to the parameterless functions may return different strings for different locales. For example, if the default locale is ENGLISH, the function `toLowerCase()` converts a capital `I` to `i`; if the default locale is TURKISH, the function `toLowerCase()` converts a capital `I` to the Unicode Character "Latin small letter dotless i" (U+0131).

    To ensure that an English string is returned, regardless of the default locale, the example shows how to call `toLowerCase` and pass `locale.ENGLISH` as the argument. (This assumes that the text is English. If the text is Turkish, you should pass `locale.TURKISH` as the argument.)


    ```java
    public static void main(String args[]) {
        String phrase = "I miss my home in Mississippi.";

        // AVOID: Calling 'toLowerCase()' or 'toUpperCase()'
        // produces different results depending on what the default locale is.
        System.out.println(phrase.toUpperCase());
        System.out.println(phrase.toLowerCase());

        // GOOD: Explicitly setting the locale when calling 'toLowerCase()' or
        // 'toUpperCase()' ensures that the resulting string is
        // English, regardless of the default locale.
        System.out.println(phrase.toLowerCase(Locale.ENGLISH));
        System.out.println(phrase.toUpperCase(Locale.ENGLISH));
    }
    ```

    ## References
    * Java API Specification: [String.toUpperCase()](https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/lang/String.html#toUpperCase()).
 -
  pack: codeql/java-queries#0
  relativeQueryPath: Likely Bugs/Inheritance/NoNonFinalInConstructor.ql
  relativeBqrsPath: codeql/java-queries/Likely Bugs/Inheritance/NoNonFinalInConstructor.bqrs
  metadata:
    name: Non-final method invocation in constructor
    description: |-
      If a constructor calls a method that is overridden in a subclass, the result can be
                    unpredictable.
    kind: problem
    problem.severity: error
    precision: very-high
    id: java/non-final-call-in-constructor
    tags: |-
      reliability
             correctness
             logic
  queryHelp: "# Non-final method invocation in constructor\nIf a constructor calls\
    \ a method that is overridden in a subclass, it can cause the overriding method\
    \ in the subclass to be called before the subclass has been initialized. This\
    \ can lead to unexpected results.\n\n\n## Recommendation\nDo not call a non-final\
    \ method from within a constructor if that method could be overridden in a subclass.\n\
    \n\n## Example\nIn the following example, executing `new Sub(\"test\")` results\
    \ in a `NullPointerException`. This is because the subclass constructor implicitly\
    \ calls the superclass constructor, which in turn calls the overridden `init`\
    \ method before the field `s` is initialized in the subclass constructor.\n\n\n\
    ```java\npublic class Super {\n\tpublic Super() {\n\t\tinit();\n\t}\n\t\n\tpublic\
    \ void init() {\n\t}\n}\n\npublic class Sub extends Super {\n\tString s;\n\tint\
    \ length;\n\n\tpublic Sub(String s) {\n\t\tthis.s = s==null ? \"\" : s;\n\t}\n\
    \t\n\t@Override\n\tpublic void init() {\n\t\tlength = s.length();\n\t}\n}\n```\n\
    To avoid this problem:\n\n* The `init` method in the super constructor should\
    \ be made `final` or `private`.\n* The initialization that is performed in the\
    \ overridden `init` method in the subclass can be moved to the subclass constructor\
    \ itself, or delegated to a separate final or private method that is called from\
    \ within the subclass constructor.\n\n## References\n* J. Bloch, *Effective Java\
    \ (second edition)*, pp. 89&ndash;90. Addison-Wesley, 2008.\n* The Java Tutorials:\
    \ [Writing Final Classes and Methods](https://docs.oracle.com/javase/tutorial/java/IandI/final.html).\n"
 -
  pack: codeql/java-queries#0
  relativeQueryPath: Likely Bugs/Likely Typos/ConstructorTypo.ql
  relativeBqrsPath: codeql/java-queries/Likely Bugs/Likely Typos/ConstructorTypo.bqrs
  metadata:
    name: Typo in constructor
    description: |-
      A method that has the same name as its declaring type may have been intended to be
                    a constructor.
    kind: problem
    problem.severity: warning
    precision: low
    id: java/constructor-typo
    tags: |-
      maintainability
             readability
             naming
  queryHelp: "# Typo in constructor\nA method that has the same name as its declaring\
    \ type may be intended to be a constructor, not a method.\n\n\n## Example\nThe\
    \ following example shows how the singleton design pattern is often misimplemented.\
    \ The programmer intends the constructor of `MasterSingleton` to be protected\
    \ so that it cannot be instantiated (because the singleton instance should be\
    \ retrieved using `getInstance`). However, the programmer accidentally wrote `void`\
    \ in front of the constructor name, which makes it a method rather than a constructor.\n\
    \n\n```java\nclass MasterSingleton\n{\n\t// ...\n\n\tprivate static MasterSingleton\
    \ singleton = new MasterSingleton();\n\tpublic static MasterSingleton getInstance()\
    \ { return singleton; }\n\n\t// Make the constructor 'protected' to prevent this\
    \ class from being instantiated.\n\tprotected void MasterSingleton() { }\n}\n\n\
    ```\n\n## Recommendation\nEnsure that methods that have the same name as their\
    \ declaring type are intended to be methods. Even if they are intended to be methods,\
    \ it may be better to rename them to avoid confusion.\n\n\n## References\n* J.\
    \ Bloch and N. Gafter, *Java Puzzlers: Traps, Pitfalls, and Corner Cases*, Puzzle\
    \ 63. Addison-Wesley, 2005.\n* E. Gamma, R. Helm, R. Johnson, J. Vlissides, *Design\
    \ Patterns: Elements of Reusable Objection-Oriented Software*, &sect;3. Addison-Wesley\
    \ Longman Publishing Co. Inc., 1995.\n* Help - Eclipse Platform: [Java Compiler\
    \ Errors/Warnings Preferences](https://help.eclipse.org/2020-12/advanced/content.jsp?topic=/org.eclipse.jdt.doc.user/reference/preferences/java/compiler/ref-preferences-errors-warnings.htm).\n\
    * Java Language Specification: [8.4 Method Declarations](https://docs.oracle.com/javase/specs/jls/se11/html/jls-8.html#jls-8.4),\
    \ [8.8 Constructor Declarations](https://docs.oracle.com/javase/specs/jls/se11/html/jls-8.html#jls-8.8).\n"
 -
  pack: codeql/java-queries#0
  relativeQueryPath: Likely Bugs/Likely Typos/ContainerSizeCmpZero.ql
  relativeBqrsPath: codeql/java-queries/Likely Bugs/Likely Typos/ContainerSizeCmpZero.bqrs
  metadata:
    name: Container size compared to zero
    description: Comparing the size of a container to zero with this operator will
      always return the same value.
    kind: problem
    problem.severity: warning
    precision: very-high
    id: java/test-for-negative-container-size
    tags: |-
      reliability
             correctness
             logic
  queryHelp: |
    # Container size compared to zero
    A map, collection, string or array will always have size of at least zero. Checking that an object of one of these types has size greater than or equal to zero will always be true, while checking that it has size less than zero will always be false.


    ## Recommendation
    For collections, maps and strings, if the intention was to check whether the object was empty, is it preferred to use the `isEmpty()` method. For arrays, check that the `length` field is greater than (**not** equal to) zero.


    ## Example
    The following example shows creation of a file guarded by comparison of a string length with zero. This can result in the attempted creation of a file with an empty name.


    ```java
    import java.io.File;

    class ContainerSizeCmpZero
    {
        private static File MakeFile(String filename) {
        if(filename != null && filename.length() >= 0) {
            return new File(filename);
        }
        return new File("default.name");
        }
    }

    ```
    In the following revised example, the check against zero has been replaced with a call to `isEmpty()`. This correctly guards against the attempted creation of a file with an empty name.


    ```java
    import java.io.File;

    class ContainerSizeCmpZero
    {
        private static File MakeFile(String filename) {
        if(filename != null && !filename.isEmpty()) {
            return new File(filename);
        }
        return new File("default.name");
        }
    }

    ```

    ## References
    * Java API Specification: [ Collection.isEmpty()](https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/util/Collection.html#isEmpty()), [ Map.isEmpty()](https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/util/Map.html#isEmpty()), [ String.isEmpty()](https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/lang/String.html#isEmpty()).
 -
  pack: codeql/java-queries#0
  relativeQueryPath: Likely Bugs/Likely Typos/ContradictoryTypeChecks.ql
  relativeBqrsPath: codeql/java-queries/Likely Bugs/Likely Typos/ContradictoryTypeChecks.bqrs
  metadata:
    name: Contradictory type checks
    description: |-
      Contradictory dynamic type checks in `instanceof` expressions
                    and casts may cause dead code or even runtime errors, and usually
                    indicate a logic error.
    kind: problem
    problem.severity: error
    precision: very-high
    id: java/contradictory-type-checks
    tags: |-
      correctness
             logic
  queryHelp: "# Contradictory type checks\nIf an `instanceof` expression occurs in\
    \ a position where the type test is guaranteed to return `false`, this is often\
    \ due to a typo or logical mistake. It also suggests that the surrounding code\
    \ is not well tested, or possibly even dead.\n\nSimilarly, a cast that is guaranteed\
    \ to fail usually indicates badly tested or dead code.\n\n\n## Recommendation\n\
    Inspect the surrounding code for logical errors.\n\n\n## Example\nIn the following\
    \ example, method `getKind` first checks whether its argument `x` is an instance\
    \ of class `Mammal`, and then whether it is an instance of class `Tiger`.\n\n\n\
    ```java\nString getKind(Animal a) {\n\tif (a instanceof Mammal) {\n\t\treturn\
    \ \"Mammal\";\n\t} else if (a instanceof Tiger) {\n\t\treturn \"Tiger!\";\n\t\
    } else {\n\t\treturn \"unknown\";\n\t}\n}\n```\nIf `Tiger` is a subclass of `Mammal`,\
    \ then the second `instanceof` check can never evaluate to `true`. Clearly, the\
    \ two conditions should be swapped:\n\n\n```java\nString getKind(Animal a) {\n\
    \tif (a instanceof Tiger) {\n\t\treturn \"Tiger!\";\n\t} else if (a instanceof\
    \ Mammal) {\n\t\treturn \"Mammal\";\n\t} else {\n\t\treturn \"unknown\";\n\t}\n\
    }\n```\n\n## References\n* Java Language Specification: [Type Comparison Operator\
    \ instanceof](https://docs.oracle.com/javase/specs/jls/se11/html/jls-15.html#jls-15.20.2).\n"
 -
  pack: codeql/java-queries#0
  relativeQueryPath: Likely Bugs/Likely Typos/DangerousNonCircuitLogic.ql
  relativeBqrsPath: codeql/java-queries/Likely Bugs/Likely Typos/DangerousNonCircuitLogic.bqrs
  metadata:
    name: Dangerous non-short-circuit logic
    description: |-
      Using a bitwise logical operator on a boolean where a conditional-and or
                    conditional-or operator is intended may yield the wrong result or
                    cause an exception.
    kind: problem
    problem.severity: warning
    precision: medium
    id: java/non-short-circuit-evaluation
    tags: |-
      reliability
             readability
             external/cwe/cwe-691
  queryHelp: "# Dangerous non-short-circuit logic\nUsing a bitwise logical operator\
    \ (`&` or `|`) on a boolean where a conditional-and or conditional-or operator\
    \ (`&&` or `||`) is intended may yield the wrong result or cause an exception.\
    \ This is especially true if the left-hand operand is a guard for the right-hand\
    \ operand.\n\nTypically, as in the example below, this kind of defect is introduced\
    \ by simply mistyping the intended logical operator rather than any conceptual\
    \ mistake by the programmer.\n\n\n## Recommendation\nIf the right-hand side of\
    \ an expression is only intended to be evaluated if the left-hand side evaluates\
    \ to `true`, use a conditional-and.\n\nSimilarly, if the right-hand side of an\
    \ expression is only intended to be evaluated if the left-hand side evaluates\
    \ to `false`, use a conditional-or.\n\n\n## Example\nIn the following example,\
    \ the `hasForename` method is implemented correctly. For a forename to be valid\
    \ it must be a non-null string with a non-zero length. The method has two expressions\
    \ (`forename != null` and `forename.length() > 0`) to check these two properties.\
    \ The second check is executed only if the first succeeds, because they are combined\
    \ using a conditional-and operator (`&&`).\n\nIn contrast, although `hasSurname`\
    \ looks almost the same, it contains a defect. Again there are two tests (`surname\
    \ != null` and `surname.length() > 0`), but they are linked by a bitwise logical\
    \ operator (`&`). Both sides of a bitwise logical operator are *always* evaluated,\
    \ so if `surname` is `null` the `hasSurname` method throws a `NullPointerException`.\
    \ To fix the defect, change `&` to `&&`.\n\n\n```java\npublic class Person\n{\n\
    \tprivate String forename;\n\tprivate String surname;\n\n\tpublic boolean hasForename()\
    \ {\n\t\treturn forename != null && forename.length() > 0;  // GOOD: Conditional-and\
    \ operator\n\t}\n\n\tpublic boolean hasSurname() {\n\t\treturn surname != null\
    \ & surname.length() > 0;  // BAD: Bitwise AND operator\n\t}\n\n\t// ...\n}\n\
    ```\n\n## References\n* J. Bloch and N. Gafter, *Java Puzzlers: Traps, Pitfalls,\
    \ and Corner Cases*, Puzzle 42. Addison-Wesley, 2005.\n* Java Language Specification:\
    \ [15.22.2 Boolean Logical Operators &amp;, ^, and |](https://docs.oracle.com/javase/specs/jls/se11/html/jls-15.html#jls-15.22.2),\
    \ [15.23 Conditional-And Operator &amp;&amp;](https://docs.oracle.com/javase/specs/jls/se11/html/jls-15.html#jls-15.23),\
    \ [15.24 Conditional-Or Operator ||](https://docs.oracle.com/javase/specs/jls/se11/html/jls-15.html#jls-15.24).\n\
    * Common Weakness Enumeration: [CWE-691](https://cwe.mitre.org/data/definitions/691.html).\n"
 -
  pack: codeql/java-queries#0
  relativeQueryPath: Likely Bugs/Likely Typos/EqualsTypo.ql
  relativeBqrsPath: codeql/java-queries/Likely Bugs/Likely Typos/EqualsTypo.bqrs
  metadata:
    name: Typo in equals
    description: A method named 'equal' may be intended to be named 'equals'.
    kind: problem
    problem.severity: warning
    precision: medium
    id: java/equals-typo
    tags: |-
      maintainability
             readability
             naming
  queryHelp: "# Typo in equals\nA method named `equal` may be a typographical error.\
    \ `equals` may have been intended instead.\n\n\n## Recommendation\nEnsure that\
    \ any such method is intended to have this name. Even if it is, it may be better\
    \ to rename it to avoid confusion with the inherited method `Object.equals`.\n\
    \n\n## Example\nThe following example shows a method named `equal`. It may be\
    \ better to rename it.\n\n\n```java\npublic class Complex\n{\n\tprivate double\
    \ real;\n\tprivate double complex;\n\n\t// ...\n\n\tpublic boolean equal(Object\
    \ obj) {  // The method is named 'equal'.\n\t\tif (!getClass().equals(obj.getClass()))\n\
    \t\t\treturn false;\n\t\tComplex other = (Complex) obj;\n\t\treturn real == other.real\
    \ && complex == other.complex;\n\t}\n}\n```\n\n## References\n* Java API Specification:\
    \ [ equals](https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/lang/Object.html#equals(java.lang.Object)).\n"
 -
  pack: codeql/java-queries#0
  relativeQueryPath: Likely Bugs/Likely Typos/HashCodeTypo.ql
  relativeBqrsPath: codeql/java-queries/Likely Bugs/Likely Typos/HashCodeTypo.bqrs
  metadata:
    name: Typo in hashCode
    description: A method named 'hashcode' may be intended to be named 'hashCode'.
    kind: problem
    problem.severity: warning
    precision: medium
    id: java/hashcode-typo
    tags: |-
      maintainability
             readability
             naming
  queryHelp: "# Typo in hashCode\nA method named `hashcode` may be a typographical\
    \ error. `hashCode` (different capitalization) may have been intended instead.\n\
    \n\n## Recommendation\nEnsure that any such method is intended to have this name.\
    \ Even if it is, it may be better to rename it to avoid confusion with the inherited\
    \ method `Object.hashCode`.\n\n\n## Example\nThe following example shows a method\
    \ named `hashcode`. It may be better to rename it.\n\n\n```java\npublic class\
    \ Person\n{\n\tprivate String title;\n\tprivate String forename;\n\tprivate String\
    \ surname;\n\n\t// ...\n\n\tpublic int hashcode() {  // The method is named 'hashcode'.\n\
    \t\tint hash = 23 * title.hashCode();\n\t\thash ^= 13 * forename.hashCode();\n\
    \t\treturn hash ^ surname.hashCode();\n\t}\n}\n```\n\n## References\n* Java API\
    \ Specification: [ Object.hashCode](https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/lang/Object.html#hashCode()).\n"
 -
  pack: codeql/java-queries#0
  relativeQueryPath: Likely Bugs/Likely Typos/MissingFormatArg.ql
  relativeBqrsPath: codeql/java-queries/Likely Bugs/Likely Typos/MissingFormatArg.bqrs
  metadata:
    name: Missing format argument
    description: |-
      A format call with an insufficient number of arguments causes
                    an 'IllegalFormatException'.
    kind: problem
    problem.severity: error
    precision: very-high
    id: java/missing-format-argument
    tags: |-
      correctness
             external/cwe/cwe-685
  queryHelp: |
    # Missing format argument
    When formatting strings using `printf`-style format strings, one must ensure that the number of supplied arguments matches the number of arguments referenced by the format string. Additional arguments will be thrown away silently, which may not be the intended behavior, and too few arguments will cause an `IllegalFormatException`.

    Format strings are used by the `format` method on the classes `String`, `Formatter`, `Console`, `PrintWriter`, and `PrintStream`. Several of these classes also supply the method alias `printf`. The class `Console` has two additional methods, `readLine` and `readPassword`, that also use format strings.


    ## Recommendation
    Supply the correct number of arguments to the format method, or change the format string to use the correct arguments.


    ## Example
    The following example supplies only one argument to be formatted, but the format string refers to two arguments, so this will throw an `IllegalFormatException`.


    ```java
    System.out.format("First string: %s Second string: %s", "Hello world");

    ```

    ## References
    * Java API Specification: [Format string syntax](https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/util/Formatter.html#syntax), [Class String](https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/lang/String.html), [Class Formatter](https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/util/Formatter.html), [Class Console](https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/io/Console.html), [Class PrintWriter](https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/io/PrintWriter.html), [Class PrintStream](https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/io/PrintStream.html).
    * SLF4J library: [org.slf4j.Logger](https://www.slf4j.org/apidocs/org/slf4j/Logger.html).
    * Common Weakness Enumeration: [CWE-685](https://cwe.mitre.org/data/definitions/685.html).
 -
  pack: codeql/java-queries#0
  relativeQueryPath: Likely Bugs/Likely Typos/MissingSpaceTypo.ql
  relativeBqrsPath: codeql/java-queries/Likely Bugs/Likely Typos/MissingSpaceTypo.bqrs
  metadata:
    name: Missing space in string literal
    description: |-
      Joining strings at compile-time to construct a string literal
                    so that two words are concatenated without a separating space
                    usually indicates a text error.
    kind: problem
    problem.severity: recommendation
    precision: very-high
    id: java/missing-space-in-concatenation
    tags: readability
  queryHelp: |
    # Missing space in string literal
    Splitting a long string literal over multiple lines can often aid readability, but this also makes it difficult to notice whether a space is missing where the strings are concatenated.


    ## Recommendation
    Check the string literal to see whether it has the intended text. In particular, look for missing spaces near line breaks.


    ## Example
    The following example shows a text literal that is split over two lines and omits a space character between the two words at the line break.


    ```java
    String s = "This text is" +
      "missing a space.";

    ```

    ## References
    * Java Language Specification: [String Literals](https://docs.oracle.com/javase/specs/jls/se11/html/jls-3.html#jls-3.10.5).
 -
  pack: codeql/java-queries#0
  relativeQueryPath: Likely Bugs/Likely Typos/NestedLoopsSameVariable.ql
  relativeBqrsPath: codeql/java-queries/Likely Bugs/Likely Typos/NestedLoopsSameVariable.bqrs
  metadata:
    name: Nested loops with same variable
    description: |-
      Nested loops in which the iteration variable is the same for each loop are difficult
                    to understand.
    kind: problem
    problem.severity: warning
    precision: low
    id: java/nested-loops-with-same-variable
    tags: |-
      maintainability
             correctness
             logic
  queryHelp: |
    # Nested loops with same variable
    The behavior of nested loops in which the iteration variable is the same for both loops is difficult to understand because the inner loop affects the iteration variable of the outer loop. This is probably a typographical error.


    ## Recommendation
    Ensure that a different iteration variable is used for each loop.


    ## References
    * Java Language Specification: [The basic for Statement](https://docs.oracle.com/javase/specs/jls/se11/html/jls-14.html#jls-14.14.1).
 -
  pack: codeql/java-queries#0
  relativeQueryPath: Likely Bugs/Likely Typos/SelfAssignment.ql
  relativeBqrsPath: codeql/java-queries/Likely Bugs/Likely Typos/SelfAssignment.bqrs
  metadata:
    name: Self assignment
    description: Assigning a variable to itself has no effect.
    kind: problem
    problem.severity: error
    precision: very-high
    id: java/redundant-assignment
    tags: |-
      reliability
             correctness
             logic
  queryHelp: |
    # Self assignment
    Assigning a variable to itself does not have any effect. Therefore, such an assignment is either completely unnecessary, or it indicates a typo or a similar mistake.


    ## Recommendation
    If the assignment is unnecessary, remove it. If the assignment indicates a typo or a similar mistake, correct the mistake.


    ## Example
    The following example shows part of a method that is intended to make a copy of an existing `MotionEvent` without preserving its history. On line 8, `o.mFlags` is assigned to itself. Given that the statement is surrounded by statements that transfer information from the fields of `o` to the fields of the new event, `ev`, the statement is clearly a mistake. To correct this, the `mFlags` value should be assigned to `ev.mFlags` instead, as shown in the corrected method.


    ```java
    static public MotionEvent obtainNoHistory(MotionEvent o) {
        MotionEvent ev = obtain(o.mNumPointers, 1);
        ev.mDeviceId = o.mDeviceId;
        o.mFlags = o.mFlags;  // Variable is assigned to itself
        ...
    }

    static public MotionEvent obtainNoHistory(MotionEvent o) {
        MotionEvent ev = obtain(o.mNumPointers, 1);
        ev.mDeviceId = o.mDeviceId;
        ev.mFlags = o.mFlags;  // Variable is assigned correctly
        ...
    }

    ```

    ## References
    * Help - Eclipse Platform: [Java Compiler Errors/Warnings Preferences](https://help.eclipse.org/2020-12/advanced/content.jsp?topic=/org.eclipse.jdt.doc.user/reference/preferences/java/compiler/ref-preferences-errors-warnings.htm).
 -
  pack: codeql/java-queries#0
  relativeQueryPath: Likely Bugs/Likely Typos/StringBufferCharInit.ql
  relativeBqrsPath: codeql/java-queries/Likely Bugs/Likely Typos/StringBufferCharInit.bqrs
  metadata:
    name: Character passed to StringBuffer or StringBuilder constructor
    description: |-
      A character value is passed to the constructor of 'StringBuffer' or 'StringBuilder'. This value will
                    be converted to an integer and interpreted as the buffer's initial capacity, which is probably not intended.
    kind: problem
    problem.severity: error
    precision: very-high
    id: java/string-buffer-char-init
    tags: |-
      reliability
             maintainability
  queryHelp: "# Character passed to StringBuffer or StringBuilder constructor\nPassing\
    \ a character to the constructor of `StringBuffer` or `StringBuilder` is probably\
    \ intended to insert the character into the newly created buffer. In fact, however,\
    \ the character value is converted to an integer and interpreted as the buffer's\
    \ initial capacity, which may yield unexpected results.\n\n\n## Example\nThe following\
    \ example shows a class representing points in two-dimensional Cartesian coordinates.\
    \ The `toString` method uses a `StringBuffer` to construct a human-readable representation\
    \ of the form `(x, y)`, where `x` and `y` are the point's coordinates.\n\nHowever,\
    \ the opening parenthesis is passed to the `StringBuffer` constructor as character\
    \ literal. Instead of being used to initialise the buffer's contents, the character\
    \ is converted to the integer value 40 and interpreted as the buffer's initial\
    \ capacity. Thus, the string representation returned by `toString` will be missing\
    \ the opening parenthesis. (Note that passing a character to `append`, on the\
    \ other hand, is unproblematic.)\n\n\n```java\nclass Point {\n\tprivate double\
    \ x, y;\n\t\n\tpublic Point(double x, double y) {\n\t\tthis.x = x;\n\t\tthis.y\
    \ = y;\n\t}\n\t\n\t@Override\n\tpublic String toString() {\n\t\tStringBuffer res\
    \ = new StringBuffer('(');\n\t\tres.append(x);\n\t\tres.append(\", \");\n\t\t\
    res.append(y);\n\t\tres.append(')');\n\t\treturn res.toString();\n\t}\n}\n\n```\n\
    \n## Recommendation\nIf the character used to initialize the buffer is a character\
    \ literal, simply replace it with the corresponding string literal. So, in our\
    \ example, replace `new StringBuffer('(')` with `new StringBuffer(\"(\")`. If\
    \ the character is not a literal value, use method `String.valueOf` to convert\
    \ it to a string.\n\n\n## References\n* J. Bloch and N. Gafter, *Java Puzzlers:\
    \ Traps, Pitfalls, and Corner Cases*, Puzzle 23. Addison-Wesley, 2005.\n* NetBeans\
    \ IDE: [Java Hints](https://web.archive.org/web/20210117160808/http://wiki.netbeans.org/Java_Hints)\n\
    * PMD: [Rule StringBufferInstantiationWithChar](https://pmd.github.io/latest/pmd_rules_java_errorprone.html#stringbufferinstantiationwithchar)\n\
    * Java API: [StringBuffer](https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/lang/StringBuffer.html),\
    \ [java.lang.StringBuilder](https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/lang/StringBuilder.html).\n"
 -
  pack: codeql/java-queries#0
  relativeQueryPath: Likely Bugs/Likely Typos/SuspiciousDateFormat.ql
  relativeBqrsPath: codeql/java-queries/Likely Bugs/Likely Typos/SuspiciousDateFormat.bqrs
  metadata:
    name: Suspicious date format
    description: Using a data format that includes both 'M' and 'Y' is likely to give
      unexpected results.
    kind: problem
    problem.severity: warning
    precision: high
    id: java/suspicious-date-format
    tags: correctness
  queryHelp: |
    # Suspicious date format
    The Java `SimpleDateFormat` class provides many placeholders so that you can define precisely the date format required. However, this also makes it easy to define a pattern that doesn't behave exactly as you intended. The most common mistake is to use the `Y` placeholder (which represents the ISO 8601 week year), rather than `y` (which represents the actual year). In this case, the date reported will appear correct until the end of the year, when the "week year" may differ from the actual year.


    ## Recommendation
    Ensure the format pattern's use of `Y` is correct, and if not replace it with `y`.


    ## Example
    The following example uses the date format `YYYY-MM-dd`. On the 30th of December 2019, this code will output "2020-12-30", rather than the intended "2019-12-30".


    ```java
    System.out.println(new SimpleDateFormat("YYYY-MM-dd").format(new Date()));

    ```
    The correct pattern in this case would be `yyyy-MM-dd` instead of `YYYY-MM-dd`.


    ## References
    * Java API Specification: [SimpleDateFormat](https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/text/SimpleDateFormat.html).
 -
  pack: codeql/java-queries#0
  relativeQueryPath: Likely Bugs/Likely Typos/ToStringTypo.ql
  relativeBqrsPath: codeql/java-queries/Likely Bugs/Likely Typos/ToStringTypo.bqrs
  metadata:
    name: Typo in toString
    description: A method named 'tostring' may be intended to be named 'toString'.
    kind: problem
    problem.severity: warning
    precision: medium
    id: java/tostring-typo
    tags: |-
      maintainability
             readability
             naming
  queryHelp: "# Typo in toString\nA method named `tostring` may be a typographical\
    \ error. `toString` (different capitalization) may have been intended instead.\n\
    \n\n## Recommendation\nEnsure that any such method is intended to have this name.\
    \ Even if it is, it may be better to rename it to avoid confusion with the inherited\
    \ method `Object.toString`.\n\n\n## Example\nThe following example shows a method\
    \ named `tostring`. It may be better to rename it.\n\n\n```java\npublic class\
    \ Customer\n{\n\tprivate String title;\n\tprivate String forename;\n\tprivate\
    \ String surname;\n\n\t// ...\n\n\tpublic String tostring() {  // The method is\
    \ named 'tostring'.\n\t\treturn title + \" \" + forename + \" \" + surname;\n\t\
    }\n}\n```\n\n## References\n* Java API Specification: [ Object.toString](https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/lang/Object.html#toString()).\n"
 -
  pack: codeql/java-queries#0
  relativeQueryPath: Likely Bugs/Likely Typos/UnusedFormatArg.ql
  relativeBqrsPath: codeql/java-queries/Likely Bugs/Likely Typos/UnusedFormatArg.bqrs
  metadata:
    name: Unused format argument
    description: |-
      A format call with a format string that refers to fewer
                    arguments than the number of supplied arguments will silently
                    ignore the additional arguments.
    kind: problem
    problem.severity: warning
    precision: very-high
    id: java/unused-format-argument
    tags: |-
      maintainability
             useless-code
             external/cwe/cwe-685
  queryHelp: |
    # Unused format argument
    When formatting strings using `printf`-style format strings, one must ensure that the number of supplied arguments matches the number of arguments referenced by the format string. Additional arguments will be thrown away silently, which may not be the intended behavior, and too few arguments will cause an `IllegalFormatException`.

    Format strings are used by the `format` method on the classes `String`, `Formatter`, `Console`, `PrintWriter`, and `PrintStream`. Several of these classes also supply the method alias `printf`. The class `Console` has two additional methods, `readLine` and `readPassword`, that also use format strings.


    ## Recommendation
    Change the format string to use all the arguments, or remove the unnecessary arguments.


    ## Example
    The following example supplies three arguments to be formatted, but the format string only refers to two arguments, so this will silently ignore the third argument.


    ```java
    System.out.format("First string: %s Second string: %s", "Hello", "world", "!");

    ```

    ## References
    * Java API Specification: [Format string syntax](https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/util/Formatter.html#syntax), [Class String](https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/lang/String.html), [Class Formatter](https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/util/Formatter.html), [Class Console](https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/io/Console.html), [Class PrintWriter](https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/io/PrintWriter.html), [Class PrintStream](https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/io/PrintStream.html).
    * SLF4J library: [org.slf4j.Logger](https://www.slf4j.org/apidocs/org/slf4j/Logger.html).
    * Common Weakness Enumeration: [CWE-685](https://cwe.mitre.org/data/definitions/685.html).
 -
  pack: codeql/java-queries#0
  relativeQueryPath: Likely Bugs/Nullness/NullAlways.ql
  relativeBqrsPath: codeql/java-queries/Likely Bugs/Nullness/NullAlways.bqrs
  metadata:
    name: Dereferenced variable is always null
    description: Dereferencing a variable whose value is 'null' causes a 'NullPointerException'.
    kind: problem
    problem.severity: error
    precision: very-high
    id: java/dereferenced-value-is-always-null
    tags: |-
      reliability
             correctness
             exceptions
             external/cwe/cwe-476
  queryHelp: "# Dereferenced variable is always null\nIf a variable is dereferenced,\
    \ and the variable has a `null` value on all possible execution paths leading\
    \ to the dereferencing, the dereferencing is guaranteed to result in a `NullPointerException`.\n\
    \nA variable may also be implicitly dereferenced if its type is a boxed primitive\
    \ type, and the variable occurs in a context in which implicit unboxing occurs.\
    \ Note that the conditional operator unboxes its second and third operands when\
    \ one of them is a primitive type and the other is the corresponding boxed type.\n\
    \n\n## Recommendation\nEnsure that the variable does not have a `null` value when\
    \ it is dereferenced.\n\n\n## Example\nIn the following examples, the condition\
    \ `!dir.exists()` is only executed if `dir` is `null`. The second example guards\
    \ the expression correctly by using `&&` instead of `||`.\n\n\n```java\npublic\
    \ void createDir(File dir) {\n\tif (dir != null || !dir.exists()) // BAD\n\t\t\
    dir.mkdir();\n}\n\npublic void createDir(File dir) {\n\tif (dir != null && !dir.exists())\
    \ // GOOD\n\t\tdir.mkdir();\n}\n\n```\n\n## References\n* The Java Tutorials:\
    \ [Autoboxing and Unboxing](https://docs.oracle.com/javase/tutorial/java/data/autoboxing.html).\n\
    * Java Language Specification: [Conditional Operator ? :](https://docs.oracle.com/javase/specs/jls/se11/html/jls-15.html#jls-15.25).\n\
    * Common Weakness Enumeration: [CWE-476](https://cwe.mitre.org/data/definitions/476.html).\n"
 -
  pack: codeql/java-queries#0
  relativeQueryPath: Likely Bugs/Nullness/NullExprDeref.ql
  relativeBqrsPath: codeql/java-queries/Likely Bugs/Nullness/NullExprDeref.bqrs
  metadata:
    name: Dereferenced expression may be null
    description: |-
      Dereferencing an expression whose value may be 'null' may cause a
                    'NullPointerException'.
    kind: problem
    problem.severity: warning
    precision: high
    id: java/dereferenced-expr-may-be-null
    tags: |-
      reliability
             correctness
             exceptions
             external/cwe/cwe-476
  queryHelp: |
    # Dereferenced expression may be null
    Dereferencing a `null` value leads to a `NullPointerException`.

    An expression may be implicitly dereferenced if its type is a boxed primitive type, and it occurs in a context in which implicit unboxing occurs.


    ## Recommendation
    Ensure that the expression does not have a `null` value when it is dereferenced. Use boxed types as appropriate to hold values that are potentially `null`.


    ## Example
    In the following example implicit unboxing can cause a `NullPointerException` if `helper` is `null`.


    ```java
    public int getID() {
        return helper == null ? null : helper.getID();
    }

    ```
    If the method is intended to return `null`, the return type should be changed to `Integer`.


    ## References
    * The Java Tutorials: [Autoboxing and Unboxing](https://docs.oracle.com/javase/tutorial/java/data/autoboxing.html).
    * Common Weakness Enumeration: [CWE-476](https://cwe.mitre.org/data/definitions/476.html).
 -
  pack: codeql/java-queries#0
  relativeQueryPath: Likely Bugs/Nullness/NullMaybe.ql
  relativeBqrsPath: codeql/java-queries/Likely Bugs/Nullness/NullMaybe.bqrs
  metadata:
    name: Dereferenced variable may be null
    description: |-
      Dereferencing a variable whose value may be 'null' may cause a
                    'NullPointerException'.
    kind: problem
    problem.severity: warning
    precision: high
    id: java/dereferenced-value-may-be-null
    tags: |-
      reliability
             correctness
             exceptions
             external/cwe/cwe-476
             non-local
  queryHelp: "# Dereferenced variable may be null\nIf a variable is dereferenced,\
    \ and the variable may have a `null` value on some execution paths leading to\
    \ the dereferencing, the dereferencing may result in a `NullPointerException`.\n\
    \nA variable may also be implicitly dereferenced if its type is a boxed primitive\
    \ type, and the variable occurs in a context in which implicit unboxing occurs.\
    \ Note that the conditional operator unboxes its second and third operands when\
    \ one of them is a primitive type and the other is the corresponding boxed type.\n\
    \n\n## Recommendation\nEnsure that the variable does not have a `null` value when\
    \ it is dereferenced.\n\n\n## Example\nIn the following example, the use of the\
    \ conditional operator causes implicit unboxing, since the integer literal has\
    \ type `int`. If the parameter `p` is ever `null` then a `NullPointerException`\
    \ will occur.\n\n\n```java\npublic Integer f(Integer p) {\n\treturn true ? p :\
    \ 5;\n}\n\n```\nIf the implicit unboxing is unintentional, it can be prevented\
    \ by making sure that both branches of the conditional operator have the same\
    \ type.\n\n\n## References\n* The Java Tutorials: [Autoboxing and Unboxing](https://docs.oracle.com/javase/tutorial/java/data/autoboxing.html).\n\
    * Java Language Specification: [Conditional Operator ? :](https://docs.oracle.com/javase/specs/jls/se11/html/jls-15.html#jls-15.25).\n\
    * Common Weakness Enumeration: [CWE-476](https://cwe.mitre.org/data/definitions/476.html).\n"
 -
  pack: codeql/java-queries#0
  relativeQueryPath: Likely Bugs/Reflection/AnnotationPresentCheck.ql
  relativeBqrsPath: codeql/java-queries/Likely Bugs/Reflection/AnnotationPresentCheck.bqrs
  metadata:
    name: AnnotationPresent check
    description: |-
      If an annotation has not been annotated with a 'RUNTIME' retention policy, checking
                    for its presence at runtime is not possible.
    kind: problem
    problem.severity: error
    precision: medium
    id: java/ineffective-annotation-present-check
    tags: |-
      correctness
             logic
  queryHelp: "# AnnotationPresent check\nTo be able to use the `isAnnotationPresent`\
    \ method on an `AnnotatedElement` at runtime, an annotation must be explicitly\
    \ annotated with a `RUNTIME` retention policy. Otherwise, the annotation is not\
    \ retained at runtime and cannot be observed using reflection.\n\n\n## Recommendation\n\
    Explicitly annotate annotations with a `RUNTIME` retention policy if you want\
    \ to observe their presence using `AnnotatedElement.isAnnotationPresent` at runtime.\n\
    \n\n## Example\nIn the following example, the call to `isAnnotationPresent` returns\
    \ `false` because the annotation cannot be observed using reflection.\n\n\n```java\n\
    public class AnnotationPresentCheck {\n\tpublic static @interface UntrustedData\
    \ { }\n\n\t@UntrustedData\n\tpublic static String getUserData() {\n\t\tScanner\
    \ scanner = new Scanner(System.in);\n\t\treturn scanner.nextLine();\n\t}\n\n\t\
    public static void main(String[] args) throws NoSuchMethodException, SecurityException\
    \ {\n\t\tString data = getUserData();\n\t\tMethod m = AnnotationPresentCheck.class.getMethod(\"\
    getUserData\");\n\t\tif(m.isAnnotationPresent(UntrustedData.class)) {  // Returns\
    \ 'false'\n\t\t\tSystem.out.println(\"Not trusting data from user.\");\n\t\t}\n\
    \t}\n}\n```\nTo correct this, the annotation is annotated with a `RUNTIME` retention\
    \ policy.\n\n\n```java\npublic class AnnotationPresentCheckFix {\n\t@Retention(RetentionPolicy.RUNTIME)\
    \  // Annotate the annotation\n\tpublic static @interface UntrustedData { }\n\n\
    \t@UntrustedData\n\tpublic static String getUserData() {\n\t\tScanner scanner\
    \ = new Scanner(System.in);\n\t\treturn scanner.nextLine();\n\t}\n\n\tpublic static\
    \ void main(String[] args) throws NoSuchMethodException, SecurityException {\n\
    \t\tString data = getUserData();\n\t\tMethod m = AnnotationPresentCheckFix.class.getMethod(\"\
    getUserData\");\n\t\tif(m.isAnnotationPresent(UntrustedData.class)) {  // Returns\
    \ 'true'\n\t\t\tSystem.out.println(\"Not trusting data from user.\");\n\t\t}\n\
    \t}\n}\n```\n\n## References\n* Java API Specification: [Annotation Type Retention](https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/lang/annotation/Retention.html),\
    \ [RetentionPolicy.RUNTIME](https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/lang/annotation/RetentionPolicy.html#RUNTIME),\
    \ [AnnotatedElement.isAnnotationPresent()](https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/lang/reflect/AnnotatedElement.html#isAnnotationPresent(java.lang.Class)).\n"
 -
  pack: codeql/java-queries#0
  relativeQueryPath: Likely Bugs/Resource Leaks/CloseReader.ql
  relativeBqrsPath: codeql/java-queries/Likely Bugs/Resource Leaks/CloseReader.bqrs
  metadata:
    name: Potential input resource leak
    description: |-
      A resource that is opened for reading but not closed may cause a resource
                    leak.
    kind: problem
    problem.severity: warning
    precision: high
    id: java/input-resource-leak
    tags: |-
      efficiency
             correctness
             resources
             external/cwe/cwe-404
             external/cwe/cwe-772
  queryHelp: "# Potential input resource leak\nA subclass of `Reader` or `InputStream`\
    \ that is opened for reading but not closed may cause a resource leak.\n\n\n##\
    \ Recommendation\nEnsure that the resource is always closed to avoid a resource\
    \ leak. Note that, because of exceptions, it is safest to close a resource in\
    \ a `finally` block. (However, this is unnecessary for subclasses of `CharArrayReader`,\
    \ `StringReader` and `ByteArrayInputStream`.)\n\nFor Java 7 or later, the recommended\
    \ way to close resources that implement `java.lang.AutoCloseable` is to declare\
    \ them within a `try-with-resources` statement, so that they are closed implicitly.\n\
    \n\n## Example\nIn the following example, the resource `br` is opened but not\
    \ closed.\n\n\n```java\npublic class CloseReader {\n\tpublic static void main(String[]\
    \ args) throws IOException {\n\t\tBufferedReader br = new BufferedReader(new FileReader(\"\
    C:\\\\test.txt\"));\n\t\tSystem.out.println(br.readLine());\n\t\t// ...\n\t}\n\
    }\n```\nIn the following example, the resource `br` is opened in a `try` block\
    \ and later closed in a `finally` block.\n\n\n```java\npublic class CloseReaderFix\
    \ {\n\tpublic static void main(String[] args) throws IOException {\n\t\tBufferedReader\
    \ br = null;\n\t\ttry {\n\t\t\tbr = new BufferedReader(new FileReader(\"C:\\\\\
    test.txt\"));\n\t\t\tSystem.out.println(br.readLine());\n\t\t}\n\t\tfinally {\n\
    \t\t\tif(br != null)\n\t\t\t\tbr.close();  // 'br' is closed\n\t\t}\n\t\t// ...\n\
    \t}\n}\n```\nNote that nested class instance creation expressions of `Reader`s\
    \ or `InputStream`s are not safe to use if the constructor of the outer expression\
    \ may throw an exception. In the following example, the `InputStreamReader` may\
    \ throw an exception, in which case the inner `FileInputStream` is not closed.\n\
    \n\n```java\npublic class CloseReaderNested {\n\tpublic static void main(String[]\
    \ args) throws IOException {\n\t\tInputStreamReader reader = null;\n\t\ttry {\n\
    \t\t\t// InputStreamReader may throw an exception, in which case the ...\n\t\t\
    \treader = new InputStreamReader(\n\t\t\t\t\t// ... FileInputStream is not closed\
    \ by the finally block\n\t\t\t\t\tnew FileInputStream(\"C:\\\\test.txt\"), \"\
    UTF-8\");\n\t\t\tSystem.out.println(reader.read());\n\t\t}\n\t\tfinally {\n\t\t\
    \tif (reader != null)\n\t\t\t\treader.close();\n\t\t}\n\t}\n}\n```\nIn this case,\
    \ the inner expression needs to be assigned to a local variable and closed separately,\
    \ as shown below.\n\n\n```java\npublic class CloseReaderNestedFix {\n\tpublic\
    \ static void main(String[] args) throws IOException {\n\t\tFileInputStream fis\
    \ = null;\n\t\tInputStreamReader reader = null;\n\t\ttry {\n\t\t\tfis = new FileInputStream(\"\
    C:\\\\test.txt\");\n\t\t\treader = new InputStreamReader(fis);\n\t\t\tSystem.out.println(reader.read());\n\
    \t\t}\n\t\tfinally {\n\t\t\tif (reader != null)\n\t\t\t\treader.close();  // 'reader'\
    \ is closed\n\t\t\tif (fis != null)\n\t\t\t\tfis.close();  // 'fis' is closed\n\
    \t\t}\n\t}\n}\n```\n\n## References\n* IBM developerWorks: [Java theory and practice:\
    \ Good housekeeping practices](https://web.archive.org/web/20201109041839/http://www.ibm.com/developerworks/java/library/j-jtp03216/index.html).\n\
    * The Java Tutorials: [The try-with-resources Statement](https://docs.oracle.com/javase/tutorial/essential/exceptions/tryResourceClose.html).\n\
    * Common Weakness Enumeration: [CWE-404](https://cwe.mitre.org/data/definitions/404.html).\n\
    * Common Weakness Enumeration: [CWE-772](https://cwe.mitre.org/data/definitions/772.html).\n"
 -
  pack: codeql/java-queries#0
  relativeQueryPath: Likely Bugs/Resource Leaks/CloseSql.ql
  relativeBqrsPath: codeql/java-queries/Likely Bugs/Resource Leaks/CloseSql.bqrs
  metadata:
    name: Potential database resource leak
    description: A database resource that is opened but not closed may cause a resource
      leak.
    kind: problem
    problem.severity: warning
    precision: high
    id: java/database-resource-leak
    tags: |-
      correctness
             resources
             external/cwe/cwe-404
             external/cwe/cwe-772
  queryHelp: "# Potential database resource leak\nA database resource in the `java.sql`\
    \ package that is opened but not closed may cause a resource leak and ultimately\
    \ resource exhaustion.\n\n\n## Recommendation\nEnsure that the resource is always\
    \ closed to avoid a resource leak. Note that, because of exceptions, it is safest\
    \ to close a resource in a `finally` block.\n\nFor Java 7 or later, the recommended\
    \ way to close resources that implement `java.lang.AutoCloseable` is to declare\
    \ them within a `try-with-resources` statement, so that they are closed implicitly.\n\
    \n\n## Example\nIn the following example, the resources `stmt` and `rs` are opened\
    \ but not closed.\n\n\n```java\npublic class CloseSql {\n\tpublic static void\
    \ runQuery(Connection con, String query) throws SQLException {\n\t\tStatement\
    \ stmt = con.createStatement();\n\t\tResultSet rs = stmt.executeQuery(query);\n\
    \t\twhile (rs.next()) {\n\t\t\t// process result set\n\t\t}\n\t}\n}\n```\nIn the\
    \ following example, the resources `stmt` and `rs` are declared within a `try-with-resources`\
    \ block and are thus closed implicitly.\n\n\n```java\npublic class CloseSqlGood\
    \ {\n\tpublic static void runQuery(Connection con, String query) throws SQLException\
    \ {\n\t\ttry (Statement stmt = con.createStatement();\n\t\t\t\tResultSet rs =\
    \ stmt.executeQuery(query)) {\n\t\t\twhile (rs.next()) {\n\t\t\t\t// process result\
    \ set\n\t\t\t}\n\t\t}\n\t}\n}\n```\nNote that the `Connection` that is passed\
    \ into the method is a long-lived object that was created elsewhere and therefore\
    \ need not be closed locally. It should instead be closed by the code that created\
    \ it or by a server shutdown procedure, as appropriate.\n\n\n## References\n*\
    \ IBM developerWorks: [Java theory and practice: Good housekeeping practices](https://web.archive.org/web/20201109041839/http://www.ibm.com/developerworks/java/library/j-jtp03216/index.html).\n\
    * The Java Tutorials: [The try-with-resources Statement](https://docs.oracle.com/javase/tutorial/essential/exceptions/tryResourceClose.html).\n\
    * Common Weakness Enumeration: [CWE-404](https://cwe.mitre.org/data/definitions/404.html).\n\
    * Common Weakness Enumeration: [CWE-772](https://cwe.mitre.org/data/definitions/772.html).\n"
 -
  pack: codeql/java-queries#0
  relativeQueryPath: Likely Bugs/Resource Leaks/CloseWriter.ql
  relativeBqrsPath: codeql/java-queries/Likely Bugs/Resource Leaks/CloseWriter.bqrs
  metadata:
    name: Potential output resource leak
    description: |-
      A resource that is opened for writing but not closed may cause a resource
                    leak.
    kind: problem
    problem.severity: warning
    precision: high
    id: java/output-resource-leak
    tags: |-
      efficiency
             correctness
             resources
             external/cwe/cwe-404
             external/cwe/cwe-772
  queryHelp: "# Potential output resource leak\nA subclass of `Writer` or `OutputStream`\
    \ that is opened for writing but not properly closed later may cause a resource\
    \ leak.\n\n\n## Recommendation\nEnsure that the resource is always closed to avoid\
    \ a resource leak. Note that, because of exceptions, it is safest to close a resource\
    \ properly in a `finally` block. (However, this is unnecessary for subclasses\
    \ of `CharArrayWriter`, `StringWriter` and `ByteArrayOutputStream`.)\n\nFor Java\
    \ 7 or later, the recommended way to close resources that implement `java.lang.AutoCloseable`\
    \ is to declare them within a `try-with-resources` statement, so that they are\
    \ closed implicitly.\n\n\n## Example\nIn the following example, the resource `bw`\
    \ is opened but not closed.\n\n\n```java\npublic class CloseWriter {\n\tpublic\
    \ static void main(String[] args) throws IOException {\n\t\tBufferedWriter bw\
    \ = new BufferedWriter(new FileWriter(\"C:\\\\test.txt\"));\n\t\tbw.write(\"Hello\
    \ world!\");\n\t\t// ...\n\t}\n}\n```\nIn the following example, the resource\
    \ `bw` is opened in a `try` block and later closed in a `finally` block.\n\n\n\
    ```java\npublic class CloseWriterFix {\n\tpublic static void main(String[] args)\
    \ throws IOException {\n\t\tBufferedWriter bw = null;\n\t\ttry {\n\t\t\tbw = new\
    \ BufferedWriter(new FileWriter(\"C:\\\\test.txt\"));\n\t\t\tbw.write(\"Hello\
    \ world!\");\n\t\t}\n\t\tfinally {\n\t\t\tif(bw != null)\n\t\t\t\tbw.close();\
    \  // 'bw' is closed\n\t\t}\n\t\t// ...\n\t}\n}\n```\nNote that nested class instance\
    \ creation expressions of `Writer`s or `OutputStream`s are not safe to use if\
    \ the constructor of the outer expression may throw an exception. In the following\
    \ example, the `OutputStreamWriter` may throw an exception, in which case the\
    \ inner `FileOutputStream` is not closed.\n\n\n```java\npublic class CloseWriterNested\
    \ {\n\tpublic static void main(String[] args) throws IOException {\n\t\tOutputStreamWriter\
    \ writer = null;\n\t\ttry {\n\t\t\t// OutputStreamWriter may throw an exception,\
    \ in which case the ...\n\t\t\twriter = new OutputStreamWriter(\n\t\t\t\t\t//\
    \ ... FileOutputStream is not closed by the finally block\n\t\t\t\t\tnew FileOutputStream(\"\
    C:\\\\test.txt\"), \"UTF-8\");\n\t\t\twriter.write(\"Hello world!\");\n\t\t}\n\
    \t\tfinally {\n\t\t\tif (writer != null)\n\t\t\t\twriter.close();\n\t\t}\n\t}\n\
    }\n```\nIn this case, the inner expression needs to be assigned to a local variable\
    \ and closed separately, as shown below.\n\n\n```java\npublic class CloseWriterNestedFix\
    \ {\n\tpublic static void main(String[] args) throws IOException {\n\t\tFileOutputStream\
    \ fos = null;\n\t\tOutputStreamWriter writer = null;\n\t\ttry {\n\t\t\tfos = new\
    \ FileOutputStream(\"C:\\\\test.txt\");\n\t\t\twriter = new OutputStreamWriter(fos);\n\
    \t\t\twriter.write(\"Hello world!\");\n\t\t}\n\t\tfinally {\n\t\t\tif (writer\
    \ != null)\n\t\t\t\twriter.close();  // 'writer' is closed\n\t\t\tif (fos != null)\n\
    \t\t\t\tfos.close();  // 'fos' is closed\n\t\t}\n\t}\n}\n```\n\n## References\n\
    * IBM developerWorks: [Java theory and practice: Good housekeeping practices](https://web.archive.org/web/20201109041839/http://www.ibm.com/developerworks/java/library/j-jtp03216/index.html).\n\
    * The Java Tutorials: [The try-with-resources Statement](https://docs.oracle.com/javase/tutorial/essential/exceptions/tryResourceClose.html).\n\
    * Common Weakness Enumeration: [CWE-404](https://cwe.mitre.org/data/definitions/404.html).\n\
    * Common Weakness Enumeration: [CWE-772](https://cwe.mitre.org/data/definitions/772.html).\n"
 -
  pack: codeql/java-queries#0
  relativeQueryPath: Likely Bugs/Serialization/IncorrectSerialVersionUID.ql
  relativeBqrsPath: codeql/java-queries/Likely Bugs/Serialization/IncorrectSerialVersionUID.bqrs
  metadata:
    name: Incorrect serialVersionUID field
    description: |-
      A 'serialVersionUID' field that is declared in a serializable class but is of the
                    wrong type cannot be used by the serialization framework.
    kind: problem
    problem.severity: warning
    precision: medium
    id: java/incorrect-serial-version-uid
    tags: |-
      reliability
             maintainability
             language-features
  queryHelp: "# Incorrect serialVersionUID field\nA serializable class that uses the\
    \ `serialVersionUID` field to act as an object version number must declare the\
    \ field to be `final`, `static`, and of type `long` for it to be used by the Java\
    \ serialization framework.\n\n\n## Recommendation\nMake sure that the `serialVersionUID`\
    \ field in a serialized class is final, static, and of type `long`.\n\n\n## Example\n\
    In the following example, `WrongNote` defines `serialVersionUID` using the wrong\
    \ type, so that it is not used by the Java serialization framework. However, `Note`\
    \ defines it correctly so that it is used by the framework.\n\n\n```java\nclass\
    \ WrongNote implements Serializable {\n\t// BAD: serialVersionUID must be static,\
    \ final, and 'long'\n\tprivate static final int serialVersionUID = 1;\n\t\n\t\
    //...\n}\n\nclass Note implements Serializable {\n\t// GOOD: serialVersionUID\
    \ is of the correct type\n\tprivate static final long serialVersionUID = 1L;\n\
    }\n```\n\n## References\n* Java API Specification: [Serializable](https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/io/Serializable.html).\n\
    * JavaWorld: [Ensure proper version control for serialized objects](https://www.infoworld.com/article/2071731/ensure-proper-version-control-for-serialized-objects.html).\n"
 -
  pack: codeql/java-queries#0
  relativeQueryPath: Likely Bugs/Serialization/IncorrectSerializableMethods.ql
  relativeBqrsPath: codeql/java-queries/Likely Bugs/Serialization/IncorrectSerializableMethods.bqrs
  metadata:
    name: Serialization methods do not match required signature
    description: |-
      A serialized class that implements 'readObject', 'readObjectNoData' or 'writeObject' but
                    does not use the correct signatures causes the default serialization mechanism to be used.
    kind: problem
    problem.severity: warning
    precision: medium
    id: java/wrong-object-serialization-signature
    tags: |-
      reliability
             maintainability
             language-features
  queryHelp: "# Serialization methods do not match required signature\nA serializable\
    \ object that defines its own serialization protocol using the methods `readObject`,\
    \ `readObjectNoData` or `writeObject` must use the signature that is expected\
    \ by the Java serialization framework. Otherwise, the default serialization mechanism\
    \ is used.\n\n\n## Recommendation\nMake sure that the signatures of `readObject`,\
    \ `readObjectNoData` and `writeObject` on serializable classes match these expected\
    \ signatures:\n\n\n```java\nprivate void readObject(java.io.ObjectInputStream\
    \ in)\n     throws IOException, ClassNotFoundException;\nprivate void readObjectNoData()\n\
    \     throws ObjectStreamException;\nprivate void writeObject(java.io.ObjectOutputStream\
    \ out)\n     throws IOException;\n```\n\n## Example\nIn the following example,\
    \ `WrongNetRequest` defines `readObject`, `readObjectNoData` and `writeObject`\
    \ using the wrong signatures. However, `NetRequest` defines them correctly.\n\n\
    \n```java\nclass WrongNetRequest implements Serializable {\n\t// BAD: Does not\
    \ match the exact signature required for a custom \n\t// deserialization protocol.\
    \ Will not be called during deserialization.\n\tvoid readObject(ObjectInputStream\
    \ in) {\n\t\t//...\n\t}\n\t\n\t// BAD: Does not match the exact signature required\
    \ for a custom \n\t// deserialization protocol. Will not be called during deserialization.\n\
    \tvoid readObjectNoData() {\n\t\t//...\n\t}\n\t\n\t// BAD: Does not match the\
    \ exact signature required for a custom \n\t// serialization protocol. Will not\
    \ be called during serialization.\n\tprotected void writeObject(ObjectOutputStream\
    \ out) {\n\t\t//...\n\t}\n}\n\nclass NetRequest implements Serializable {\n\t\
    // GOOD: Signature for a custom deserialization implementation.\n\tprivate void\
    \ readObject(ObjectInputStream in) {\n\t\t//...\n\t}\n\t\n\t// GOOD: Signature\
    \ for a custom deserialization implementation.\n\tprivate void readObjectNoData()\
    \ {\n\t\t//...\n\t}\n\t\n\t// GOOD: Signature for a custom serialization implementation.\n\
    \tprivate void writeObject(ObjectOutputStream out) {\n\t\t//...\n\t}\n}\n```\n\
    \n## References\n* Java API Specification: [Serializable](https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/io/Serializable.html).\n\
    * Oracle Technology Network: [Discover the secrets of the Java Serialization API](https://www.oracle.com/technical-resources/articles/java/serializationapi.html).\n"
 -
  pack: codeql/java-queries#0
  relativeQueryPath: Likely Bugs/Serialization/MissingVoidConstructorOnExternalizable.ql
  relativeBqrsPath: codeql/java-queries/Likely Bugs/Serialization/MissingVoidConstructorOnExternalizable.bqrs
  metadata:
    name: Externalizable but no public no-argument constructor
    description: |-
      A class that implements 'Externalizable' but does not have a public no-argument
                    constructor causes an 'InvalidClassException' to be thrown.
    kind: problem
    problem.severity: warning
    precision: medium
    id: java/missing-no-arg-constructor-on-externalizable
    tags: |-
      reliability
             maintainability
             language-features
  queryHelp: |
    # Externalizable but no public no-argument constructor
    A class that implements `java.io.Externalizable` must have a public no-argument constructor. The constructor is used by the Java serialization framework when it creates the object during deserialization. If the class does not define such a constructor, the Java serialization framework throws an `InvalidClassException`.

    The Java Development Kit API documentation for `Externalizable` states:

    > When an `Externalizable` object is reconstructed, an instance is created using the public no-arg constructor, then the `readExternal` method called.


    ## Recommendation
    Make sure that externalizable classes always have a no-argument constructor.


    ## Example
    In the following example, `WrongMemo` does not declare a public no-argument constructor. When the Java serialization framework tries to deserialize the object, an `InvalidClassException` is thrown. However, `Memo` does declare a public no-argument constructor, so that the object is deserialized successfully.


    ```java
    class WrongMemo implements Externalizable {
        private String memo;

        // BAD: No public no-argument constructor is defined. Deserializing this object
        // causes an 'InvalidClassException'.

        public WrongMemo(String memo) {
            this.memo = memo;
        }

        public void writeExternal(ObjectOutput arg0) throws IOException {
            //...
        }
        public void readExternal(ObjectInput in) throws IOException, ClassNotFoundException {
            //...
        }
    }

    class Memo implements Externalizable {
        private String memo;

        // GOOD: Declare a public no-argument constructor, which is used by the
        // serialization framework when the object is deserialized.
        public Memo() {
        }

        public Memo(String memo) {
            this.memo = memo;
        }

        public void writeExternal(ObjectOutput out) throws IOException {
            //...
        }
        public void readExternal(ObjectInput in) throws IOException, ClassNotFoundException {
            //...
        }
    }

    ```

    ## References
    * Java API Specification: [Externalizable](https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/io/Externalizable.html).
 -
  pack: codeql/java-queries#0
  relativeQueryPath: Likely Bugs/Serialization/MissingVoidConstructorsOnSerializable.ql
  relativeBqrsPath: codeql/java-queries/Likely Bugs/Serialization/MissingVoidConstructorsOnSerializable.bqrs
  metadata:
    name: Serializable but no void constructor
    description: |-
      A non-serializable, immediate superclass of a serializable class that does not
                    itself declare an accessible, no-argument constructor causes deserialization to
                    fail.
    kind: problem
    problem.severity: warning
    precision: medium
    id: java/missing-no-arg-constructor-on-serializable
    tags: |-
      reliability
             maintainability
             language-features
  queryHelp: "# Serializable but no void constructor\nA serializable class that is\
    \ a subclass of a non-serializable class cannot be deserialized if its superclass\
    \ does not declare a no-argument constructor. The Java serialization framework\
    \ uses the no-argument constructor when it initializes the object instance that\
    \ is created during deserialization. Deserialization fails with an `InvalidClassException`\
    \ if its superclass does not declare a no-argument constructor.\n\nThe Java Development\
    \ Kit API documentation states:\n\n> To allow subtypes of non-serializable classes\
    \ to be serialized, the subtype may assume responsibility for saving and restoring\
    \ the state of the supertype's public, protected, and (if accessible) package\
    \ fields. The subtype may assume this responsibility only if the class it extends\
    \ has an accessible no-arg constructor to initialize the class's state. It is\
    \ an error to declare a class `Serializable` if this is not the case. The error\
    \ will be detected at runtime.\n\n\n## Recommendation\nMake sure that every non-serializable\
    \ class that is extended by a serializable class has a no-argument constructor.\n\
    \n\n## Example\nIn the following example, the class `WrongSubItem` cannot be deserialized\
    \ because its superclass `WrongItem` does not declare a no-argument constructor.\
    \ However, the class `SubItem` *can* be serialized because it declares a no-argument\
    \ constructor.\n\n\n```java\nclass WrongItem {\n    private String name;\n\n \
    \   // BAD: This class does not have a no-argument constructor, and throws an\n\
    \    // 'InvalidClassException' at runtime.\n\n    public WrongItem(String name)\
    \ {\n        this.name = name;\n    }\n}\n\nclass WrongSubItem extends WrongItem\
    \ implements Serializable {\n    public WrongSubItem() {\n        super(null);\n\
    \    }\n\n    public WrongSubItem(String name) {\n        super(name);\n    }\n\
    }\n\nclass Item {\n    private String name;\n\n    // GOOD: This class declares\
    \ a no-argument constructor, which allows serializable \n    // subclasses to\
    \ be deserialized without error.\n    public Item() {}\n\n    public Item(String\
    \ name) {\n        this.name = name;\n    }\n}\n\nclass SubItem extends Item implements\
    \ Serializable {\n    public SubItem() { \n        super(null); \n    }\n\n  \
    \  public SubItem(String name) {\n        super(name);\n    }\n}\n```\n\n## References\n\
    * Java API Specification: [Serializable](https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/io/Serializable.html).\n\
    * J. Bloch, *Effective Java (second edition)*, Item 74. Addison-Wesley, 2008.\n"
 -
  pack: codeql/java-queries#0
  relativeQueryPath: Likely Bugs/Serialization/NonSerializableComparator.ql
  relativeBqrsPath: codeql/java-queries/Likely Bugs/Serialization/NonSerializableComparator.bqrs
  metadata:
    name: Non-serializable comparator
    description: |-
      A comparator that is passed to an ordered collection (for example, a treemap) must be
                    serializable, otherwise the collection fails to serialize at run-time.
    kind: problem
    problem.severity: warning
    precision: low
    id: java/non-serializable-comparator
    tags: |-
      reliability
             maintainability
             language-features
  queryHelp: |
    # Non-serializable comparator
    A class that implements `java.util.Comparator` and is used to construct a sorted collection needs to be serializable. An ordered collection (such as a `java.util.TreeMap`) that is constructed using a comparator serializes successfully only if the comparator is serializable.

    The `Collection`s in the Java Standard Library that require a comparator (`TreeSet`, `TreeMap`, `PriorityQueue`) all call `ObjectOutputStream.defaultWriteObject`, which tries to serialize every non-static, non-transient field in the class. As the comparator is stored in a field in these collections, the attempt to serialize a non-serializable comparator throws a `java.io.NotSerializableException`.


    ## Recommendation
    Comparators should be serializable if they are used in sorted collections that may be serialized. In most cases, simply changing the comparator so it also implements `Serializable` is enough. Comparators that have internal state may require additional changes (for example, custom `writeObject` and `readObject` methods). In these cases, it is best to follow general best practices for serializable objects (see references below).


    ## Example
    In the following example, `WrongComparator` is not serializable because it does not implement `Serializable`. However, `StringComparator` is serializable because it does implement `Serializable`.


    ```java
    // BAD: This is not serializable, and throws a 'java.io.NotSerializableException'
    // when used in a serializable sorted collection.
    class WrongComparator implements Comparator<String> {
        public int compare(String o1, String o2) {
            return o1.compareTo(o2);
        }
    }

    // GOOD: This is serializable, and can be used in collections that are meant to be serialized.
    class StringComparator implements Comparator<String>, Serializable {
        private static final long serialVersionUID = -5972458403679726498L;

        public int compare(String arg0, String arg1) {
            return arg0.compareTo(arg1);
        }
    }
    ```

    ## References
    * Java API Specification: [Comparator](https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/util/Comparator.html), [ObjectOutputStream](https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/io/ObjectOutputStream.html), [Serializable](https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/io/Serializable.html).
 -
  pack: codeql/java-queries#0
  relativeQueryPath: Likely Bugs/Serialization/NonSerializableField.ql
  relativeBqrsPath: codeql/java-queries/Likely Bugs/Serialization/NonSerializableField.bqrs
  metadata:
    name: Non-serializable field
    description: |-
      A non-transient field in a serializable class must also be serializable
                    otherwise it causes the class to fail to serialize with a 'NotSerializableException'.
    kind: problem
    problem.severity: warning
    precision: low
    id: java/non-serializable-field
    tags: |-
      reliability
             maintainability
             language-features
  queryHelp: |
    # Non-serializable field
    If a serializable class is serialized using the default Java serialization mechanism, each non-static, non-transient field in the class must also be serializable. Otherwise, the class generates a `java.io.NotSerializableException` as its fields are written out by `ObjectOutputStream.writeObject`.

    As an exception, classes that define their own `readObject` and `writeObject` methods can have fields that are not themselves serializable. The `readObject` and `writeObject` methods are responsible for encoding any state in those fields that needs to be serialized.


    ## Recommendation
    To avoid causing a `NotSerializableException`, do one of the following:

    * **Mark the field as `transient` :** Marking the field as `transient` makes the serialization mechanism skip the field. Before doing this, make sure that the field is not really intended to be part of the persistent state of the object.
    * **Define custom `readObject` and `writeObject` methods for the `Serializable` class :** Explicitly defining the `readObject` and `writeObject` methods enables you to choose which fields to read from, or write to, an object stream during serialization.
    * **Make the type of the field `Serializable` :** If the field is part of the object's persistent state and you wish to use Java's default serialization mechanism, the type of the field must implement `Serializable`. When choosing this option, make sure that you follow best practices for serialization.

    ## Example 1
    In the following example, `WrongPerformanceRecord` contains a field `factors` that is not serializable but is in a serializable class. This causes a `java.io.NotSerializableException` when the field is written out by `writeObject`. However, `PerformanceRecord` contains a field `factors` that is marked as `transient`, so that the serialization mechanism skips the field. This means that a correctly serialized record is output by `writeObject`.


    ```java
    class DerivedFactors {             // Class that contains derived values computed from entries in a
        private Number efficiency;     // performance record
        private Number costPerItem;
        private Number profitPerItem;
        ...
    }

    class WrongPerformanceRecord implements Serializable {
        private String unitId;
        private Number dailyThroughput;
        private Number dailyCost;
        private DerivedFactors factors;  // BAD: 'DerivedFactors' is not serializable
                                         // but is in a serializable class. This
                                         // causes a 'java.io.NotSerializableException'
                                         // when 'WrongPerformanceRecord' is serialized.
        ...
    }

    class PerformanceRecord implements Serializable {
        private String unitId;
        private Number dailyThroughput;
        private Number dailyCost;
        transient private DerivedFactors factors;  // GOOD: 'DerivedFactors' is declared
                                                   // 'transient' so it does not contribute to the
                                                   // serializable state of 'PerformanceRecord'.
        ...
    }

    ```

    ## Example 2
    In this second example, `WrongPair` takes two generic parameters `L` and `R`. The class itself is serializable, but users of this class are not forced to pass serializable objects to its constructor, which could lead to problems during serialization. The solution is to set upper type bounds for the parameters, to force the user to supply only serializable objects. A similar example is the `WrongEvent` class, which takes a weakly typed `eventData` object. A better solution is to force the user to supply an object whose class implements the `Serializable` interface.


    ```java
    class WrongPair<L, R> implements Serializable{
        private final L left;            // BAD
        private final R right;           // BAD: L and R are not guaranteed to be serializable

        public WrongPair(L left, R right){ ... }

        ...
    }

    class Pair<L extends Serializable, R extends Serializable> implements Serializable{
        private final L left;            // GOOD: L and R must implement Serializable
        private final R right;

        public Pair(L left, R right){ ... }

        ...
    }

    class WrongEvent implements Serializable{
        private Object eventData;        // BAD: Type is too general.

        public WrongEvent(Object eventData){ ... }
    }

    class Event implements Serializable{
        private Serializable eventData;  // GOOD: Force the user to supply only serializable data

        public Event(Serializable eventData){ ... }
    }

    ```

    ## References
    * Java API Specification: [Serializable](https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/io/Serializable.html), [ObjectOutputStream](https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/io/ObjectOutputStream.html).
 -
  pack: codeql/java-queries#0
  relativeQueryPath: Likely Bugs/Serialization/NonSerializableInnerClass.ql
  relativeBqrsPath: codeql/java-queries/Likely Bugs/Serialization/NonSerializableInnerClass.bqrs
  metadata:
    name: Serializable inner class of non-serializable class
    description: |-
      A class that is serializable with an enclosing class that is not serializable
                    causes serialization to fail.
    kind: problem
    problem.severity: warning
    precision: medium
    id: java/non-serializable-inner-class
    tags: |-
      reliability
             maintainability
             language-features
  queryHelp: "# Serializable inner class of non-serializable class\nNon-static nested\
    \ classes that implement `Serializable` must be defined in an enclosing class\
    \ that is also serializable. Non-static nested classes retain an implicit reference\
    \ to an instance of their enclosing class. If the enclosing class is not serializable,\
    \ the Java serialization mechanism fails with a `java.io.NotSerializableException`.\n\
    \n\n## Recommendation\nTo avoid causing a `NotSerializableException`, do one of\
    \ the following:\n\n* **Declare the nested class as `static` :** If the nested\
    \ class does not use any of the non-static fields or methods of the enclosing\
    \ class, it is best to declare it `static`. This removes the implicit reference\
    \ to an instance of the enclosing class, and has the additional effect of breaking\
    \ an unnecessary dependency between the two classes. A similar solution is to\
    \ turn the nested class into a separate top-level class.\n* **Make the enclosing\
    \ class implement `Serializable` :** However, this is not recommended because\
    \ the implementation of inner classes may be compiler-specific, and serializing\
    \ an inner class can result in non-portability across compilers. The Java Serialization\
    \ Specification states: <blockquote><p> Serialization of inner classes (i.e.,\
    \ nested classes that are not static member classes), including local and anonymous\
    \ classes, is strongly discouraged for several reasons. Because inner classes\
    \ declared in non-static contexts contain implicit non-transient references to\
    \ enclosing class instances, serializing such an inner class instance will result\
    \ in serialization of its associated outer class instance as well. Synthetic fields\
    \ generated by javac (or other Java(TM) compilers) to implement inner classes\
    \ are implementation dependent and may vary between compilers; differences in\
    \ such fields can disrupt compatibility as well as result in conflicting default\
    \ serialVersionUID values. The names assigned to local and anonymous inner classes\
    \ are also implementation dependent and may differ between compilers. </p> </blockquote>\n\
    \n## Example\nIn the following example, the class `WrongSession` cannot be serialized\
    \ without causing a `NotSerializableException`, because it is enclosed by a non-serializable\
    \ class. However, the class `Session` can be serialized because it is declared\
    \ as `static`.\n\n\n```java\nclass NonSerializableServer {\n\n    // BAD: The\
    \ following class is serializable, but the enclosing class\n    // 'NonSerializableServer'\
    \ is not. Serializing an instance of 'WrongSession' \n    // causes a 'java.io.NotSerializableException'.\n\
    \    class WrongSession implements Serializable {\n        private static final\
    \ long serialVersionUID = 8970783971992397218L;\n        private int id;\n   \
    \     private String user;\n        \n        WrongSession(int id, String user)\
    \ { /*...*/ }\n    }\n    \n    public WrongSession getNewSession(String user)\
    \ {\n        return new WrongSession(newId(), user);\n    }\n}\n\nclass Server\
    \ {\n\n    // GOOD: The following class can be correctly serialized because it\
    \ is static.\n    static class Session implements Serializable {\n        private\
    \ static final long serialVersionUID = 1065454318648105638L;\n        private\
    \ int id;\n        private String user;\n        \n        Session(int id, String\
    \ user) { /*...*/ }\n    }\n    \n    public Session getNewSession(String user)\
    \ {\n        return new Session(newId(), user);\n    }\n}\n```\n\n## References\n\
    * Java Object Serialization Specification: [1.10 The Serializable Interface](https://docs.oracle.com/en/java/javase/11/docs/specs/serialization/serial-arch.html#the-serializable-interface),\
    \ [2.1 The ObjectOutputStream Class](https://docs.oracle.com/en/java/javase/11/docs/specs/serialization/output.html#the-objectoutputstream-class).\n"
 -
  pack: codeql/java-queries#0
  relativeQueryPath: Likely Bugs/Serialization/ReadResolveObject.ql
  relativeBqrsPath: codeql/java-queries/Likely Bugs/Serialization/ReadResolveObject.bqrs
  metadata:
    name: "ReadResolve must have Object return type, not void"
    description: |-
      An implementation of 'readResolve' that does not have the signature that is expected
                    by the Java serialization framework is not recognized by the serialization
                    mechanism.
    kind: problem
    problem.severity: warning
    precision: medium
    id: java/wrong-readresolve-signature
    tags: |-
      reliability
             maintainability
             language-features
  queryHelp: "# ReadResolve must have Object return type, not void\nIf a class uses\
    \ the `readResolve` method to specify a replacement object instance when the object\
    \ is read from a stream, ensure that the signature of `readResolve` is *exactly*\
    \ what the Java serialization mechanism expects.\n\n\n## Recommendation\nEnsure\
    \ that the signature of the `readResolve` method in the class matches the expected\
    \ signature:\n\n` ANY-ACCESS-MODIFIER Object readResolve() throws ObjectStreamException;\
    \ `\n\nNote that the method *must* return a `java.lang.Object`.\n\nIf `readResolve`\
    \ is used for instance control of a serializable singleton, (that is, to make\
    \ sure that deserializing a singleton class does not result in another instance\
    \ of the singleton) it may be possible to use an `enum` with a single element\
    \ instead. The Java serialization specification explicitly ensures that deserializing\
    \ an `enum` does not create a new instance. (For details about this technique,\
    \ see \\[Bloch\\].)\n\n\n## Example\nIn the following example, `FalseSingleton.readResolve`\
    \ has the wrong signature, which causes deserialization to create a new instance\
    \ of the singleton. However, `Singleton.readResolve` has the correct signature,\
    \ which means that deserialization does not result in another instance of the\
    \ singleton.\n\n\n```java\nclass FalseSingleton implements Serializable {\n\t\
    private static final long serialVersionUID = -7480651116825504381L;\n\tprivate\
    \ static FalseSingleton instance;\n\t\n\tprivate FalseSingleton() {}\n\t\n\tpublic\
    \ static FalseSingleton getInstance() {\n\t\tif (instance == null) {\n\t\t\tinstance\
    \ = new FalseSingleton();\n\t\t}\n\t\treturn instance;\n\t}\n\t\n\t// BAD: Signature\
    \ of 'readResolve' does not match the exact signature that is expected\n\t// (that\
    \ is, it does not return 'java.lang.Object').\n\tpublic FalseSingleton readResolve()\
    \ throws ObjectStreamException {\n\t\treturn FalseSingleton.getInstance();\n\t\
    }\n}\n\nclass Singleton implements Serializable {\n\tprivate static final long\
    \ serialVersionUID = -7480651116825504381L;\n\tprivate static Singleton instance;\n\
    \t\n\tprivate Singleton() {}\n\t\n\tpublic static Singleton getInstance() {\n\t\
    \tif (instance == null) {\n\t\t\tinstance = new Singleton();\n\t\t}\n\t\treturn\
    \ instance;\n\t}\n\t\n\t// GOOD: Signature of 'readResolve' matches the exact\
    \ signature that is expected.\n\t// It replaces the singleton that is read from\
    \ a stream with an instance of 'Singleton',\n\t// instead of creating a new singleton.\n\
    \tprivate Object readResolve() throws ObjectStreamException {\n\t\treturn Singleton.getInstance();\n\
    \t}\n}\n```\n\n## References\n* Java API Specification: [Serializable](https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/io/Serializable.html).\n\
    * Java Object Serialization Specification: [3.7 The readResolve Method](https://docs.oracle.com/en/java/javase/11/docs/specs/serialization/input.html#the-readresolve-method),\
    \ [1.12 Serialization of Enum Constants](https://docs.oracle.com/en/java/javase/11/docs/specs/serialization/serial-arch.html#serialization-of-enum-constants).\n\
    * J. Bloch, *Effective Java (second edition)*, Item 77. Addison-Wesley, 2008.\n"
 -
  pack: codeql/java-queries#0
  relativeQueryPath: Likely Bugs/Serialization/TransientNotSerializable.ql
  relativeBqrsPath: codeql/java-queries/Likely Bugs/Serialization/TransientNotSerializable.bqrs
  metadata:
    name: Transient field in non-serializable class
    description: Using the 'transient' field modifier in non-serializable classes
      has no effect.
    kind: problem
    problem.severity: recommendation
    precision: low
    id: java/transient-not-serializable
    tags: |-
      reliability
             maintainability
             language-features
  queryHelp: "# Transient field in non-serializable class\nThe `transient` modifier\
    \ is used to identify fields that are not part of the persistent state of the\
    \ class. As such, it only has an effect if the class is serializable, and has\
    \ no purpose in a non-serializable class.\n\nA field that is marked `transient`\
    \ in a non-serializable class is likely to be a leftover from a time when the\
    \ class was serializable.\n\n\n## Recommendation\nIf the class is non-serializable,\
    \ leave out the `transient` modifier. Otherwise, use the modifier, and ensure\
    \ that the class (or a relevant supertype) implements `Serializable`.\n\n\n##\
    \ Example\nThe following example shows two fields that are declared `transient`.\
    \ The modifier only has an effect in the class that implements `Serializable`.\n\
    \n\n```java\nclass State {\n\t// The 'transient' modifier has no effect here because\n\
    \t// the 'State' class does not implement 'Serializable'.\n\tprivate transient\
    \ int[] stateData;\n}\n\nclass PersistentState implements Serializable {\n\tprivate\
    \ int[] stateData;\n\t// The 'transient' modifier indicates that this field is\
    \ not part of\n\t// the persistent state and should therefore not be serialized.\n\
    \tprivate transient int[] cachedComputedData;\n}\n```\n\n## References\n* Java\
    \ Language Specification: [8.3.1.3 transient Fields](https://docs.oracle.com/javase/specs/jls/se11/html/jls-8.html#jls-8.3.1.3).\n\
    * Java Object Serialization Specification: [1.5 Defining Serializable Fields for\
    \ a Class](https://docs.oracle.com/en/java/javase/11/docs/specs/serialization/serial-arch.html#defining-serializable-fields-for-a-class).\n"
 -
  pack: codeql/java-queries#0
  relativeQueryPath: Likely Bugs/Statements/ContinueInFalseLoop.ql
  relativeBqrsPath: codeql/java-queries/Likely Bugs/Statements/ContinueInFalseLoop.bqrs
  metadata:
    name: Continue statement that does not continue
    description: |-
      A 'continue' statement only re-runs the loop if the
                    loop-condition is true. Therefore using 'continue' in a loop
                    with a constant false condition is misleading and usually a
                    bug.
    kind: problem
    id: java/continue-in-false-loop
    problem.severity: warning
    precision: high
    tags: correctness
  queryHelp: |
    # Continue statement that does not continue
    A `continue` statement only re-runs the loop if the loop condition is true. Therefore using `continue` in a loop with a constant false condition will never cause the loop body to be re-run, which is misleading.


    ## Recommendation
    Replace the `continue` statement with a `break` statement if the intent is to break from the loop.


    ## References
    * Java Language Specification: [14.13 The do Statement](https://docs.oracle.com/javase/specs/jls/se11/html/jls-14.html#jls-14.13).
 -
  pack: codeql/java-queries#0
  relativeQueryPath: Likely Bugs/Statements/EmptyBlock.ql
  relativeBqrsPath: codeql/java-queries/Likely Bugs/Statements/EmptyBlock.bqrs
  metadata:
    name: "Empty branch of conditional, or empty loop body"
    description: |-
      An undocumented empty block or statement hinders readability. It may also
                    indicate incomplete code.
    kind: problem
    problem.severity: warning
    precision: low
    id: java/empty-block
    tags: |-
      reliability
             readability
  queryHelp: "# Empty branch of conditional, or empty loop body\nAn unexplained empty\
    \ block or statement makes the code less readable. It might also indicate missing\
    \ code, a misplaced semicolon, or a misplaced brace. For these reasons, it should\
    \ be avoided.\n\n\n## Recommendation\nIf a block is empty because some code is\
    \ missing, add the code.\n\nIf an `if` statement has an empty `then` branch and\
    \ a non-empty `else` branch, it may be possible to negate the condition and move\
    \ the statements of the `else` branch into the `then` branch.\n\nIf a block is\
    \ deliberately empty, add a comment to explain why.\n\n\n## Example\nIn the following\
    \ example, the `while` loop has intentionally been left empty. The purpose of\
    \ the loop is to scan a `String` for the first occurrence of the character `'='`.\
    \ A programmer reading the code might not understand the reason for the empty\
    \ loop body, and think that something is missing, or perhaps even that the loop\
    \ is useless. Therefore it is a good practice to add a comment to an empty block\
    \ explaining why it is empty.\n\n\n```java\npublic class Parser\n{\n\tpublic void\
    \ parse(String input) {\n\t\tint pos = 0;\n\t\t// ...\n\t\t// AVOID: Empty block\n\
    \t\twhile (input.charAt(pos++) != '=') { }\n\t\t// ...\n\t}\n}\n\n```\n\n## References\n\
    * Help - Eclipse Platform: [Java Compiler Errors/Warnings Preferences](https://help.eclipse.org/2020-12/advanced/content.jsp?topic=/org.eclipse.jdt.doc.user/reference/preferences/java/compiler/ref-preferences-errors-warnings.htm).\n\
    * Java Language Specification: [14.2 Blocks](https://docs.oracle.com/javase/specs/jls/se11/html/jls-14.html#jls-14.2),\
    \ [14.6 The Empty Statement](https://docs.oracle.com/javase/specs/jls/se11/html/jls-14.html#jls-14.6),\
    \ [14.9 The if Statement](https://docs.oracle.com/javase/specs/jls/se11/html/jls-14.html#jls-14.9),\
    \ [14.12 The while Statement](https://docs.oracle.com/javase/specs/jls/se11/html/jls-14.html#jls-14.12),\
    \ [14.13 The do Statement](https://docs.oracle.com/javase/specs/jls/se11/html/jls-14.html#jls-14.13),\
    \ [14.14 The for Statement](https://docs.oracle.com/javase/specs/jls/se11/html/jls-14.html#jls-14.14).\n"
 -
  pack: codeql/java-queries#0
  relativeQueryPath: Likely Bugs/Statements/EmptySynchronizedBlock.ql
  relativeBqrsPath: codeql/java-queries/Likely Bugs/Statements/EmptySynchronizedBlock.bqrs
  metadata:
    name: Empty synchronized block
    description: |-
      Empty synchronized blocks may indicate the presence of
                    incomplete code or incorrect synchronization, and may lead to concurrency problems.
    kind: problem
    problem.severity: warning
    precision: low
    id: java/empty-synchronized-block
    tags: |-
      reliability
             correctness
             concurrency
             language-features
             external/cwe/cwe-585
  queryHelp: |
    # Empty synchronized block
    Empty synchronized blocks suspend execution until a lock can be acquired, which is then released immediately. This is unlikely to achieve the desired effect and may indicate the presence of incomplete code or incorrect synchronization. It may also lead to concurrency problems.


    ## Recommendation
    Check which code needs to be synchronized. Any code that requires synchronization on the given lock should be placed within the synchronized block.


    ## References
    * Java Language Specification: [The synchronized Statement](https://docs.oracle.com/javase/specs/jls/se11/html/jls-14.html#jls-14.19).
    * The Java Tutorials: [Synchronization](https://docs.oracle.com/javase/tutorial/essential/concurrency/sync.html).
    * Common Weakness Enumeration: [CWE-585](https://cwe.mitre.org/data/definitions/585.html).
 -
  pack: codeql/java-queries#0
  relativeQueryPath: Likely Bugs/Statements/ImpossibleCast.ql
  relativeBqrsPath: codeql/java-queries/Likely Bugs/Statements/ImpossibleCast.bqrs
  metadata:
    name: Impossible array cast
    description: |-
      Trying to cast an array of a particular type as an array of a subtype causes a
                    'ClassCastException' at runtime.
    kind: problem
    problem.severity: error
    precision: low
    id: java/impossible-array-cast
    tags: |-
      reliability
             correctness
             logic
             external/cwe/cwe-704
  queryHelp: |
    # Impossible array cast
    Some downcasts on arrays will fail at runtime. An object `a` with dynamic type `A[]` cannot be cast to `B[]`, where `B` is a subtype of `A`, even if all the elements of `a` can be cast to `B`.


    ## Recommendation
    Ensure that the array creation expression constructs an array object of the right type.


    ## Example
    The following example shows an assignment that throws a `ClassCastException` at runtime.

    ```java
    String[] strs = (String[])new Object[]{ "hello", "world" };
    ```
    To avoid the exception, a `String` array should be created instead.

    ```java
    String[] strs = new String[]{ "hello", "world" };
    ```

    ## References
    * Java Language Specification: [Narrowing Reference Conversion](https://docs.oracle.com/javase/specs/jls/se11/html/jls-5.html#jls-5.1.6), [Subtyping among Array Types](https://docs.oracle.com/javase/specs/jls/se11/html/jls-4.html#jls-4.10.3).
    * Common Weakness Enumeration: [CWE-704](https://cwe.mitre.org/data/definitions/704.html).
 -
  pack: codeql/java-queries#0
  relativeQueryPath: Likely Bugs/Statements/InconsistentCallOnResult.ql
  relativeBqrsPath: codeql/java-queries/Likely Bugs/Statements/InconsistentCallOnResult.bqrs
  metadata:
    name: Inconsistent operation on return value
    description: |-
      If the same operation is usually performed
                    on the result of a method call, any cases where it
                    is not performed may indicate resource leaks or other problems.
    kind: problem
    problem.severity: warning
    precision: low
    id: java/inconsistent-call-on-result
    tags: |-
      reliability
             correctness
             external/cwe/cwe-252
             statistical
             non-attributable
  queryHelp: |
    # Inconsistent operation on return value
    If the same operation (for example, `free`, `delete`, `close`) is usually performed on the result of a method call, any instances where it is not performed may be misuses of the API, leading to resource leaks or other problems.


    ## Recommendation
    Ensure that the same operation is performed on the result of *all* calls to a particular method, if appropriate.


    ## Example
    In the following example of good usage, the result of the call to `writer.prepareAppendValue` is assigned to `outValue`, and later `close` is called on `outValue`. Any instances where `close` is *not* called may cause resource leaks.


    ```java
    DataOutputStream outValue = null;
    try {
        outValue = writer.prepareAppendValue(6);
        outValue.write("value0".getBytes());
    }
    catch (IOException e) {
    }
    finally {
        if (outValue != null) {
            outValue.close();
        }
    }

    ```
 -
  pack: codeql/java-queries#0
  relativeQueryPath: Likely Bugs/Statements/MissingEnumInSwitch.ql
  relativeBqrsPath: codeql/java-queries/Likely Bugs/Statements/MissingEnumInSwitch.bqrs
  metadata:
    name: Missing enum case in switch
    description: |-
      A 'switch' statement that is based on an 'enum' type and does not have cases for all
                    the 'enum' constants is usually a coding mistake.
    kind: problem
    problem.severity: warning
    precision: medium
    id: java/missing-case-in-switch
    tags: |-
      reliability
             readability
             external/cwe/cwe-478
  queryHelp: "# Missing enum case in switch\nA `switch` statement that is based on\
    \ a variable with an `enum` type should either have a default case or handle all\
    \ possible constants of that `enum` type. Handling all but one or two `enum` constants\
    \ is usually a coding mistake.\n\n\n## Recommendation\nIf there are only a handful\
    \ of missing cases, add them to the end of the `switch` statement. If there are\
    \ many cases that do not need to be handled individually, add a default case to\
    \ handle them.\n\nIf there are some `enum` constants that should never occur in\
    \ this particular part of the code, then program defensively by adding cases for\
    \ those constants and explicitly throwing an exception (rather than just having\
    \ no cases for those constants).\n\n\n## Example\nIn the following example, the\
    \ case for 'YES' is missing. Therefore, if `answer` is 'YES', an exception is\
    \ thrown at run time. To fix this, a case for 'YES' should be added.\n\n\n```java\n\
    enum Answer { YES, NO, MAYBE }\n\nclass Optimist\n{\n\tAnswer interpret(Answer\
    \ answer) {\n\t\tswitch (answer) {\n\t\t\tcase MAYBE:\n\t\t\t\treturn Answer.YES;\n\
    \t\t\tcase NO:\n\t\t\t\treturn Answer.MAYBE;\n\t\t\t// Missing case for 'YES'\n\
    \t\t}\n\t\tthrow new RuntimeException(\"uncaught case: \" + answer);\n\t}\n}\n\
    \n```\n\n## References\n* Help - Eclipse Platform: [Java Compiler Errors/Warnings\
    \ Preferences](https://help.eclipse.org/2020-12/advanced/content.jsp?topic=/org.eclipse.jdt.doc.user/reference/preferences/java/compiler/ref-preferences-errors-warnings.htm).\n\
    * Java Language Specification: [8.9 Enum Types](https://docs.oracle.com/javase/specs/jls/se11/html/jls-8.html#jls-8.9),\
    \ [14.11 The switch Statement](https://docs.oracle.com/javase/specs/jls/se11/html/jls-14.html#jls-14.11).\n\
    * Common Weakness Enumeration: [CWE-478](https://cwe.mitre.org/data/definitions/478.html).\n"
 -
  pack: codeql/java-queries#0
  relativeQueryPath: Likely Bugs/Statements/PartiallyMaskedCatch.ql
  relativeBqrsPath: codeql/java-queries/Likely Bugs/Statements/PartiallyMaskedCatch.bqrs
  metadata:
    name: Unreachable catch clause
    description: |-
      An unreachable 'catch' clause may indicate a mistake in exception handling or may
                    be unnecessary.
    kind: problem
    problem.severity: warning
    precision: high
    id: java/unreachable-catch-clause
    tags: |-
      reliability
             correctness
             exceptions
             external/cwe/cwe-561
  queryHelp: "# Unreachable catch clause\nAn unreachable `catch` clause may indicate\
    \ a logical mistake in the exception handling code or may simply be unnecessary.\n\
    \nAlthough certain unreachable `catch` clauses cause a compiler error, there are\
    \ also unreachable `catch` clauses that do not cause a compiler error. A `catch`\
    \ clause `C` is considered reachable by the compiler if both of the following\
    \ conditions are true:\n\n* A checked exception that is thrown in the `try` block\
    \ is assignable to the parameter of `C`.\n* There is no previous `catch` clause\
    \ whose parameter type is equal to, or a supertype of, the parameter type of `C`.\n\
    However, a `catch` clause that is considered reachable by the compiler can be\
    \ unreachable if both of the following conditions are true:\n\n* The `catch` clause's\
    \ parameter type `E` does not include any unchecked exceptions.\n* All exceptions\
    \ that are thrown in the `try` block whose type is a (strict) subtype of `E` are\
    \ already handled by previous `catch` clauses.\n\n## Recommendation\nEnsure that\
    \ unreachable `catch` clauses are removed or that further corrections are made\
    \ to make them reachable.\n\nNote that if a `try-catch` statement contains multiple\
    \ `catch` clauses, and an exception that is thrown in the `try` block matches\
    \ more than one of the `catch` clauses, only the first matching clause is executed.\n\
    \n\n## Example\nIn the following example, the second `catch` clause is unreachable.\
    \ The code is incomplete because a `FileOutputStream` is opened but no methods\
    \ are called to write to the stream. Such methods typically throw `IOException`s,\
    \ which would make the second `catch` clause reachable.\n\n\n```java\nFileOutputStream\
    \ fos = null;\ntry {\n\tfos = new FileOutputStream(new File(\"may_not_exist.txt\"\
    ));\n} catch (FileNotFoundException e) {\n\t// ask the user and try again\n} catch\
    \ (IOException e) {\n\t// more serious, abort\n} finally {\n\tif (fos!=null) {\
    \ try { fos.close(); } catch (IOException e) { /*ignore*/ } }\n}\n```\n\n## References\n\
    * Java Language Specification: [Execution of try-catch](https://docs.oracle.com/javase/specs/jls/se11/html/jls-14.html#jls-14.20.1),\
    \ [Unreachable Statements](https://docs.oracle.com/javase/specs/jls/se11/html/jls-14.html#jls-14.21).\n\
    * Help - Eclipse Platform: [Java Compiler Errors/Warnings Preferences](https://help.eclipse.org/2020-12/advanced/content.jsp?topic=/org.eclipse.jdt.doc.user/reference/preferences/java/compiler/ref-preferences-errors-warnings.htm).\n\
    * Common Weakness Enumeration: [CWE-561](https://cwe.mitre.org/data/definitions/561.html).\n"
 -
  pack: codeql/java-queries#0
  relativeQueryPath: Likely Bugs/Statements/ReturnValueIgnored.ql
  relativeBqrsPath: codeql/java-queries/Likely Bugs/Statements/ReturnValueIgnored.bqrs
  metadata:
    name: Method result ignored
    description: |-
      If most of the calls to a method use the return value
                    of that method, the calls that do not check the return value may be mistakes.
    kind: problem
    problem.severity: warning
    precision: low
    id: java/return-value-ignored
    tags: |-
      reliability
             correctness
             external/cwe/cwe-252
             statistical
             non-attributable
  queryHelp: |
    # Method result ignored
    If the result of a method call is used in most cases, any calls to that method where the result is ignored are inconsistent, and may be erroneous uses of the API. Often, the result is some kind of status indicator, and is therefore important to check.


    ## Recommendation
    Ensure that the results of *all* calls to a particular method are used. The return value of a method that returns a status value should normally be checked before any modified data or allocated resource is used.


    ## Example
    Line 1 of the following example shows the value returned by `get` being ignored. Line 3 shows it being assigned to `fs`.


    ```java
    FileSystem.get(conf);  // Return value is not used

    FileSystem fs = FileSystem.get(conf);  // Return value is assigned to 'fs'
    ```

    ## References
    * CERT Secure Coding Standards: [ EXP00-J. Do not ignore values returned by methods](https://www.securecoding.cert.org/confluence/display/java/EXP00-J.+Do+not+ignore+values+returned+by+methods).
    * Common Weakness Enumeration: [CWE-252](https://cwe.mitre.org/data/definitions/252.html).
 -
  pack: codeql/java-queries#0
  relativeQueryPath: Likely Bugs/Statements/StaticFieldWrittenByInstance.ql
  relativeBqrsPath: codeql/java-queries/Likely Bugs/Statements/StaticFieldWrittenByInstance.bqrs
  metadata:
    name: Static field written by instance method
    description: |-
      Writing to a static field from an instance method is prone to race conditions
                    unless you use synchronization. In addition, it makes it difficult to keep the
                    static state consistent and affects code readability.
    kind: problem
    problem.severity: warning
    precision: low
    id: java/static-field-written-by-instance
    tags: |-
      reliability
             maintainability
  queryHelp: "# Static field written by instance method\nA static field represents\
    \ state shared between all instances of a particular class. Typically, static\
    \ methods are provided to manipulate this static state, and it is bad practice\
    \ to modify the static state of a class from an instance method (or from a constructor).\n\
    \nThere are several reasons why this is bad practice. It can be very difficult\
    \ to keep the static state consistent when there are multiple instances through\
    \ which it could be modified. Such modifications represent a readability issue:\
    \ most programmers would expect a static method to affect static state, and an\
    \ instance method to affect instance state.\n\n\n## Recommendation\nIf the field\
    \ should be an instance field, ensure that it does not have a `static` modifier.\n\
    \nIf the field does have to be static, evaluate the assumptions in the code. Does\
    \ the field really have to be modified directly in an instance method? It might\
    \ be better to access the field from within static methods, so that any concerns\
    \ about synchronization can be addressed without numerous synchronization statements\
    \ in the code. Perhaps the field modification is part of the static initialization\
    \ of the class, and should be moved to a static initializer or method.\n\n\n##\
    \ Example\nIn the following example, a static field, `customers`, is written to\
    \ by an instance method, `initialize`. It is entirely reasonable for another developer\
    \ to assume that an instance method called `initialize` should be called on each\
    \ new instance, and that is what the code in `Department` does. Unfortunately,\
    \ the static field is shared between all instances of `Customer`, and so each\
    \ time `initialize` is called, the old state is lost.\n\n\n```java\npublic class\
    \ Customer {\n\tprivate static List<Customer> customers;\n\tpublic void initialize()\
    \ {\n\t\t// AVOID: Static field is written to by instance method.\n\t\tcustomers\
    \ = new ArrayList<Customer>();\n\t\tregister();\n\t}\n\tpublic static void add(Customer\
    \ c) {\n\t\tcustomers.add(c);\n\t}\n}\n\n// ...\npublic class Department {\n\t\
    public void addCustomer(String name) {\n\t\tCustomer c = new Customer(n);\n\t\t\
    // The following call overwrites the list of customers\n\t\t// stored in 'Customer'\
    \ (see above).\n\t\tc.initialize();\n\t\tCustomer.add(c);\n\t}\n}\n\n```\nThe\
    \ solution is to extract the static initialization of `customers` to a static\
    \ method, where it will happen exactly once.\n\n\n## References\n* Java Language\
    \ Specification: [8.3.1.1 static Fields](https://docs.oracle.com/javase/specs/jls/se11/html/jls-8.html#jls-8.3.1.1).\n"
 -
  pack: codeql/java-queries#0
  relativeQueryPath: Likely Bugs/Statements/UseBraces.ql
  relativeBqrsPath: codeql/java-queries/Likely Bugs/Statements/UseBraces.bqrs
  metadata:
    name: Misleading indentation
    description: |-
      If a control structure does not use braces, misleading indentation makes it
                    difficult to see which statements are within its scope.
    kind: problem
    problem.severity: warning
    precision: very-high
    id: java/misleading-indentation
    tags: |-
      maintainability
             correctness
             logic
  queryHelp: |
    # Misleading indentation
    A control structure (an `if` statement or a loop) has a body that is either a block of statements surrounded by curly braces or a single statement.

    If you omit braces, it is particularly important to ensure that the indentation of the code matches the control flow of the code.


    ## Recommendation
    It is usually considered good practice to include braces for all control structures in Java. This is because it makes it easier to maintain the code later. For example, it's easy to see at a glance which part of the code is in the scope of an `if` statement, and adding more statements to the body of the `if` statement is less error-prone.

    You should also ensure that the indentation of the code is consistent with the actual flow of control, so that it does not confuse programmers.


    ## Example
    In the example below, the original version of `Cart` is missing braces. This means that the code triggers a `NullPointerException` at runtime if `i` is `null`.


    ```java
    class Cart {
        Map<Integer, Integer> items = ...
        public void addItem(Item i) {
            // No braces and misleading indentation.
            if (i != null)
                log("Adding item: " + i);
                // Indentation suggests that the following statements
                // are in the body of the 'if'.
                Integer curQuantity = items.get(i.getID());
                if (curQuantity == null) curQuantity = 0;
                items.put(i.getID(), curQuantity+1);
        }
    }
    ```
    The corrected version of `Cart` does include braces, so that the code executes as the indentation suggests.


    ```java
    class Cart {
        Map<Integer, Integer> items = ...
        public void addItem(Item i) {
            // Braces included.
            if (i != null) {
                log("Adding item: " + i);
                Integer curQuantity = items.get(i.getID());
                if (curQuantity == null) curQuantity = 0;
                items.put(i.getID(), curQuantity+1);
            }
        }
    }
    ```
    In the following example the indentation may or may not be misleading depending on your tab width settings. As such, mixing tabs and spaces in this way is not recommended, since what looks fine in one context can be very misleading in another.


    ```java
    // Tab width 8
            if (b)       // Indentation: 1 tab
                    f(); // Indentation: 2 tabs
            g();         // Indentation: 8 spaces

    // Tab width 4
        if (b)   // Indentation: 1 tab
            f(); // Indentation: 2 tabs
            g(); // Indentation: 8 spaces
    ```
    If you mix tabs and spaces in this way, then you might get seemingly false positives, since your tab width settings cannot be taken into account.


    ## References
    * Java SE Documentation: [Compound Statements](https://www.oracle.com/java/technologies/javase/codeconventions-statements.html#15395).
    * Wikipedia: [Indentation style](https://en.wikipedia.org/wiki/Indentation_style).
 -
  pack: codeql/java-queries#0
  relativeQueryPath: Likely Bugs/Termination/ConstantLoopCondition.ql
  relativeBqrsPath: codeql/java-queries/Likely Bugs/Termination/ConstantLoopCondition.bqrs
  metadata:
    name: Constant loop condition
    description: |-
      A loop condition that remains constant throughout the iteration
                    indicates faulty logic and is likely to cause infinite
                    looping.
    kind: problem
    problem.severity: warning
    precision: very-high
    id: java/constant-loop-condition
    tags: |-
      correctness
             external/cwe/cwe-835
  queryHelp: |
    # Constant loop condition
    Loops can contain multiple exit conditions, either directly in the loop condition or as guards around `break` or `return` statements. If none of the exit conditions can ever be satisfied, then the loop will never terminate.


    ## Recommendation
    When writing a loop that is intended to terminate, make sure that all the necessary exit conditions can be satisfied and that loop termination is clear.


    ## Example
    The following example searches for a field of a given name, and intends to throw an exception if the field cannot be found. However, if the field cannot be found, the double loop structure means that the exit conditions will never be met, resulting in an infinite loop.


    ```java
    Object getField(Object obj, String name) throws NoSuchFieldError {
      Class clazz = obj.getClass();
      while (clazz != null) {
        for (Field f : clazz.getDeclaredFields()) {
          if (f.getName().equals(name)) {
            f.setAccessible(true);
            return f.get(obj);
          }
        }
      }
      throw new NoSuchFieldError(name);
    }

    ```
    The solution is to rewrite the code as follows using an `if`-statement.


    ```java
    Object getField(Object obj, String name) throws NoSuchFieldError {
      Class clazz = obj.getClass();
      if (clazz != null) {
        for (Field f : clazz.getDeclaredFields()) {
          if (f.getName().equals(name)) {
            f.setAccessible(true);
            return f.get(obj);
          }
        }
      }
      throw new NoSuchFieldError(name);
    }

    ```

    ## References
    * Java Language Specification: [Blocks and Statements](https://docs.oracle.com/javase/specs/jls/se11/html/jls-14.html).
    * Common Weakness Enumeration: [CWE-835](https://cwe.mitre.org/data/definitions/835.html).
 -
  pack: codeql/java-queries#0
  relativeQueryPath: Likely Bugs/Termination/SpinOnField.ql
  relativeBqrsPath: codeql/java-queries/Likely Bugs/Termination/SpinOnField.bqrs
  metadata:
    name: Spin on field
    description: |-
      Repeatedly reading a non-volatile field within the condition of an empty loop may
                    result in an infinite loop.
    kind: problem
    problem.severity: warning
    precision: medium
    id: java/spin-on-field
    tags: |-
      efficiency
             correctness
             concurrency
  queryHelp: |
    # Spin on field
    Repeatedly reading a non-volatile field within the condition of an empty loop statement may result in an infinite loop, since a compiler optimization may move this field access out of the loop.


    ## Example
    In the following example, the method `spin` repeatedly tests the field `done` in a loop. The method repeats the while-loop until the value of the field `done` is set by another thread. However, the compiler could optimize the code as shown in the second code snippet, because the field `done` is not marked as `volatile` and there are no statements in the body of the loop that could change the value of `done`. The optimized version of `spin` loops forever, even when another thread would set `done` to `true`.


    ```java
    class Spin {
        public boolean done = false;

        public void spin() {
            while(!done){
            }
        }
    }

    class Spin { // optimized
        public boolean done = false;

        public void spin() {
            boolean cond = done;
            while(!cond){
            }
        }
    }

    ```

    ## Recommendation
    Ensure that access to this field is properly synchronized. Alternatively, avoid spinning on the field and instead use the `wait` and `notifyAll` methods or the `java.util.concurrent` library to communicate between threads.


    ## References
    * Java Language Specification: [Threads and Locks](https://docs.oracle.com/javase/specs/jls/se11/html/jls-17.html).
 -
  pack: codeql/java-queries#0
  relativeQueryPath: Metrics/Authors/AuthorsPerFile.ql
  relativeBqrsPath: codeql/java-queries/Metrics/Authors/AuthorsPerFile.bqrs
  metadata:
    name: Number of authors (Javadoc)
    description: The number of different authors (by Javadoc tag) of a file.
    kind: treemap
    treemap.warnOn: highValues
    metricType: file
    metricAggregate: avg max
    id: java/authors-per-file
    tags: maintainability
  queryHelp: |
    # Number of authors (Javadoc)
    A file's Javadoc comment can include a tag that lists the authors who have worked on the file.

    A file that has been changed by a large number of different authors is the product of many minds. New authors working on the file may be less familiar with the design and implementation of the code than the original authors, which can be a potential source of defects. Furthermore, if the code is not carefully maintained, it often results in a lack of conceptual integrity.


    ## Recommendation
    There is clearly no way to reduce the number of authors that have worked on a file - it is impossible to rewrite history. However, you should pay special attention in a code review to a file that has been worked on by a large number of authors. The file may be need to be refactored or rewritten by an individual, experienced programmer.


    ## References
    * F. P. Brooks Jr, *The Mythical Man-Month*, Chapter 4. Addison-Wesley, 1974.
 -
  pack: codeql/java-queries#0
  relativeQueryPath: Metrics/Callables/CCyclomaticComplexity.ql
  relativeBqrsPath: codeql/java-queries/Metrics/Callables/CCyclomaticComplexity.bqrs
  metadata:
    name: Cyclomatic complexity of functions
    description: The number of possible execution paths through a method or constructor.
    kind: treemap
    treemap.warnOn: highValues
    metricType: callable
    metricAggregate: avg max sum
    id: java/cyclomatic-complexity-per-function
    tags: |-
      testability
             complexity
             maintainability
  queryHelp: |
    # Cyclomatic complexity of functions
    The cyclomatic complexity of a method (or constructor) is the number of possible linearly-independent execution paths through that method (see \[Wikipedia\]). It was originally introduced as a complexity measure by Thomas McCabe \[McCabe\].

    A method with high cyclomatic complexity is typically difficult to understand and test.


    ## Example

    ```java
    int f(int i, int j) {
        int result;
        if(i % 2 == 0) {
            result = i + j;
        }
        else {
            if(j % 2 == 0) {
                result = i * j;
            }
            else {
                result = i - j;
            }
        }
        return result;
    }
    ```
    The control flow graph for this method is as follows:

    ![Control Flow Diagram](./CCyclomaticComplexity_ControlFlow.png)As you can see from the graph, the number of linearly-independent execution paths through the method is 3. Therefore, the cyclomatic complexity is 3.


    ## Recommendation
    Simplify methods that have a high cyclomatic complexity. For example, tidy up complex logic, and/or split methods into multiple smaller methods using the 'Extract Method' refactoring from \[Fowler\].


    ## References
    * M. Fowler, *Refactoring*. Addison-Wesley, 1999.
    * T. J. McCabe, *A Complexity Measure*. IEEE Transactions on Software Engineering, SE-2(4), December 1976.
    * Wikipedia: [Cyclomatic complexity](http://en.wikipedia.org/wiki/Cyclomatic_complexity).
 -
  pack: codeql/java-queries#0
  relativeQueryPath: Metrics/Callables/CLinesOfCode.ql
  relativeBqrsPath: codeql/java-queries/Metrics/Callables/CLinesOfCode.bqrs
  metadata:
    name: Lines of code in methods
    description: The number of lines of code in a method.
    kind: treemap
    treemap.warnOn: highValues
    metricType: callable
    metricAggregate: avg sum max
    id: java/lines-of-code-per-function
    tags: |-
      maintainability
             complexity
  queryHelp: |
    # Lines of code in methods
    A method that contains a high number of lines of code has a number of problems:

    * It can be difficult to understand, difficult to check, and a common source of defects (particularly towards the end of the method, because few people read that far).
    * It is likely to lack cohesion because it has too many responsibilities.
    * It increases the risk of introducing new defects during routine code changes.

    ## Recommendation
    Break up long methods into smaller methods by extracting parts of their functionality into simpler methods, for example by using the 'Extract Method' refactoring from \[Fowler\]. As an approximate guide, a method should fit on one screen or side of Letter/A4 paper.


    ## References
    * M. Fowler, *Refactoring*, pp. 89-95. Addison-Wesley, 1999.
 -
  pack: codeql/java-queries#0
  relativeQueryPath: Metrics/Callables/CLinesOfComment.ql
  relativeBqrsPath: codeql/java-queries/Metrics/Callables/CLinesOfComment.bqrs
  metadata:
    name: Lines of comment in methods
    description: The number of comment lines in a method.
    kind: treemap
    treemap.warnOn: lowValues
    metricType: callable
    metricAggregate: avg sum max
    id: java/lines-of-comment-per-function
    tags: |-
      maintainability
             documentation
  queryHelp: |
    # Lines of comment in methods
    This metric measures the (absolute) number of comment lines for each method.

    Whilst the absolute number of comment lines a method has is not always especially meaningful when taken out of context, methods with very few comment lines are almost undocumented and may be hard to understand.


    ## Recommendation
    Methods containing very few comments should be examined to see whether or not they need more documentation. At a minimum, most methods (aside from getters, setters and other trivial methods) usually benefit from at least a brief comment as to their purpose. Less trivial methods can often be improved by adding appropriate comments to communicate the programmer's intent, or to summarize what a bit of code does. (See \[McConnell\] for more on writing good comments.)

    There are some cases, however, where adding more comments should not be the main focus of refactoring:

    * If your method is very long, the priority is to break it up into smaller methods with sensible names that communicate intent. These new methods should then be commented appropriately.
    * If your method is very hard to understand, you should redesign the way it works to make things simpler. Tricky code is bad code - you shouldn't document it, you should rewrite it (and then document it).
    * If your method is already absolutely clear and you don't have anything useful to say, don't add meaningless comments. Comments are there to communicate information that is not obvious from the code, not to repeat what's already there. If you can't say something that couldn't be generated by an automatic documentation generator (see \[Atwood\]), don't say anything.

    ## References
    * J. Atwood. [Avoiding Undocumentation](http://www.codinghorror.com/blog/2005/11/avoiding-undocumentation.html). Published online, 2005.
    * S. McConnell. *Code Complete*, 2nd Edition. Microsoft Press, 2004.
 -
  pack: codeql/java-queries#0
  relativeQueryPath: Metrics/Callables/CNumberOfCalls.ql
  relativeBqrsPath: codeql/java-queries/Metrics/Callables/CNumberOfCalls.bqrs
  metadata:
    name: Number of calls in methods
    description: The number of calls that is made by a method or constructor.
    kind: treemap
    treemap.warnOn: highValues
    metricType: callable
    metricAggregate: avg sum max
    id: java/calls-per-function
    tags: |-
      testability
             complexity
             maintainability
  queryHelp: |
    # Number of calls in methods
    If the number of calls that is made by a method (or constructor) to other methods is high, the method can be difficult to understand, because you have to read through all the methods that it calls to fully understand what it does. There are various reasons why a method may make a high number of calls, including:

    * The method is simply too large in general.
    * The method has too many responsibilities (see \[Martin\]).
    * The method spends all of its time delegating rather than doing any work itself.

    ## Recommendation
    The appropriate action depends on the reason why the method makes a high number of calls:

    * If the method is too large, you should refactor it into multiple smaller methods, using the 'Extract Method' refactoring from \[Fowler\], for example.
    * If the method is taking on too many responsibilities, a new layer of methods can be introduced below the top-level method, each of which can do some of the original work. The top-level method then only needs to delegate to a much smaller number of methods, which themselves delegate to the methods lower down.
    * If the method spends all of its time delegating, some of the work that is done by the subsidiary methods can be moved into the top-level method, and the subsidiary methods can be removed. This is the refactoring called 'Inline Method' in \[Fowler\].

    ## References
    * M. Fowler, *Refactoring*. Addison-Wesley, 1999.
    * R. Martin. *Agile Software Development: Principles, Patterns, and Practices* Chapter 8 - SRP: The Single-Responsibility Principle. Pearson Education, 2003.
 -
  pack: codeql/java-queries#0
  relativeQueryPath: Metrics/Callables/CNumberOfParameters.ql
  relativeBqrsPath: codeql/java-queries/Metrics/Callables/CNumberOfParameters.bqrs
  metadata:
    name: Number of parameters to methods
    description: The number of parameters of a method or constructor.
    kind: treemap
    treemap.warnOn: highValues
    metricType: callable
    metricAggregate: avg max
    id: java/parameters-per-function
    tags: |-
      testability
             complexity
             maintainability
  queryHelp: "# Number of parameters to methods\nA method (or constructor) that uses\
    \ a high number of formal parameters makes maintenance more difficult:\n\n* It\
    \ is difficult to write a call to the method, because the programmer must know\
    \ how to supply an appropriate value for each parameter.\n* It is *externally*\
    \ difficult to understand, because calls to the method are longer than a single\
    \ line of code.\n* It can be *internally* difficult to understand, because it\
    \ has so many dependencies.\n\n## Recommendation\nRestrict the number of formal\
    \ parameters for a method, according to the reason for the high number:\n\n* Several\
    \ of the parameters are logically related, but are passed into the method separately.\
    \ The parameters that are logically related should be grouped together (see the\
    \ 'Introduce Parameter Object' refactoring on pp. 238-242 of \\[Fowler\\]).\n\
    * The method has too many responsibilities. It should be broken into multiple\
    \ methods (see the 'Extract Method' refactoring on pp. 89-95 of \\[Fowler\\]),\
    \ and each new method should be passed a subset of the original parameters.\n\
    * The method has redundant parameters that are not used. The two main reasons\
    \ for this are: (1) parameters were added for future extensibility but are never\
    \ used; (2) the body of the method was changed so that it no longer uses certain\
    \ parameters, but the method signature was not correspondingly updated. In both\
    \ cases, the theoretically correct solution is to delete the unused parameters\
    \ (see the 'Remove Parameter' refactoring on pp. 223-225 of \\[Fowler\\]), although\
    \ you must do this cautiously if the method is part of a published interface.\n\
    When a method is part of a published interface, one possible solution is to add\
    \ a new, wrapper method to the interface that has a tidier signature. Alternatively,\
    \ you can publish a new version of the interface that has a better design. Clearly,\
    \ however, neither of these solutions is ideal, so you should take care to design\
    \ interfaces the right way from the start.\n\nThe practice of adding parameters\
    \ for future extensibility is especially bad. It is confusing to other programmers,\
    \ who are uncertain what values they should pass in for these unnecessary parameters,\
    \ and it adds unused code that is potentially difficult to remove later.\n\n\n\
    ## Examples\nIn the following example, although the parameters are logically related,\
    \ they are passed into the `printAnnotation` method separately.\n\n\n```java\n\
    void printAnnotation(String annotationMessage, int annotationLine, int annotationOffset,\n\
    \                     int annotationLength) {\n    System.out.println(\"Message:\
    \ \" + annotationMessage);\n    System.out.println(\"Line: \" + annotationLine);\n\
    \    System.out.println(\"Offset: \" + annotationOffset);\n    System.out.println(\"\
    Length: \" + annotationLength);\n```\nIn the following modified example, the parameters\
    \ that are logically related are grouped together in a class, and an instance\
    \ of the class is passed into the method instead.\n\n\n```java\nclass Annotation\
    \ {\n    //...\n}\n\nvoid printAnnotation(Annotation annotation) {\n    System.out.println(\"\
    Message: \" + annotation.getMessage());\n    System.out.println(\"Line: \" + annotation.getLine());\n\
    \    System.out.println(\"Offset: \" + annotation.getOffset());\n    System.out.println(\"\
    Length: \" + annotation.getLength());\n}\n```\nIn the following example, the `printMembership`\
    \ method has too many responsibilities, and so needs to be passed four arguments.\n\
    \n\n```java\nvoid printMembership(Set<Fellow> fellows, Set<Member> members, \n\
    \                     Set<Associate> associates, Set<Student> students) {\n  \
    \  for(Fellow f: fellows) {\n        System.out.println(f);\n    }\n    for(Member\
    \ m: members) {\n        System.out.println(m);\n    }\n    for(Associate a: associates)\
    \ {\n        System.out.println(a);\n    }\n    for(Student s: students) {\n \
    \       System.out.println(s);\n    }\n}\n\nvoid printRecords() {\n    //...\n\
    \    printMembership(fellows, members, associates, students);\n}\n```\nIn the\
    \ following modified example, `printMembership` has been broken into four methods.\
    \ (For brevity, only one method is shown.) As a result, each new method needs\
    \ to be passed only one of the original four arguments.\n\n\n```java\nvoid printFellows(Set<Fellow>\
    \ fellows) {\n    for(Fellow f: fellows) {\n        System.out.println(f);\n \
    \   }\n}\n\n//...\n\nvoid printRecords() {\n    //...\n    printFellows(fellows);\n\
    \    printMembers(members);\n    printAssociates(associates);\n    printStudents(students);\n\
    }\n```\n\n## References\n* M. Fowler, *Refactoring*. Addison-Wesley, 1999.\n"
 -
  pack: codeql/java-queries#0
  relativeQueryPath: Metrics/Callables/CNumberOfStatements.ql
  relativeBqrsPath: codeql/java-queries/Metrics/Callables/CNumberOfStatements.bqrs
  metadata:
    name: Number of statements in methods
    description: The number of statements in a method or constructor.
    kind: treemap
    treemap.warnOn: highValues
    metricType: callable
    metricAggregate: avg sum max
    id: java/statements-per-function
    tags: maintainability
  queryHelp: |
    # Number of statements in methods
    This metric measures the number of statements for each method.

    Methods that consist of too many statements are hard to understand, difficult to check and a common source of bugs (particularly towards the end of the method, since few people ever read that far). They often lack cohesion because they are trying to do too many things at once, and should be refactored into multiple, smaller methods. As a rough guide, methods should be able to fit on a single screen or side of A4. Anything longer than that increases the risk of introducing new defects during routine code changes.


    ## Recommendation
    Over-long methods should be broken up into smaller ones by extracting parts of their functionality out into auxiliary methods, using the technique that Martin Fowler's *Refactoring* book calls 'Extract Method' (see References).


    ## References
    * M. Fowler. *Refactoring* pp. 89-95. Addison-Wesley, 1999.
 -
  pack: codeql/java-queries#0
  relativeQueryPath: Metrics/Callables/StatementNestingDepth.ql
  relativeBqrsPath: codeql/java-queries/Metrics/Callables/StatementNestingDepth.bqrs
  metadata:
    name: Statement nesting depth
    description: |-
      The maximum level of nesting of statements (for example 'if', 'for', 'while') in a
                    method. Blocks are not counted.
    kind: treemap
    treemap.warnOn: highValues
    metricType: callable
    metricAggregate: avg max
    id: java/statement-nesting-depth-per-function
    tags: |-
      maintainability
             complexity
  queryHelp: |
    # Statement nesting depth
    A method that contains a high level of nesting can be very difficult to understand. As noted in \[McConnell\], the human brain cannot easily handle more than three levels of nested `if` statements.


    ## Recommendation
    Extract nested statements into new methods, for example by using the 'Extract Method' refactoring from \[Fowler\].

    For more ways to reduce the level of nesting in a method, see \[McConnell\].

    Furthermore, a method that has a high level of nesting often indicates that its design can be improved in other ways, as well as dealing with the nesting problem itself.


    ## Example
    In the following example, the code has four levels of nesting and is unnecessarily difficult to read.


    ```java
    public static void printCharacterCodes_Bad(String[] strings) {
        if (strings != null) {
            for (String s : strings) {
                if (s != null) {
                    for (int i = 0; i < s.length(); i++) {
                        System.out.println(s.charAt(i) + "=" + (int) s.charAt(i));
                    }
                }
            }
        }
    }
    ```
    In the following modified example, some of the nested statements have been extracted into a new method `PrintAllCharInts`.


    ```java
    public static void printAllCharInts(String s) {
        if (s != null) {
            for (int i = 0; i < s.length(); i++) {
                System.out.println(s.charAt(i) + "=" + (int) s.charAt(i));
            }
        }
    }
    public static void printCharacterCodes_Good(String[] strings) {
        if (strings != null) {
            for(String s : strings){
                printAllCharInts(s);
            }
        }
    }
    ```

    ## References
    * M. Fowler, *Refactoring*, pp. 89-95. Addison-Wesley, 1999.
    * S. McConnell, *Code Complete*, 2nd Edition, &sect;19.4. Microsoft Press, 2004.
 -
  pack: codeql/java-queries#0
  relativeQueryPath: Metrics/Dependencies/ExternalDependencies.ql
  relativeBqrsPath: codeql/java-queries/Metrics/Dependencies/ExternalDependencies.bqrs
  metadata:
    deprecated: ""
    name: External dependencies
    description: Count the number of dependencies a Java source file has on jar files.
    kind: treemap
    treemap.warnOn: highValues
    metricType: externalDependency
    id: java/external-dependencies
 -
  pack: codeql/java-queries#0
  relativeQueryPath: Metrics/Dependencies/ExternalDependenciesSourceLinks.ql
  relativeBqrsPath: codeql/java-queries/Metrics/Dependencies/ExternalDependenciesSourceLinks.bqrs
  metadata:
    deprecated: ""
    name: External dependency source links
    kind: source-link
    metricType: externalDependency
    id: java/dependency-source-links
 -
  pack: codeql/java-queries#0
  relativeQueryPath: Metrics/Files/FAfferentCoupling.ql
  relativeBqrsPath: codeql/java-queries/Metrics/Files/FAfferentCoupling.bqrs
  metadata:
    name: Incoming file dependencies
    description: The number of compilation units that depend on a compilation unit.
    kind: treemap
    treemap.warnOn: highValues
    metricType: file
    metricAggregate: avg max
    id: java/incoming-file-dependencies
    tags: |-
      changeability
             modularity
  queryHelp: |
    # Incoming file dependencies
    This metric measures the number of incoming dependencies for each compilation unit, i.e. the number of other compilation units that depend on it. (A compilation unit is a `.java` or `.class` file.)

    Compilation units that are depended on by many other units are typically time-consuming to change, because changing them forces all of the units that depend on them to be recompiled. Most systems have some units like this at the lowest level, and it is not necessarily a problem as long as the unit is only changed infrequently -- for instance, a compilation unit containing a string class might be depended upon by everything, but would be unlikely to change on a regular basis.

    What is problematic is if a compilation unit that is heavily depended upon also depends on a lot of other compilation units that have reasons to change frequently, because it is then likely to need recompiling on a regular basis, triggering a ripple effect of recompilation throughout the code: such units are known as hubs, and can be responsible for greatly increasing the time needed for incremental recompilation.


    ## Recommendation
    Aside from the advice given for classes that have high afferent coupling, which still applies when a compilation unit contains a single class, it is important to look at the number of classes that are in a particular compilation unit when dealing with high afferent coupling at the unit level. Having multiple classes in the same file can cause far more units to depend on a particular unit than would otherwise be the case: the solution is to move each class to its own compilation unit. This is a good idea in any case, as it makes the code more understandable and easier to maintain.


    ## References
    * M. Fowler. *Refactoring*. Addison-Wesley, 1999.
 -
  pack: codeql/java-queries#0
  relativeQueryPath: Metrics/Files/FCommentRatio.ql
  relativeBqrsPath: codeql/java-queries/Metrics/Files/FCommentRatio.bqrs
  metadata:
    name: Percentage of documentation in files
    description: The percentage of comment lines in a file.
    kind: treemap
    treemap.warnOn: lowValues
    metricType: file
    metricAggregate: avg max
    id: java/comment-ratio-per-file
    tags: |-
      maintainability
             documentation
  queryHelp: |
    # Percentage of documentation in files
    This metric measures the percentage of a file's lines that are comment rather than code.

    A low percentage of comments in a file may indicate either a potentially worrying lack of documentation or that the file was generated by an automated tool. A quick visual inspection should be sufficient to distinguish between the two cases.


    ## Recommendation
    Files that were not auto-generated and have a low comment percentage should be documented more fully. Refer to \[McConnell\] for more on how to write good comments.


    ## References
    * S. McConnell. *Code Complete*, 2nd Edition. Microsoft Press, 2004.
 -
  pack: codeql/java-queries#0
  relativeQueryPath: Metrics/Files/FCyclomaticComplexity.ql
  relativeBqrsPath: codeql/java-queries/Metrics/Files/FCyclomaticComplexity.bqrs
  metadata:
    name: Average cyclomatic complexity of files
    description: The average cyclomatic complexity of the methods in a file.
    kind: treemap
    treemap.warnOn: highValues
    metricType: file
    metricAggregate: avg max
    id: java/average-cyclomatic-complexity-per-file
    tags: |-
      testability
             complexity
  queryHelp: |
    # Average cyclomatic complexity of files
    This metric measures the average cyclomatic complexity of the functions in a file.

    The cyclomatic complexity of a function is the number of linearly independent execution paths through that function. A path is linearly independent path if it differs from all other paths by at least one node. Straight-line code therefore has a cyclomatic complexity of one, while branches, switches and loops increase cyclomatic complexity.

    Functions with a high cyclomatic complexity are typically hard to understand and test. By extension, files whose functions have a high average cyclomatic complexity are problematic, and usually would benefit from refactoring.

    As a concrete example, consider the following function:


    ```java
    int f(int i, int j) {
        // start
        int result;
        if(i % 2 == 0) {
            // iEven
            result = i + j;
        }
        else {
            // iOdd
            if(j % 2 == 0) {
                // jEven
                result = i * j;
            }
            else {
                // jOdd
                result = i - j;
            }
        }
        return result;
        // end
    }
    ```
    The control flow graph for this function is as follows:

    ![Control Flow Graph](./FCyclomaticComplexity_ControlFlow.png)The graph shows that the number of linearly independent execution paths through the function, and hence its cyclomatic complexity, is `3`. The three paths are:

    * `start -> iEven -> end`
    * `start -> iOdd -> jEven -> end`
    * `start -> iOdd -> jOdd -> end`

    ## Recommendation
    Functions with a high cyclomatic complexity should be simplified, for instance by tidying up any complex logic within them or by splitting them into multiple methods using the Extract Method refactoring.


    ## References
    * M. Fowler, *Refactoring*. Addison-Wesley, 1999.
    * T. J. McCabe, *A Complexity Measure*. IEEE Transactions on Software Engineering, SE-2(4), December 1976.
    * Dave Thomas, [Refactoring as Meta Programming?](http://www.jot.fm/issues/issue_2005_01/column1/), in Journal of Object Technology, vol. 4, no. 1, January-February 2005, pp. 7-11.
    * Wikipedia: [Cyclomatic complexity](http://en.wikipedia.org/wiki/Cyclomatic_complexity)
    * Wikipedia: [Code refactoring](http://en.wikipedia.org/wiki/Code_refactoring)
 -
  pack: codeql/java-queries#0
  relativeQueryPath: Metrics/Files/FEfferentCoupling.ql
  relativeBqrsPath: codeql/java-queries/Metrics/Files/FEfferentCoupling.bqrs
  metadata:
    name: Outgoing file dependencies
    description: The number of compilation units on which a compilation unit depends.
    kind: treemap
    treemap.warnOn: highValues
    metricType: file
    metricAggregate: avg max
    id: java/outgoing-file-dependencies
    tags: |-
      testability
             modularity
             maintainability
  queryHelp: |
    # Outgoing file dependencies
    This metric measures the number of outgoing dependencies for each compilation unit, i.e. the number of other units on which this compilation unit depends.

    Compilation units that depend on many other units are typically subject to more frequent recompilation, because they have to be recompiled every time one of the many units on which they depend changes. It is particularly problematic if such a compilation unit is also heavily depended on by other units, because any minor change to one of its dependencies will trigger a ripple effect of recompilation throughout the code: such units are known as hubs, and can be responsible for greatly increasing the time needed for incremental recompilation.


    ## Recommendation
    Unit-level efferent coupling can be reduced by splitting the unit into pieces along its dependency fault lines, as illustrated by the following diagrams. Initially, the compilation unit has many incoming and outgoing dependencies, but it is not the case that the entire unit depends on every dependency. For example, sub-unit `Y` only depends on `O2` and `O4` (note that `Y` is not necessarily a class, just a part of the compilation unit):

    <table> <tbody><tr> <td><img></img></td> </tr> <tr> <td>Before</td> </tr> </tbody></table>
    This suggests the following refactoring, where the unit containing `X`, `Y` and `Z` is split into three new units, each with fewer dependencies. Notice how the efferent coupling of each of the new units is significantly lower than that of the original unit:

    <table> <tbody><tr> <td><img></img></td> </tr> <tr> <td>After</td> </tr> </tbody></table>
    Performing this refactoring clearly relies on an ability to determine suitable places at which to partition the compilation unit. This can often be done by simple inspection of the code, but for more complicated units there are scientific approaches as well. As a simple example of this, consider a compilation unit that contains multiple classes. This could be partitioned by visualizing the dependencies of the various classes and grouping those with the same dependencies. Each group would then be turned into a new compilation unit. (Of course, for classes it is often best to just have a compilation unit for each class; this example is merely intended to illustrate how one might go about partitioning a unit in a mechanical way.)


    ## References
    * M. Fowler. *Refactoring*. Addison-Wesley, 1999.
 -
  pack: codeql/java-queries#0
  relativeQueryPath: Metrics/Files/FLines.ql
  relativeBqrsPath: codeql/java-queries/Metrics/Files/FLines.bqrs
  metadata:
    name: Number of lines
    description: The number of lines in each file.
    kind: treemap
    treemap.warnOn: highValues
    id: java/lines-per-file
    metricType: file
    metricAggregate: avg sum max
 -
  pack: codeql/java-queries#0
  relativeQueryPath: Metrics/Files/FLinesOfCode.ql
  relativeBqrsPath: codeql/java-queries/Metrics/Files/FLinesOfCode.bqrs
  metadata:
    name: Lines of code in files
    description: The number of lines of code in a file.
    kind: treemap
    treemap.warnOn: highValues
    metricType: file
    metricAggregate: avg sum max
    id: java/lines-of-code-in-files
    tags: |-
      maintainability
             complexity
  queryHelp: |
    # Lines of code in files
    There are a number of problems associated with a high number of lines of code:

    * It can be difficult to understand and maintain, even with good tool support.
    * It increases the likelihood of multiple developers needing to work on the same file at once, and it therefore increases the likelihood of merge conflicts.
    * It may increase network traffic if you use a version control system that requires the whole file to be transmitted even for a tiny change.
    * It may arise as a result of bundling many unrelated things into the same file, and so it can indicate weak code organization.

    ## Recommendation
    The solution depends on the reason for the high number of lines:

    * If the file's main class is too large, you should refactor it into smaller classes, for example by using the 'Extract Class' refactoring from \[Fowler\].
    * If the file's main class contains many nested classes, you should move the nested classes to their own files (in a subsidiary package, where appropriate).
    * If the file contains multiple non-public classes in addition to its main class, you should move them into separate files. This is particularly important if they are logically unrelated to the file's main class.
    * If the file has been automatically generated by a tool, no changes are required because the file will not be maintained by a programmer.

    ## References
    * M. Fowler, *Refactoring*. Addison-Wesley, 1999.
 -
  pack: codeql/java-queries#0
  relativeQueryPath: Metrics/Files/FLinesOfComment.ql
  relativeBqrsPath: codeql/java-queries/Metrics/Files/FLinesOfComment.bqrs
  metadata:
    name: Lines of comments in files
    description: The number of lines of comment in a file.
    kind: treemap
    treemap.warnOn: lowValues
    metricType: file
    metricAggregate: avg sum max
    id: java/lines-of-comments-in-files
    tags: |-
      maintainability
             documentation
  queryHelp: |
    # Lines of comments in files
    This metric measures the number of comment lines for each file.

    Whilst the absolute number of comment lines in a file may not provide much useful information out of context, a very small number of comments in a file may indicate either a potentially worrying lack of documentation or that the file was generated by an automated tool - a quick visual inspection should be sufficient to distinguish between the two cases.


    ## Recommendation
    If the file is not an auto-generated one, it should be documented at the first convenient opportunity (i.e. now). We note in passing that:

    * From a pragmatic standpoint, it is clear that not all files are equally important to document, so some common sense needs to be applied when deciding which code should be documented first.
    * Documenting entire files after the fact is not only onerous, but also often yields lower-quality documentation than would have been written by the original author at the time of writing the code (because other developers may not understand the context as well as the person who wrote the code). For this reason, finding completely undocumented files should be treated as a sign that your documentation practices in general need to improve.

    ## References
    * S. McConnell. *Code Complete*, 2nd Edition. Microsoft Press, 2004.
 -
  pack: codeql/java-queries#0
  relativeQueryPath: Metrics/Files/FLinesOfCommentedCode.ql
  relativeBqrsPath: codeql/java-queries/Metrics/Files/FLinesOfCommentedCode.bqrs
  metadata:
    name: Lines of commented-out code in files
    description: The number of lines of commented-out code in a file.
    kind: treemap
    treemap.warnOn: highValues
    metricType: file
    metricAggregate: avg sum max
    id: java/lines-of-commented-out-code-in-files
    tags: |-
      maintainability
             documentation
  queryHelp: |
    # Lines of commented-out code in files
    This metric counts the number of lines of commented-out code in each file. Large amounts of commented-out code often indicate poorly maintained code.


    ## References
    * Mark Needham: [The danger of commenting out code](http://www.markhneedham.com/blog/2009/01/17/the-danger-of-commenting-out-code/).
    * Los Techies: [Commented Code == Technical Debt](http://lostechies.com/rodpaddock/2010/12/29/commented-code-technical-debt).
    * High Integrity C++ Coding Standard: [2.3.2 Do not comment out code](http://www.codingstandard.com/rule/2-3-2-do-not-comment-out-code/).
 -
  pack: codeql/java-queries#0
  relativeQueryPath: Metrics/Files/FLinesOfDuplicatedCode.ql
  relativeBqrsPath: codeql/java-queries/Metrics/Files/FLinesOfDuplicatedCode.bqrs
  metadata:
    deprecated: ""
    name: Duplicated lines in files
    description: |-
      The number of lines in a file, including code, comment and whitespace lines,
                    which are duplicated in at least one other place.
    kind: treemap
    treemap.warnOn: highValues
    metricType: file
    metricAggregate: avg sum max
    id: java/duplicated-lines-in-files
    tags: |-
      testability
             modularity
  queryHelp: |
    # Duplicated lines in files
    This metric measures the number of lines in a file that are contained within a block that is duplicated elsewhere. These lines may include code, comments and whitespace, and the duplicate block may be in this file or in another file.

    A file that contains many lines that are duplicated within the code base is problematic for a number of reasons.

    Duplicated code increases overall code size, making the code base harder to maintain and harder to understand. It also becomes harder to fix bugs, since a programmer applying a fix to one copy has to always remember to update other copies accordingly. Finally, code duplication is generally an indication of a poorly designed or hastily written code base, which typically suffers from other problems as well.


    ## Recommendation
    Refactor files with lots of duplicated code to extract the common code into a shared library or module.


    ## References
    * Wikipedia: [Duplicate code](http://en.wikipedia.org/wiki/Duplicate_code).
    * M. Fowler, *Refactoring*. Addison-Wesley, 1999.
 -
  pack: codeql/java-queries#0
  relativeQueryPath: Metrics/Files/FLinesOfSimilarCode.ql
  relativeBqrsPath: codeql/java-queries/Metrics/Files/FLinesOfSimilarCode.bqrs
  metadata:
    deprecated: ""
    name: Similar lines in files
    description: |-
      The number of lines in a file, including code, comment and whitespace lines,
                    which are similar to lines in at least one other place.
    kind: treemap
    treemap.warnOn: highValues
    metricType: file
    metricAggregate: avg sum max
    id: java/similar-lines-per-file
    tags: testability
  queryHelp: |
    # Similar lines in files
    A file that contains many lines that are similar to other code within the code base is problematic for the same reasons as a file that contains a lot of (exactly) duplicated code.

    Duplicated code increases overall code size, making the code base harder to maintain and harder to understand. It also becomes harder to fix bugs, since a programmer applying a fix to one copy has to always remember to update other copies accordingly. Finally, code duplication is generally an indication of a poorly designed or hastily written code base, which typically suffers from other problems as well.


    ## Recommendation
    Refactor similar code snippets by extracting common functionality into methods that can be reused across classes.


    ## References
    * Wikipedia: [Duplicate code](http://en.wikipedia.org/wiki/Duplicate_code).
    * M. Fowler, *Refactoring*. Addison-Wesley, 1999.
 -
  pack: codeql/java-queries#0
  relativeQueryPath: Metrics/Files/FNumberOfClasses.ql
  relativeBqrsPath: codeql/java-queries/Metrics/Files/FNumberOfClasses.bqrs
  metadata:
    name: Number of classes
    description: The number of classes in a compilation unit.
    kind: treemap
    treemap.warnOn: highValues
    metricType: file
    metricAggregate: avg sum max
    id: java/classes-per-file
    tags: maintainability
  queryHelp: |
    # Number of classes
    This metric measures the number of classes below this location in the tree. At a file level, this would just be the number of classes in the file.

    There are both advantages and disadvantages to putting multiple classes in the same file, so some judgment needs to be applied when interpreting these results. That said, putting large numbers of classes, or unrelated classes, in the same file is a malpractice that makes the organization of the code harder to understand. There is a debate in the programming community as to whether it is necessary to go as far as having a 'one class per file' rule, but there is far more agreement over the principle that you should not bundle large numbers of unrelated classes into a single file. Indeed, Java already enforces a 'one *public* class per file' rule - this was done to make importing packages efficient (see \[Kabutz\]).

    The disadvantages of putting multiple classes in the same file include:

    * It causes problems with incremental compilation because changes to a class force all of the other classes in the same file to be recompiled, even if they don't actually need to be. Furthermore, files that contain multiple classes generally have higher coupling, which can also make for slower builds.
    * It increases the likelihood of multiple developers working on the same file at once, and thereby the likelihood of merge conflicts.
    * Projects whose files contain multiple classes can be less intuitive to navigate, even with tool support, because the logical organization of the code is obscured.
    * It makes your files larger, which can increase network traffic if you're using a poor version control system.
    * It makes it harder to look at the files changed in a commit and infer what has been changed at a code level.
    * Some compilers generate error messages based on the file name rather than the class name, which are less helpful if there is not a one-to-one correspondence between files and classes.
    There are a couple of advantages, however:

    * It reduces the proliferation of files containing very few lines of code.
    * It can be used positively to group logically-related classes together.

    ## Recommendation
    Generally speaking, the goal is to ensure that only strongly logically-related classes are 'packaged' together in the same file. This usually militates in favor of having a separate file for each class. If your code currently puts lots of large, unrelated classes in the same file, the solution is to move them all into separate files.

    As with any rule or guideline, however, there are exceptions. The primary one is that helper classes that are only used in the context of a file's main class should probably stay in the same file, e.g. an iterator class for a container can happily cohabit the container's source file. The same applies to enumerations.


    ## References
    * H. Kabutz. [Java History 101: Once Upon an Oak](https://www.devx.com/java-zone/10686/). Published online.
 -
  pack: codeql/java-queries#0
  relativeQueryPath: Metrics/Files/FNumberOfInterfaces.ql
  relativeBqrsPath: codeql/java-queries/Metrics/Files/FNumberOfInterfaces.bqrs
  metadata:
    name: Number of interfaces
    description: The number of interfaces in a compilation unit.
    kind: treemap
    treemap.warnOn: highValues
    metricType: file
    metricAggregate: avg sum max
    id: java/interfaces-per-file
    tags: maintainability
  queryHelp: |
    # Number of interfaces
    This metric measures the number of interfaces below this location in the tree. At a file level, this would just be the number of interfaces in the file.

    In general, it is not a good idea to put multiple interfaces in the same file. Interfaces are intended in some sense to be publicly visible, and changes to them are expected to have a higher impact than changes to internal classes. Making a change to an interface forces everybody who depends on that interface to recompile their code, which is already hugely disruptive. If multiple interfaces are in the same file, not only do the people who depend on the changing interface need to recompile, but so does everyone who depends on any of the interfaces in the file (since they have a physical dependency on the file, not just a logical dependency on one of the interfaces in it). For this reason, a strict rule of one interface per file should be rigorously enforced.

    Note that this should be compared to the advice for classes - whilst it is advisable to use a single file for each class, it is acceptable to put classes in the same file when they are logically related (if only then). It is far less acceptable in the case of interfaces due to their public-facing nature.


    ## Recommendation
    Any interfaces that currently share a source file with another interface (or indeed a class) should be given their own file.


    ## References
    * Java Language Specification. [9 Interfaces](https://docs.oracle.com/javase/specs/jls/se11/html/jls-9.html).
 -
  pack: codeql/java-queries#0
  relativeQueryPath: Metrics/Files/FNumberOfTests.ql
  relativeBqrsPath: codeql/java-queries/Metrics/Files/FNumberOfTests.bqrs
  metadata:
    name: Number of tests
    description: The number of test methods defined in a compilation unit.
    kind: treemap
    treemap.warnOn: lowValues
    metricType: file
    metricAggregate: avg sum max
    id: java/tests-in-files
    tags: maintainability
  queryHelp: |
    # Number of tests
    This metric measures the number of tests below this location in the tree. At a file level, this would just be the number of test methods in the file.

    A method is considered to be a "test method" if one of the major unit testing frameworks would invoke it as part of a test cycle. Recognised frameworks include JUnit 3, JUnit 4 and TestNG. For example, methods marked with the `org.junit.Test` annotation are counted as test methods.

    In general, having many test cases is a good thing rather than a bad thing. However, at the file level, tests should typically be grouped by the functionality they relate to, which makes a file with an exceptionally high number of tests a strong candidate for splitting up. At a higher level, this metric makes it possible to compare the number of tests in different components, potentially flagging functionality that is comparatively under-tested.


    ## Recommendation
    Since it is typically not a problem to have too many tests, this metric is usually included for the purposes of collecting information, rather than finding problematic areas in the code. With that in mind, it is usually a good idea to avoid an excessive number of tests in a single file, and to maintain a broadly comparable level of testing across components.

    When assessing the thoroughness of a code base's test suite, the number of test methods provides only part of the story. Test coverage statistics allow a more detailed examination of which parts of the code deserve improvements in this area.


    ## References
    * JUnit: official website at [http://junit.org/](http://junit.org/).
    * TestNG: official website at [http://testng.org/](http://testng.org/).
 -
  pack: codeql/java-queries#0
  relativeQueryPath: Metrics/Files/FSelfContainedness.ql
  relativeBqrsPath: codeql/java-queries/Metrics/Files/FSelfContainedness.bqrs
  metadata:
    name: Self-containedness of files
    description: The percentage of the types on which a compilation unit depends for
      which we have the source code.
    kind: treemap
    treemap.warnOn: lowValues
    metricType: file
    metricAggregate: avg max
    id: java/source-dependency-ratio-per-file
    tags: |-
      portability
             modularity
  queryHelp: |
    # Self-containedness of files
    This metric measures the percentage of the types on which a compilation unit depends for which we have source code available.

    The availability of source code is one of the key factors affecting how easy or difficult it will be to build a software project in the future, especially on platforms other than those for which it was originally developed. Projects will a high level of self-containedness are likely to be more portable and easier to build in ten years' time than those that depend on many binary-only, third-party libraries. (This is one reason why many of the dependencies of open-source projects are distributed as source code, aside from the fact that the binaries are generally larger and more unwieldy to distribute.)

    In the context of Java's platform independence, the availability of source code is less critical than it is for platform-dependent languages. However, note that there can be minor binary incompatibilities between different versions of Java.


    ## Recommendation
    Low self-containedness may or may not be a problem, depending on the context of your project. However, if you determine that it is an issue for you, it is best tackled at a project level, in the following ways:

    * Try to use libraries for which the source code is available.
    * Try to obtain the source code for binary-only libraries from the authors.
    * Where practical, rewrite parts of your code to reduce your dependence on external libraries.

    ## References
    * Wikipedia: [Software portability](http://en.wikipedia.org/wiki/Software_portability)
    * Oracle Technology Network: [Java SE 6 Compatibility](https://www.oracle.com/java/technologies/javase/compatibility.html)
    * Java Language Specification: [Binary Compatibility](https://docs.oracle.com/javase/specs/jls/se11/html/jls-13.html)
 -
  pack: codeql/java-queries#0
  relativeQueryPath: Metrics/RefTypes/TAfferentCoupling.ql
  relativeBqrsPath: codeql/java-queries/Metrics/RefTypes/TAfferentCoupling.bqrs
  metadata:
    name: Incoming type dependencies
    description: The number of types that depend on a type.
    kind: treemap
    treemap.warnOn: highValues
    metricType: reftype
    metricAggregate: avg max
    id: java/incoming-type-dependencies
    tags: |-
      changeability
             modularity
  queryHelp: |
    # Incoming type dependencies
    This metric measures the number of incoming dependencies for each reference type, i.e. the number of other types that depend on it.

    Types that are depended upon by many other types typically require a lot of effort to change, because changing them will force their dependents to change as well. This is not necessarily a bad thing -- indeed, most systems will have some such types (one example might be a string class). However, types with a high number of incoming dependencies and a high number of outgoing dependencies are hard to maintain. A type with both high afferent coupling *and* high efferent coupling is referred to as a hub type. Such types can be problematic, because on the one hand they are hard to change (high afferent coupling), yet on the other they have many reasons to change (high efferent coupling). This contradiction yields code that is very hard to maintain or test.

    Conversely, some types may only be depended on by very few other types. Again, this is not necessarily a problem -- we would expect, for example, that the top-level types of a system would meet this criterion. When lower-level types have very few incoming dependencies, however, it can be an indication that a type is not pulling its weight. In extreme cases, types may even have an afferent coupling of `0`, indicating that they are dead code.


    ## Recommendation
    It is unwise to refactor a type based purely on its high or low number of incoming dependencies -- a type's afferent coupling value only makes sense in the context of its role in the system as a whole. However, when combined with other metrics such as efferent coupling, it is possible to make some general recommendations:

    * Types with high numbers of incoming *and* outgoing dependencies are hub types that are prime candidates for refactoring (although this will not always be easy). The general strategy is to split the type into smaller types that each have fewer responsibilities, and refactor the code that previously used the hub type accordingly.
    * Types that have very few incoming dependencies and are not at the top level of a system may not be pulling their weight and should be refactored, e.g. using the 'Collapse Hierarchy' or 'Inline Class' techniques in \[Fowler\] (see the section entitled 'Lazy Class' on p.68).
    * Types that have an afferent coupling of `0` may be dead code -- in this situation, they can often be deleted.

    ## References
    * M. Fowler. *Refactoring*. Addison-Wesley, 1999.
 -
  pack: codeql/java-queries#0
  relativeQueryPath: Metrics/RefTypes/TEfferentCoupling.ql
  relativeBqrsPath: codeql/java-queries/Metrics/RefTypes/TEfferentCoupling.bqrs
  metadata:
    name: Outgoing type dependencies
    description: The number of types on which a class depends.
    kind: treemap
    treemap.warnOn: highValues
    metricType: reftype
    metricAggregate: avg max
    id: java/outgoing-type-dependencies
    tags: |-
      testability
             modularity
             maintainability
  queryHelp: |
    # Outgoing type dependencies
    Efferent coupling is the number of outgoing dependencies for each class. In other words, it is the number of other types on which each class depends.

    A class that depends on many other types is quite brittle, because if any of its dependencies change, the class itself may have to change as well. Furthermore, the reason for the high number of dependencies is often that different parts of the class depend on different groups of other types, so it is common to find that classes with high efferent coupling also lack cohesion.


    ## Recommendation
    You can reduce efferent coupling by splitting up a class so that each part depends on fewer types.


    ## Example
    In the following example, class `X` depends on both `Y` and `Z`.


    ```java
    class X {
        public void iUseY(Y y) {
            y.doStuff();
        }

        public Y soDoY() {
            return new Y();
        }

        public Z iUseZ(Z z1, Z z2) {
            return z1.combine(z2);
        }
    }
    ```
    However, the methods that use `Y` do not use `Z`, and the methods that use `Z` do not use `Y`. Therefore, the class can be split into two classes, one of which depends only on `Y` and the other only on `Z`


    ```java
    class YX {
        public void iUseY(Y y) {
            y.doStuff();
        }

        public Y soDoY() {
            return new Y();
        }
    }

    class ZX {
        public Z iUseZ(Z z1, Z z2) {
            return z1.combine(z2);
        }
    }
    ```
    Although this is a slightly artificial example, this sort of situation does tend to occur in more complicated classes, so the general technique is quite widely applicable.


    ## References
    * IBM developerWorks: [Evolutionary architecture and emergent design: Emergent design through metrics](https://web.archive.org/web/20190919085934/https://www.ibm.com/developerworks/library/j-eaed6/).
    * R. Martin, *Agile Software Development: Principles, Patterns and Practices*. Pearson, 2011.
 -
  pack: codeql/java-queries#0
  relativeQueryPath: Metrics/RefTypes/TEfferentSourceCoupling.ql
  relativeBqrsPath: codeql/java-queries/Metrics/RefTypes/TEfferentSourceCoupling.bqrs
  metadata:
    name: Outgoing dependencies to source types
    description: The number of source types on which a type depends.
    kind: treemap
    treemap.warnOn: highValues
    metricType: reftype
    metricAggregate: avg max
    id: java/outgoing-source-type-dependencies
    tags: |-
      changeability
             maintainability
             modularity
  queryHelp: |
    # Outgoing dependencies to source types
    This metric measures the number of outgoing source dependencies for each reference type, i.e. the number of other source types on which each reference type depends. Dependencies into libraries are not counted.

    Types that depend on many other types are quite brittle, because if any of their dependencies change then they may have to as well. Furthermore, the reason for the high number of dependencies is often that different bits of the class depend on different sets of other types, so it is not uncommon to find that classes with high efferent coupling also lack cohesion.


    ## Recommendation
    Efferent coupling can be reduced by splitting a class into pieces along its dependency fault lines. For example, consider the following very simple class:

    ```java

    class X {
        public void iUseY(Y y) {
            y.doStuff();
        }

        public Y soDoY() {
            return new Y();
        }

        public Z iUseZ(Z z1, Z z2) {
            return z1.combine(z2);
        }
    }

    ```
    In this class, `X` depends on both `Y` and `Z`, but the functions that are using `Y` are not also using `Z`, and vice-versa. We could thus split the class into two, one of which depends only on `Y` and the other only on `Z`:

    ```java

    class YX {
        public void iUseY(Y y) {
            y.doStuff();
        }

        public Y soDoY() {
            return new Y();
        }
    }

    class ZX {
        public Z iUseZ(Z z1, Z z2) {
            return z1.combine(z2);
        }
    }

    ```
    Whilst this is a somewhat contrived example, this sort of situation does tend to crop up even (or especially) in more complicated classes, so the general technique is quite widely applicable.


    ## References
    * A. Glover. [Code quality for software architects](https://web.archive.org/web/20190919093358/http://7thgen.info/wiki/Code_Quality_For_Software_Architects). Published online, 2006.
    * R. Martin. *Agile Software Development: Principles, Patterns and Practices*. Pearson, 2011.
 -
  pack: codeql/java-queries#0
  relativeQueryPath: Metrics/RefTypes/TInheritanceDepth.ql
  relativeBqrsPath: codeql/java-queries/Metrics/RefTypes/TInheritanceDepth.bqrs
  metadata:
    name: Type inheritance depth
    description: The depth of a reference type in the inheritance hierarchy.
    kind: treemap
    treemap.warnOn: highValues
    metricType: reftype
    metricAggregate: avg max
    id: java/inheritance-depth
    tags: |-
      changeability
             modularity
 -
  pack: codeql/java-queries#0
  relativeQueryPath: Metrics/RefTypes/TLackOfCohesionCK.ql
  relativeBqrsPath: codeql/java-queries/Metrics/RefTypes/TLackOfCohesionCK.bqrs
  metadata:
    name: Lack of type cohesion (CK)
    description: Lack of cohesion for a class as defined by Chidamber and Kemerer.
    kind: treemap
    treemap.warnOn: highValues
    metricType: reftype
    metricAggregate: avg max
    id: java/lack-of-cohesion-ck
    tags: |-
      modularity
             maintainability
  queryHelp: |
    # Lack of type cohesion (CK)
    A cohesive class is one in which most methods access the same fields. A class that lacks cohesion is usually one that has multiple responsibilities.

    Various measures of lack of cohesion have been proposed. The Chidamber and Kemerer version of lack of cohesion inspects pairs of methods. If there are many pairs that access the same data, the class is cohesive. If there are many pairs that do not access any common data, the class is not cohesive. More precisely, if:

    * `n1` is the number of pairs of distinct methods in a class that *do not have* at least one commonly-accessed field, and
    * `n2` is the number of pairs of distinct methods in a class that *do have* at least one commonly-accessed field,
    the lack of cohesion measure (LCOM) can be defined as:

    LCOM = max((n1 - n2) / 2, 0)

    High values of LCOM indicate a significant lack of cohesion. As a rough indication, an LCOM of 500 or more may give you cause for concern.


    ## Recommendation
    Classes generally lack cohesion because they have more responsibilities than they should (see \[Martin\]). In general, the solution is to identify each of the different responsibilities that the class has, and split them into multiple classes, using the 'Extract Class' refactoring from \[Fowler\], for example.


    ## References
    * S. R. Chidamber and C. F. Kemerer, *A metrics suite for object-oriented design*. IEEE Transactions on Software Engineering, 20(6):476-493, 1994.
    * M. Fowler, *Refactoring*, pp. 65, 122-5. Addison-Wesley, 1999.
    * R. Martin. *Agile Software Development: Principles, Patterns, and Practices* Chapter 8 - SRP: The Single-Responsibility Principle. Pearson Education, 2003.
    * O. de Moor et al, *Keynote Address: .QL for Source Code Analysis*. Proceedings of the 7th IEEE International Working Conference on Source Code Analysis and Manipulation, 2007.
 -
  pack: codeql/java-queries#0
  relativeQueryPath: Metrics/RefTypes/TLackOfCohesionHS.ql
  relativeBqrsPath: codeql/java-queries/Metrics/RefTypes/TLackOfCohesionHS.bqrs
  metadata:
    name: Lack of type cohesion (HS)
    description: Lack of cohesion for a type as defined by Henderson-Sellers.
    kind: treemap
    treemap.warnOn: highValues
    metricType: reftype
    metricAggregate: avg max
    id: java/lack-of-cohesion-hs
    tags: modularity
  queryHelp: |
    # Lack of type cohesion (HS)
    This metric provides an indication of the lack of cohesion of a reference type, using a method proposed by Brian Henderson-Sellers in 1996. The idea behind measuring a type's cohesion is that most methods in well-designed classes will access the same fields. Types that exhibit a lack of cohesion are often trying to take on multiple responsibilities, and should be split into several smaller classes.

    Various measures of lack of cohesion have been proposed: while the basic intuition is simple, the precise way to measure this property has been the subject of intense debate. Rather than getting involved in this debate, more than one such lack of cohesion measure is provided for comparison purposes.

    The Henderson-Sellers version of lack of cohesion can be defined as follows. Let `M` be the set of methods in a class, `F` be the set of fields in the class, `r(f)` be the number of methods that access field `f`, and `ar` be the mean of `r(f)` over `f` in `F`, then the lack of cohesion measure `LCOM` can be defined as:

    ```

    LCOM = (ar - |M|) / (1 - |M|)

    ```
    As per \[Walton\], we restrict `M` to methods that read some field in the class, and `F` to fields that are read by some method in the class. High values of `LCOM` indicate a worrisome lack of cohesion. The precise value of the metric for which warnings are issued is configurable, but as a rough indication, an `LCOM` of `0.95` or more may give you cause for concern.


    ## Recommendation
    Types generally lack cohesion because they are taking on more responsibilities than they should (see \[Martin\] for more on responsibilities). In general, the solution is to identify each of the different responsibilities the class is taking on, and split them out into multiple classes, e.g. using the 'Extract Class' refactoring from \[Fowler\].


    ## References
    * M. Fowler. *Refactoring* pp. 65, 122-5. Addison-Wesley, 1999.
    * B. Henderson-Sellers. *Object-Oriented Metrics: Measures of Complexity*. Prentice-Hall, 1996.
    * R. Martin. *Agile Software Development: Principles, Patterns, and Practices* Chapter 8 - SRP: The Single-Responsibility Principle. Pearson Education, 2003.
    * O. de Moor et al. *Keynote Address: .QL for Source Code Analysis*. Proceedings of the 7th IEEE International Working Conference on Source Code Analysis and Manipulation, 2007.
 -
  pack: codeql/java-queries#0
  relativeQueryPath: Metrics/RefTypes/TLinesOfCode.ql
  relativeBqrsPath: codeql/java-queries/Metrics/RefTypes/TLinesOfCode.bqrs
  metadata:
    name: Lines of code in types
    description: The number of lines of code in a type.
    kind: treemap
    treemap.warnOn: highValues
    metricType: reftype
    metricAggregate: avg sum max
    id: java/lines-of-code-per-type
    tags: maintainability
  queryHelp: |
    # Lines of code in types
    This metric measures the number of lines of code for each type.

    Large types can be problematic:

    * They can be hard to understand and maintain, even with good tool support.
    * They often arise as a result of bundling many unrelated things into the same type, and so can be a symptom of weak type cohesion.

    ## Recommendation
    Types are generally too large because they are taking on more responsibilities than they should (see \[Martin\] for more on responsibilities). In general, the solution is to identify each of the different responsibilities the class is taking on, and split them out into multiple classes, e.g. using the 'Extract Class' refactoring from \[Fowler\].


    ## References
    * M. Fowler. *Refactoring* pp. 65, 122-5. Addison-Wesley, 1999.
    * R. Martin. *Agile Software Development: Principles, Patterns, and Practices* Chapter 8 - SRP: The Single-Responsibility Principle. Pearson Education, 2003.
 -
  pack: codeql/java-queries#0
  relativeQueryPath: Metrics/RefTypes/TLinesOfComment.ql
  relativeBqrsPath: codeql/java-queries/Metrics/RefTypes/TLinesOfComment.bqrs
  metadata:
    name: Lines of comment in types
    description: The number of lines of comment in a type.
    kind: treemap
    treemap.warnOn: lowValues
    metricType: reftype
    metricAggregate: avg sum max
    id: java/lines-of-comments-per-type
    tags: |-
      maintainability
             documentation
  queryHelp: |
    # Lines of comment in types
    This metric measures the number of comment lines for each type.

    Whilst the absolute number of comment lines in a type may not provide much useful information out of context, a very small number of comments in a type may indicate either a potentially worrying lack of documentation or that the type was generated by an automated tool - a quick visual inspection should be sufficient to distinguish between the two cases.


    ## Recommendation
    If the type is not an auto-generated one, it should be documented at the first convenient opportunity (i.e. now). We note in passing that:

    * From a pragmatic standpoint, it is clear that not all types are equally important to document, so some common sense needs to be applied when deciding which code should be documented first.
    * Documenting entire types after the fact is not only onerous, but also often yields lower-quality documentation than would have been written by the original author at the time of writing the code (because other developers may not understand the context as well as the person who wrote the code). For this reason, finding completely undocumented types should be treated as a sign that your documentation practices in general need to improve.

    ## References
    * S. McConnell. *Code Complete*, 2nd Edition. Microsoft Press, 2004.
 -
  pack: codeql/java-queries#0
  relativeQueryPath: Metrics/RefTypes/TNumberOfCallables.ql
  relativeBqrsPath: codeql/java-queries/Metrics/RefTypes/TNumberOfCallables.bqrs
  metadata:
    name: Number of methods
    description: The number of methods and constructors in a reference type.
    kind: treemap
    treemap.warnOn: highValues
    metricType: reftype
    metricAggregate: avg sum max
    id: java/functions-per-type
    tags: maintainability
 -
  pack: codeql/java-queries#0
  relativeQueryPath: Metrics/RefTypes/TNumberOfFields.ql
  relativeBqrsPath: codeql/java-queries/Metrics/RefTypes/TNumberOfFields.bqrs
  metadata:
    name: Number of fields
    description: "The number of fields in a class, excluding enum constants."
    kind: treemap
    treemap.warnOn: highValues
    metricType: reftype
    metricAggregate: avg sum max
    id: java/fields-per-type
    tags: |-
      maintainability
             complexity
 -
  pack: codeql/java-queries#0
  relativeQueryPath: Metrics/RefTypes/TNumberOfStatements.ql
  relativeBqrsPath: codeql/java-queries/Metrics/RefTypes/TNumberOfStatements.bqrs
  metadata:
    name: Number of statements in types
    description: The number of statements in the methods and constructors of a type.
    kind: treemap
    treemap.warnOn: highValues
    metricType: reftype
    metricAggregate: avg sum max
    id: java/statements-per-type
    tags: maintainability
  queryHelp: |
    # Number of statements in types
    This metric measures the number of statements that occur in a type.

    If there are too many statements in a type, it is generally for one of two reasons:

    * One or more individual methods of the type contain too many statements, making them hard to understand, difficult to check and a common source of defects (particularly towards the end of the methods, since few people ever read that far). These methods typically lack cohesion because they are trying to do too many things.
    * The type contains too many methods, which generally indicates that it is trying to do too much, either at the interface or implementation level or both. It can be difficult for readers to understand because there is a confusing list of operations.

    ## Recommendation
    As described above, types reported as violations by this rule contain one or more methods with too many statements, or the type itself contains too many methods.

    * Individual methods of the type that contain too many statements should be refactored into multiple, smaller methods. As a rough guide, methods should be able to fit on a single screen or side of A4. Anything longer than that increases the risk of introducing new defects during routine code changes.
    * Types that contain too many methods often lack cohesion and are prime candidates for refactoring.

    ## References
    * M. Fowler. *Refactoring*. Addison-Wesley, 1999.
 -
  pack: codeql/java-queries#0
  relativeQueryPath: Metrics/RefTypes/TPercentageOfComments.ql
  relativeBqrsPath: codeql/java-queries/Metrics/RefTypes/TPercentageOfComments.bqrs
  metadata:
    name: Percentage of documentation in types
    description: The percentage of a type's lines that are comment rather than code.
    kind: treemap
    treemap.warnOn: lowValues
    metricType: reftype
    metricAggregate: avg max
    id: java/documentation-ratio-per-type
    tags: |-
      maintainability
             documentation
  queryHelp: |
    # Percentage of documentation in types
    This metric measures the percentage of a type's lines that are comment rather than code.

    A very low percentage of comments in a type may indicate either a potentially worrying lack of documentation or that the type was generated by an automated tool - a quick visual inspection should be sufficient to distinguish between the two cases.


    ## Recommendation
    If the type is not an auto-generated one, it should be documented at the first convenient opportunity (i.e. now). We note in passing that:

    * From a pragmatic standpoint, it is clear that not all types are equally important to document, so some common sense needs to be applied when deciding which code should be documented first.
    * Documenting entire types after the fact is not only onerous, but also often yields lower-quality documentation than would have been written by the original author at the time of writing the code (because other developers may not understand the context as well as the person who wrote the code). For this reason, finding completely undocumented types should be treated as a sign that your documentation practices in general need to improve.

    ## References
    * S. McConnell. *Code Complete*, 2nd Edition. Microsoft Press, 2004.
 -
  pack: codeql/java-queries#0
  relativeQueryPath: Metrics/RefTypes/TPercentageOfComplexCode.ql
  relativeBqrsPath: codeql/java-queries/Metrics/RefTypes/TPercentageOfComplexCode.bqrs
  metadata:
    name: Percentage of complex code in types
    description: The percentage of a type's code that is part of a complex method.
    kind: treemap
    treemap.warnOn: highValues
    metricType: reftype
    metricAggregate: avg max
    id: java/complex-code-ratio-per-type
    tags: |-
      testability
             complexity
  queryHelp: |
    # Percentage of complex code in types
    This metric measures the percentage of the code within each type that is part of a complex method (defined to be a method that has a high cyclomatic complexity, i.e. there are a high number of linearly-independent execution paths through the method).

    Methods with high cyclomatic complexity are typically difficult to understand and test. Types whose code is primarily contained within such tricky methods are often strong candidates for refactoring.


    ## Recommendation
    Each of the individual methods whose cyclomatic complexity is too high should be simplified, e.g. by tidying up complex logic and/or by splitting the method into multiple smaller methods using the 'Extract Method' refactoring from \[Fowler\]. If splitting the methods up results in a class with too many methods, the refactoring should be followed up with another one to resolve the new problem (as per the advice given for that situation).


    ## References
    * M. Fowler. *Refactoring*. Addison-Wesley, 1999.
 -
  pack: codeql/java-queries#0
  relativeQueryPath: Metrics/RefTypes/TResponse.ql
  relativeBqrsPath: codeql/java-queries/Metrics/RefTypes/TResponse.bqrs
  metadata:
    name: Class response
    description: |-
      The number of unique methods or constructors that can be called by all the methods
                    or constructors of a class.
    kind: treemap
    treemap.warnOn: highValues
    metricType: reftype
    metricAggregate: avg max
    id: java/response-per-type
    tags: |-
      maintainability
             complexity
  queryHelp: |
    # Class response
    *Response* is the number of unique methods (or constructors) that can be called by all the methods (or constructors) of a class. For example, if a class has two methods (X and Y), and one method calls methods A and B, and the other method calls methods A and C, the class's response is 3 (methods A, B, and C are called).

    Classes that have a high response can be difficult to understand and test. This is because you have to read through all the methods that can possibly be called to fully understand the class.


    ## Recommendation
    Generally, when a class has a high response, it is because it contains methods that individually make large numbers of calls or because it has high efferent coupling. The solution is therefore to fix these underlying problems, and the class's response decreases accordingly.


    ## References
    * S. R. Chidamber and C. F. Kemerer, *A metrics suite for object-oriented design*. IEEE Transactions on Software Engineering, 20(6):476-493, 1994.
 -
  pack: codeql/java-queries#0
  relativeQueryPath: Metrics/RefTypes/TSelfContainedness.ql
  relativeBqrsPath: codeql/java-queries/Metrics/RefTypes/TSelfContainedness.bqrs
  metadata:
    name: Self-containedness of types
    description: The percentage of the types on which a type depends for which we
      have the source code.
    kind: treemap
    treemap.warnOn: lowValues
    metricType: reftype
    metricAggregate: avg max
    id: java/source-dependency-ratio-per-type
    tags: |-
      portability
             modularity
  queryHelp: |
    # Self-containedness of types
    This metric measures the percentage of the types on which a type depends for which we have source code available.

    The availability of source code is one of the key factors affecting how easy or difficult it will be to build a software project in the future, especially on platforms other than those for which it was originally developed. Projects will a high level of self-containedness are likely to be more portable and easier to build in ten years' time than those that depend on many binary-only, third-party libraries. (This is one reason why many of the dependencies of open-source projects are distributed as source code, aside from the fact that the binaries are generally larger and more unwieldy to distribute.)

    In the context of Java's platform independence, the availability of source code is less critical than it is for platform-dependent languages. However, note that there can be minor binary incompatibilities between different versions of Java.


    ## Recommendation
    Low self-containedness may or may not be a problem, depending on the context of your project. However, if you determine that it is an issue for you, it is best tackled at a project level, in the following ways:

    * Try to use libraries for which the source code is available.
    * Try to obtain the source code for binary-only libraries from the authors.
    * Where practical, rewrite parts of your code to reduce your dependence on external libraries.

    ## References
    * Wikipedia. [Software portability](http://en.wikipedia.org/wiki/Software_portability). Published online.
    * Oracle Technology Network: [Java SE 6 Compatibility](http://www.oracle.com/technetwork/java/javase/compatibility-137541.html)
    * Java Language Specification: [Binary Compatibility](https://docs.oracle.com/javase/specs/jls/se11/html/jls-13.html)
 -
  pack: codeql/java-queries#0
  relativeQueryPath: Metrics/RefTypes/TSizeOfAPI.ql
  relativeBqrsPath: codeql/java-queries/Metrics/RefTypes/TSizeOfAPI.bqrs
  metadata:
    name: Size of a type's API
    description: The number of public methods in a public class.
    kind: treemap
    treemap.warnOn: highValues
    metricType: reftype
    metricAggregate: avg sum max
    id: java/public-functions-per-type
    tags: |-
      testability
             modularity
 -
  pack: codeql/java-queries#0
  relativeQueryPath: Metrics/RefTypes/TSpecialisationIndex.ql
  relativeBqrsPath: codeql/java-queries/Metrics/RefTypes/TSpecialisationIndex.bqrs
  metadata:
    name: Type specialization index
    description: The extent to which a subclass overrides the behavior of its superclasses.
    kind: treemap
    treemap.warnOn: highValues
    metricType: reftype
    metricAggregate: avg max
    id: java/type-specialization-index
    tags: |-
      modularity
             maintainability
  queryHelp: |
    # Type specialization index
    Specialization index is the extent to which a subclass overrides the behavior of its ancestor classes. It is computed as follows:

    1. Determine the number of overridden methods in the subclass (not counting overrides of abstract methods).
    1. Multiply this number by the subclass's depth in the inheritance hierarchy.
    1. Divide the result by the subclass's total number of methods.
    If a class overrides many of the methods of its ancestor classes, it indicates that the abstractions in the ancestor classes should be reviewed. This is particularly true for subclasses that are lower down in the inheritance hierarchy. In general, subclasses should *add* behavior to their superclasses, rather than *redefining* the behavior that is already there.


    ## Recommendation
    The most common reason that classes have a high specialization index is that multiple subclasses specialize a common base class in the same way. In this case, the relevant method(s) should be pulled up into the base class (see the 'Pull Up Method' refactoring in \[Fowler\]).


    ## Example
    In the following example, duplicating `getName` in each of the subclasses is unnecessary.


    ```java
    abstract class Animal {
        protected String animalName;

        public Animal(String name) {
            animalName = name;
        }

        public String getName(){
            return animalName;
        }
        public abstract String getKind();
    }

    class Dog extends Animal {
        public Dog(String name) {
            super(name);
        }

        public String getName() {  // This method duplicates the method in class 'Cat'.
            return animalName + " the " +  getKind();
        }

        public String getKind() {
            return "dog";
        }
     }

    class Cat extends Animal {
        public Cat(String name) {
            super(name);
        }

        public String getName() {  // This method duplicates the method in class 'Dog'.
            return animalName + " the " +  getKind();
        }

        public String getKind() {
            return "cat";
        }
    }

    ```
    To decrease the specialization index of the subclasses, pull up `getName` into the base class.


    ```java
    abstract class Animal {
        private String animalName;

        public Animal(String name) {
            animalName = name;
        }

        public String getName() {  // Method has been pulled up into the base class.
            return animalName + " the " +  getKind();
        }

        public abstract String getKind();
    }

    class Dog extends Animal {
        public Dog(String name) {
            super(name);
        }

        public String getKind() {
            return "dog";
        }
    }

    class Cat extends Animal {
        public Cat(String name) {
            super(name);
        }

        public String getKind() {
            return "cat";
        }
    }

    ```

    ## References
    * M. Fowler, *Refactoring*, pp. 260-3. Addison-Wesley, 1999.
    * M. Lorenz and J. Kidd, *Object-oriented Software Metrics*. Prentice Hall, 1994.
    * O. de Moor et al, *Keynote Address: .QL for Source Code Analysis*. Proceedings of the 7th IEEE International Working Conference on Source Code Analysis and Manipulation, 2007.
 -
  pack: codeql/java-queries#0
  relativeQueryPath: Metrics/Summaries/FrameworkCoverage.ql
  relativeBqrsPath: codeql/java-queries/Metrics/Summaries/FrameworkCoverage.bqrs
  metadata:
    id: java/summary/framework-coverage
    name: Metrics of framework coverage
    description: Expose metrics for the number of API endpoints covered by CSV models.
    kind: metric
    tags: summary
 -
  pack: codeql/java-queries#0
  relativeQueryPath: Metrics/Summaries/GeneratedVsManualCoverage.ql
  relativeBqrsPath: codeql/java-queries/Metrics/Summaries/GeneratedVsManualCoverage.bqrs
  metadata:
    id: java/summary/generated-vs-manual-coverage
    name: Metrics of generated versus manual MaD coverage
    description: Expose metrics for the number of API endpoints covered by generated
      versus manual MaD models.
    kind: table
    tags: summary
 -
  pack: codeql/java-queries#0
  relativeQueryPath: Metrics/Summaries/LinesOfCode.ql
  relativeBqrsPath: codeql/java-queries/Metrics/Summaries/LinesOfCode.bqrs
  metadata:
    id: java/summary/lines-of-code
    name: Total lines of Java/Kotlin code in the database
    description: |-
      The total number of lines of code across all Java and Kotlin files. This is a useful metric of the size of a database.
                    For all source files that were seen during the build, this query counts the lines of code, excluding whitespace
                    or comments.
    kind: metric
    tags: |-
      summary
             lines-of-code
             debug
 -
  pack: codeql/java-queries#0
  relativeQueryPath: Metrics/Summaries/LinesOfCodeJava.ql
  relativeBqrsPath: codeql/java-queries/Metrics/Summaries/LinesOfCodeJava.bqrs
  metadata:
    id: java/summary/lines-of-code-java
    name: Total lines of Java code in the database
    description: |-
      The total number of lines of code across all Java files. This is a useful metric of the size of a database.
                    For all Java files that were seen during the build, this query counts the lines of code, excluding whitespace
                    or comments.
    kind: metric
    tags: |-
      summary
             debug
 -
  pack: codeql/java-queries#0
  relativeQueryPath: Metrics/Summaries/LinesOfCodeKotlin.ql
  relativeBqrsPath: codeql/java-queries/Metrics/Summaries/LinesOfCodeKotlin.bqrs
  metadata:
    id: java/summary/lines-of-code-kotlin
    name: Total lines of Kotlin code in the database
    description: |-
      The total number of lines of code across all Kotlin files. This is a useful metric of the size of a database.
                    For all Kotlin files that were seen during the build, this query counts the lines of code, excluding whitespace
                    or comments.
    kind: metric
    tags: |-
      summary
             debug
 -
  pack: codeql/java-queries#0
  relativeQueryPath: Performance/ConcatenationInLoops.ql
  relativeBqrsPath: codeql/java-queries/Performance/ConcatenationInLoops.bqrs
  metadata:
    name: String concatenation in loop
    description: |-
      Performing string concatenation in a loop that iterates many times may affect
                    performance.
    kind: problem
    problem.severity: warning
    precision: low
    id: java/string-concatenation-in-loop
    tags: |-
      efficiency
             maintainability
  queryHelp: "# String concatenation in loop\nWhen string concatenation is performed\
    \ using the \"+\" operator, the compiler translates this operation to a suitable\
    \ manipulation, possibly constructing several intermediate strings. In general,\
    \ because strings are immutable, at least one new string has to be constructed\
    \ to hold the result.\n\nBuilding up a string one piece at a time in a loop requires\
    \ a new string on every iteration, repeatedly copying longer and longer prefixes\
    \ to fresh string objects. As a result, performance can be severely degraded.\n\
    \n\n## Recommendation\nWhenever a string is constructed using a loop that iterates\
    \ more than just a few times, it is usually better to create a `StringBuffer`\
    \ or `StringBuilder` object and append to that. Because such buffers are based\
    \ on mutable character arrays, which do not require a new string to be created\
    \ for each concatenation, they can reduce the cost of repeatedly growing the string.\n\
    \nTo choose between `StringBuffer` and `StringBuilder`, check if the new buffer\
    \ object can possibly be accessed by several different threads while in use. If\
    \ multi-thread safety is required, use a `StringBuffer`. For purely local string\
    \ buffers, you can avoid the overhead of synchronization by using a `StringBuilder`.\n\
    \n\n## Example\nThe following example shows a simple test that measures the time\
    \ taken to construct a string. It constructs the same string of 65,536 binary\
    \ digits, character-by-character, first by repeatedly appending to a string, and\
    \ then by using a `StringBuilder`. The second method is three orders of magnitude\
    \ faster.\n\n\n```java\npublic class ConcatenationInLoops {\n\tpublic static void\
    \ main(String[] args) {\n\t\tRandom r = new Random(123);\n\t\tlong start = System.currentTimeMillis();\n\
    \t\tString s = \"\";\n\t\tfor (int i = 0; i < 65536; i++)\n\t\t\ts += r.nextInt(2);\n\
    \t\tSystem.out.println(System.currentTimeMillis() - start);  // This prints roughly\
    \ 4500.\n\n\t\tr = new Random(123);\n\t\tstart = System.currentTimeMillis();\n\
    \t\tStringBuilder sb = new StringBuilder();\n\t\tfor (int i = 0; i < 65536; i++)\n\
    \t\t\tsb.append(r.nextInt(2));\n\t\ts = sb.toString();\n\t\tSystem.out.println(System.currentTimeMillis()\
    \ - start);  // This prints 5.\n\t}\n}\n```\n\n## References\n* J. Bloch, *Effective\
    \ Java (second edition)*, Item 51. Addison-Wesley, 2008.\n* Java API Specification:\
    \ [StringBuffer](https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/lang/StringBuffer.html),\
    \ [StringBuilder](https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/lang/StringBuilder.html).\n"
 -
  pack: codeql/java-queries#0
  relativeQueryPath: Performance/InefficientEmptyStringTest.ql
  relativeBqrsPath: codeql/java-queries/Performance/InefficientEmptyStringTest.bqrs
  metadata:
    name: Inefficient empty string test
    description: Checking a string for equality with an empty string is inefficient.
    kind: problem
    problem.severity: recommendation
    precision: high
    id: java/inefficient-empty-string-test
    tags: |-
      efficiency
             maintainability
  queryHelp: "# Inefficient empty string test\nWhen checking whether a string `s`\
    \ is empty, perhaps the most obvious solution is to write something like `s.equals(\"\
    \")` (or `\"\".equals(s)`). However, this actually carries a fairly significant\
    \ overhead, because `String.equals` performs a number of type tests and conversions\
    \ before starting to compare the content of the strings.\n\n\n## Recommendation\n\
    The preferred way of checking whether a string `s` is empty is to check if its\
    \ length is equal to zero. Thus, the condition is `s.length() == 0`. The `length`\
    \ method is implemented as a simple field access, and so should be noticeably\
    \ faster than calling `equals`.\n\nNote that in Java 6 and later, the `String`\
    \ class has an `isEmpty` method that checks whether a string is empty. If the\
    \ codebase does not need to support Java 5, it may be better to use that method\
    \ instead.\n\n\n## Example\nIn the following example, class `InefficientDBClient`\
    \ uses `equals` to test whether the strings `user` and `pw` are empty. Note that\
    \ the test `\"\".equals(pw)` guards against `NullPointerException`, but the test\
    \ `user.equals(\"\")` throws a `NullPointerException` if `user` is `null`.\n\n\
    In contrast, the class `EfficientDBClient` uses `length` instead of `equals`.\
    \ The class preserves the behavior of `InefficientDBClient` by guarding `pw.length()\
    \ == 0` but not `user.length() == 0` with an explicit test for `null`. Whether\
    \ or not this guard is desirable depends on the intended behavior of the program.\n\
    \n\n```java\n// Inefficient version\nclass InefficientDBClient {\n\tpublic void\
    \ connect(String user, String pw) {\n\t\tif (user.equals(\"\") || \"\".equals(pw))\n\
    \t\t\tthrow new RuntimeException();\n\t\t...\n\t}\n}\n\n// More efficient version\n\
    class EfficientDBClient {\n\tpublic void connect(String user, String pw) {\n\t\
    \tif (user.length() == 0 || (pw != null && pw.length() == 0))\n\t\t\tthrow new\
    \ RuntimeException();\n\t\t...\n\t}\n}\n\n```\n\n## References\n* Java API Specification:\
    \ [String.length()](https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/lang/String.html#length()),\
    \ [String.isEmpty()](https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/lang/String.html#isEmpty()),\
    \ [String.equals()](https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/lang/String.html#equals(java.lang.Object)).\n"
 -
  pack: codeql/java-queries#0
  relativeQueryPath: Performance/InefficientKeySetIterator.ql
  relativeBqrsPath: codeql/java-queries/Performance/InefficientKeySetIterator.bqrs
  metadata:
    name: Inefficient use of key set iterator
    description: Iterating through the values of a map using the key set is inefficient.
    kind: problem
    problem.severity: recommendation
    precision: high
    id: java/inefficient-key-set-iterator
    tags: |-
      efficiency
             maintainability
  queryHelp: "# Inefficient use of key set iterator\nJava's Collections Framework\
    \ provides several different ways of iterating the contents of a map. You can\
    \ retrieve the set of keys, the collection of values, or the set of \"entries\"\
    \ (which are, in effect, key/value pairs).\n\nThe choice of iterator can affect\
    \ performance. For example, it is considered bad practice to iterate the key set\
    \ of a map if the body of the loop performs a map lookup on each retrieved key\
    \ anyway.\n\n\n## Recommendation\nEvaluate the requirements of the loop body.\
    \ If it does not actually need the key apart from looking it up in the map, iterate\
    \ the map's values (obtained by a call to `values`) instead. If the loop genuinely\
    \ needs both key and value for each mapping in the map, iterate the entry set\
    \ (obtained by a call to `entrySet`) and retrieve the key and value from each\
    \ entry. This saves a more expensive map lookup each time.\n\n\n## Example\nIn\
    \ the following example, the first version of the method `findId` iterates the\
    \ map `people` using the key set. This is inefficient because the body of the\
    \ loop needs to access the value for each key. In contrast, the second version\
    \ iterates the map using the entry set because the loop body needs both the key\
    \ and the value for each mapping.\n\n\n```java\n// AVOID: Iterate the map using\
    \ the key set.\nclass AddressBook {\n\tprivate Map<String, Person> people = ...;\n\
    \tpublic String findId(String first, String last) {\n\t\tfor (String id : people.keySet())\
    \ {\n\t\t\tPerson p = people.get(id);\n\t\t\tif (first.equals(p.firstName()) &&\
    \ last.equals(p.lastName()))\n\t\t\t\treturn id;\n\t\t}\n\t\treturn null;\n\t\
    }\n}\n\n// GOOD: Iterate the map using the entry set.\nclass AddressBook {\n\t\
    private Map<String, Person> people = ...;\n\tpublic String findId(String first,\
    \ String last) {\n\t\tfor (Entry<String, Person> entry: people.entrySet()) {\n\
    \t\t\tPerson p = entry.getValue();\n\t\t\tif (first.equals(p.firstName()) && last.equals(p.lastName()))\n\
    \t\t\t\treturn entry.getKey();\n\t\t}\n\t\treturn null;\n\t}\n}\n```\n\n## References\n\
    * Java API Specification: [Map.entrySet()](https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/util/Map.html#entrySet()).\n"
 -
  pack: codeql/java-queries#0
  relativeQueryPath: Performance/InefficientOutputStream.ql
  relativeBqrsPath: codeql/java-queries/Performance/InefficientOutputStream.bqrs
  metadata:
    name: Inefficient output stream
    description: |-
      Using the default implementation of 'write(byte[],int,int)'
                    provided by 'java.io.OutputStream' is very inefficient.
    kind: problem
    problem.severity: warning
    precision: very-high
    id: java/inefficient-output-stream
    tags: efficiency
  queryHelp: "# Inefficient output stream\nThe classes `java.io.OutputStream` and\
    \ `java.io.FilterOutputStream` only require subclasses to implement the method\
    \ `write(byte b)`. Typically, uses of `OutputStream`s will not write single bytes,\
    \ but an array via the `write(byte[] b, int off, int len)` method. The default\
    \ implementation of this method, which you are not required to override, calls\
    \ `write(byte b)` for each byte in the array. If this method involves I/O, such\
    \ as accessing the network or disk, this is likely to incur significant overhead.\n\
    \n\n## Recommendation\nAlways provide an implementation of the `write(byte[] b,\
    \ int off, int len)` method.\n\n\n## Example\nThe following example shows a subclass\
    \ of `OutputStream` that simply wraps a `DigestOutputStream` to confirm that the\
    \ data it writes to a file has the expected MD5 hash. Without an implementation\
    \ of `write(byte[] b, int off, int len)` this will be very slow, because it makes\
    \ a call to `DigestOutputStream.write(byte b)` and `FileOutputStream.write(byte\
    \ b)` for each byte written.\n\n\n```java\npublic class DigestCheckingFileOutputStream\
    \ extends OutputStream {\n\tprivate DigestOutputStream digest;\n\tprivate byte[]\
    \ expectedMD5;\n\n\tpublic DigestCheckingFileOutputStream(File file, byte[] expectedMD5)\n\
    \t\tthrows IOException, NoSuchAlgorithmException {\n\t\t\tthis.expectedMD5 = expectedMD5;\n\
    \t\t\tdigest = new DigestOutputStream(new FileOutputStream(file),\n\t\t\t\t\t\t\
    \t\t\t\t\tMessageDigest.getInstance(\"MD5\"));\n\t\t}\n\n\t@Override\n\tpublic\
    \ void write(int b) throws IOException {\n\t\tdigest.write(b);\n\t}\n\n\t@Override\n\
    \tpublic void close() throws IOException {\n\t\tsuper.close();\n\n\t\tdigest.close();\n\
    \t\tbyte[] md5 = digest.getMessageDigest().digest();\n\t\tif (expectedMD5 != null\
    \ && !Arrays.equals(expectedMD5, md5)) {\n\t\t\tthrow new InternalError();\n\t\
    \t}\n\t}\n}\n\n```\nThe example can be updated to use a more efficient method.\
    \ In this case, calls to `write(byte[] b, int off, int len)` are simply forwarded\
    \ to `DigestOutputStream.write(byte[] b, int off, int len)`.\n\n\n```java\npublic\
    \ class DigestCheckingFileOutputStream extends OutputStream {\n\tprivate DigestOutputStream\
    \ digest;\n\tprivate byte[] expectedMD5;\n\n\tpublic DigestCheckingFileOutputStream(File\
    \ file, byte[] expectedMD5)\n\t\tthrows IOException, NoSuchAlgorithmException\
    \ {\n\t\t\tthis.expectedMD5 = expectedMD5;\n\t\t\tdigest = new DigestOutputStream(new\
    \ FileOutputStream(file),\n\t\t\t\t\t\t\t\t\t\t\tMessageDigest.getInstance(\"\
    MD5\"));\n\t\t}\n\n\t@Override\n\tpublic void write(int b) throws IOException\
    \ {\n\t\tdigest.write(b);\n\t}\n\n\t@Override\n\tpublic void write(byte[] b, int\
    \ off, int len) throws IOException {\n\t\tdigest.write(b, off, len);\n\t}\n\n\t\
    @Override\n\tpublic void close() throws IOException {\n\t\tsuper.close();\n\n\t\
    \tdigest.close();\n\t\tbyte[] md5 = digest.getMessageDigest().digest();\n\t\t\
    if (expectedMD5 != null && !Arrays.equals(expectedMD5, md5)) {\n\t\t\tthrow new\
    \ InternalError();\n\t\t}\n\t}\n}\n\n```\n\n## References\n* Java API Specification:\
    \ [OutputStream.write(byte\\[\\] b, int off, int len)](https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/io/OutputStream.html#write(byte[],int,int)),\
    \ [FilterOutputStream.write(byte\\[\\] b, int off, int len)](https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/io/FilterOutputStream.html#write(byte[],int,int)).\n"
 -
  pack: codeql/java-queries#0
  relativeQueryPath: Performance/InefficientPrimConstructor.ql
  relativeBqrsPath: codeql/java-queries/Performance/InefficientPrimConstructor.bqrs
  metadata:
    name: Inefficient primitive constructor
    description: Calling the constructor of a boxed type is inefficient.
    kind: problem
    problem.severity: recommendation
    precision: high
    id: java/inefficient-boxed-constructor
    tags: |-
      efficiency
             maintainability
  queryHelp: "# Inefficient primitive constructor\nPrimitive values (for example `int`,\
    \ `float`, `boolean`) all have corresponding reference types known as *boxed types*\
    \ (for example `Integer`, `Float`, `Boolean`). These boxed types can be used when\
    \ an actual object is required. While they all provide constructors that take\
    \ a primitive value of the appropriate type, it is usually considered bad practice\
    \ to call those constructors directly.\n\nEach boxed type provides a static `valueOf`\
    \ method that takes an argument of the appropriate primitive type and returns\
    \ an object representing it. The advantage of calling `valueOf` over calling a\
    \ constructor is that it allows for some caching of instances. By reusing these\
    \ cached instances instead of constructing new heap objects all the time, a significant\
    \ amount of garbage collector effort can be saved.\n\n\n## Recommendation\nIn\
    \ almost all circumstances, a call of, for example, `Integer.valueOf(42)` can\
    \ be used instead of `new Integer(42)`.\n\nNote that sometimes you can rely on\
    \ Java's *autoboxing* feature, which implicitly calls `valueOf`. For details,\
    \ see the example.\n\n\n## Example\nThe following example shows the three ways\
    \ of creating a new integer. In the autoboxing example, the zero is autoboxed\
    \ to an `Integer` because the constructor `Account` takes an argument of this\
    \ type.\n\n\n```java\npublic class Account {\n\tprivate Integer balance;\n\tpublic\
    \ Account(Integer startingBalance) {\n\t\tthis.balance = startingBalance;\n\t\
    }\n}\n\npublic class BankManager {\n\tpublic void openAccount(Customer c) {\n\t\
    \t...\n\t\t// AVOID: Inefficient primitive constructor\n\t\taccounts.add(new Account(new\
    \ Integer(0)));\n\t\t// GOOD: Use 'valueOf'\n\t\taccounts.add(new Account(Integer.valueOf(0)));\n\
    \t\t// GOOD: Rely on autoboxing\n\t\taccounts.add(new Account(0));\n\t}\n}\n```\n\
    \n## References\n* J. Bloch, *Effective Java (second edition)*, Items 1 and 5.\
    \ Addison-Wesley, 2008.\n* Java API Specification: [Boolean.valueOf()](https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/lang/Boolean.html#valueOf(boolean)),\
    \ [Byte.valueOf()](https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/lang/Byte.html#valueOf(byte)),\
    \ [Short.valueOf()](https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/lang/Short.html#valueOf(short)),\
    \ [Character.valueOf()](https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/lang/Character.html#valueOf(char)),\
    \ [Integer.valueOf()](https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/lang/Integer.html#valueOf(int)),\
    \ [Long.valueOf()](https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/lang/Long.html#valueOf(long)),\
    \ [Float.valueOf()](https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/lang/Float.html#valueOf(float)),\
    \ [Double.valueOf()](https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/lang/Double.html#valueOf(double)).\n"
 -
  pack: codeql/java-queries#0
  relativeQueryPath: Performance/InnerClassCouldBeStatic.ql
  relativeBqrsPath: codeql/java-queries/Performance/InnerClassCouldBeStatic.bqrs
  metadata:
    name: Inner class could be static
    description: |-
      A non-static nested class keeps a reference to the enclosing object,
                    which makes the nested class bigger and may cause a memory leak.
    kind: problem
    problem.severity: recommendation
    precision: high
    id: java/non-static-nested-class
    tags: |-
      efficiency
             maintainability
  queryHelp: |
    # Inner class could be static
    Nested classes allow logical grouping of related concerns, increasing encapsulation and readability. However, there is a potential disadvantage when using them that you should be aware of.

    Any non-static nested class implicitly holds onto its "enclosing instance". This means that:

    * The nested class has an implicitly defined field. The field holds a reference to the instance of the enclosing class that constructed the nested class.
    * The nested class's constructors have an implicit parameter. The parameter is used for passing in the instance of the enclosing class. A reference to the instance is then stored in the field mentioned above.
    Often, this is useful and necessary, because non-static nested class instances have access to instance state on their enclosing classes. However, if this instance state is not needed by the nested class, this makes nested class instances larger than necessary, and hidden references to the enclosing classes are often the source of subtle memory leaks.


    ## Recommendation
    When a nested class does not need the enclosing instance, it is better to declare the nested class `static`, avoiding the implicit field. As a result, instances of the nested class become smaller, and hidden references to the enclosing class are made explicit.

    If a reference to the enclosing class instance is required during construction of the nested class instance (but not subsequently), the constructor of the nested class should be refactored so that it is explicitly given a reference to the enclosing instance.

    If the nested class refers to a type variable of an enclosing class instance, consider parameterizing the nested class by that type variable.


    ## References
    * J. Bloch, *Effective Java (second edition)*, Item 22. Addison-Wesley, 2008.
    * Java Language Specification: [8.1.3. Inner Classes and Enclosing Instances](https://docs.oracle.com/javase/specs/jls/se11/html/jls-8.html#jls-8.1.3).
    * The Java Tutorials: [Nested Classes](https://docs.oracle.com/javase/tutorial/java/javaOO/nested.html).
 -
  pack: codeql/java-queries#0
  relativeQueryPath: Performance/NewStringString.ql
  relativeBqrsPath: codeql/java-queries/Performance/NewStringString.bqrs
  metadata:
    name: Inefficient String constructor
    description: |-
      Using the 'String(String)' constructor is less memory efficient than using the
                    constructor argument directly.
    kind: problem
    problem.severity: recommendation
    precision: high
    id: java/inefficient-string-constructor
    tags: |-
      efficiency
             maintainability
  queryHelp: "# Inefficient String constructor\nThe `String` class is immutable, which\
    \ means that there is no way to change the string that it represents. Consequently,\
    \ there is rarely a need to copy a `String` object or construct a new instance\
    \ based on an existing string, for example by writing something like `String hello\
    \ = new String(\"hello\")`. Furthermore, this practice is not memory efficient.\n\
    \n\n## Recommendation\nThe copied string is functionally indistinguishable from\
    \ the argument that was passed into the `String` constructor, so you can simply\
    \ omit the constructor call and use the argument passed into it directly. Unless\
    \ an explicit copy of the argument string is needed, this is a safe transformation.\n\
    \n\n## Example\nThe following example shows three cases of copying a string using\
    \ the `String` constructor, which is inefficient. In each case, simply removing\
    \ the constructor call `new String` and leaving the argument results in better\
    \ code and less memory churn.\n\n\n```java\npublic void sayHello(String world)\
    \ {\n\t// AVOID: Inefficient 'String' constructor\n\tString message = new String(\"\
    hello \");\n\n\t// AVOID: Inefficient 'String' constructor\n\tmessage = new String(message\
    \ + world);\n\n\t// AVOID: Inefficient 'String' constructor\n\tSystem.out.println(new\
    \ String(message));\n}\n```\n\n## References\n* J. Bloch, *Effective Java (second\
    \ edition)*, Item 5. Addison-Wesley, 2008.\n* Java API Specification: [String(String)](https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/lang/String.html#%3Cinit%3E(java.lang.String)).\n"
 -
  pack: codeql/java-queries#0
  relativeQueryPath: Security/CWE/CWE-020/ExternalAPIsUsedWithUntrustedData.ql
  relativeBqrsPath: codeql/java-queries/Security/CWE/CWE-020/ExternalAPIsUsedWithUntrustedData.bqrs
  metadata:
    name: Frequency counts for external APIs that are used with untrusted data
    description: |-
      This reports the external APIs that are used with untrusted data, along with how
                    frequently the API is called, and how many unique sources of untrusted data flow
                    to it.
    id: java/count-untrusted-data-external-api
    kind: table
    tags: security external/cwe/cwe-20
  queryHelp: |
    # Frequency counts for external APIs that are used with untrusted data
    Using unsanitized untrusted data in an external API can cause a variety of security issues. This query reports all external APIs that are used with untrusted data, along with how frequently the API is used, and how many unique sources of untrusted data flow to this API. This query is designed primarily to help identify which APIs may be relevant for security analysis of this application.

    An external API is defined as a method call to a method that is not defined in the source code, not overridden in the source code, and is not modeled as a taint step in the default taint library. External APIs may be from the Java standard library, third party dependencies or from internal dependencies. The query will report the method signature with a fully qualified name, along with either `[param x]`, where `x` indicates the position of the parameter receiving the untrusted data or `[qualifier]` indicating the untrusted data is used as the qualifier to the method call.


    ## Recommendation
    For each result:

    * If the result highlights a known sink, no action is required.
    * If the result highlights an unknown sink for a problem, then add modeling for the sink to the relevant query.
    * If the result represents a call to an external API which transfers taint, add the appropriate modeling, and re-run the query to determine what new results have appeared due to this additional modeling.
    Otherwise, the result is likely uninteresting. Custom versions of this query can extend the `SafeExternalAPIMethod` class to exclude known safe external APIs from future analysis.


    ## Example
    If the query were to return the API `javax.servlet.http.HttpServletResponse.sendError(int, java.lang.String) [param 1]` then we should first consider whether this a security relevant sink. In this case, this is writing to a HTTP response, so we should consider whether this is an XSS sink. If it is, we should confirm that it is handled by the XSS query.

    If the query were to return the API `java.lang.StringBuilder.append(java.lang.String) [param 0]`, then this should be reviewed as a possible taint step, because tainted data would flow from the 0th argument to the qualifier of the call.

    Note that both examples are correctly handled by the standard taint tracking library and XSS query.


    ## References
    * Common Weakness Enumeration: [CWE-20](https://cwe.mitre.org/data/definitions/20.html).
 -
  pack: codeql/java-queries#0
  relativeQueryPath: Security/CWE/CWE-020/OverlyLargeRange.ql
  relativeBqrsPath: codeql/java-queries/Security/CWE/CWE-020/OverlyLargeRange.bqrs
  metadata:
    name: Overly permissive regular expression range
    description: |-
      Overly permissive regular expression ranges match a wider range of characters than intended.
                    This may allow an attacker to bypass a filter or sanitizer.
    kind: problem
    problem.severity: warning
    security-severity: 5.0
    precision: high
    id: java/overly-large-range
    tags: |-
      correctness
             security
             external/cwe/cwe-020
  queryHelp: |
    # Overly permissive regular expression range
    It's easy to write a regular expression range that matches a wider range of characters than you intended. For example, `/[a-zA-z]/` matches all lowercase and all uppercase letters, as you would expect, but it also matches the characters: `` [ \ ] ^ _ ` ``.

    Another common problem is failing to escape the dash character in a regular expression. An unescaped dash is interpreted as part of a range. For example, in the character class `[a-zA-Z0-9%=.,-_]` the last character range matches the 55 characters between `,` and `_` (both included), which overlaps with the range `[0-9]` and is clearly not intended by the writer.


    ## Recommendation
    Avoid any confusion about which characters are included in the range by writing unambiguous regular expressions. Always check that character ranges match only the expected characters.


    ## Example
    The following example code is intended to check whether a string is a valid 6 digit hex color.

    ```java

    import java.util.regex.Pattern
    public class Tester {
        public static boolean is_valid_hex_color(String color) {
            return Pattern.matches("#[0-9a-fA-f]{6}", color);
        }
    }

    ```
    However, the `A-f` range is overly large and matches every uppercase character. It would parse a "color" like `#XXYYZZ` as valid.

    The fix is to use an uppercase `A-F` range instead.

    ```javascript

    import java.util.regex.Pattern
    public class Tester {
        public static boolean is_valid_hex_color(String color) {
            return Pattern.matches("#[0-9a-fA-F]{6}", color);
        }
    }

    ```

    ## References
    * GitHub Advisory Database: [CVE-2021-42740: Improper Neutralization of Special Elements used in a Command in Shell-quote](https://github.com/advisories/GHSA-g4rg-993r-mgx7)
    * wh0.github.io: [Exploiting CVE-2021-42740](https://wh0.github.io/2021/10/28/shell-quote-rce-exploiting.html)
    * Yosuke Ota: [no-obscure-range](https://ota-meshi.github.io/eslint-plugin-regexp/rules/no-obscure-range.html)
    * Paul Boyd: [The regex \[,-.\]](https://pboyd.io/posts/comma-dash-dot/)
    * Common Weakness Enumeration: [CWE-20](https://cwe.mitre.org/data/definitions/20.html).
 -
  pack: codeql/java-queries#0
  relativeQueryPath: Security/CWE/CWE-020/UntrustedDataToExternalAPI.ql
  relativeBqrsPath: codeql/java-queries/Security/CWE/CWE-020/UntrustedDataToExternalAPI.bqrs
  metadata:
    name: Untrusted data passed to external API
    description: "Data provided remotely is used in this external API without sanitization,\
      \ which could be a security risk."
    id: java/untrusted-data-to-external-api
    kind: path-problem
    precision: low
    problem.severity: error
    security-severity: 7.8
    tags: security external/cwe/cwe-20
  queryHelp: "# Untrusted data passed to external API\nUsing unsanitized untrusted\
    \ data in an external API can cause a variety of security issues. This query reports\
    \ external APIs that use untrusted data. The results are not filtered so that\
    \ you can audit all examples. The query provides data for security reviews of\
    \ the application and you can also use it to identify external APIs that should\
    \ be modeled as either taint steps, or sinks for specific problems.\n\nAn external\
    \ API is defined as a method call to a method that is not defined in the source\
    \ code, not overridden in the source code, and is not modeled as a taint step\
    \ in the default taint library. External APIs may be from the Java standard library,\
    \ third-party dependencies or from internal dependencies. The query reports uses\
    \ of untrusted data in either the qualifier or as one of the arguments of external\
    \ APIs.\n\n\n## Recommendation\nFor each result:\n\n* If the result highlights\
    \ a known sink, confirm that the result is reported by the relevant query, or\
    \ that the result is a false positive because this data is sanitized.\n* If the\
    \ result highlights an unknown sink for a problem, then add modeling for the sink\
    \ to the relevant query, and confirm that the result is either found, or is safe\
    \ due to appropriate sanitization.\n* If the result represents a call to an external\
    \ API that transfers taint, add the appropriate modeling, and re-run the query\
    \ to determine what new results have appeared due to this additional modeling.\n\
    Otherwise, the result is likely uninteresting. Custom versions of this query can\
    \ extend the `SafeExternalAPIMethod` class to exclude known safe external APIs\
    \ from future analysis.\n\n\n## Example\nIn this first example, a request parameter\
    \ is read from `HttpServletRequest` and then ultimately used in a call to the\
    \ `HttpServletResponse.sendError` external API:\n\n\n```java\npublic class XSS\
    \ extends HttpServlet {\n\tprotected void doGet(HttpServletRequest request, HttpServletResponse\
    \ response)\n\tthrows ServletException, IOException {\n\t\t// BAD: a request parameter\
    \ is written directly to an error response page\n\t\tresponse.sendError(HttpServletResponse.SC_NOT_FOUND,\n\
    \t\t\t\t\"The page \\\"\" + request.getParameter(\"page\") + \"\\\" was not found.\"\
    );\n\t}\n}\n\n```\nThis is an XSS sink. The XSS query should therefore be reviewed\
    \ to confirm that this sink is appropriately modeled, and if it is, to confirm\
    \ that the query reports this particular result, or that the result is a false\
    \ positive due to some existing sanitization.\n\nIn this second example, again\
    \ a request parameter is read from `HttpServletRequest`.\n\n\n```java\npublic\
    \ class SQLInjection extends HttpServlet {\n\tprotected void doGet(HttpServletRequest\
    \ request, HttpServletResponse response)\n\tthrows ServletException, IOException\
    \ {\n\n\t\tStringBuilder sqlQueryBuilder = new StringBuilder();\n\t\tsqlQueryBuilder.append(\"\
    SELECT * FROM user WHERE user_id='\");\n\t\tsqlQueryBuilder.append(request.getParameter(\"\
    user_id\"));\n\t\tsqlQueryBuilder.append(\"'\");\n\n\t\t// ...\n\t}\n}\n\n```\n\
    If the query reported the call to `StringBuilder.append` on line 7, this would\
    \ suggest that this external API is not currently modeled as a taint step in the\
    \ taint tracking library. The next step would be to model this as a taint step,\
    \ then re-run the query to determine what additional results might be found. In\
    \ this example, it seems likely that the result of the `StringBuilder` will be\
    \ executed as an SQL query, potentially leading to an SQL injection vulnerability.\n\
    \nNote that both examples are correctly handled by the standard taint tracking\
    \ library and XSS query.\n\n\n## References\n* Common Weakness Enumeration: [CWE-20](https://cwe.mitre.org/data/definitions/20.html).\n"
 -
  pack: codeql/java-queries#0
  relativeQueryPath: Security/CWE/CWE-022/TaintedPath.ql
  relativeBqrsPath: codeql/java-queries/Security/CWE/CWE-022/TaintedPath.bqrs
  metadata:
    name: Uncontrolled data used in path expression
    description: Accessing paths influenced by users can allow an attacker to access
      unexpected resources.
    kind: path-problem
    problem.severity: error
    security-severity: 7.5
    precision: high
    id: java/path-injection
    tags: |-
      security
             external/cwe/cwe-022
             external/cwe/cwe-023
             external/cwe/cwe-036
             external/cwe/cwe-073
  queryHelp: "# Uncontrolled data used in path expression\nAccessing paths controlled\
    \ by users can allow an attacker to access unexpected resources. This can result\
    \ in sensitive information being revealed or deleted, or an attacker being able\
    \ to influence behavior by modifying unexpected files.\n\nPaths that are naively\
    \ constructed from data controlled by a user may be absolute paths, or may contain\
    \ unexpected special characters such as \"..\". Such a path could point anywhere\
    \ on the file system.\n\n\n## Recommendation\nValidate user input before using\
    \ it to construct a file path.\n\nCommon validation methods include checking that\
    \ the normalized path is relative and does not contain any \"..\" components,\
    \ or checking that the path is contained within a safe folder. The method you\
    \ should use depends on how the path is used in the application, and whether the\
    \ path should be a single path component.\n\nIf the path should be a single path\
    \ component (such as a file name), you can check for the existence of any path\
    \ separators (\"/\" or \"\\\\\"), or \"..\" sequences in the input, and reject\
    \ the input if any are found.\n\nNote that removing \"../\" sequences is *not*\
    \ sufficient, since the input could still contain a path separator followed by\
    \ \"..\". For example, the input \".../...//\" would still result in the string\
    \ \"../\" if only \"../\" sequences are removed.\n\nFinally, the simplest (but\
    \ most restrictive) option is to use an allow list of safe patterns and make sure\
    \ that the user input matches one of these patterns.\n\n\n## Example\nIn this\
    \ example, a file name is read from a `java.net.Socket` and then used to access\
    \ a file and send it back over the socket. However, a malicious user could enter\
    \ a file name anywhere on the file system, such as \"/etc/passwd\" or \"../../../etc/passwd\"\
    .\n\n\n```java\npublic void sendUserFile(Socket sock, String user) {\n\tBufferedReader\
    \ filenameReader = new BufferedReader(\n\t\t\tnew InputStreamReader(sock.getInputStream(),\
    \ \"UTF-8\"));\n\tString filename = filenameReader.readLine();\n\t// BAD: read\
    \ from a file without checking its path\n\tBufferedReader fileReader = new BufferedReader(new\
    \ FileReader(filename));\n\tString fileLine = fileReader.readLine();\n\twhile(fileLine\
    \ != null) {\n\t\tsock.getOutputStream().write(fileLine.getBytes());\n\t\tfileLine\
    \ = fileReader.readLine();\n\t}\n}\n\n```\nIf the input should only be a file\
    \ name, you can check that it doesn't contain any path separators or \"..\" sequences.\n\
    \n\n```java\npublic void sendUserFileGood(Socket sock, String user) {\n\tBufferedReader\
    \ filenameReader = new BufferedReader(\n\t\t\tnew InputStreamReader(sock.getInputStream(),\
    \ \"UTF-8\"));\n\tString filename = filenameReader.readLine();\n\t// GOOD: ensure\
    \ that the filename has no path separators or parent directory references\n\t\
    if (filename.contains(\"..\") || filename.contains(\"/\") || filename.contains(\"\
    \\\\\")) {\n\t\tthrow new IllegalArgumentException(\"Invalid filename\");\n\t\
    }\n\tBufferedReader fileReader = new BufferedReader(new FileReader(filename));\n\
    \tString fileLine = fileReader.readLine();\n\twhile(fileLine != null) {\n\t\t\
    sock.getOutputStream().write(fileLine.getBytes());\n\t\tfileLine = fileReader.readLine();\n\
    \t}\t\n}\n\n```\nIf the input should be within a specific directory, you can check\
    \ that the resolved path is still contained within that directory.\n\n\n```java\n\
    public void sendUserFileGood(Socket sock, String user) {\n\tBufferedReader filenameReader\
    \ = new BufferedReader(\n\t\t\tnew InputStreamReader(sock.getInputStream(), \"\
    UTF-8\"));\n\tString filename = filenameReader.readLine();\n\n\tPath publicFolder\
    \ = Paths.get(\"/home/\" + user + \"/public\").normalize().toAbsolutePath();\n\
    \tPath filePath = publicFolder.resolve(filename).normalize().toAbsolutePath();\n\
    \n\t// GOOD: ensure that the path stays within the public folder\n\tif (!filePath.startsWith(publicFolder\
    \ + File.separator)) {\n\t\tthrow new IllegalArgumentException(\"Invalid filename\"\
    );\n\t}\n\tBufferedReader fileReader = new BufferedReader(new FileReader(filePath.toString()));\n\
    \tString fileLine = fileReader.readLine();\n\twhile(fileLine != null) {\n\t\t\
    sock.getOutputStream().write(fileLine.getBytes());\n\t\tfileLine = fileReader.readLine();\n\
    \t}\n}\n```\n\n## References\n* OWASP: [Path Traversal](https://owasp.org/www-community/attacks/Path_Traversal).\n\
    * Common Weakness Enumeration: [CWE-22](https://cwe.mitre.org/data/definitions/22.html).\n\
    * Common Weakness Enumeration: [CWE-23](https://cwe.mitre.org/data/definitions/23.html).\n\
    * Common Weakness Enumeration: [CWE-36](https://cwe.mitre.org/data/definitions/36.html).\n\
    * Common Weakness Enumeration: [CWE-73](https://cwe.mitre.org/data/definitions/73.html).\n"
 -
  pack: codeql/java-queries#0
  relativeQueryPath: Security/CWE/CWE-022/ZipSlip.ql
  relativeBqrsPath: codeql/java-queries/Security/CWE/CWE-022/ZipSlip.bqrs
  metadata:
    name: Arbitrary file access during archive extraction ("Zip Slip")
    description: |-
      Extracting files from a malicious ZIP file, or similar type of archive, without
                    validating that the destination file path is within the destination directory
                    can allow an attacker to unexpectedly gain access to resources.
    kind: path-problem
    id: java/zipslip
    problem.severity: error
    security-severity: 7.5
    precision: high
    tags: |-
      security
             external/cwe/cwe-022
  queryHelp: |
    # Arbitrary file access during archive extraction ("Zip Slip")
    Extracting files from a malicious zip file, or similar type of archive, is at risk of directory traversal attacks if filenames from the archive are not properly validated.

    Zip archives contain archive entries representing each file in the archive. These entries include a file path for the entry, but these file paths are not restricted and may contain unexpected special elements such as the directory traversal element (`..`). If these file paths are used to create a filesystem path, then a file operation may happen in an unexpected location. This can result in sensitive information being revealed or deleted, or an attacker being able to influence behavior by modifying unexpected files.

    For example, if a zip file contains a file entry `..\sneaky-file`, and the zip file is extracted to the directory `c:\output`, then naively combining the paths would result in an output file path of `c:\output\..\sneaky-file`, which would cause the file to be written to `c:\sneaky-file`.


    ## Recommendation
    Ensure that output paths constructed from zip archive entries are validated to prevent writing files to unexpected locations.

    The recommended way of writing an output file from a zip archive entry is to verify that the normalized full path of the output file starts with a prefix that matches the destination directory. Path normalization can be done with either `java.io.File.getCanonicalFile()` or `java.nio.file.Path.normalize()`. Prefix checking can be done with `String.startsWith(..)`, but it is better to use `java.nio.file.Path.startsWith(..)`, as the latter works on complete path segments.

    Another alternative is to validate archive entries against a whitelist of expected files.


    ## Example
    In this example, a file path taken from a zip archive item entry is combined with a destination directory. The result is used as the destination file path without verifying that the result is within the destination directory. If provided with a zip file containing an archive path like `..\sneaky-file`, then this file would be written outside the destination directory.


    ```java
    void writeZipEntry(ZipEntry entry, File destinationDir) {
        File file = new File(destinationDir, entry.getName());
        FileOutputStream fos = new FileOutputStream(file); // BAD
        // ... write entry to fos ...
    }

    ```
    To fix this vulnerability, we need to verify that the normalized `file` still has `destinationDir` as its prefix, and throw an exception if this is not the case.


    ```java
    void writeZipEntry(ZipEntry entry, File destinationDir) {
        File file = new File(destinationDir, entry.getName());
        if (!file.toPath().normalize().startsWith(destinationDir.toPath()))
            throw new Exception("Bad zip entry");
        FileOutputStream fos = new FileOutputStream(file); // OK
        // ... write entry to fos ...
    }

    ```

    ## References
    * Snyk: [Zip Slip Vulnerability](https://snyk.io/research/zip-slip-vulnerability).
    * OWASP: [Path Traversal](https://owasp.org/www-community/attacks/Path_Traversal).
    * Common Weakness Enumeration: [CWE-22](https://cwe.mitre.org/data/definitions/22.html).
 -
  pack: codeql/java-queries#0
  relativeQueryPath: Security/CWE/CWE-023/PartialPathTraversal.ql
  relativeBqrsPath: codeql/java-queries/Security/CWE/CWE-023/PartialPathTraversal.bqrs
  metadata:
    name: Partial path traversal vulnerability
    description: A prefix used to check that a canonicalised path falls within another
      must be slash-terminated.
    kind: problem
    problem.severity: error
    security-severity: 9.3
    precision: medium
    id: java/partial-path-traversal
    tags: |-
      security
             external/cwe/cwe-023
  queryHelp: |
    # Partial path traversal vulnerability
    A common way to check that a user-supplied path `SUBDIR` falls inside a directory `DIR` is to use `getCanonicalPath()` to remove any path-traversal elements and then check that `DIR` is a prefix. However, if `DIR` is not slash-terminated, this can unexpectedly allow access to siblings of `DIR`.

    See also `java/partial-path-traversal-from-remote`, which is similar to this query but only flags instances with evidence of remote exploitability.


    ## Recommendation
    If the user should only access items within a certain directory `DIR`, ensure that `DIR` is slash-terminated before checking that `DIR` is a prefix of the user-provided path, `SUBDIR`. Note, Java's `getCanonicalPath()` returns a **non**-slash-terminated path string, so a slash must be added to `DIR` if that method is used.


    ## Example
    In this example, the `if` statement checks if `parent.getCanonicalPath()` is a prefix of `dir.getCanonicalPath()`. However, `parent.getCanonicalPath()` is not slash-terminated. This means that users that supply `dir` may be also allowed to access siblings of `parent` and not just children of `parent`, which is a security issue.


    ```java
    public class PartialPathTraversalBad {
        public void example(File dir, File parent) throws IOException {
            if (!dir.getCanonicalPath().startsWith(parent.getCanonicalPath())) {
                throw new IOException("Path traversal attempt: " + dir.getCanonicalPath());
            }
        }
    }

    ```
    In this example, the `if` statement checks if `parent.toPath()` is a prefix of `dir.normalize()`. Because `Path#startsWith` does the correct check that `dir` is a child of `parent`, users will not be able to access siblings of `parent`, as desired.


    ```java
    import java.io.File;

    public class PartialPathTraversalGood {
        public void example(File dir, File parent) throws IOException {
            if (!dir.toPath().normalize().startsWith(parent.toPath())) {
                throw new IOException("Path traversal attempt: " + dir.getCanonicalPath());
            }
        }
    }

    ```

    ## References
    * OWASP: [Partial Path Traversal](https://owasp.org/www-community/attacks/Path_Traversal).
    * CVE-2022-23457: [ ESAPI Vulnerability Report](https://github.com/ESAPI/esapi-java-legacy/blob/develop/documentation/GHSL-2022-008_The_OWASP_Enterprise_Security_API.md).
    * Common Weakness Enumeration: [CWE-23](https://cwe.mitre.org/data/definitions/23.html).
 -
  pack: codeql/java-queries#0
  relativeQueryPath: Security/CWE/CWE-023/PartialPathTraversalFromRemote.ql
  relativeBqrsPath: codeql/java-queries/Security/CWE/CWE-023/PartialPathTraversalFromRemote.bqrs
  metadata:
    name: Partial path traversal vulnerability from remote
    description: A prefix used to check that a canonicalised path falls within another
      must be slash-terminated.
    kind: path-problem
    problem.severity: error
    security-severity: 9.3
    precision: high
    id: java/partial-path-traversal-from-remote
    tags: |-
      security
             external/cwe/cwe-023
  queryHelp: |
    # Partial path traversal vulnerability from remote
    A common way to check that a user-supplied path `SUBDIR` falls inside a directory `DIR` is to use `getCanonicalPath()` to remove any path-traversal elements and then check that `DIR` is a prefix. However, if `DIR` is not slash-terminated, this can unexpectedly allow accessing siblings of `DIR`.

    See also `java/partial-path-traversal`, which is similar to this query, but may also flag non-remotely-exploitable instances of partial path traversal vulnerabilities.


    ## Recommendation
    If the user should only access items within a certain directory `DIR`, ensure that `DIR` is slash-terminated before checking that `DIR` is a prefix of the user-provided path, `SUBDIR`. Note, Java's `getCanonicalPath()` returns a **non**-slash-terminated path string, so a slash must be added to `DIR` if that method is used.


    ## Example
    In this example, the `if` statement checks if `parent.getCanonicalPath()` is a prefix of `dir.getCanonicalPath()`. However, `parent.getCanonicalPath()` is not slash-terminated. This means that users that supply `dir` may be also allowed to access siblings of `parent` and not just children of `parent`, which is a security issue.


    ```java
    public class PartialPathTraversalBad {
        public void example(File dir, File parent) throws IOException {
            if (!dir.getCanonicalPath().startsWith(parent.getCanonicalPath())) {
                throw new IOException("Path traversal attempt: " + dir.getCanonicalPath());
            }
        }
    }

    ```
    In this example, the `if` statement checks if `parent.toPath()` is a prefix of `dir.normalize()`. Because `Path#startsWith` does the correct check that `dir` is a child of `parent`, users will not be able to access siblings of `parent`, as desired.


    ```java
    import java.io.File;

    public class PartialPathTraversalGood {
        public void example(File dir, File parent) throws IOException {
            if (!dir.toPath().normalize().startsWith(parent.toPath())) {
                throw new IOException("Path traversal attempt: " + dir.getCanonicalPath());
            }
        }
    }

    ```

    ## References
    * OWASP: [Partial Path Traversal](https://owasp.org/www-community/attacks/Path_Traversal).
    * CVE-2022-23457: [ ESAPI Vulnerability Report](https://github.com/ESAPI/esapi-java-legacy/blob/develop/documentation/GHSL-2022-008_The_OWASP_Enterprise_Security_API.md).
    * Common Weakness Enumeration: [CWE-23](https://cwe.mitre.org/data/definitions/23.html).
 -
  pack: codeql/java-queries#0
  relativeQueryPath: Security/CWE/CWE-074/JndiInjection.ql
  relativeBqrsPath: codeql/java-queries/Security/CWE/CWE-074/JndiInjection.bqrs
  metadata:
    name: JNDI lookup with user-controlled name
    description: |-
      Performing a JNDI lookup with a user-controlled name can lead to the download of an untrusted
                    object and to execution of arbitrary code.
    kind: path-problem
    problem.severity: error
    security-severity: 9.8
    precision: high
    id: java/jndi-injection
    tags: |-
      security
             external/cwe/cwe-074
  queryHelp: |
    # JNDI lookup with user-controlled name
    The Java Naming and Directory Interface (JNDI) is a Java API for a directory service that allows Java software clients to discover and look up data and resources (in the form of Java objects) via a name. If the name being used to look up the data is controlled by the user, it can point to a malicious server, which can return an arbitrary object. In the worst case, this can allow remote code execution.


    ## Recommendation
    The general recommendation is to avoid passing untrusted data to the `InitialContext.lookup ` method. If the name being used to look up the object must be provided by the user, make sure that it's not in the form of an absolute URL or that it's the URL pointing to a trusted server.


    ## Example
    In the following examples, the code accepts a name from the user, which it uses to look up an object.

    In the first example, the user provided name is used to look up an object.

    The second example validates the name before using it to look up an object.


    ```java
    import javax.naming.Context;
    import javax.naming.InitialContext;

    public void jndiLookup(HttpServletRequest request) throws NamingException {
      String name = request.getParameter("name");

      Hashtable<String, String> env = new Hashtable<String, String>();
      env.put(Context.INITIAL_CONTEXT_FACTORY, "com.sun.jndi.rmi.registry.RegistryContextFactory");
      env.put(Context.PROVIDER_URL, "rmi://trusted-server:1099");
      InitialContext ctx = new InitialContext(env);

      // BAD: User input used in lookup
      ctx.lookup(name);

      // GOOD: The name is validated before being used in lookup
      if (isValid(name)) {
        ctx.lookup(name);
      } else {
        // Reject the request
      }
    }
    ```

    ## References
    * Oracle: [Java Naming and Directory Interface (JNDI)](https://docs.oracle.com/javase/8/docs/technotes/guides/jndi/).
    * Black Hat materials: [A Journey from JNDI/LDAP Manipulation to Remote Code Execution Dream Land](https://www.blackhat.com/docs/us-16/materials/us-16-Munoz-A-Journey-From-JNDI-LDAP-Manipulation-To-RCE-wp.pdf).
    * Veracode: [Exploiting JNDI Injections in Java](https://www.veracode.com/blog/research/exploiting-jndi-injections-java).
    * Common Weakness Enumeration: [CWE-74](https://cwe.mitre.org/data/definitions/74.html).
 -
  pack: codeql/java-queries#0
  relativeQueryPath: Security/CWE/CWE-074/XsltInjection.ql
  relativeBqrsPath: codeql/java-queries/Security/CWE/CWE-074/XsltInjection.bqrs
  metadata:
    name: XSLT transformation with user-controlled stylesheet
    description: |-
      Performing an XSLT transformation with user-controlled stylesheets can lead to
                    information disclosure or execution of arbitrary code.
    kind: path-problem
    problem.severity: error
    security-severity: 9.8
    precision: high
    id: java/xslt-injection
    tags: |-
      security
             external/cwe/cwe-074
  queryHelp: "# XSLT transformation with user-controlled stylesheet\nXSLT (Extensible\
    \ Stylesheet Language Transformations) is a language for transforming XML documents\
    \ into other XML documents or other formats. Processing unvalidated XSLT stylesheets\
    \ can allow attackers to read arbitrary files from the filesystem or to execute\
    \ arbitrary code.\n\n\n## Recommendation\nThe general recommendation is to not\
    \ process untrusted XSLT stylesheets. If user-provided stylesheets must be processed,\
    \ enable the secure processing mode.\n\n\n## Example\nIn the following examples,\
    \ the code accepts an XSLT stylesheet from the user and processes it.\n\nIn the\
    \ first example, the user-provided XSLT stylesheet is parsed and processed.\n\n\
    In the second example, secure processing mode is enabled.\n\n\n```java\nimport\
    \ javax.xml.XMLConstants;\nimport javax.xml.transform.TransformerFactory;\nimport\
    \ javax.xml.transform.stream.StreamResult;\nimport javax.xml.transform.stream.StreamSource;\n\
    \npublic void transform(Socket socket, String inputXml) throws Exception {\n \
    \ StreamSource xslt = new StreamSource(socket.getInputStream());\n  StreamSource\
    \ xml = new StreamSource(new StringReader(inputXml));\n  StringWriter result =\
    \ new StringWriter();\n  TransformerFactory factory = TransformerFactory.newInstance();\n\
    \n  // BAD: User provided XSLT stylesheet is processed\n  factory.newTransformer(xslt).transform(xml,\
    \ new StreamResult(result));\n\n  // GOOD: The secure processing mode is enabled\n\
    \  factory.setFeature(XMLConstants.FEATURE_SECURE_PROCESSING, true);\n  factory.newTransformer(xslt).transform(xml,\
    \ new StreamResult(result));\n}  \n```\n\n## References\n* Wikipedia: [XSLT](https://en.wikipedia.org/wiki/XSLT).\n\
    * The Java Tutorials: [Transforming XML Data with XSLT](https://docs.oracle.com/javase/tutorial/jaxp/xslt/transformingXML.html).\n\
    * [XSLT Injection Basics](https://blog.hunniccyber.com/ektron-cms-remote-code-execution-xslt-transform-injection-java/).\n\
    * Common Weakness Enumeration: [CWE-74](https://cwe.mitre.org/data/definitions/74.html).\n"
 -
  pack: codeql/java-queries#0
  relativeQueryPath: Security/CWE/CWE-078/ExecRelative.ql
  relativeBqrsPath: codeql/java-queries/Security/CWE/CWE-078/ExecRelative.bqrs
  metadata:
    name: Executing a command with a relative path
    description: |-
      Executing a command with a relative path is vulnerable to
                    malicious changes in the PATH environment variable.
    kind: problem
    problem.severity: warning
    security-severity: 5.4
    precision: medium
    id: java/relative-path-command
    tags: |-
      security
             external/cwe/cwe-078
             external/cwe/cwe-088
  queryHelp: "# Executing a command with a relative path\nWhen a command is executed\
    \ with a relative path, the runtime uses the PATH environment variable to find\
    \ which executable to run. Therefore, any user who can change the PATH environment\
    \ variable can cause the software to run a different, malicious executable.\n\n\
    \n## Recommendation\nIn most cases, simply use a command that has an absolute\
    \ path instead of a relative path.\n\nIn some cases, the location of the executable\
    \ might be different on different installations. In such cases, consider specifying\
    \ the location of key executables with some form of configuration. When using\
    \ this approach, be careful that the configuration system is not itself vulnerable\
    \ to malicious modifications.\n\n\n## Example\n\n```java\nclass Test {\n    public\
    \ static void main(String[] args) {\n        // BAD: relative path\n        Runtime.getRuntime().exec(\"\
    make\");\n        \n        // GOOD: absolute path\n        Runtime.getRuntime().exec(\"\
    /usr/bin/make\");\n\n        // GOOD: build an absolute path from known values\n\
    \        Runtime.getRuntime().exec(Paths.MAKE_PREFIX + \"/bin/make\");\n    }\n\
    }\n```\n\n## References\n* Common Weakness Enumeration: [CWE-78](https://cwe.mitre.org/data/definitions/78.html).\n\
    * Common Weakness Enumeration: [CWE-88](https://cwe.mitre.org/data/definitions/88.html).\n"
 -
  pack: codeql/java-queries#0
  relativeQueryPath: Security/CWE/CWE-078/ExecTainted.ql
  relativeBqrsPath: codeql/java-queries/Security/CWE/CWE-078/ExecTainted.bqrs
  metadata:
    name: Uncontrolled command line
    description: |-
      Using externally controlled strings in a command line is vulnerable to malicious
                    changes in the strings.
    kind: path-problem
    problem.severity: error
    security-severity: 9.8
    precision: high
    id: java/command-line-injection
    tags: |-
      security
             external/cwe/cwe-078
             external/cwe/cwe-088
  queryHelp: |
    # Uncontrolled command line
    Code that passes user input directly to `Runtime.exec`, or some other library routine that executes a command, allows the user to execute malicious code.


    ## Recommendation
    If possible, use hard-coded string literals to specify the command to run or library to load. Instead of passing the user input directly to the process or library function, examine the user input and then choose among hard-coded string literals.

    If the applicable libraries or commands cannot be determined at compile time, then add code to verify that the user input string is safe before using it.


    ## Example
    The following example shows code that takes a shell script that can be changed maliciously by a user, and passes it straight to `Runtime.exec` without examining it first.


    ```java
    class Test {
        public static void main(String[] args) {
            String script = System.getenv("SCRIPTNAME");
            if (script != null) {
                // BAD: The script to be executed is controlled by the user.
                Runtime.getRuntime().exec(script);
            }
        }
    }
    ```

    ## References
    * OWASP: [Command Injection](https://www.owasp.org/index.php/Command_Injection).
    * SEI CERT Oracle Coding Standard for Java: [IDS07-J. Sanitize untrusted data passed to the Runtime.exec() method](https://wiki.sei.cmu.edu/confluence/display/java/IDS07-J.+Sanitize+untrusted+data+passed+to+the+Runtime.exec()+method).
    * Common Weakness Enumeration: [CWE-78](https://cwe.mitre.org/data/definitions/78.html).
    * Common Weakness Enumeration: [CWE-88](https://cwe.mitre.org/data/definitions/88.html).
 -
  pack: codeql/java-queries#0
  relativeQueryPath: Security/CWE/CWE-078/ExecTaintedEnvironment.ql
  relativeBqrsPath: codeql/java-queries/Security/CWE/CWE-078/ExecTaintedEnvironment.bqrs
  metadata:
    name: Building a command with an injected environment variable
    description: |-
      Passing environment variables containing externally controlled
                    strings to a command line is vulnerable to malicious changes to the
                    environment of a subprocess.
    problem.severity: error
    kind: path-problem
    security-severity: 9.8
    precision: medium
    id: java/exec-tainted-environment
    tags: |-
      security
          external/cwe/cwe-078
          external/cwe/cwe-088
          external/cwe/cwe-454
  queryHelp: |
    # Building a command with an injected environment variable
    Passing unvalidated user input into the environment variables of a subprocess can allow an attacker to execute malicious code.


    ## Recommendation
    If possible, use hard-coded string literals to specify the environment variable or its value. Instead of passing the user input directly to the process or library function, examine the user input and then choose among hard-coded string literals.

    If the applicable environment variables cannot be determined at compile time, then add code to verify that the user input string is safe before using it.


    ## Example
    In the following (BAD) example, the environment variable `PATH` is set to the value of the user input `path` without validation.


    ```java
    public void doGet(HttpServletRequest request, HttpServletResponse response) {
        String path = request.getParameter("path");

        Map<String, String> env = processBuilder.environment();
        // BAD: path is tainted and being added to the environment
        env.put("PATH", path);

        processBuilder.start();
    }
    ```
    In the following (BAD) example, an environment variable is set with a name that is derived from the user input `var` without validation.


    ```java
    public void doGet(HttpServletRequest request, HttpServletResponse response) {
        String attr = request.getParameter("attribute");
        String value = request.getParameter("value");

        Map<String, String> env = processBuilder.environment();
        // BAD: attr and value are tainted and being added to the environment
        env.put(attr, value);

        processBuilder.start();
    }
    ```
    In the following (GOOD) example, the user's input is validated before being used to set the environment variable.


    ```java
    String opt = request.getParameter("opt");
    String value = request.getParameter("value");

    Map<String, String> env = processBuilder.environment();

    // GOOD: opt and value are checked before being added to the environment
    if (permittedJavaOptions.contains(opt) && validOption(opt, value)) {
        env.put(opt, value);
    }
    ```
    In the following (GOOD) example, the user's input is checked and used to determine an environment variable to add.


    ```java
    Map<String, String> env = builder.environment();
    String debug = request.getParameter("debug");

    // GOOD: Checking the value and not tainting the variable added to the environment
    if (debug != null) {
        env.put("PYTHONDEBUG", "1");
    }

    ```

    ## References
    * The Java Tutorials: [Environment Variables](https://docs.oracle.com/javase/tutorial/essential/environment/env.html).
    * OWASP: [Command injection](https://owasp.org/www-community/attacks/Command_Injection).
    * Common Weakness Enumeration: [CWE-78](https://cwe.mitre.org/data/definitions/78.html).
    * Common Weakness Enumeration: [CWE-88](https://cwe.mitre.org/data/definitions/88.html).
    * Common Weakness Enumeration: [CWE-454](https://cwe.mitre.org/data/definitions/454.html).
 -
  pack: codeql/java-queries#0
  relativeQueryPath: Security/CWE/CWE-078/ExecUnescaped.ql
  relativeBqrsPath: codeql/java-queries/Security/CWE/CWE-078/ExecUnescaped.bqrs
  metadata:
    name: Building a command line with string concatenation
    description: |-
      Using concatenated strings in a command line is vulnerable to malicious
                    insertion of special characters in the strings.
    kind: problem
    problem.severity: error
    security-severity: 9.8
    precision: high
    id: java/concatenated-command-line
    tags: |-
      security
             external/cwe/cwe-078
             external/cwe/cwe-088
  queryHelp: |
    # Building a command line with string concatenation
    Code that builds a command line by concatenating strings that have been entered by a user allows the user to execute malicious code.


    ## Recommendation
    Execute external commands using an array of strings rather than a single string. By using an array, many possible vulnerabilities in the formatting of the string are avoided.


    ## Example
    In the following example, `latlonCoords` contains a string that has been entered by a user but not validated by the program. This allows the user to, for example, append an ampersand (&amp;) followed by the command for a malicious program to the end of the string. The ampersand instructs Windows to execute another program. In the block marked 'BAD', `latlonCoords` is passed to `exec` as part of a concatenated string, which allows more than one command to be executed. However, in the block marked 'GOOD', `latlonCoords` is passed as part of an array, which means that `exec` treats it only as an argument.


    ```java
    class Test {
        public static void main(String[] args) {
            // BAD: user input might include special characters such as ampersands
            {
                String latlonCoords = args[1];
                Runtime rt = Runtime.getRuntime();
                Process exec = rt.exec("cmd.exe /C latlon2utm.exe " + latlonCoords);
            }

            // GOOD: use an array of arguments instead of executing a string
            {
                String latlonCoords = args[1];
                Runtime rt = Runtime.getRuntime();
                Process exec = rt.exec(new String[] {
                        "c:\\path\to\latlon2utm.exe",
                        latlonCoords });
            }
        }
    }

    ```

    ## References
    * OWASP: [Command Injection](https://www.owasp.org/index.php/Command_Injection).
    * SEI CERT Oracle Coding Standard for Java: [IDS07-J. Sanitize untrusted data passed to the Runtime.exec() method](https://wiki.sei.cmu.edu/confluence/display/java/IDS07-J.+Sanitize+untrusted+data+passed+to+the+Runtime.exec()+method).
    * Common Weakness Enumeration: [CWE-78](https://cwe.mitre.org/data/definitions/78.html).
    * Common Weakness Enumeration: [CWE-88](https://cwe.mitre.org/data/definitions/88.html).
 -
  pack: codeql/java-queries#0
  relativeQueryPath: Security/CWE/CWE-079/AndroidWebViewAddJavascriptInterface.ql
  relativeBqrsPath: codeql/java-queries/Security/CWE/CWE-079/AndroidWebViewAddJavascriptInterface.bqrs
  metadata:
    name: Access Java object methods through JavaScript exposure
    id: java/android/webview-addjavascriptinterface
    description: Exposing a Java object in a WebView with a JavaScript interface can
      lead to malicious JavaScript controlling the application.
    kind: problem
    problem.severity: warning
    security-severity: 6.1
    precision: medium
    tags: |-
      security
             external/cwe/cwe-079
  queryHelp: |
    # Access Java object methods through JavaScript exposure
    Calling the `addJavascriptInterface` method of the `android.webkit.WebView` class allows the web pages of a WebView to access a Java object's methods via JavaScript.

    Objects exposed to JavaScript are available in all frames of the WebView.


    ## Recommendation
    If you need to expose Java objects to JavaScript, guarantee that no untrusted third-party content is loaded into the WebView.


    ## Example
    In the following (bad) example, a Java object is exposed to JavaScript.


    ```java
    import android.webkit.JavascriptInterface;
    import android.database.sqlite.SQLiteOpenHelper;

    class ExposedObject extends SQLiteOpenHelper {
        @JavascriptInterface
        public String studentEmail(String studentName) {
            // SQL injection
            String query = "SELECT email FROM students WHERE studentname = '" + studentName + "'";

            Cursor cursor = db.rawQuery(query, null);
            cursor.moveToFirst();
            String email = cursor.getString(0);

            return email;
        }
    }

    webview.getSettings().setJavaScriptEnabled(true);
    webview.addJavaScriptInterface(new ExposedObject(), "exposedObject");
    webview.loadData("", "text/html", null);

    String name = "Robert'; DROP TABLE students; --";
    webview.loadUrl("javascript:alert(exposedObject.studentEmail(\""+ name +"\"))");

    ```

    ## References
    * Android Documentation: [addJavascriptInterface](https://developer.android.com/reference/android/webkit/WebView#addJavascriptInterface(java.lang.Object,%20java.lang.String))
    * Common Weakness Enumeration: [CWE-79](https://cwe.mitre.org/data/definitions/79.html).
 -
  pack: codeql/java-queries#0
  relativeQueryPath: Security/CWE/CWE-079/AndroidWebViewSettingsEnabledJavaScript.ql
  relativeBqrsPath: codeql/java-queries/Security/CWE/CWE-079/AndroidWebViewSettingsEnabledJavaScript.bqrs
  metadata:
    name: Android WebView JavaScript settings
    description: Enabling JavaScript execution in a WebView can result in cross-site
      scripting attacks.
    kind: problem
    id: java/android/websettings-javascript-enabled
    problem.severity: warning
    security-severity: 6.1
    precision: medium
    tags: |-
      security
             external/cwe/cwe-079
  queryHelp: |
    # Android WebView JavaScript settings
    Enabling JavaScript in an Android WebView allows the execution of JavaScript code in the context of the running application. This creates a cross-site scripting vulnerability.

    For example, if your application's WebView allows for visiting web pages that you do not trust, it is possible for an attacker to lead the user to a page which loads malicious JavaScript.

    You can enable or disable Javascript execution using the `setJavaScriptEnabled` method of the settings of a WebView.


    ## Recommendation
    JavaScript execution is disabled by default. You can explicitly disable it by calling `setJavaScriptEnabled(false)` on the settings of the WebView.

    If JavaScript is necessary, only load content from trusted servers using encrypted channels, such as HTTPS with certificate verification.


    ## Example
    In the following (bad) example, a WebView has JavaScript enabled in its settings:


    ```java
    WebSettings settings = webview.getSettings();
    settings.setJavaScriptEnabled(true);

    ```
    In the following (good) example, a WebView explicitly disallows JavaScript execution:


    ```java
    WebSettings settings = webview.getSettings();
    settings.setJavaScriptEnabled(false);

    ```

    ## References
    * Android documentation: [setJavaScriptEnabled](https://developer.android.com/reference/android/webkit/WebSettings#setJavaScriptEnabled(boolean))
    * Common Weakness Enumeration: [CWE-79](https://cwe.mitre.org/data/definitions/79.html).
 -
  pack: codeql/java-queries#0
  relativeQueryPath: Security/CWE/CWE-079/XSS.ql
  relativeBqrsPath: codeql/java-queries/Security/CWE/CWE-079/XSS.bqrs
  metadata:
    name: Cross-site scripting
    description: |-
      Writing user input directly to a web page
                    allows for a cross-site scripting vulnerability.
    kind: path-problem
    problem.severity: error
    security-severity: 6.1
    precision: high
    id: java/xss
    tags: |-
      security
             external/cwe/cwe-079
  queryHelp: "# Cross-site scripting\nDirectly writing user input (for example, an\
    \ HTTP request parameter) to a web page, without properly sanitizing the input\
    \ first, allows for a cross-site scripting vulnerability.\n\n\n## Recommendation\n\
    To guard against cross-site scripting, consider using contextual output encoding/escaping\
    \ before writing user input to the page, or one of the other solutions that are\
    \ mentioned in the reference.\n\n\n## Example\nThe following example shows the\
    \ `page` parameter being written directly to the page, leaving the website vulnerable\
    \ to cross-site scripting.\n\n\n```java\npublic class XSS extends HttpServlet\
    \ {\n\tprotected void doGet(HttpServletRequest request, HttpServletResponse response)\n\
    \tthrows ServletException, IOException {\n\t\t// BAD: a request parameter is written\
    \ directly to the Servlet response stream\n\t\tresponse.getWriter().print(\n\t\
    \t\t\t\"The page \\\"\" + request.getParameter(\"page\") + \"\\\" was not found.\"\
    );\n\n\t}\n}\n\n```\n\n## References\n* OWASP: [XSS (Cross Site Scripting) Prevention\
    \ Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/Cross_Site_Scripting_Prevention_Cheat_Sheet.html).\n\
    * Wikipedia: [Cross-site scripting](http://en.wikipedia.org/wiki/Cross-site_scripting).\n\
    * Common Weakness Enumeration: [CWE-79](https://cwe.mitre.org/data/definitions/79.html).\n"
 -
  pack: codeql/java-queries#0
  relativeQueryPath: Security/CWE/CWE-089/SqlConcatenated.ql
  relativeBqrsPath: codeql/java-queries/Security/CWE/CWE-089/SqlConcatenated.bqrs
  metadata:
    name: Query built by concatenation with a possibly-untrusted string
    description: |-
      Building a SQL or Java Persistence query by concatenating a possibly-untrusted string
                    is vulnerable to insertion of malicious code.
    kind: problem
    problem.severity: error
    security-severity: 8.8
    precision: medium
    id: java/concatenated-sql-query
    tags: |-
      security
             external/cwe/cwe-089
             external/cwe/cwe-564
  queryHelp: |
    # Query built by concatenation with a possibly-untrusted string
    Even when the components of a SQL query are not fully controlled by a user, it is a vulnerability to build the query by directly concatenating those components. Perhaps a separate vulnerability will allow the user to gain control of the component. As well, a user who cannot gain full control of an input might influence it enough to cause the SQL query to fail to run.


    ## Recommendation
    Usually, it is better to use a SQL prepared statement than to build a complete SQL query with string concatenation. A prepared statement can include a wildcard, written as a question mark (?), for each part of the SQL query that is expected to be filled in by a different value each time it is run. When the query is later executed, a value must be supplied for each wildcard in the query.

    In the Java Persistence Query Language, it is better to use queries with parameters than to build a complete query with string concatenation. A Java Persistence query can include a parameter placeholder for each part of the query that is expected to be filled in by a different value when run. A parameter placeholder may be indicated by a colon (:) followed by a parameter name, or by a question mark (?) followed by an integer position. When the query is later executed, a value must be supplied for each parameter in the query, using the `setParameter` method. Specifying the query using the `@NamedQuery` annotation introduces an additional level of safety: the query must be a constant string literal, preventing construction by string concatenation, and the only way to fill in values for parts of the query is by setting positional parameters.

    It is good practice to use prepared statements (in SQL) or query parameters (in the Java Persistence Query Language) for supplying parameter values to a query, whether or not any of the parameters are directly traceable to user input. Doing so avoids any need to worry about quoting and escaping.


    ## Example
    In the following example, the code runs a simple SQL query in two different ways.

    The first way involves building a query, `query1`, by concatenating the result of `getCategory` with some string literals. The result of `getCategory` can include special characters, or it might be refactored later so that it may return something that contains special characters.

    The second way, which shows good practice, involves building a query, `query2`, with a single string literal that includes a wildcard (`?`). The wildcard is then given a value by calling `setString`. This version is immune to injection attacks, because any special characters in the result of `getCategory` are not given any special treatment.


    ```java
    {
        // BAD: the category might have SQL special characters in it
        String category = getCategory();
        Statement statement = connection.createStatement();
        String query1 = "SELECT ITEM,PRICE FROM PRODUCT WHERE ITEM_CATEGORY='"
            + category + "' ORDER BY PRICE";
        ResultSet results = statement.executeQuery(query1);
    }

    {
        // GOOD: use a prepared query
        String category = getCategory();
        String query2 = "SELECT ITEM,PRICE FROM PRODUCT WHERE ITEM_CATEGORY=? ORDER BY PRICE";
        PreparedStatement statement = connection.prepareStatement(query2);
        statement.setString(1, category);
        ResultSet results = statement.executeQuery();
    }
    ```

    ## References
    * OWASP: [SQL Injection Prevention Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/SQL_Injection_Prevention_Cheat_Sheet.html).
    * SEI CERT Oracle Coding Standard for Java: [IDS00-J. Prevent SQL injection](https://wiki.sei.cmu.edu/confluence/display/java/IDS00-J.+Prevent+SQL+injection).
    * The Java Tutorials: [Using Prepared Statements](https://docs.oracle.com/javase/tutorial/jdbc/basics/prepared.html).
    * Common Weakness Enumeration: [CWE-89](https://cwe.mitre.org/data/definitions/89.html).
    * Common Weakness Enumeration: [CWE-564](https://cwe.mitre.org/data/definitions/564.html).
 -
  pack: codeql/java-queries#0
  relativeQueryPath: Security/CWE/CWE-089/SqlTainted.ql
  relativeBqrsPath: codeql/java-queries/Security/CWE/CWE-089/SqlTainted.bqrs
  metadata:
    name: Query built from user-controlled sources
    description: |-
      Building a SQL or Java Persistence query from user-controlled sources is vulnerable to insertion of
                    malicious code by the user.
    kind: path-problem
    problem.severity: error
    security-severity: 8.8
    precision: high
    id: java/sql-injection
    tags: |-
      security
             external/cwe/cwe-089
             external/cwe/cwe-564
  queryHelp: |
    # Query built from user-controlled sources
    If a database query is built using string concatenation, and the components of the concatenation include user input, a user is likely to be able to run malicious database queries. This applies to various database query languages, including SQL and the Java Persistence Query Language.


    ## Recommendation
    Usually, it is better to use a SQL prepared statement than to build a complete SQL query with string concatenation. A prepared statement can include a wildcard, written as a question mark (?), for each part of the SQL query that is expected to be filled in by a different value each time it is run. When the query is later executed, a value must be supplied for each wildcard in the query.

    In the Java Persistence Query Language, it is better to use queries with parameters than to build a complete query with string concatenation. A Java Persistence query can include a parameter placeholder for each part of the query that is expected to be filled in by a different value when run. A parameter placeholder may be indicated by a colon (:) followed by a parameter name, or by a question mark (?) followed by an integer position. When the query is later executed, a value must be supplied for each parameter in the query, using the `setParameter` method. Specifying the query using the `@NamedQuery` annotation introduces an additional level of safety: the query must be a constant string literal, preventing construction by string concatenation, and the only way to fill in values for parts of the query is by setting positional parameters.

    It is good practice to use prepared statements (in SQL) or query parameters (in the Java Persistence Query Language) for supplying parameter values to a query, whether or not any of the parameters are directly traceable to user input. Doing so avoids any need to worry about quoting and escaping.


    ## Example
    In the following example, the code runs a simple SQL query in two different ways.

    The first way involves building a query, `query1`, by concatenating an environment variable with some string literals. The environment variable can include special characters, so this code allows for SQL injection attacks.

    The second way, which shows good practice, involves building a query, `query2`, with a single string literal that includes a wildcard (`?`). The wildcard is then given a value by calling `setString`. This version is immune to injection attacks, because any special characters in the environment variable are not given any special treatment.


    ```java
    {
        // BAD: the category might have SQL special characters in it
        String category = System.getenv("ITEM_CATEGORY");
        Statement statement = connection.createStatement();
        String query1 = "SELECT ITEM,PRICE FROM PRODUCT WHERE ITEM_CATEGORY='"
            + category + "' ORDER BY PRICE";
        ResultSet results = statement.executeQuery(query1);
    }

    {
        // GOOD: use a prepared query
        String category = System.getenv("ITEM_CATEGORY");
        String query2 = "SELECT ITEM,PRICE FROM PRODUCT WHERE ITEM_CATEGORY=? ORDER BY PRICE";
        PreparedStatement statement = connection.prepareStatement(query2);
        statement.setString(1, category);
        ResultSet results = statement.executeQuery();
    }
    ```

    ## Example
    The following code shows several different ways to run a Java Persistence query.

    The first example involves building a query, `query1`, by concatenating an environment variable with some string literals. Just like the SQL example, the environment variable can include special characters, so this code allows for Java Persistence query injection attacks.

    The remaining examples demonstrate different methods for safely building a Java Persistence query with user-supplied values:

    1. `query2` uses a single string literal that includes a placeholder for a parameter, indicated by a colon (`:`) and parameter name (`category`).
    1. `query3` uses a single string literal that includes a placeholder for a parameter, indicated by a question mark (`?`) and position number (`1`).
    1. `namedQuery1` is defined using the `@NamedQuery` annotation, whose `query` attribute is a string literal that includes a placeholder for a parameter, indicated by a colon (`:`) and parameter name (`category`).
    1. `namedQuery2` is defined using the `@NamedQuery` annotation, whose `query` attribute includes a placeholder for a parameter, indicated by a question mark (`?`) and position number (`1`).
    The parameter is then given a value by calling `setParameter`. These versions are immune to injection attacks, because any special characters in the environment variable or user-supplied value are not given any special treatment.


    ```java
    {
        // BAD: the category might have Java Persistence Query Language special characters in it
        String category = System.getenv("ITEM_CATEGORY");
        Statement statement = connection.createStatement();
        String query1 = "SELECT p FROM Product p WHERE p.category LIKE '"
            + category + "' ORDER BY p.price";
        Query q = entityManager.createQuery(query1);
    }

    {
        // GOOD: use a named parameter and set its value
        String category = System.getenv("ITEM_CATEGORY");
        String query2 = "SELECT p FROM Product p WHERE p.category LIKE :category ORDER BY p.price"
        Query q = entityManager.createQuery(query2);
        q.setParameter("category", category);
    }

    {
        // GOOD: use a positional parameter and set its value
        String category = System.getenv("ITEM_CATEGORY");
        String query3 = "SELECT p FROM Product p WHERE p.category LIKE ?1 ORDER BY p.price"
        Query q = entityManager.createQuery(query3);
        q.setParameter(1, category);
    }

    {
        // GOOD: use a named query with a named parameter and set its value
        @NamedQuery(
                name="lookupByCategory",
                query="SELECT p FROM Product p WHERE p.category LIKE :category ORDER BY p.price")
        private static class NQ {}
        ...
        String category = System.getenv("ITEM_CATEGORY");
        Query namedQuery1 = entityManager.createNamedQuery("lookupByCategory");
        namedQuery1.setParameter("category", category);
    }

    {
        // GOOD: use a named query with a positional parameter and set its value
        @NamedQuery(
                name="lookupByCategory",
                query="SELECT p FROM Product p WHERE p.category LIKE ?1 ORDER BY p.price")
        private static class NQ {}
        ...
        String category = System.getenv("ITEM_CATEGORY");
        Query namedQuery2 = entityManager.createNamedQuery("lookupByCategory");
        namedQuery2.setParameter(1, category);
    }
    ```

    ## References
    * OWASP: [SQL Injection Prevention Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/SQL_Injection_Prevention_Cheat_Sheet.html).
    * SEI CERT Oracle Coding Standard for Java: [IDS00-J. Prevent SQL injection](https://wiki.sei.cmu.edu/confluence/display/java/IDS00-J.+Prevent+SQL+injection).
    * The Java Tutorials: [Using Prepared Statements](https://docs.oracle.com/javase/tutorial/jdbc/basics/prepared.html).
    * The Java EE Tutorial: [The Java Persistence Query Language](https://docs.oracle.com/javaee/7/tutorial/persistence-querylanguage.htm).
    * Common Weakness Enumeration: [CWE-89](https://cwe.mitre.org/data/definitions/89.html).
    * Common Weakness Enumeration: [CWE-564](https://cwe.mitre.org/data/definitions/564.html).
 -
  pack: codeql/java-queries#0
  relativeQueryPath: Security/CWE/CWE-090/LdapInjection.ql
  relativeBqrsPath: codeql/java-queries/Security/CWE/CWE-090/LdapInjection.bqrs
  metadata:
    name: LDAP query built from user-controlled sources
    description: |-
      Building an LDAP query from user-controlled sources is vulnerable to insertion of
                    malicious LDAP code by the user.
    kind: path-problem
    problem.severity: error
    security-severity: 9.8
    precision: high
    id: java/ldap-injection
    tags: |-
      security
             external/cwe/cwe-090
  queryHelp: "# LDAP query built from user-controlled sources\nIf an LDAP query is\
    \ built using string concatenation, and the components of the concatenation include\
    \ user input, a user is likely to be able to run malicious LDAP queries.\n\n\n\
    ## Recommendation\nIf user input must be included in an LDAP query, it should\
    \ be escaped to avoid a malicious user providing special characters that change\
    \ the meaning of the query. If possible build the LDAP query using framework helper\
    \ methods, for example from Spring's `LdapQueryBuilder` and `LdapNameBuilder`,\
    \ instead of string concatenation. Alternatively, escape user input using an appropriate\
    \ LDAP encoding method, for example: `encodeForLDAP` or `encodeForDN` from OWASP\
    \ ESAPI, `LdapEncoder.filterEncode` or `LdapEncoder.nameEncode` from Spring LDAP,\
    \ or `Filter.encodeValue` from UnboundID library.\n\n\n## Example\nIn the following\
    \ examples, the code accepts an \"organization name\" and a \"username\" from\
    \ the user, which it uses to query LDAP.\n\nThe first example concatenates the\
    \ unvalidated and unencoded user input directly into both the DN (Distinguished\
    \ Name) and the search filter used for the LDAP query. A malicious user could\
    \ provide special characters to change the meaning of these queries, and search\
    \ for a completely different set of values. The LDAP query is executed using Java\
    \ JNDI API.\n\nThe second example uses the OWASP ESAPI library to encode the user\
    \ values before they are included in the DN and search filters. This ensures the\
    \ meaning of the query cannot be changed by a malicious user.\n\n\n```java\nimport\
    \ javax.naming.directory.DirContext;\nimport org.owasp.esapi.Encoder;\nimport\
    \ org.owasp.esapi.reference.DefaultEncoder;\n\npublic void ldapQueryBad(HttpServletRequest\
    \ request, DirContext ctx) throws NamingException {\n  String organizationName\
    \ = request.getParameter(\"organization_name\");\n  String username = request.getParameter(\"\
    username\");\n\n  // BAD: User input used in DN (Distinguished Name) without encoding\n\
    \  String dn = \"OU=People,O=\" + organizationName;\n\n  // BAD: User input used\
    \ in search filter without encoding\n  String filter = \"username=\" + userName;\n\
    \n  ctx.search(dn, filter, new SearchControls());\n}\n\npublic void ldapQueryGood(HttpServletRequest\
    \ request, DirContext ctx) throws NamingException {\n  String organizationName\
    \ = request.getParameter(\"organization_name\");\n  String username = request.getParameter(\"\
    username\");\n\n  // ESAPI encoder\n  Encoder encoder = DefaultEncoder.getInstance();\n\
    \n  // GOOD: Organization name is encoded before being used in DN\n  String safeOrganizationName\
    \ = encoder.encodeForDN(organizationName);\n  String safeDn = \"OU=People,O=\"\
    \ + safeOrganizationName;\n\n  // GOOD: User input is encoded before being used\
    \ in search filter\n  String safeUsername = encoder.encodeForLDAP(username);\n\
    \  String safeFilter = \"username=\" + safeUsername;\n  \n  ctx.search(safeDn,\
    \ safeFilter, new SearchControls());\n}\n```\nThe third example uses Spring `LdapQueryBuilder`\
    \ to build an LDAP query. In addition to simplifying the building of complex search\
    \ parameters, it also provides proper escaping of any unsafe characters in search\
    \ filters. The DN is built using `LdapNameBuilder`, which also provides proper\
    \ escaping.\n\n\n```java\nimport static org.springframework.ldap.query.LdapQueryBuilder.query;\n\
    import org.springframework.ldap.support.LdapNameBuilder;\n\npublic void ldapQueryGood(@RequestParam\
    \ String organizationName, @RequestParam String username) {\n  // GOOD: Organization\
    \ name is encoded before being used in DN\n  String safeDn = LdapNameBuilder.newInstance()\n\
    \    .add(\"O\", organizationName)\n    .add(\"OU=People\")\n    .build().toString();\n\
    \n  // GOOD: User input is encoded before being used in search filter\n  LdapQuery\
    \ query = query()\n    .base(safeDn)\n    .where(\"username\").is(username);\n\
    \n  ldapTemplate.search(query, new AttributeCheckAttributesMapper());\n}\n```\n\
    The fourth example uses `UnboundID` classes, `Filter` and `DN`, to construct a\
    \ safe filter and base DN.\n\n\n```java\nimport com.unboundid.ldap.sdk.LDAPConnection;\n\
    import com.unboundid.ldap.sdk.DN;\nimport com.unboundid.ldap.sdk.RDN;\nimport\
    \ com.unboundid.ldap.sdk.Filter;\n\npublic void ldapQueryGood(HttpServletRequest\
    \ request, LDAPConnection c) {\n  String organizationName = request.getParameter(\"\
    organization_name\");\n  String username = request.getParameter(\"username\");\n\
    \n  // GOOD: Organization name is encoded before being used in DN\n  DN safeDn\
    \ = new DN(new RDN(\"OU\", \"People\"), new RDN(\"O\", organizationName));\n\n\
    \  // GOOD: User input is encoded before being used in search filter\n  Filter\
    \ safeFilter = Filter.createEqualityFilter(\"username\", username);\n  \n  c.search(safeDn.toString(),\
    \ SearchScope.ONE, safeFilter);\n}\n```\nThe fifth example shows how to build\
    \ a safe filter and DN using the Apache LDAP API.\n\n\n```java\nimport org.apache.directory.ldap.client.api.LdapConnection;\n\
    import org.apache.directory.api.ldap.model.name.Dn;\nimport org.apache.directory.api.ldap.model.name.Rdn;\n\
    import org.apache.directory.api.ldap.model.message.SearchRequest;\nimport org.apache.directory.api.ldap.model.message.SearchRequestImpl;\n\
    import static org.apache.directory.ldap.client.api.search.FilterBuilder.equal;\n\
    \npublic void ldapQueryGood(HttpServletRequest request, LdapConnection c) {\n\
    \  String organizationName = request.getParameter(\"organization_name\");\n  String\
    \ username = request.getParameter(\"username\");\n\n  // GOOD: Organization name\
    \ is encoded before being used in DN\n  Dn safeDn = new Dn(new Rdn(\"OU\", \"\
    People\"), new Rdn(\"O\", organizationName));\n\n  // GOOD: User input is encoded\
    \ before being used in search filter\n  String safeFilter = equal(\"username\"\
    , username);\n  \n  SearchRequest searchRequest = new SearchRequestImpl();\n \
    \ searchRequest.setBase(safeDn);\n  searchRequest.setFilter(safeFilter);\n  c.search(searchRequest);\n\
    }\n```\n\n## References\n* OWASP: [LDAP Injection Prevention Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/LDAP_Injection_Prevention_Cheat_Sheet.html).\n\
    * OWASP ESAPI: [OWASP ESAPI](https://owasp.org/www-project-enterprise-security-api/).\n\
    * Spring LdapQueryBuilder doc: [LdapQueryBuilder](https://docs.spring.io/spring-ldap/docs/current/apidocs/org/springframework/ldap/query/LdapQueryBuilder.html).\n\
    * Spring LdapNameBuilder doc: [LdapNameBuilder](https://docs.spring.io/spring-ldap/docs/current/apidocs/org/springframework/ldap/support/LdapNameBuilder.html).\n\
    * UnboundID: [Understanding and Defending Against LDAP Injection Attacks](https://ldap.com/2018/05/04/understanding-and-defending-against-ldap-injection-attacks/).\n\
    * Common Weakness Enumeration: [CWE-90](https://cwe.mitre.org/data/definitions/90.html).\n"
 -
  pack: codeql/java-queries#0
  relativeQueryPath: Security/CWE/CWE-094/ArbitraryApkInstallation.ql
  relativeBqrsPath: codeql/java-queries/Security/CWE/CWE-094/ArbitraryApkInstallation.bqrs
  metadata:
    id: java/android/arbitrary-apk-installation
    name: Android APK installation
    description: Creating an intent with a URI pointing to a untrusted file can lead
      to the installation of an untrusted application.
    kind: path-problem
    security-severity: 9.3
    problem.severity: error
    precision: medium
    tags: |-
      security
             external/cwe/cwe-094
  queryHelp: |
    # Android APK installation
    Android allows an application to install an Android Package Kit (APK) using an `Intent` with the `"application/vnd.android.package-archive"` MIME type. If the file used in the `Intent` is from a location that is not controlled by the application (for example, an SD card that is universally writable), this can result in the unintended installation of untrusted applications.


    ## Recommendation
    You should install packages using the `PackageInstaller` class.

    If you need to install from a file, you should use a `FileProvider`. Content providers can provide more specific permissions than file system permissions can.

    When your application does not require package installations, do not add the `REQUEST_INSTALL_PACKAGES` permission in the manifest file.


    ## Example
    In the following (bad) example, the package is installed from a file which may be altered by another application:


    ```java
    import android.app.Activity;
    import android.content.Intent;
    import android.net.Uri;
    import android.os.Environment;

    import java.io.File;

    /* Get a file from external storage */
    File file = new File(Environment.getExternalStorageDirectory(), "myapp.apk");
    Intent intent = new Intent(Intent.ACTION_VIEW);
    /* Set the mimetype to APK */
    intent.setDataAndType(Uri.fromFile(file), "application/vnd.android.package-archive");

    startActivity(intent);

    ```
    In the following (good) example, the package is installed by using a `FileProvider`:


    ```java
    import android.app.Activity;
    import android.content.Context;
    import android.content.Intent;
    import android.net.Uri;
    import androidx.core.content.FileProvider;

    import java.io.File;
    import java.io.FileOutputStream;

    String tempFilename = "temporary.apk";
    byte[] buffer = new byte[16384];

    /* Copy application asset into temporary file */
    try (InputStream is = getAssets().open(assetName);
         FileOutputStream fout = openFileOutput(tempFilename, Context.MODE_PRIVATE)) {
        int n;
        while ((n=is.read(buffer)) >= 0) {
            fout.write(buffer, 0, n);
        }
    }

    /* Expose temporary file with FileProvider */
    File toInstall = new File(this.getFilesDir(), tempFilename);
    Uri applicationUri = FileProvider.getUriForFile(this, "com.example.apkprovider", toInstall);

    /* Create Intent and set data to APK file. */
    Intent intent = new Intent(Intent.ACTION_INSTALL_PACKAGE);
    intent.setData(applicationUri);
    intent.setFlags(Intent.FLAG_GRANT_READ_URI_PERMISSION);

    startActivity(intent);

    ```
    In the following (good) example, the package is installed using an instance of the `android.content.pm.PackageInstaller` class:


    ```java
    import android.content.Context;
    import android.content.Intent;
    import android.content.pm.PackageInstaller;

    private static final String PACKAGE_INSTALLED_ACTION =
        "com.example.SESSION_API_PACKAGE_INSTALLED";

    /* Create the package installer and session */
    PackageInstaller packageInstaller = getPackageManager().getPackageInstaller();
    PackageInstaller.SessionParams params =
        new PackageInstaller.SessionParams(PackageInstaller.SessionParams.MODE_FULL_INSTALL);
    int sessionId = packageInstaller.createSession(params);
    session = packageInstaller.openSession(sessionId);

    /* Load asset into session */
    try (OutputStream packageInSession = session.openWrite("package", 0, -1);
         InputStream is = getAssets().open(assetName)) {
        byte[] buffer = new byte[16384];
        int n;
        while ((n = is.read(buffer)) >= 0) {
            packageInSession.write(buffer, 0, n);
        }
    }

    /* Create status receiver */
    Intent intent = new Intent(this, InstallApkSessionApi.class);
    intent.setAction(PACKAGE_INSTALLED_ACTION);
    PendingIntent pendingIntent = PendingIntent.getActivity(context, 0, intent, 0);
    IntentSender statusReceiver = pendingIntent.getIntentSender();

    /* Commit the session */
    session.commit(statusReceiver);

    ```

    ## References
    * Android Developers: [Intent.ACTION_INSTALL_PACKAGE](https://developer.android.com/reference/android/content/Intent#ACTION_INSTALL_PACKAGE).
    * Android Developers: [Manifest.permission.REQUEST_INSTALL_PACKAGES](https://developer.android.com/reference/android/Manifest.permission#REQUEST_INSTALL_PACKAGES).
    * Android Developers: [PackageInstaller](https://developer.android.com/reference/android/content/pm/PackageInstaller).
    * Android Developers: [FileProvider](https://developer.android.com/reference/androidx/core/content/FileProvider).
    * Common Weakness Enumeration: [CWE-94](https://cwe.mitre.org/data/definitions/94.html).
 -
  pack: codeql/java-queries#0
  relativeQueryPath: Security/CWE/CWE-094/GroovyInjection.ql
  relativeBqrsPath: codeql/java-queries/Security/CWE/CWE-094/GroovyInjection.bqrs
  metadata:
    name: Groovy Language injection
    description: |-
      Evaluation of a user-controlled Groovy script
                    may lead to arbitrary code execution.
    kind: path-problem
    problem.severity: error
    security-severity: 9.3
    precision: high
    id: java/groovy-injection
    tags: |-
      security
             external/cwe/cwe-094
  queryHelp: "# Groovy Language injection\nApache Groovy is a powerful, optionally\
    \ typed and dynamic language, with static-typing and static compilation capabilities.\
    \ It integrates smoothly with any Java program, and immediately delivers to your\
    \ application powerful features, including scripting capabilities, Domain-Specific\
    \ Language authoring, runtime and compile-time meta-programming and functional\
    \ programming. If a Groovy script is built using attacker-controlled data, and\
    \ then evaluated, then it may allow the attacker to achieve RCE.\n\n\n## Recommendation\n\
    It is generally recommended to avoid using untrusted input in a Groovy evaluation.\
    \ If this is not possible, use a sandbox solution. Developers must also take care\
    \ that Groovy compile-time metaprogramming can also lead to RCE: it is possible\
    \ to achieve RCE by compiling a Groovy script (see the article \"Abusing Meta\
    \ Programming for Unauthenticated RCE!\" linked below). Groovy's `SecureASTCustomizer`\
    \ allows securing source code by controlling what code constructs are permitted.\
    \ This is typically done when using Groovy for its scripting or domain specific\
    \ language (DSL) features. The fundamental problem is that Groovy is a dynamic\
    \ language, yet `SecureASTCustomizer` works by looking at Groovy AST statically.\
    \ This makes it very easy for an attacker to bypass many of the intended checks\
    \ (see \\[Groovy SecureASTCustomizer is harmful\\](https://kohsuke.org/2012/04/27/groovy-secureastcustomizer-is-harmful/)).\
    \ Therefore, besides `SecureASTCustomizer`, runtime checks are also necessary\
    \ before calling Groovy methods (see \\[Improved sandboxing of Groovy scripts\\\
    ](https://melix.github.io/blog/2015/03/sandboxing.html)). It is also possible\
    \ to use a block-list method, excluding unwanted classes from being loaded by\
    \ the JVM. This method is not always recommended, because block-lists can be bypassed\
    \ by unexpected values.\n\n\n## Example\nThe following example uses untrusted\
    \ data to evaluate a Groovy script.\n\n\n```java\npublic class GroovyInjection\
    \ {\n    void injectionViaClassLoader(HttpServletRequest request) {    \n    \
    \    String script = request.getParameter(\"script\");\n        final GroovyClassLoader\
    \ classLoader = new GroovyClassLoader();\n        Class groovy = classLoader.parseClass(script);\n\
    \        GroovyObject groovyObj = (GroovyObject) groovy.newInstance();\n    }\n\
    \n    void injectionViaEval(HttpServletRequest request) {\n        String script\
    \ = request.getParameter(\"script\");\n        Eval.me(script);\n    }\n\n   \
    \ void injectionViaGroovyShell(HttpServletRequest request) {\n        GroovyShell\
    \ shell = new GroovyShell();\n        String script = request.getParameter(\"\
    script\");\n        shell.evaluate(script);\n    }\n\n    void injectionViaGroovyShellGroovyCodeSource(HttpServletRequest\
    \ request) {\n        GroovyShell shell = new GroovyShell();\n        String script\
    \ = request.getParameter(\"script\");\n        GroovyCodeSource gcs = new GroovyCodeSource(script,\
    \ \"test\", \"Test\");\n        shell.evaluate(gcs);\n    }\n}\n\n\n```\nThe following\
    \ example uses classloader block-list approach to exclude loading dangerous classes.\n\
    \n\n```java\npublic class SandboxGroovyClassLoader extends ClassLoader {\n   \
    \ public SandboxGroovyClassLoader(ClassLoader parent) {\n        super(parent);\n\
    \    }\n\n    /* override `loadClass` here to prevent loading sensitive classes,\
    \ such as `java.lang.Runtime`, `java.lang.ProcessBuilder`, `java.lang.System`,\
    \ etc.  */\n    /* Note we must also block `groovy.transform.ASTTest`, `groovy.lang.GrabConfig`\
    \ and `org.buildobjects.process.ProcBuilder` to prevent compile-time RCE. */\n\
    \n    static void runWithSandboxGroovyClassLoader() throws Exception {\n     \
    \   // GOOD: route all class-loading via sand-boxing classloader.\n        SandboxGroovyClassLoader\
    \ classLoader = new GroovyClassLoader(new SandboxGroovyClassLoader());\n     \
    \   \n        Class<?> scriptClass = classLoader.parseClass(untrusted.getQueryString());\n\
    \        Object scriptInstance = scriptClass.newInstance();\n        Object result\
    \ = scriptClass.getDeclaredMethod(\"bar\", new Class[]{}).invoke(scriptInstance,\
    \ new Object[]{});\n    }\n}\n```\n\n## References\n* Orange Tsai: [Abusing Meta\
    \ Programming for Unauthenticated RCE!](https://blog.orange.tw/2019/02/abusing-meta-programming-for-unauthenticated-rce.html).\n\
    * Cdric Champeau: [Improved sandboxing of Groovy scripts](https://melix.github.io/blog/2015/03/sandboxing.html).\n\
    * Kohsuke Kawaguchi: [Groovy SecureASTCustomizer is harmful](https://kohsuke.org/2012/04/27/groovy-secureastcustomizer-is-harmful/).\n\
    * Welk1n: [Groovy Injection payloads](https://github.com/welk1n/exploiting-groovy-in-Java/).\n\
    * Charles Chan: [Secure Groovy Script Execution in a Sandbox](https://levelup.gitconnected.com/secure-groovy-script-execution-in-a-sandbox-ea39f80ee87/).\n\
    * Eugene: [Scripting and sandboxing in a JVM environment](https://stringconcat.com/en/scripting-and-sandboxing/).\n\
    * Common Weakness Enumeration: [CWE-94](https://cwe.mitre.org/data/definitions/94.html).\n"
 -
  pack: codeql/java-queries#0
  relativeQueryPath: Security/CWE/CWE-094/InsecureBeanValidation.ql
  relativeBqrsPath: codeql/java-queries/Security/CWE/CWE-094/InsecureBeanValidation.bqrs
  metadata:
    name: Insecure Bean Validation
    description: "User-controlled data may be evaluated as a Java EL expression, leading\
      \ to arbitrary code execution."
    kind: path-problem
    problem.severity: error
    security-severity: 9.3
    precision: high
    id: java/insecure-bean-validation
    tags: |-
      security
             external/cwe/cwe-094
  queryHelp: "# Insecure Bean Validation\nCustom error messages for constraint validators\
    \ support different types of interpolation, including [Java EL expressions](https://docs.jboss.org/hibernate/validator/5.1/reference/en-US/html/chapter-message-interpolation.html#section-interpolation-with-message-expressions).\
    \ Controlling part of the message template being passed to `ConstraintValidatorContext.buildConstraintViolationWithTemplate()`\
    \ argument can lead to arbitrary Java code execution. Unfortunately, it is common\
    \ that validated (and therefore, normally untrusted) bean properties flow into\
    \ the custom error message.\n\n\n## Recommendation\nThere are different approaches\
    \ to remediate the issue:\n\n* Do not include validated bean properties in the\
    \ custom error message.\n* Use parameterized messages instead of string concatenation.\
    \ For example:\n```\nHibernateConstraintValidatorContext context =\n   constraintValidatorContext.unwrap(HibernateConstraintValidatorContext.class);\n\
    context.addMessageParameter(\"foo\", \"bar\");\ncontext.buildConstraintViolationWithTemplate(\"\
    My violation message contains a parameter {foo}\")\n   .addConstraintViolation();\n\
    ```\n* Sanitize the validated bean properties to make sure that there are no EL\
    \ expressions. An example of valid sanitization logic can be found [here](https://github.com/hibernate/hibernate-validator/blob/master/engine/src/main/java/org/hibernate/validator/internal/engine/messageinterpolation/util/InterpolationHelper.java#L17).\n\
    * Disable the EL interpolation and only use `ParameterMessageInterpolator`:\n\
    ```\nValidator validator = Validation.byDefaultProvider()\n   .configure()\n \
    \  .messageInterpolator(new ParameterMessageInterpolator())\n   .buildValidatorFactory()\n\
    \   .getValidator();\n```\n* Replace Hibernate Validator with Apache BVal, which\
    \ in its latest version does not interpolate EL expressions by default. Note that\
    \ this replacement may not be a simple drop-in replacement.\n\n## Example\nThe\
    \ following validator could result in arbitrary Java code execution:\n\n\n```java\n\
    import javax.validation.ConstraintValidator;\nimport javax.validation.ConstraintValidatorContext;\n\
    import org.hibernate.validator.constraintvalidation.HibernateConstraintValidatorContext;\n\
    import java.util.regex.Matcher;\nimport java.util.regex.Pattern;\n\npublic class\
    \ TestValidator implements ConstraintValidator<Object, String> {\n\n    public\
    \ static class InterpolationHelper {\n\n        public static final char BEGIN_TERM\
    \ = '{';\n        public static final char END_TERM = '}';\n        public static\
    \ final char EL_DESIGNATOR = '$';\n        public static final char ESCAPE_CHARACTER\
    \ = '\\\\';\n\n        private static final Pattern ESCAPE_MESSAGE_PARAMETER_PATTERN\
    \ = Pattern.compile( \"([\\\\\" + ESCAPE_CHARACTER + BEGIN_TERM + END_TERM + EL_DESIGNATOR\
    \ + \"])\" );\n\n        private InterpolationHelper() {\n        }\n\n      \
    \  public static String escapeMessageParameter(String messageParameter) {\n  \
    \          if ( messageParameter == null ) {\n                return null;\n \
    \           }\n            return ESCAPE_MESSAGE_PARAMETER_PATTERN.matcher( messageParameter\
    \ ).replaceAll( Matcher.quoteReplacement( String.valueOf( ESCAPE_CHARACTER ) )\
    \ + \"$1\" );\n        }\n\n    }\n\n    @Override\n    public boolean isValid(String\
    \ object, ConstraintValidatorContext constraintContext) {\n        String value\
    \ = object + \" is invalid\";\n\n        // Bad: Bean properties (normally user-controlled)\
    \ are passed directly to `buildConstraintViolationWithTemplate`\n        constraintContext.buildConstraintViolationWithTemplate(value).addConstraintViolation().disableDefaultConstraintViolation();\n\
    \n        // Good: Bean properties (normally user-controlled) are escaped \n \
    \       String escaped = InterpolationHelper.escapeMessageParameter(value);\n\
    \        constraintContext.buildConstraintViolationWithTemplate(escaped).addConstraintViolation().disableDefaultConstraintViolation();\n\
    \n        // Good: Bean properties (normally user-controlled) are parameterized\n\
    \        HibernateConstraintValidatorContext context = constraintContext.unwrap(\
    \ HibernateConstraintValidatorContext.class );\n        context.addMessageParameter(\
    \ \"prop\", object );\n        context.buildConstraintViolationWithTemplate( \"\
    {prop} is invalid\").addConstraintViolation();\n        return false;\n    }\n\
    \n}\n\n```\n\n## References\n* Hibernate Reference Guide: [ConstraintValidatorContext](https://docs.jboss.org/hibernate/stable/validator/reference/en-US/html_single/#_the_code_constraintvalidatorcontext_code).\n\
    * GitHub Security Lab research: [Bean validation](https://securitylab.github.com/research/bean-validation-RCE).\n\
    * Common Weakness Enumeration: [CWE-94](https://cwe.mitre.org/data/definitions/94.html).\n"
 -
  pack: codeql/java-queries#0
  relativeQueryPath: Security/CWE/CWE-094/JexlInjection.ql
  relativeBqrsPath: codeql/java-queries/Security/CWE/CWE-094/JexlInjection.bqrs
  metadata:
    name: Expression language injection (JEXL)
    description: |-
      Evaluation of a user-controlled JEXL expression
                    may lead to arbitrary code execution.
    kind: path-problem
    problem.severity: error
    security-severity: 9.3
    precision: high
    id: java/jexl-expression-injection
    tags: |-
      security
             external/cwe/cwe-094
  queryHelp: "# Expression language injection (JEXL)\nJava EXpression Language (JEXL)\
    \ is a simple expression language provided by the Apache Commons JEXL library.\
    \ The syntax is close to a mix of ECMAScript and shell-script. The language allows\
    \ invocation of methods available in the JVM. If a JEXL expression is built using\
    \ attacker-controlled data, and then evaluated, then it may allow the attacker\
    \ to run arbitrary code.\n\n\n## Recommendation\nIt is generally recommended to\
    \ avoid using untrusted input in a JEXL expression. If it is not possible, JEXL\
    \ expressions should be run in a sandbox that allows accessing only explicitly\
    \ allowed classes.\n\n\n## Example\nThe following example uses untrusted data\
    \ to build and run a JEXL expression.\n\n\n```java\npublic void evaluate(Socket\
    \ socket) throws IOException {\n  try (BufferedReader reader = new BufferedReader(\n\
    \        new InputStreamReader(socket.getInputStream()))) {\n    \n    String\
    \ input = reader.readLine();\n    JexlEngine jexl = new JexlBuilder().create();\n\
    \    JexlExpression expression = jexl.createExpression(input);\n    JexlContext\
    \ context = new MapContext();\n    expression.evaluate(context);\n  }\n}\n```\n\
    The next example shows how an untrusted JEXL expression can be run in a sandbox\
    \ that allows accessing only methods in the `java.lang.Math` class. The sandbox\
    \ is implemented using `JexlSandbox` class that is provided by Apache Commons\
    \ JEXL 3.\n\n\n```java\npublic void evaluate(Socket socket) throws IOException\
    \ {\n  try (BufferedReader reader = new BufferedReader(\n        new InputStreamReader(socket.getInputStream())))\
    \ {\n    \n    JexlSandbox onlyMath = new JexlSandbox(false);\n    onlyMath.white(\"\
    java.lang.Math\");\n    JexlEngine jexl = new JexlBuilder().sandbox(onlyMath).create();\n\
    \      \n    String input = reader.readLine();\n    JexlExpression expression\
    \ = jexl.createExpression(input);\n    JexlContext context = new MapContext();\n\
    \    expression.evaluate(context);\n  }\n}\n```\nThe next example shows another\
    \ way how a sandbox can be implemented. It uses a custom implementation of `JexlUberspect`\
    \ that checks if callees are instances of allowed classes.\n\n\n```java\npublic\
    \ void evaluate(Socket socket) throws IOException {\n  try (BufferedReader reader\
    \ = new BufferedReader(\n        new InputStreamReader(socket.getInputStream())))\
    \ {\n    \n    JexlUberspect sandbox = new JexlUberspectSandbox();\n    JexlEngine\
    \ jexl = new JexlBuilder().uberspect(sandbox).create();\n      \n    String input\
    \ = reader.readLine();\n    JexlExpression expression = jexl.createExpression(input);\n\
    \    JexlContext context = new MapContext();\n    expression.evaluate(context);\n\
    \  }\n\n  private static class JexlUberspectSandbox implements JexlUberspect {\n\
    \n    private static final List<String> ALLOWED_CLASSES =\n              Arrays.asList(\"\
    java.lang.Math\", \"java.util.Random\");\n\n    private final JexlUberspect uberspect\
    \ = new JexlBuilder().create().getUberspect();\n\n    private void checkAccess(Object\
    \ obj) {\n      if (!ALLOWED_CLASSES.contains(obj.getClass().getCanonicalName()))\
    \ {\n        throw new AccessControlException(\"Not allowed\");\n      }\n   \
    \ }\n\n    @Override\n    public JexlMethod getMethod(Object obj, String method,\
    \ Object... args) {\n      checkAccess(obj);\n      return uberspect.getMethod(obj,\
    \ method, args);\n    }\n\n    @Override\n    public List<PropertyResolver> getResolvers(JexlOperator\
    \ op, Object obj) {\n      checkAccess(obj);\n      return uberspect.getResolvers(op,\
    \ obj);\n    }\n\n    @Override\n    public void setClassLoader(ClassLoader loader)\
    \ {\n      uberspect.setClassLoader(loader);\n    }\n\n    @Override\n    public\
    \ int getVersion() {\n      return uberspect.getVersion();\n    }\n\n    @Override\n\
    \    public JexlMethod getConstructor(Object obj, Object... args) {\n      checkAccess(obj);\n\
    \      return uberspect.getConstructor(obj, args);\n    }\n\n    @Override\n \
    \   public JexlPropertyGet getPropertyGet(Object obj, Object identifier) {\n \
    \     checkAccess(obj);\n      return uberspect.getPropertyGet(obj, identifier);\n\
    \    }\n\n    @Override\n    public JexlPropertyGet getPropertyGet(List<PropertyResolver>\
    \ resolvers, Object obj, Object identifier) {\n      checkAccess(obj);\n     \
    \ return uberspect.getPropertyGet(resolvers, obj, identifier);\n    }\n\n    @Override\n\
    \    public JexlPropertySet getPropertySet(Object obj, Object identifier, Object\
    \ arg) {\n      checkAccess(obj);\n      return uberspect.getPropertySet(obj,\
    \ identifier, arg);\n    }\n\n    @Override\n    public JexlPropertySet getPropertySet(List<PropertyResolver>\
    \ resolvers, Object obj, Object identifier, Object arg) {\n      checkAccess(obj);\n\
    \      return uberspect.getPropertySet(resolvers, obj, identifier, arg);\n   \
    \ }\n\n    @Override\n    public Iterator<?> getIterator(Object obj) {\n     \
    \ checkAccess(obj);\n      return uberspect.getIterator(obj);\n    }\n\n    @Override\n\
    \    public JexlArithmetic.Uberspect getArithmetic(JexlArithmetic arithmetic)\
    \ {\n      return uberspect.getArithmetic(arithmetic);\n    } \n  }\n}\n```\n\n\
    ## References\n* Apache Commons JEXL: [Project page](https://commons.apache.org/proper/commons-jexl/).\n\
    * Apache Commons JEXL documentation: [JEXL 2.1.1 API](https://commons.apache.org/proper/commons-jexl/javadocs/apidocs-2.1.1/).\n\
    * Apache Commons JEXL documentation: [JEXL 3.1 API](https://commons.apache.org/proper/commons-jexl/apidocs/index.html).\n\
    * OWASP: [Expression Language Injection](https://owasp.org/www-community/vulnerabilities/Expression_Language_Injection).\n\
    * Common Weakness Enumeration: [CWE-94](https://cwe.mitre.org/data/definitions/94.html).\n"
 -
  pack: codeql/java-queries#0
  relativeQueryPath: Security/CWE/CWE-094/MvelInjection.ql
  relativeBqrsPath: codeql/java-queries/Security/CWE/CWE-094/MvelInjection.bqrs
  metadata:
    name: Expression language injection (MVEL)
    description: |-
      Evaluation of a user-controlled MVEL expression
                    may lead to remote code execution.
    kind: path-problem
    problem.severity: error
    security-severity: 9.3
    precision: high
    id: java/mvel-expression-injection
    tags: |-
      security
             external/cwe/cwe-094
  queryHelp: "# Expression language injection (MVEL)\nMVEL is an expression language\
    \ based on Java-syntax, which offers many features including invocation of methods\
    \ available in the JVM. If a MVEL expression is built using attacker-controlled\
    \ data, and then evaluated, then it may allow attackers to run arbitrary code.\n\
    \n\n## Recommendation\nIncluding user input in a MVEL expression should be avoided.\n\
    \n\n## Example\nIn the following sample, the first example uses untrusted data\
    \ to build a MVEL expression and then runs it in the default context. In the second\
    \ example, the untrusted data is validated with a custom method that checks that\
    \ the expression does not contain unexpected code before evaluating it.\n\n\n\
    ```java\npublic void evaluate(Socket socket) throws IOException {\n  try (BufferedReader\
    \ reader = new BufferedReader(\n    new InputStreamReader(socket.getInputStream())))\
    \ {\n  \n    String expression = reader.readLine();\n    // BAD: the user-provided\
    \ expression is directly evaluated\n    MVEL.eval(expression);\n  }\n}\n\npublic\
    \ void safeEvaluate(Socket socket) throws IOException {\n  try (BufferedReader\
    \ reader = new BufferedReader(\n    new InputStreamReader(socket.getInputStream())))\
    \ {\n  \n    String expression = reader.readLine();\n    // GOOD: the user-provided\
    \ expression is validated before evaluation\n    validateExpression(expression);\n\
    \    MVEL.eval(expression);\n  }\n}\n\nprivate void validateExpression(String\
    \ expression) {\n  // Validate that the expression does not contain unexpected\
    \ code.\n  // For instance, this can be done with allow-lists or deny-lists of\
    \ code patterns.\n}\n```\n\n## References\n* MVEL Documentation: [Language Guide\
    \ for 2.0](http://mvel.documentnode.com/).\n* OWASP: [Expression Language Injection](https://owasp.org/www-community/vulnerabilities/Expression_Language_Injection).\n\
    * Common Weakness Enumeration: [CWE-94](https://cwe.mitre.org/data/definitions/94.html).\n"
 -
  pack: codeql/java-queries#0
  relativeQueryPath: Security/CWE/CWE-094/SpelInjection.ql
  relativeBqrsPath: codeql/java-queries/Security/CWE/CWE-094/SpelInjection.bqrs
  metadata:
    name: Expression language injection (Spring)
    description: |-
      Evaluation of a user-controlled Spring Expression Language (SpEL) expression
                    may lead to remote code execution.
    kind: path-problem
    problem.severity: error
    security-severity: 9.3
    precision: high
    id: java/spel-expression-injection
    tags: |-
      security
             external/cwe/cwe-094
  queryHelp: "# Expression language injection (Spring)\nThe Spring Expression Language\
    \ (SpEL) is a powerful expression language provided by the Spring Framework. The\
    \ language offers many features including invocation of methods available in the\
    \ JVM. If a SpEL expression is built using attacker-controlled data, and then\
    \ evaluated in a powerful context, then it may allow the attacker to run arbitrary\
    \ code.\n\nThe `SpelExpressionParser` class parses a SpEL expression string and\
    \ returns an `Expression` instance that can be then evaluated by calling one of\
    \ its methods. By default, an expression is evaluated in a powerful `StandardEvaluationContext`\
    \ that allows the expression to access other methods available in the JVM.\n\n\
    \n## Recommendation\nIn general, including user input in a SpEL expression should\
    \ be avoided. If user input must be included in the expression, it should be then\
    \ evaluated in a limited context that doesn't allow arbitrary method invocation.\n\
    \n\n## Example\nThe following example uses untrusted data to build a SpEL expression\
    \ and then runs it in the default powerful context.\n\n\n```java\npublic Object\
    \ evaluate(Socket socket) throws IOException {\n  try (BufferedReader reader =\
    \ new BufferedReader(\n      new InputStreamReader(socket.getInputStream())))\
    \ {\n\n    String string = reader.readLine();\n    ExpressionParser parser = new\
    \ SpelExpressionParser();\n    Expression expression = parser.parseExpression(string);\n\
    \    return expression.getValue();\n  }\n}\n```\nThe next example shows how an\
    \ untrusted SpEL expression can be run in `SimpleEvaluationContext` that doesn't\
    \ allow accessing arbitrary methods. However, it's recommended to avoid using\
    \ untrusted input in SpEL expressions.\n\n\n```java\npublic Object evaluate(Socket\
    \ socket) throws IOException {\n  try (BufferedReader reader = new BufferedReader(\n\
    \      new InputStreamReader(socket.getInputStream()))) {\n\n    String string\
    \ = reader.readLine();\n    ExpressionParser parser = new SpelExpressionParser();\n\
    \    Expression expression = parser.parseExpression(string);\n    SimpleEvaluationContext\
    \ context \n        = SimpleEvaluationContext.forReadWriteDataBinding().build();\n\
    \    return expression.getValue(context);\n  }\n}\n```\n\n## References\n* Spring\
    \ Framework Reference Documentation: [Spring Expression Language (SpEL)](https://docs.spring.io/spring/docs/4.2.x/spring-framework-reference/html/expressions.html).\n\
    * OWASP: [Expression Language Injection](https://owasp.org/www-community/vulnerabilities/Expression_Language_Injection).\n\
    * Common Weakness Enumeration: [CWE-94](https://cwe.mitre.org/data/definitions/94.html).\n"
 -
  pack: codeql/java-queries#0
  relativeQueryPath: Security/CWE/CWE-094/TemplateInjection.ql
  relativeBqrsPath: codeql/java-queries/Security/CWE/CWE-094/TemplateInjection.bqrs
  metadata:
    name: Server-side template injection
    description: Untrusted input interpreted as a template can lead to remote code
      execution.
    kind: path-problem
    problem.severity: error
    security-severity: 9.3
    precision: high
    id: java/server-side-template-injection
    tags: |-
      security
             external/cwe/cwe-1336
             external/cwe/cwe-094
  queryHelp: "# Server-side template injection\nTemplate injection occurs when user\
    \ input is embedded in a template's code in an unsafe manner. An attacker can\
    \ use native template syntax to inject a malicious payload into a template, which\
    \ is then executed server-side. This permits the attacker to run arbitrary code\
    \ in the server's context.\n\n\n## Recommendation\nTo fix this, ensure that untrusted\
    \ input is not used as part of a template's code. If the application requirements\
    \ do not allow this, use a sandboxed environment where access to unsafe attributes\
    \ and methods is prohibited.\n\n\n## Example\nIn the example given below, an untrusted\
    \ HTTP parameter `code` is used as a Velocity template string. This can lead to\
    \ remote code execution.\n\n\n```java\n@Controller\npublic class VelocitySSTI\
    \ {\n\n\t@GetMapping(value = \"bad\")\n\tpublic void bad(HttpServletRequest request)\
    \ {\n\t\tVelocity.init();\n\n\t\tString code = request.getParameter(\"code\");\n\
    \n\t\tVelocityContext context = new VelocityContext();\n\n\t\tcontext.put(\"name\"\
    , \"Velocity\");\n\t\tcontext.put(\"project\", \"Jakarta\");\n\n\t\tStringWriter\
    \ w = new StringWriter();\n\t\t// evaluate( Context context, Writer out, String\
    \ logTag, String instring )\n\t\tVelocity.evaluate(context, w, \"mystring\", code);\n\
    \t}\n}\n\n```\nIn the next example, the problem is avoided by using a fixed template\
    \ string `s`. Since the template's code is not attacker-controlled in this case,\
    \ this solution prevents the execution of untrusted code.\n\n\n```java\n@Controller\n\
    public class VelocitySSTI {\n\n\t@GetMapping(value = \"good\")\n\tpublic void\
    \ good(HttpServletRequest request) {\n\t\tVelocity.init();\n\t\tVelocityContext\
    \ context = new VelocityContext();\n\n\t\tcontext.put(\"name\", \"Velocity\");\n\
    \t\tcontext.put(\"project\", \"Jakarta\");\n\n\t\tString s = \"We are using $project\
    \ $name to render this.\";\n\t\tStringWriter w = new StringWriter();\n\t\tVelocity.evaluate(context,\
    \ w, \"mystring\", s);\n\t\tSystem.out.println(\" string : \" + w);\n\t}\n}\n\n\
    ```\n\n## References\n* Portswigger: [Server Side Template Injection](https://portswigger.net/web-security/server-side-template-injection).\n\
    * Common Weakness Enumeration: [CWE-1336](https://cwe.mitre.org/data/definitions/1336.html).\n\
    * Common Weakness Enumeration: [CWE-94](https://cwe.mitre.org/data/definitions/94.html).\n"
 -
  pack: codeql/java-queries#0
  relativeQueryPath: Security/CWE/CWE-1104/MavenPomDependsOnBintray.ql
  relativeBqrsPath: codeql/java-queries/Security/CWE/CWE-1104/MavenPomDependsOnBintray.bqrs
  metadata:
    name: Depending upon JCenter/Bintray as an artifact repository
    description: Using a deprecated artifact repository may eventually give attackers
      access for a supply chain attack.
    kind: problem
    problem.severity: error
    security-severity: 6.5
    precision: very-high
    id: java/maven/dependency-upon-bintray
    tags: |-
      security
             external/cwe/cwe-1104
  queryHelp: |
    # Depending upon JCenter/Bintray as an artifact repository
    [Bintray and JCenter are shutting down on February 1st, 2022](https://jfrog.com/blog/into-the-sunset-bintray-jcenter-gocenter-and-chartcenter/). Relying upon repositories that are deprecated or scheduled to be shutdown can have unintended consequences; for example, artifacts being resolved from a different artifact server or a total failure of the CI build.

    When artifact repositories are left unmaintained for a long period of time, vulnerabilities may emerge. Theoretically, this could allow attackers to inject malicious code into the artifacts that you are resolving and infect build artifacts that are being produced. This can be used by attackers to perform a [supply chain attack](https://en.wikipedia.org/wiki/Supply_chain_attack) against your project's users.


    ## Recommendation
    Always use the canonical repository for resolving your dependencies.


    ## Example
    The following example shows locations in a Maven POM file where artifact repository upload/download is configured. The use of Bintray in any of these locations is not advised.


    ```xml
    <?xml version="1.0" encoding="UTF-8"?>
    <project xmlns="http://maven.apache.org/POM/4.0.0"
             xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
             xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd">

        <modelVersion>4.0.0</modelVersion>

        <groupId>com.semmle</groupId>
        <artifactId>parent</artifactId>
        <version>1.0</version>
        <packaging>pom</packaging>

        <name>Bintray Usage</name>
        <description>An example of using bintray to download and upload dependencies</description>

        <distributionManagement>
            <repository>
                <id>jcenter</id>
                <name>JCenter</name>
                <!-- BAD! Don't use JCenter -->
                <url>https://jcenter.bintray.com</url>
            </repository>
            <snapshotRepository>
                <id>jcenter-snapshots</id>
                <name>JCenter</name>
                <!-- BAD! Don't use JCenter -->
                <url>https://jcenter.bintray.com</url>
            </snapshotRepository>
        </distributionManagement>
        <repositories>
            <repository>
                <id>jcenter</id>
                <name>JCenter</name>
                <!-- BAD! Don't use JCenter -->
                <url>https://jcenter.bintray.com</url>
            </repository>
        </repositories>
        <repositories>
            <repository>
                <id>jcenter</id>
                <name>JCenter</name>
                <!-- BAD! Don't use Bintray -->
                <url>https://dl.bintray.com/groovy/maven</url>
            </repository>
        </repositories>
        <pluginRepositories>
            <pluginRepository>
                <id>jcenter-plugins</id>
                <name>JCenter</name>
                <!-- BAD! Don't use JCenter -->
                <url>https://jcenter.bintray.com</url>
            </pluginRepository>
        </pluginRepositories>
    </project>

    ```

    ## References
    * JFrog blog: [ Into the Sunset on May 1st: Bintray, JCenter, GoCenter, and ChartCenter ](https://jfrog.com/blog/into-the-sunset-bintray-jcenter-gocenter-and-chartcenter/)
    * Common Weakness Enumeration: [CWE-1104](https://cwe.mitre.org/data/definitions/1104.html).
 -
  pack: codeql/java-queries#0
  relativeQueryPath: Security/CWE/CWE-113/NettyResponseSplitting.ql
  relativeBqrsPath: codeql/java-queries/Security/CWE/CWE-113/NettyResponseSplitting.bqrs
  metadata:
    name: Disabled Netty HTTP header validation
    description: |-
      Disabling HTTP header validation makes code vulnerable to
                    attack by header splitting if user input is written directly to
                    an HTTP header.
    kind: problem
    problem.severity: error
    security-severity: 6.1
    precision: high
    id: java/netty-http-request-or-response-splitting
    tags: |-
      security
             external/cwe/cwe-93
             external/cwe/cwe-113
  queryHelp: "# Disabled Netty HTTP header validation\nDirectly writing user input\
    \ (for example, an HTTP request parameter) to an HTTP header can lead to an HTTP\
    \ request-splitting or response-splitting vulnerability.\n\nHTTP response splitting\
    \ can lead to vulnerabilities such as XSS and cache poisoning.\n\nHTTP request\
    \ splitting can allow an attacker to inject an additional HTTP request into a\
    \ client's outgoing socket connection. This can allow an attacker to perform an\
    \ SSRF-like attack.\n\nIn the context of a servlet container, if the user input\
    \ includes blank lines and the servlet container does not escape the blank lines,\
    \ then a remote user can cause the response to turn into two separate responses.\
    \ The remote user can then control one or more responses, which is also HTTP response\
    \ splitting.\n\n\n## Recommendation\nGuard against HTTP header splitting in the\
    \ same way as guarding against cross-site scripting. Before passing any data into\
    \ HTTP headers, either check the data for special characters, or escape any special\
    \ characters that are present.\n\nIf the code calls Netty API's directly, ensure\
    \ that the `validateHeaders` parameter is set to `true`.\n\n\n## Example\nThe\
    \ following example shows the 'name' parameter being written to a cookie in two\
    \ different ways. The first way writes it directly to the cookie, and thus is\
    \ vulnerable to response-splitting attacks. The second way first removes all special\
    \ characters, thus avoiding the potential problem.\n\n\n```java\npublic class\
    \ ResponseSplitting extends HttpServlet {\n\tprotected void doGet(HttpServletRequest\
    \ request, HttpServletResponse response)\n\tthrows ServletException, IOException\
    \ {\n\t\t// BAD: setting a cookie with an unvalidated parameter\n\t\tCookie cookie\
    \ = new Cookie(\"name\", request.getParameter(\"name\"));\n\t\tresponse.addCookie(cookie);\n\
    \n\t\t// GOOD: remove special characters before putting them in the header\n\t\
    \tString name = removeSpecial(request.getParameter(\"name\"));\n\t\tCookie cookie2\
    \ = new Cookie(\"name\", name);\n\t\tresponse.addCookie(cookie2);\n\t}\n\n\tprivate\
    \ static String removeSpecial(String str) {\n\t\treturn str.replaceAll(\"[^a-zA-Z\
    \ ]\", \"\");\n\t}\n}\n\n```\n\n## Example\nThe following example shows the use\
    \ of the library 'netty' with HTTP response-splitting verification configurations.\
    \ The second way will verify the parameters before using them to build the HTTP\
    \ response.\n\n\n```java\nimport io.netty.handler.codec.http.DefaultHttpHeaders;\n\
    \npublic class ResponseSplitting {\n    // BAD: Disables the internal response\
    \ splitting verification\n    private final DefaultHttpHeaders badHeaders = new\
    \ DefaultHttpHeaders(false);\n\n    // GOOD: Verifies headers passed don't contain\
    \ CRLF characters\n    private final DefaultHttpHeaders goodHeaders = new DefaultHttpHeaders();\n\
    \n    // BAD: Disables the internal response splitting verification\n    private\
    \ final DefaultHttpResponse badResponse = new DefaultHttpResponse(version, httpResponseStatus,\
    \ false);\n\n    // GOOD: Verifies headers passed don't contain CRLF characters\n\
    \    private final DefaultHttpResponse goodResponse = new DefaultHttpResponse(version,\
    \ httpResponseStatus);\n}\n\n```\n\n## Example\nThe following example shows the\
    \ use of the netty library with configurations for verification of HTTP request\
    \ splitting. The second recommended approach in the example verifies the parameters\
    \ before using them to build the HTTP request.\n\n\n```java\npublic class NettyRequestSplitting\
    \ {\n    // BAD: Disables the internal request splitting verification\n    private\
    \ final DefaultHttpHeaders badHeaders = new DefaultHttpHeaders(false);\n\n   \
    \ // GOOD: Verifies headers passed don't contain CRLF characters\n    private\
    \ final DefaultHttpHeaders goodHeaders = new DefaultHttpHeaders();\n\n    // BAD:\
    \ Disables the internal request splitting verification\n    private final DefaultHttpRequest\
    \ badRequest = new DefaultHttpRequest(httpVersion, method, uri, false);\n\n  \
    \  // GOOD: Verifies headers passed don't contain CRLF characters\n    private\
    \ final DefaultHttpRequest goodResponse = new DefaultHttpRequest(httpVersion,\
    \ method, uri);\n}\n\n```\n\n## References\n* SecLists.org: [HTTP response splitting](https://seclists.org/bugtraq/2005/Apr/187).\n\
    * OWASP: [HTTP Response Splitting](https://www.owasp.org/index.php/HTTP_Response_Splitting).\n\
    * Wikipedia: [HTTP response splitting](http://en.wikipedia.org/wiki/HTTP_response_splitting).\n\
    * CAPEC: [CAPEC-105: HTTP Request Splitting](https://capec.mitre.org/data/definitions/105.html)\n\
    * Common Weakness Enumeration: [CWE-93](https://cwe.mitre.org/data/definitions/93.html).\n\
    * Common Weakness Enumeration: [CWE-113](https://cwe.mitre.org/data/definitions/113.html).\n"
 -
  pack: codeql/java-queries#0
  relativeQueryPath: Security/CWE/CWE-113/ResponseSplitting.ql
  relativeBqrsPath: codeql/java-queries/Security/CWE/CWE-113/ResponseSplitting.bqrs
  metadata:
    name: HTTP response splitting
    description: |-
      Writing user input directly to an HTTP header
                    makes code vulnerable to attack by header splitting.
    kind: path-problem
    problem.severity: error
    security-severity: 6.1
    precision: high
    id: java/http-response-splitting
    tags: |-
      security
             external/cwe/cwe-113
  queryHelp: "# HTTP response splitting\nDirectly writing user input (for example,\
    \ an HTTP request parameter) to an HTTP header can lead to an HTTP request-splitting\
    \ or response-splitting vulnerability.\n\nHTTP response splitting can lead to\
    \ vulnerabilities such as XSS and cache poisoning.\n\nHTTP request splitting can\
    \ allow an attacker to inject an additional HTTP request into a client's outgoing\
    \ socket connection. This can allow an attacker to perform an SSRF-like attack.\n\
    \nIn the context of a servlet container, if the user input includes blank lines\
    \ and the servlet container does not escape the blank lines, then a remote user\
    \ can cause the response to turn into two separate responses. The remote user\
    \ can then control one or more responses, which is also HTTP response splitting.\n\
    \n\n## Recommendation\nGuard against HTTP header splitting in the same way as\
    \ guarding against cross-site scripting. Before passing any data into HTTP headers,\
    \ either check the data for special characters, or escape any special characters\
    \ that are present.\n\nIf the code calls Netty API's directly, ensure that the\
    \ `validateHeaders` parameter is set to `true`.\n\n\n## Example\nThe following\
    \ example shows the 'name' parameter being written to a cookie in two different\
    \ ways. The first way writes it directly to the cookie, and thus is vulnerable\
    \ to response-splitting attacks. The second way first removes all special characters,\
    \ thus avoiding the potential problem.\n\n\n```java\npublic class ResponseSplitting\
    \ extends HttpServlet {\n\tprotected void doGet(HttpServletRequest request, HttpServletResponse\
    \ response)\n\tthrows ServletException, IOException {\n\t\t// BAD: setting a cookie\
    \ with an unvalidated parameter\n\t\tCookie cookie = new Cookie(\"name\", request.getParameter(\"\
    name\"));\n\t\tresponse.addCookie(cookie);\n\n\t\t// GOOD: remove special characters\
    \ before putting them in the header\n\t\tString name = removeSpecial(request.getParameter(\"\
    name\"));\n\t\tCookie cookie2 = new Cookie(\"name\", name);\n\t\tresponse.addCookie(cookie2);\n\
    \t}\n\n\tprivate static String removeSpecial(String str) {\n\t\treturn str.replaceAll(\"\
    [^a-zA-Z ]\", \"\");\n\t}\n}\n\n```\n\n## Example\nThe following example shows\
    \ the use of the library 'netty' with HTTP response-splitting verification configurations.\
    \ The second way will verify the parameters before using them to build the HTTP\
    \ response.\n\n\n```java\nimport io.netty.handler.codec.http.DefaultHttpHeaders;\n\
    \npublic class ResponseSplitting {\n    // BAD: Disables the internal response\
    \ splitting verification\n    private final DefaultHttpHeaders badHeaders = new\
    \ DefaultHttpHeaders(false);\n\n    // GOOD: Verifies headers passed don't contain\
    \ CRLF characters\n    private final DefaultHttpHeaders goodHeaders = new DefaultHttpHeaders();\n\
    \n    // BAD: Disables the internal response splitting verification\n    private\
    \ final DefaultHttpResponse badResponse = new DefaultHttpResponse(version, httpResponseStatus,\
    \ false);\n\n    // GOOD: Verifies headers passed don't contain CRLF characters\n\
    \    private final DefaultHttpResponse goodResponse = new DefaultHttpResponse(version,\
    \ httpResponseStatus);\n}\n\n```\n\n## Example\nThe following example shows the\
    \ use of the netty library with configurations for verification of HTTP request\
    \ splitting. The second recommended approach in the example verifies the parameters\
    \ before using them to build the HTTP request.\n\n\n```java\npublic class NettyRequestSplitting\
    \ {\n    // BAD: Disables the internal request splitting verification\n    private\
    \ final DefaultHttpHeaders badHeaders = new DefaultHttpHeaders(false);\n\n   \
    \ // GOOD: Verifies headers passed don't contain CRLF characters\n    private\
    \ final DefaultHttpHeaders goodHeaders = new DefaultHttpHeaders();\n\n    // BAD:\
    \ Disables the internal request splitting verification\n    private final DefaultHttpRequest\
    \ badRequest = new DefaultHttpRequest(httpVersion, method, uri, false);\n\n  \
    \  // GOOD: Verifies headers passed don't contain CRLF characters\n    private\
    \ final DefaultHttpRequest goodResponse = new DefaultHttpRequest(httpVersion,\
    \ method, uri);\n}\n\n```\n\n## References\n* SecLists.org: [HTTP response splitting](https://seclists.org/bugtraq/2005/Apr/187).\n\
    * OWASP: [HTTP Response Splitting](https://www.owasp.org/index.php/HTTP_Response_Splitting).\n\
    * Wikipedia: [HTTP response splitting](http://en.wikipedia.org/wiki/HTTP_response_splitting).\n\
    * CAPEC: [CAPEC-105: HTTP Request Splitting](https://capec.mitre.org/data/definitions/105.html)\n\
    * Common Weakness Enumeration: [CWE-113](https://cwe.mitre.org/data/definitions/113.html).\n"
 -
  pack: codeql/java-queries#0
  relativeQueryPath: Security/CWE/CWE-117/LogInjection.ql
  relativeBqrsPath: codeql/java-queries/Security/CWE/CWE-117/LogInjection.bqrs
  metadata:
    name: Log Injection
    description: |-
      Building log entries from user-controlled data may allow
                    insertion of forged log entries by malicious users.
    kind: path-problem
    problem.severity: error
    security-severity: 7.8
    precision: medium
    id: java/log-injection
    tags: |-
      security
             external/cwe/cwe-117
  queryHelp: |
    # Log Injection
    If unsanitized user input is written to a log entry, a malicious user may be able to forge new log entries.

    Forgery can occur if a user provides some input creating the appearance of multiple log entries. This can include unescaped new-line characters, or HTML or other markup.


    ## Recommendation
    User input should be suitably sanitized before it is logged.

    If the log entries are plain text then line breaks should be removed from user input, using for example `String replace(char oldChar, char newChar)` or similar. Care should also be taken that user input is clearly marked in log entries, and that a malicious user cannot cause confusion in other ways.

    For log entries that will be displayed in HTML, user input should be HTML encoded before being logged, to prevent forgery and other forms of HTML injection.


    ## Example
    In the first example, a username, provided by the user, is logged using `logger.warn` (from `org.slf4j.Logger`). In the first case (`/bad` endpoint), the username is logged without any sanitization. If a malicious user provides `Guest'%0AUser:'Admin` as a username parameter, the log entry will be split into two separate lines, where the first line will be `User:'Guest'` and the second one will be `User:'Admin'`.


    ```java
    package com.example.restservice;

    import org.slf4j.Logger;
    import org.slf4j.LoggerFactory;
    import org.springframework.web.bind.annotation.GetMapping;
    import org.springframework.web.bind.annotation.RequestParam;
    import org.springframework.web.bind.annotation.RestController;

    @RestController
    public class LogInjection {

        private final Logger log = LoggerFactory.getLogger(LogInjection.class);

        // /bad?username=Guest'%0AUser:'Admin
        @GetMapping("/bad")
        public String bad(@RequestParam(value = "username", defaultValue = "name") String username) {
            log.warn("User:'{}'", username);
            // The logging call above would result in multiple log entries as shown below:
            // User:'Guest'
            // User:'Admin'
            return username;
        }
    }


    ```
    In the second example (`/good` endpoint), `matches()` is used to ensure the user input only has alphanumeric characters. If a malicious user provides \`Guest'%0AUser:'Admin\` as a username parameter, the log entry will not be logged at all, preventing the injection.


    ```java
    package com.example.restservice;

    import org.slf4j.Logger;
    import org.slf4j.LoggerFactory;
    import org.springframework.web.bind.annotation.GetMapping;
    import org.springframework.web.bind.annotation.RequestParam;
    import org.springframework.web.bind.annotation.RestController;

    @RestController
    public class LogInjection {

        private final Logger log = LoggerFactory.getLogger(LogInjection.class);

        // /good?username=Guest'%0AUser:'Admin
        @GetMapping("/good")
        public String good(@RequestParam(value = "username", defaultValue = "name") String username) {
            // The regex check here, allows only alphanumeric characters to pass.
            // Hence, does not result in log injection
            if (username.matches("\\w*")) {
                log.warn("User:'{}'", username);

                return username;
            }
        }
    }

    ```

    ## References
    * OWASP: [Log Injection](https://owasp.org/www-community/attacks/Log_Injection).
    * Common Weakness Enumeration: [CWE-117](https://cwe.mitre.org/data/definitions/117.html).
 -
  pack: codeql/java-queries#0
  relativeQueryPath: Security/CWE/CWE-1204/StaticInitializationVector.ql
  relativeBqrsPath: codeql/java-queries/Security/CWE/CWE-1204/StaticInitializationVector.bqrs
  metadata:
    name: Using a static initialization vector for encryption
    description: "An initialization vector (IV) used for ciphers of certain modes\
      \ (such as CBC or GCM) should be unique and unpredictable, to maximize encryption\
      \ and prevent dictionary attacks."
    kind: path-problem
    problem.severity: warning
    security-severity: 7.5
    precision: high
    id: java/static-initialization-vector
    tags: |-
      security
             external/cwe/cwe-329
             external/cwe/cwe-1204
  queryHelp: |
    # Using a static initialization vector for encryption
    When a cipher is used in certain modes such as CBC or GCM, it requires an initialization vector (IV). Under the same secret key, IVs should be unique and ideally unpredictable. If the same IV is used with the same secret key, then the same plaintext results in the same ciphertext. This can let an attacker learn if the same data pieces are transferred or stored, or help the attacker run a dictionary attack.


    ## Recommendation
    Use a random IV generated by `SecureRandom`.


    ## Example
    The following example initializes a cipher with a static IV, which is unsafe:


    ```java
    byte[] iv = new byte[16]; // all zeroes
    GCMParameterSpec params = new GCMParameterSpec(128, iv);
    Cipher cipher = Cipher.getInstance("AES/GCM/PKCS5PADDING");
    cipher.init(Cipher.ENCRYPT_MODE, key, params);
    ```
    The next example initializes a cipher with a random IV:


    ```java
    byte[] iv = new byte[16];
    SecureRandom random = SecureRandom.getInstanceStrong();
    random.nextBytes(iv);
    GCMParameterSpec params = new GCMParameterSpec(128, iv);
    Cipher cipher = Cipher.getInstance("AES/GCM/PKCS5PADDING");
    cipher.init(Cipher.ENCRYPT_MODE, key, params);
    ```

    ## References
    * Wikipedia: [Initialization vector](https://en.wikipedia.org/wiki/Initialization_vector).
    * National Institute of Standards and Technology: [Recommendation for Block Cipher Modes of Operation](https://nvlpubs.nist.gov/nistpubs/Legacy/SP/nistspecialpublication800-38a.pdf).
    * National Institute of Standards and Technology: [FIPS 140-2: Security Requirements for Cryptographic Modules](https://nvlpubs.nist.gov/nistpubs/FIPS/NIST.FIPS.140-2.pdf).
    * Common Weakness Enumeration: [CWE-329](https://cwe.mitre.org/data/definitions/329.html).
    * Common Weakness Enumeration: [CWE-1204](https://cwe.mitre.org/data/definitions/1204.html).
 -
  pack: codeql/java-queries#0
  relativeQueryPath: Security/CWE/CWE-129/ImproperValidationOfArrayConstruction.ql
  relativeBqrsPath: codeql/java-queries/Security/CWE/CWE-129/ImproperValidationOfArrayConstruction.bqrs
  metadata:
    name: Improper validation of user-provided size used for array construction
    description: Using unvalidated external input as the argument to a construction
      of an array can lead to index out of bound exceptions.
    kind: path-problem
    problem.severity: warning
    security-severity: 8.8
    precision: medium
    id: java/improper-validation-of-array-construction
    tags: |-
      security
             external/cwe/cwe-129
  queryHelp: |
    # Improper validation of user-provided size used for array construction
    Using unvalidated input when specifying the size of a newly created array can result in the creation of an array with size zero. If this array is subsequently accessed without further checks, an `ArrayIndexOutOfBoundsException` may be thrown, because there is no guarantee that the array is not empty.

    This problem occurs when user input is used as the size during array initialization, either directly or following one or more calculations. If the user input is unvalidated, it may cause the size of the array to be zero.


    ## Recommendation
    The size used in the array initialization should be verified to be greater than zero before being used. Alternatively, the array access may be protected by a conditional check that ensures it is only accessed if the index is less than the array size.


    ## Example
    The following program constructs an array with the size specified by some user input:


    ```java
    public class ImproperValidationOfArrayIndex extends HttpServlet {

      protected void doGet(HttpServletRequest request, HttpServletResponse response)
      throws ServletException, IOException {
        try {
          // User provided value
          int numberOfItems = Integer.parseInt(request.getParameter("numberOfItems").trim());

          if (numberOfItems >= 0) {
            /*
             * BAD numberOfItems may be zero, which would cause the array indexing operation to
             * throw an ArrayIndexOutOfBoundsException
             */
            String items = new String[numberOfItems];
            items[0] = "Item 1";
          }

          if (numberOfItems > 0) {
            /*
             * GOOD numberOfItems must be greater than zero, so the indexing succeeds.
             */
            String items = new String[numberOfItems];
            items[0] = "Item 1";
          }

        } catch (NumberFormatException e) { }
      }
    }
    ```
    The first array construction is protected by a condition that checks if the user input is zero or more. However, if the user provides `0` as the `numberOfItems` parameter, then an empty array is created, and any array access would fail with an `ArrayIndexOutOfBoundsException`.

    The second array construction is protected by a condition that checks if the user input is greater than zero. The array will therefore never be empty, and the following array access will not throw an `ArrayIndexOutOfBoundsException`.


    ## References
    * Java API Specification: [ArrayIndexOutOfBoundsException](https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/lang/ArrayIndexOutOfBoundsException.html).
    * Common Weakness Enumeration: [CWE-129](https://cwe.mitre.org/data/definitions/129.html).
 -
  pack: codeql/java-queries#0
  relativeQueryPath: Security/CWE/CWE-129/ImproperValidationOfArrayConstructionCodeSpecified.ql
  relativeBqrsPath: codeql/java-queries/Security/CWE/CWE-129/ImproperValidationOfArrayConstructionCodeSpecified.bqrs
  metadata:
    name: Improper validation of code-specified size used for array construction
    description: |-
      Using a code-specified value that may be zero as the argument to
                    a construction of an array can lead to index out of bound exceptions.
    kind: path-problem
    problem.severity: recommendation
    security-severity: 8.8
    precision: medium
    id: java/improper-validation-of-array-construction-code-specified
    tags: |-
      security
             external/cwe/cwe-129
  queryHelp: |
    # Improper validation of code-specified size used for array construction
    Constructing an array using a size that may be zero can result in the creation of an empty array. If an empty array is accessed without further checks, an `ArrayIndexOutOfBoundsException` is thrown.

    This can happen when a fixed value of zero, or a random value that may be zero, is used as the size directly.


    ## Recommendation
    The size used in the array initialization should be verified to be greater than zero before being used. Alternatively, the array access may be placed within a conditional that ensures it is only accessed if the index is less than the array size.


    ## Example
    The following program constructs an array with the size specified by some random value:


    ```java
    public class PossibleArrayIndexOutOfBounds {

      public static void main(String[] args) {
          int numberOfItems = new Random().nextInt(10);

          if (numberOfItems >= 0) {
            /*
             * BAD numberOfItems may be zero, which would cause the array indexing operation to
             * throw an ArrayIndexOutOfBoundsException
             */
            String items = new String[numberOfItems];
            items[0] = "Item 1";
          }

          if (numberOfItems > 0) {
            /*
             * GOOD numberOfItems must be greater than zero, so the indexing succeeds.
             */
            String items = new String[numberOfItems];
            items[0] = "Item 1";
          }
      }
    }
    ```
    The first array construction is protected by a condition that checks if the random value is zero or more. However, if the random value is `0` then an empty array is created, and any array access would fail with an `ArrayIndexOutOfBoundsException`.

    The second array construction is protected by a condition that checks if the random value is greater than zero. The array will therefore never be empty, and the following array access will not throw an `ArrayIndexOutOfBoundsException`.


    ## References
    * Java API Specification: [ArrayIndexOutOfBoundsException](https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/lang/ArrayIndexOutOfBoundsException.html).
    * Common Weakness Enumeration: [CWE-129](https://cwe.mitre.org/data/definitions/129.html).
 -
  pack: codeql/java-queries#0
  relativeQueryPath: Security/CWE/CWE-129/ImproperValidationOfArrayIndex.ql
  relativeBqrsPath: codeql/java-queries/Security/CWE/CWE-129/ImproperValidationOfArrayIndex.bqrs
  metadata:
    name: Improper validation of user-provided array index
    description: "Using external input as an index to an array, without proper validation,\
      \ can lead to index out of bound exceptions."
    kind: path-problem
    problem.severity: warning
    security-severity: 8.8
    precision: medium
    id: java/improper-validation-of-array-index
    tags: |-
      security
             external/cwe/cwe-129
  queryHelp: |
    # Improper validation of user-provided array index
    Using unvalidated input as part of an index into the array can cause the array access to throw an `ArrayIndexOutOfBoundsException`. This is because there is no guarantee that the index provided is within the bounds of the array.

    This problem occurs when user input is used as an array index, either directly or following one or more calculations. If the user input is unsanitized, it may be any value, which could result in either a negative index, or an index which is larger than the size of the array, either of which would result in an `ArrayIndexOutOfBoundsException`.


    ## Recommendation
    The index used in the array access should be checked against the bounds of the array before being used. The index should be smaller than the array size, and it should not be negative.


    ## Example
    The following program accesses an element from a fixed size constant array:


    ```java
    public class ImproperValidationOfArrayIndex extends HttpServlet {

      protected void doGet(HttpServletRequest request, HttpServletResponse response)
      throws ServletException, IOException {
        String[] productDescriptions = new String[] { "Chocolate bar", "Fizzy drink" };

        // User provided value
        String productID = request.getParameter("productID");
        try {
            int productID = Integer.parseInt(userProperty.trim());

            /*
             * BAD Array is accessed without checking if the user provided value is out of
             * bounds.
             */
            String productDescription = productDescriptions[productID];

            if (productID >= 0 && productID < productDescriptions.length) {
              // GOOD We have checked that the array index is valid first
              productDescription = productDescriptions[productID];
            } else {
              productDescription = "No product for that ID";
            }

            response.getWriter().write(productDescription);

        } catch (NumberFormatException e) { }
      }
    }
    ```
    The first access of the `productDescriptions` array uses the user-provided value as the index without performing any checks. If the user provides a negative value, or a value larger than the size of the array, then an `ArrayIndexOutOfBoundsException` may be thrown.

    The second access of the `productDescriptions` array is contained within a conditional expression that verifies the user-provided value is a valid index into the array. This ensures that the access operation never throws an `ArrayIndexOutOfBoundsException`.


    ## References
    * Java API Specification: [ArrayIndexOutOfBoundsException](https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/lang/ArrayIndexOutOfBoundsException.html).
    * Common Weakness Enumeration: [CWE-129](https://cwe.mitre.org/data/definitions/129.html).
 -
  pack: codeql/java-queries#0
  relativeQueryPath: Security/CWE/CWE-129/ImproperValidationOfArrayIndexCodeSpecified.ql
  relativeBqrsPath: codeql/java-queries/Security/CWE/CWE-129/ImproperValidationOfArrayIndexCodeSpecified.bqrs
  metadata:
    name: Improper validation of code-specified array index
    description: |-
      Using a code-specified value as an index to an array, without
                    proper validation, can lead to index out of bound exceptions.
    kind: path-problem
    problem.severity: recommendation
    security-severity: 8.8
    precision: medium
    id: java/improper-validation-of-array-index-code-specified
    tags: |-
      security
             external/cwe/cwe-129
  queryHelp: |
    # Improper validation of code-specified array index
    Using a hard-coded or randomly provided value as the index to an array access can cause that array access to throw an `ArrayIndexOutOfBoundsException` if the value is outside the bounds of that array.

    This problem occurs when a literal value, or a value generated using the `Random`, is used as an index for an array access operation. If one or more of the range of values produced by the random operation, or the fixed value of the literal, is outside the bounds of the array then this can cause an `ArrayIndexOutOfBoundsException`.


    ## Recommendation
    If the index is a literal value, then the literal value may need to be modified to specify an index that is guaranteed to lie within the bounds of the array. Alternatively, the literal value may represent a default value that was never intended to be used in the array access, in which case the logic should be modified to ensure the default value is never used.

    For indices that flow from randomly generated values, either the random operation should be modified to generate a value that is guaranteed to be within the bounds of the array, or the array access should be protected by suitable conditional checks that verify the index is smaller than the length and larger than or equal to zero.


    ## Example
    The following program searches through an array to find the index at which some search text matches:


    ```java
    public class ImproperValidationOfArrayIndex extends HttpServlet {

      protected void doGet(HttpServletRequest request, HttpServletResponse response)
      throws ServletException, IOException {
        // Search for products in productDescriptions that match the search term
        String searchTerm = request.getParameter("productSearchTerm");
        int foundProductID = -1;
        for (int i = 0; i < productDescriptions.length; i++) {
          if (productDescriptions[i].contains(searchTerm)) {
            // Found matching product
            foundProductID = i;
            break;
          }
        }

        // BAD We may not have found a product in which case the index would be -1
        response.getWriter().write(productDescriptions[foundProductID]);

        if (foundProductID >= 0) {
          // GOOD We have checked we found a product first
          response.getWriter().write(productDescriptions[foundProductID]);
        } else {
          response.getWriter().write("No product found");
        }
      }
    }
    ```
    If the search text is not found, `foundProductID` is set to the default value - specified as `-1`. In the first access, `foundProductID` is used without checking whether the index is `-1`. This code can therefore throw a `ArrayIndexOutOfBoundsException` if the search text is not found.

    In the second case, the array access is protected by a conditional that verifies the index is greater than or equal to zero. This ensures that an `ArrayIndexOutOfBoundsException` cannot be thrown.


    ## References
    * Java API Specification: [ArrayIndexOutOfBoundsException](https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/lang/ArrayIndexOutOfBoundsException.html).
    * Common Weakness Enumeration: [CWE-129](https://cwe.mitre.org/data/definitions/129.html).
 -
  pack: codeql/java-queries#0
  relativeQueryPath: Security/CWE/CWE-134/ExternallyControlledFormatString.ql
  relativeBqrsPath: codeql/java-queries/Security/CWE/CWE-134/ExternallyControlledFormatString.bqrs
  metadata:
    name: Use of externally-controlled format string
    description: Using external input in format strings can lead to exceptions or
      information leaks.
    kind: path-problem
    problem.severity: error
    security-severity: 9.3
    precision: high
    id: java/tainted-format-string
    tags: |-
      security
             external/cwe/cwe-134
  queryHelp: "# Use of externally-controlled format string\nThe `String.format` method\
    \ and related methods, like `PrintStream.printf` and `Formatter.format`, all accept\
    \ a format string that is used to format the trailing arguments to the format\
    \ call by providing inline format specifiers. If the format string contains unsanitized\
    \ input from an untrusted source, then that string may contain extra format specifiers\
    \ that cause an exception to be thrown or information to be leaked.\n\nThe Java\
    \ standard library implementation for the format methods throws an exception if\
    \ either the format specifier does not match the type of the argument, or if there\
    \ are too few or too many arguments. If unsanitized input is used in the format\
    \ string, it may contain invalid extra format specifiers which cause an exception\
    \ to be thrown.\n\nPositional format specifiers may be used to access an argument\
    \ to the format call by position. Unsanitized input in the format string may use\
    \ a positional format specifier to access information that was not intended to\
    \ be visible. For example, when formatting a Calendar instance we may intend to\
    \ print only the year, but a user-specified format string may include a specifier\
    \ to access the month and day.\n\n\n## Recommendation\nIf the argument passed\
    \ as a format string is meant to be a plain string rather than a format string,\
    \ then pass `%s` as the format string, and pass the original argument as the sole\
    \ trailing argument.\n\n\n## Example\nThe following program is meant to check\
    \ a card security code for a stored credit card:\n\n\n```java\npublic class ResponseSplitting\
    \ extends HttpServlet {\n  protected void doGet(HttpServletRequest request, HttpServletResponse\
    \ response)\n  throws ServletException, IOException {\n    Calendar expirationDate\
    \ = new GregorianCalendar(2017, GregorianCalendar.SEPTEMBER, 1);\n    // User\
    \ provided value\n    String cardSecurityCode = request.getParameter(\"cardSecurityCode\"\
    );\n    \n    if (notValid(cardSecurityCode)) {\n      \n      /*\n       * BAD:\
    \ user provided value is included in the format string.\n       * A malicious\
    \ user could provide an extra format specifier, which causes an\n       * exception\
    \ to be thrown. Or they could provide a %1$tm or %1$te format specifier to\n \
    \      * access the month or day of the expiration date.\n       */\n      System.out.format(cardSecurityCode\
    \ +\n                          \" is not the right value. Hint: the card expires\
    \ in %1$ty.\",\n                        expirationDate);\n      \n      // GOOD:\
    \ %s is used to include the user-provided cardSecurityCode in the output\n   \
    \   System.out.format(\"%s is not the right value. Hint: the card expires in %2$ty.\"\
    ,\n                        cardSecurityCode,\n                        expirationDate);\n\
    \    }\n\n  }\n}\n```\nHowever, in the first format call it uses the cardSecurityCode\
    \ provided by the user in a format string. If the user includes a format specifier\
    \ in the cardSecurityCode field, they may be able to cause an exception to be\
    \ thrown, or to be able to access extra information about the stored card expiration\
    \ date.\n\nThe second format call shows the correct approach. The user-provided\
    \ value is passed as an argument to the format call. This prevents any format\
    \ specifiers in the user provided value from being evaluated.\n\n\n## References\n\
    * SEI CERT Oracle Coding Standard for Java: [IDS06-J. Exclude unsanitized user\
    \ input from format strings](https://wiki.sei.cmu.edu/confluence/display/java/IDS06-J.+Exclude+unsanitized+user+input+from+format+strings).\n\
    * The Java Tutorials: [Formatting Numeric Print Output](https://docs.oracle.com/javase/tutorial/java/data/numberformat.html).\n\
    * Java API Specification: [Formatter](https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/util/Formatter.html).\n\
    * Common Weakness Enumeration: [CWE-134](https://cwe.mitre.org/data/definitions/134.html).\n"
 -
  pack: codeql/java-queries#0
  relativeQueryPath: Security/CWE/CWE-190/ArithmeticTainted.ql
  relativeBqrsPath: codeql/java-queries/Security/CWE/CWE-190/ArithmeticTainted.bqrs
  metadata:
    name: User-controlled data in arithmetic expression
    description: |-
      Arithmetic operations on user-controlled data that is not validated can cause
                    overflows.
    kind: path-problem
    problem.severity: warning
    security-severity: 8.6
    precision: medium
    id: java/tainted-arithmetic
    tags: |-
      security
             external/cwe/cwe-190
             external/cwe/cwe-191
  queryHelp: "# User-controlled data in arithmetic expression\nPerforming calculations\
    \ on user-controlled data can result in integer overflows unless the input is\
    \ validated.\n\nIf the user is free to enter very large numbers, even arithmetic\
    \ operations that would usually result in a small change in magnitude may result\
    \ in overflows.\n\n\n## Recommendation\nAlways guard against overflow in arithmetic\
    \ operations on user-controlled data by doing one of the following:\n\n* Validate\
    \ the user input.\n* Define a guard on the arithmetic expression, so that the\
    \ operation is performed only if the result can be known to be less than, or equal\
    \ to, the maximum value for the type, for example `MAX_VALUE`.\n* Use a wider\
    \ type, so that larger input values do not cause overflow.\n\n## Example\nIn this\
    \ example, a value is read from standard input into an `int`. Because the value\
    \ is a user-controlled value, it could be extremely large. Performing arithmetic\
    \ operations on this value could therefore cause an overflow. To avoid this happening,\
    \ the example shows how to perform a check before performing a multiplication.\n\
    \n\n```java\nclass Test {\n\tpublic static void main(String[] args) {\n\t\t{\n\
    \t\t\tint data;\n\n\t\t\tBufferedReader readerBuffered = new BufferedReader(\n\
    \t\t\t\t\tnew InputStreamReader(System.in, \"UTF-8\"));\n\t\t\tString stringNumber\
    \ = readerBuffered.readLine();\n\t\t\tif (stringNumber != null) {\n\t\t\t\tdata\
    \ = Integer.parseInt(stringNumber.trim());\n\t\t\t} else {\n\t\t\t\tdata = 0;\n\
    \t\t\t}\n\n\t\t\t// BAD: may overflow if input data is very large, for example\n\
    \t\t\t// 'Integer.MAX_VALUE'\n\t\t\tint scaled = data * 10;\n\n\t\t\t//...\n\t\
    \t\t\n\t\t\t// GOOD: use a guard to ensure no overflows occur\n\t\t\tint scaled2;\n\
    \t\t\tif (data < Integer.MAX_VALUE / 10)\n\t\t\t\tscaled2 = data * 10;\n\t\t\t\
    else\n\t\t\t\tscaled2 = Integer.MAX_VALUE;\n\t\t}\n\t}\n}\n```\n\n## References\n\
    * SEI CERT Oracle Coding Standard for Java: [NUM00-J. Detect or prevent integer\
    \ overflow](https://wiki.sei.cmu.edu/confluence/display/java/NUM00-J.+Detect+or+prevent+integer+overflow).\n\
    * Common Weakness Enumeration: [CWE-190](https://cwe.mitre.org/data/definitions/190.html).\n\
    * Common Weakness Enumeration: [CWE-191](https://cwe.mitre.org/data/definitions/191.html).\n"
 -
  pack: codeql/java-queries#0
  relativeQueryPath: Security/CWE/CWE-190/ArithmeticUncontrolled.ql
  relativeBqrsPath: codeql/java-queries/Security/CWE/CWE-190/ArithmeticUncontrolled.bqrs
  metadata:
    name: Uncontrolled data in arithmetic expression
    description: |-
      Arithmetic operations on uncontrolled data that is not validated can cause
                    overflows.
    kind: path-problem
    problem.severity: warning
    security-severity: 8.6
    precision: medium
    id: java/uncontrolled-arithmetic
    tags: |-
      security
             external/cwe/cwe-190
             external/cwe/cwe-191
  queryHelp: "# Uncontrolled data in arithmetic expression\nPerforming calculations\
    \ on uncontrolled data can result in integer overflows unless the input is validated.\n\
    \nIf the data is not under your control, and can take extremely large values,\
    \ even arithmetic operations that would usually result in a small change in magnitude\
    \ may result in overflows.\n\n\n## Recommendation\nAlways guard against overflow\
    \ in arithmetic operations on uncontrolled data by doing one of the following:\n\
    \n* Validate the data.\n* Define a guard on the arithmetic expression, so that\
    \ the operation is performed only if the result can be known to be less than,\
    \ or equal to, the maximum value for the type, for example `MAX_VALUE`.\n* Use\
    \ a wider type, so that larger input values do not cause overflow.\n\n## Example\n\
    In this example, a random integer is generated. Because the value is not controlled\
    \ by the programmer, it could be extremely large. Performing arithmetic operations\
    \ on this value could therefore cause an overflow. To avoid this happening, the\
    \ example shows how to perform a check before performing a multiplication.\n\n\
    \n```java\nclass Test {\n\tpublic static void main(String[] args) {\n\t\t{\n\t\
    \t\tint data = (new java.security.SecureRandom()).nextInt();\n\n\t\t\t// BAD:\
    \ may overflow if data is large\n\t\t\tint scaled = data * 10;\n\n\t\t\t// ...\n\
    \n\t\t\t// GOOD: use a guard to ensure no overflows occur\n\t\t\tint scaled2;\n\
    \t\t\tif (data < Integer.MAX_VALUE/10)\n\t\t\t\tscaled2 = data * 10;\n\t\t\telse\
    \ \n\t\t\t\tscaled2 = Integer.MAX_VALUE;\n\t\t}\n\t}\n}\n```\n\n## References\n\
    * SEI CERT Oracle Coding Standard for Java: [NUM00-J. Detect or prevent integer\
    \ overflow](https://wiki.sei.cmu.edu/confluence/display/java/NUM00-J.+Detect+or+prevent+integer+overflow).\n\
    * Common Weakness Enumeration: [CWE-190](https://cwe.mitre.org/data/definitions/190.html).\n\
    * Common Weakness Enumeration: [CWE-191](https://cwe.mitre.org/data/definitions/191.html).\n"
 -
  pack: codeql/java-queries#0
  relativeQueryPath: Security/CWE/CWE-190/ArithmeticWithExtremeValues.ql
  relativeBqrsPath: codeql/java-queries/Security/CWE/CWE-190/ArithmeticWithExtremeValues.bqrs
  metadata:
    name: Use of extreme values in arithmetic expression
    description: |-
      If a variable is assigned the maximum or minimum value for that variable's type and
                    is then used in an arithmetic expression, this may result in an overflow.
    kind: path-problem
    problem.severity: recommendation
    security-severity: 8.6
    precision: medium
    id: java/extreme-value-arithmetic
    tags: |-
      security
             reliability
             external/cwe/cwe-190
             external/cwe/cwe-191
  queryHelp: "# Use of extreme values in arithmetic expression\nAssigning the maximum\
    \ or minimum value for a type to a variable of that type and then using the variable\
    \ in calculations may cause overflows.\n\n\n## Recommendation\nBefore using the\
    \ variable, ensure that it is reassigned a value that does not cause an overflow,\
    \ or use a wider type to do the arithmetic.\n\n\n## Example\nIn this example,\
    \ assigning `Long.MAX_VALUE` to a variable and adding one causes an overflow.\
    \ However, casting to a `long` beforehand ensures that the arithmetic is done\
    \ in the wider type, and so does not overflow.\n\n\n```java\nclass Test {\n\t\
    public static void main(String[] args) {\t\n\t\t{\n\t\t\tlong i = Long.MAX_VALUE;\n\
    \t\t\t// BAD: overflow\n\t\t\tlong j = i + 1;\n\t\t}\n\t\t\n\t\t{\n\t\t\tint i\
    \ = Integer.MAX_VALUE;\n\t\t\t// GOOD: no overflow\n\t\t\tlong j = (long)i + 1;\n\
    \t\t}\n\t}\n}\n```\n\n## References\n* SEI CERT Oracle Coding Standard for Java:\
    \ [NUM00-J. Detect or prevent integer overflow](https://wiki.sei.cmu.edu/confluence/display/java/NUM00-J.+Detect+or+prevent+integer+overflow).\n\
    * Common Weakness Enumeration: [CWE-190](https://cwe.mitre.org/data/definitions/190.html).\n\
    * Common Weakness Enumeration: [CWE-191](https://cwe.mitre.org/data/definitions/191.html).\n"
 -
  pack: codeql/java-queries#0
  relativeQueryPath: Security/CWE/CWE-190/ComparisonWithWiderType.ql
  relativeBqrsPath: codeql/java-queries/Security/CWE/CWE-190/ComparisonWithWiderType.bqrs
  metadata:
    name: Comparison of narrow type with wide type in loop condition
    description: |-
      Comparisons between types of different widths in a loop condition can cause the loop
                    to behave unexpectedly.
    kind: problem
    problem.severity: warning
    security-severity: 8.1
    precision: medium
    id: java/comparison-with-wider-type
    tags: |-
      reliability
             security
             external/cwe/cwe-190
             external/cwe/cwe-197
  queryHelp: "# Comparison of narrow type with wide type in loop condition\nIn a loop\
    \ condition, comparison of a value of a narrow type with a value of a wide type\
    \ may always evaluate to `true` if the wider value is sufficiently large (or small).\
    \ This is because the narrower value may overflow. This can lead to an infinite\
    \ loop.\n\n\n## Recommendation\nChange the types of the compared values so that\
    \ the value on the narrower side of the comparison is at least as wide as the\
    \ value it is being compared with.\n\n\n## Example\nIn this example, `bytesReceived`\
    \ is compared against `MAXGET` in a `while` loop. However, `bytesReceived` is\
    \ a `short`, and `MAXGET` is a `long`. Because `MAXGET` is larger than `Short.MAX_VALUE`,\
    \ the loop condition is always `true`, so the loop never terminates.\n\nThis problem\
    \ is avoided in the 'GOOD' case because `bytesReceived2` is a `long`, which is\
    \ as wide as the type of `MAXGET`.\n\n\n```java\nclass Test {\n\tpublic static\
    \ void main(String[] args) {\n\t\t\n\t\t{\t\t\n\t\t\tint BIGNUM = Integer.MAX_VALUE;\n\
    \t\t\tlong MAXGET = Short.MAX_VALUE + 1;\n\t\t\t\n\t\t\tchar[] buf = new char[BIGNUM];\n\
    \n\t\t\tshort bytesReceived = 0;\n\t\t\t\n\t\t\t// BAD: 'bytesReceived' is compared\
    \ with a value of wider type.\n\t\t\t// 'bytesReceived' overflows before reaching\
    \ MAXGET,\n\t\t\t// causing an infinite loop.\n\t\t\twhile (bytesReceived < MAXGET)\
    \ {\n\t\t\t\tbytesReceived += getFromInput(buf, bytesReceived);\n\t\t\t}\n\t\t\
    }\n\t\t\n\t\t{\n\t\t\tlong bytesReceived2 = 0;\n\t\t\t\n\t\t\t// GOOD: 'bytesReceived2'\
    \ has a type at least as wide as MAXGET.\n\t\t\twhile (bytesReceived2 < MAXGET)\
    \ {\n\t\t\t\tbytesReceived2 += getFromInput(buf, bytesReceived2);\n\t\t\t}\n\t\
    \t}\n\t\t\n\t}\n\t\n\tpublic static int getFromInput(char[] buf, short pos) {\n\
    \t\t// write to buf\n\t\t// ...\n\t\treturn 1;\n\t}\n}\n```\n\n## References\n\
    * SEI CERT Oracle Coding Standard for Java: [NUM00-J. Detect or prevent integer\
    \ overflow](https://wiki.sei.cmu.edu/confluence/display/java/NUM00-J.+Detect+or+prevent+integer+overflow).\n\
    * Common Weakness Enumeration: [CWE-190](https://cwe.mitre.org/data/definitions/190.html).\n\
    * Common Weakness Enumeration: [CWE-197](https://cwe.mitre.org/data/definitions/197.html).\n"
 -
  pack: codeql/java-queries#0
  relativeQueryPath: Security/CWE/CWE-200/AndroidSensitiveNotifications.ql
  relativeBqrsPath: codeql/java-queries/Security/CWE/CWE-200/AndroidSensitiveNotifications.bqrs
  metadata:
    name: Exposure of sensitive information to notifications
    id: java/android/sensitive-notification
    kind: path-problem
    description: Sensitive information exposed in a system notification can be read
      by an unauthorized application.
    problem.severity: error
    precision: medium
    security-severity: 6.5
    tags: |-
      security
             external/cwe/cwe-200
  queryHelp: |
    # Exposure of sensitive information to notifications
    Sensitive information such as passwords or two-factor authentication (2FA) codes should not be exposed in a system notification. Notifications should not be considered secure, as other untrusted applications may be able to use a `NotificationListenerService` to read the contents of notifications.


    ## Recommendation
    Do not expose sensitive data in notifications.


    ## Example
    In the following sample, the `password` is sent as part of a notification. This can allow another application to read this password.


    ```java
    // BAD: `password` is exposed in a notification.
    void confirmPassword(String password) {
        NotificationManager manager = NotificationManager.from(this);
        manager.send(
            new Notification.Builder(this, CHANNEL_ID)
            .setContentText("Your password is: " + password)
            .build());
    }
    ```

    ## References
    * OWASP Mobile Application Security: [Android Data Storage - Application Notifications](https://mas.owasp.org/MASTG/Android/0x05d-Testing-Data-Storage/#app-notifications)
    * Common Weakness Enumeration: [CWE-200](https://cwe.mitre.org/data/definitions/200.html).
 -
  pack: codeql/java-queries#0
  relativeQueryPath: Security/CWE/CWE-200/AndroidSensitiveTextField.ql
  relativeBqrsPath: codeql/java-queries/Security/CWE/CWE-200/AndroidSensitiveTextField.bqrs
  metadata:
    name: Exposure of sensitive information to UI text views
    id: java/android/sensitive-text
    kind: path-problem
    description: Sensitive information displayed in UI text views should be properly
      masked.
    problem.severity: warning
    precision: medium
    security-severity: 6.5
    tags: |-
      security
             external/cwe/cwe-200
  queryHelp: |
    # Exposure of sensitive information to UI text views
    Sensitive information such as passwords should not be displayed in UI components unless explicitly required, to mitigate shoulder-surfing attacks.


    ## Recommendation
    For editable text fields containing sensitive information, the `inputType` should be set to `textPassword` or similar to ensure it is properly masked. Otherwise, sensitive data that must be displayed should be hidden by default, and only revealed based on an explicit user action.


    ## Example
    In the following (bad) case, sensitive information in `password` is exposed to the `TextView`.


    ```java
    TextView pwView = getViewById(R.id.pw_text);
    pwView.setText("Your password is: " + password);
    ```
    In the following (good) case, the user must press a button to reveal sensitive information.


    ```java
    TextView pwView = findViewById(R.id.pw_text);
    pwView.setVisibility(View.INVISIBLE);
    pwView.setText("Your password is: " + password);

    Button showButton = findViewById(R.id.show_pw_button);
    showButton.setOnClickListener(new View.OnClickListener() {
        public void onClick(View v) {
          pwView.setVisibility(View.VISIBLE);
        }
    });

    ```

    ## References
    * OWASP Mobile Application Security: [Android Data Storage - UI Components](https://mas.owasp.org/MASTG/Android/0x05d-Testing-Data-Storage/#ui-components)
    * Common Weakness Enumeration: [CWE-200](https://cwe.mitre.org/data/definitions/200.html).
 -
  pack: codeql/java-queries#0
  relativeQueryPath: Security/CWE/CWE-200/AndroidWebViewSettingsAllowsContentAccess.ql
  relativeBqrsPath: codeql/java-queries/Security/CWE/CWE-200/AndroidWebViewSettingsAllowsContentAccess.bqrs
  metadata:
    name: Android WebView settings allows access to content links
    id: java/android/websettings-allow-content-access
    description: Access to content providers in a WebView can allow access to protected
      information by loading content:// links.
    kind: problem
    problem.severity: warning
    precision: medium
    security-severity: 6.5
    tags: |-
      security
            external/cwe/cwe-200
  queryHelp: |
    # Android WebView settings allows access to content links
    Android can provide access to content providers within a WebView using the `setAllowContentAccess` setting.

    Allowing access to content providers via `content://` URLs may allow JavaScript to access protected content.


    ## Recommendation
    If your app does not require access to the `content://` URL functionality, you should explicitly disable the setting by calling `setAllowContentAccess(false)` on the settings of the WebView.


    ## Example
    In the following (bad) example, access to `content://` URLs is explicitly allowed.


    ```java
    WebSettings settings = webview.getSettings();

    settings.setAllowContentAccess(true);

    ```
    In the following (good) example, access to `content://` URLs is explicitly denied.


    ```java
    WebSettings settings = webview.getSettings();

    settings.setAllowContentAccess(false);

    ```

    ## References
    * Android Documentation: [setAllowContentAccess](https://developer.android.com/reference/android/webkit/WebSettings#setAllowContentAccess(boolean)).
    * Common Weakness Enumeration: [CWE-200](https://cwe.mitre.org/data/definitions/200.html).
 -
  pack: codeql/java-queries#0
  relativeQueryPath: Security/CWE/CWE-200/AndroidWebViewSettingsFileAccess.ql
  relativeBqrsPath: codeql/java-queries/Security/CWE/CWE-200/AndroidWebViewSettingsFileAccess.bqrs
  metadata:
    name: Android WebSettings file access
    kind: problem
    description: Enabling access to the file system in a WebView allows attackers
      to view sensitive information.
    id: java/android/websettings-file-access
    problem.severity: warning
    security-severity: 6.5
    precision: medium
    tags: |-
      security
             external/cwe/cwe-200
  queryHelp: |
    # Android WebSettings file access
    Allowing file access in an Android WebView can expose a device's file system to the JavaScript running in that WebView. If the JavaScript contains vulnerabilities or the WebView loads untrusted content, file access allows an attacker to steal the user's data.


    ## Recommendation
    When possible, do not allow file access. The file access settings are disabled by default. You can explicitly disable file access by setting the following settings to `false`:

    * `setAllowFileAccess`
    * `setAllowFileAccessFromFileURLs`
    * `setAllowUniversalAccessFromFileURLs`
    If your application requires access to the file system, it is best to avoid using `file://` URLs. Instead, use an alternative that loads files via HTTPS, such as `androidx.webkit.WebViewAssetLoader`.


    ## Example
    In the following (bad) example, the WebView is configured with settings that allow local file access.


    ```java
    WebSettings settings = view.getSettings();

    settings.setAllowFileAccess(true);
    settings.setAllowFileAccessFromURLs(true);
    settings.setAllowUniversalAccessFromURLs(true);

    ```
    In the following (good) example, the WebView is configured to disallow file access.


    ```java
    WebSettings settings = view.getSettings();

    settings.setAllowFileAccess(false);
    settings.setAllowFileAccessFromURLs(false);
    settings.setAllowUniversalAccessFromURLs(false);

    ```
    As mentioned previously, asset loaders can load files without file system access. In the following (good) example, an asset loader is configured to load assets over HTTPS.


    ```java
    WebViewAssetLoader loader = new WebViewAssetLoader.Builder()
        // Replace the domain with a domain you control, or use the default
        // appassets.androidplatform.com
        .setDomain("appassets.example.com")
        .addPathHandler("/resources", new AssetsPathHandler(this))
        .build();

    webView.setWebViewClient(new WebViewClientCompat() {
        @Override
        public WebResourceResponse shouldInterceptRequest(WebView view, WebResourceRequest request) {
            return assetLoader.shouldInterceptRequest(request.getUrl());
        }
    });

    webView.loadUrl("https://appassets.example.com/resources/www/index.html");

    ```

    ## References
    * Android documentation: [WebSettings.setAllowFileAccess](https://developer.android.com/reference/android/webkit/WebSettings#setAllowFileAccess(boolean)).
    * Android documentation: [WebSettings.setAllowFileAccessFromFileURLs](https://developer.android.com/reference/android/webkit/WebSettings#setAllowFileAccessFromFileURLs(boolean)).
    * Android documentation: [WebSettings.setAllowUniversalAccessFromFileURLs](https://developer.android.com/reference/android/webkit/WebSettings#setAllowUniversalAccessFromFileURLs(boolean)).
    * Android documentation: [WebViewAssetLoader](https://developer.android.com/reference/androidx/webkit/WebViewAssetLoader).
    * Common Weakness Enumeration: [CWE-200](https://cwe.mitre.org/data/definitions/200.html).
 -
  pack: codeql/java-queries#0
  relativeQueryPath: Security/CWE/CWE-200/TempDirLocalInformationDisclosure.ql
  relativeBqrsPath: codeql/java-queries/Security/CWE/CWE-200/TempDirLocalInformationDisclosure.bqrs
  metadata:
    name: Local information disclosure in a temporary directory
    description: Writing information without explicit permissions to a shared temporary
      directory may disclose it to other users.
    kind: path-problem
    problem.severity: warning
    security-severity: 6.5
    precision: medium
    id: java/local-temp-file-or-directory-information-disclosure
    tags: |-
      security
             external/cwe/cwe-200
             external/cwe/cwe-732
  queryHelp: |
    # Local information disclosure in a temporary directory
    Local information disclosure can occur when files/directories are written into directories that are shared between all users on the system.

    On most [unix-like](https://en.wikipedia.org/wiki/Unix-like) systems, the system temporary directory is shared between local users. If files/directories are created within the system temporary directory without using APIs that explicitly set the correct file permissions, local information disclosure can occur.

    Depending upon the particular file contents exposed, this vulnerability can have a [CVSSv3.1 base score of 6.2/10](https://nvd.nist.gov/vuln-metrics/cvss/v3-calculator?vector=AV:L/AC:L/PR:N/UI:N/S:U/C:H/I:N/A:N&version=3.1).


    ## Recommendation
    Use JDK methods that specifically protect against this vulnerability:

    * [java.nio.file.Files.createTempDirectory](https://docs.oracle.com/javase/8/docs/api/java/nio/file/Files.html#createTempDirectory-java.nio.file.Path-java.lang.String-java.nio.file.attribute.FileAttribute...-)
    * [java.nio.file.Files.createTempFile](https://docs.oracle.com/javase/8/docs/api/java/nio/file/Files.html#createTempFile-java.nio.file.Path-java.lang.String-java.lang.String-java.nio.file.attribute.FileAttribute...-)
    Otherwise, create the file/directory by manually specifying the expected posix file permissions. For example: `PosixFilePermissions.asFileAttribute(EnumSet.of(PosixFilePermission.OWNER_READ, PosixFilePermission.OWNER_WRITE))`

    * [java.nio.file.Files.createFile](https://docs.oracle.com/javase/8/docs/api/java/nio/file/Files.html#createFile-java.nio.file.Path-java.nio.file.attribute.FileAttribute...-)
    * [java.nio.file.Files.createDirectory](https://docs.oracle.com/javase/8/docs/api/java/nio/file/Files.html#createDirectory-java.nio.file.Path-java.nio.file.attribute.FileAttribute...-)
    * [java.nio.file.Files.createDirectories](https://docs.oracle.com/javase/8/docs/api/java/nio/file/Files.html#createDirectories-java.nio.file.Path-java.nio.file.attribute.FileAttribute...-)

    ## Example
    In the following example, files and directories are created with file permissions that allow other local users to read their contents.


    ```java
    import java.io.File;

    public class TempDirUsageVulnerable {
        void exampleVulnerable() {
            File temp1 = File.createTempFile("random", ".txt"); // BAD: File has permissions `-rw-r--r--`

            File temp2 = File.createTempFile("random", "file", null); // BAD: File has permissions `-rw-r--r--`

            File systemTempDir = new File(System.getProperty("java.io.tmpdir"));
            File temp3 = File.createTempFile("random", "file", systemTempDir); // BAD: File has permissions `-rw-r--r--`

            File tempDir = com.google.common.io.Files.createTempDir(); // BAD: CVE-2020-8908: Directory has permissions `drwxr-xr-x`

            new File(System.getProperty("java.io.tmpdir"), "/child").mkdir(); // BAD: Directory has permissions `-rw-r--r--`

            File tempDirChildFile = new File(System.getProperty("java.io.tmpdir"), "/child-create-file.txt");
            Files.createFile(tempDirChildFile.toPath()); // BAD: File has permissions `-rw-r--r--`

            File tempDirChildDir = new File(System.getProperty("java.io.tmpdir"), "/child-dir");
            tempDirChildDir.mkdir(); // BAD: Directory has permissions `drwxr-xr-x`
            Files.createDirectory(tempDirChildDir.toPath()); // BAD: Directory has permissions `drwxr-xr-x`
        }
    }

    ```
    In the following example, files and directories are created with file permissions that protect their contents.


    ```java
    import java.io.File;
    import java.io.IOException;
    import java.io.UncheckedIOException;
    import java.nio.file.Files;
    import java.nio.file.Path;
    import java.nio.file.attribute.PosixFilePermission;
    import java.nio.file.attribute.PosixFilePermissions;

    import java.util.EnumSet;


    public class TempDirUsageSafe {
        void exampleSafe() throws IOException {
            Path temp1 = Files.createTempFile("random", ".txt"); // GOOD: File has permissions `-rw-------`

            Path temp2 = Files.createTempDirectory("random-directory"); // GOOD: File has permissions `drwx------`

            // Creating a temporary file with a non-randomly generated name
            File tempChildFile = new File(System.getProperty("java.io.tmpdir"), "/child-create-file.txt");
            // Warning: This will fail on windows as it doesn't support PosixFilePermissions.
            // See `exampleSafeWithWindowsSupportFile` if your code needs to support windows and unix-like systems.
            Files.createFile(
                tempChildFile.toPath(),
                PosixFilePermissions.asFileAttribute(EnumSet.of(PosixFilePermission.OWNER_READ, PosixFilePermission.OWNER_WRITE))
            ); // GOOD: Good has permissions `-rw-------`
        }

        /*
         * An example of a safe use of createFile or createDirectory if your code must support windows and unix-like systems.
         */
        void exampleSafeWithWindowsSupportFile() {
            // Creating a temporary file with a non-randomly generated name
            File tempChildFile = new File(System.getProperty("java.io.tmpdir"), "/child-create-file.txt");
            createTempFile(tempChildFile.toPath()); // GOOD: Good has permissions `-rw-------`
        }

        static void createTempFile(Path tempDirChild) {
            try {
                if (tempDirChild.getFileSystem().supportedFileAttributeViews().contains("posix")) {
                    // Explicit permissions setting is only required on unix-like systems because
                    // the temporary directory is shared between all users.
                    // This is not necessary on Windows, each user has their own temp directory
                    final EnumSet<PosixFilePermission> posixFilePermissions =
                            EnumSet.of(
                                PosixFilePermission.OWNER_READ,
                                PosixFilePermission.OWNER_WRITE
                            );
                    if (!Files.exists(tempDirChild)) {
                        Files.createFile(
                            tempDirChild,
                            PosixFilePermissions.asFileAttribute(posixFilePermissions)
                        ); // GOOD: Directory has permissions `-rw-------`
                    } else {
                        Files.setPosixFilePermissions(
                                tempDirChild,
                                posixFilePermissions
                        ); // GOOD: Good has permissions `-rw-------`, or will throw an exception if this fails
                    }
                } else if (!Files.exists(tempDirChild)) {
                    // On Windows, we still need to create the directory, when it doesn't already exist.
                    Files.createDirectory(tempDirChild); // GOOD: Windows doesn't share the temp directory between users
                }
            } catch (IOException exception) {
                throw new UncheckedIOException("Failed to create temp file", exception);
            }
        }

        void exampleSafeWithWindowsSupportDirectory() {
            File tempDirChildDir = new File(System.getProperty("java.io.tmpdir"), "/child-dir");
            createTempDirectories(tempDirChildDir.toPath()); // GOOD: Directory has permissions `drwx------`
        }

        static void createTempDirectories(Path tempDirChild) {
            try {
                if (tempDirChild.getFileSystem().supportedFileAttributeViews().contains("posix")) {
                    // Explicit permissions setting is only required on unix-like systems because
                    // the temporary directory is shared between all users.
                    // This is not necessary on Windows, each user has their own temp directory
                    final EnumSet<PosixFilePermission> posixFilePermissions =
                            EnumSet.of(
                                PosixFilePermission.OWNER_READ,
                                PosixFilePermission.OWNER_WRITE,
                                PosixFilePermission.OWNER_EXECUTE
                            );
                    if (!Files.exists(tempDirChild)) {
                        Files.createDirectories(
                            tempDirChild,
                            PosixFilePermissions.asFileAttribute(posixFilePermissions)
                        ); // GOOD: Directory has permissions `drwx------`
                    } else {
                        Files.setPosixFilePermissions(
                                tempDirChild,
                                posixFilePermissions
                        ); // GOOD: Good has permissions `drwx------`, or will throw an exception if this fails
                    }
                } else if (!Files.exists(tempDirChild)) {
                    // On Windows, we still need to create the directory, when it doesn't already exist.
                    Files.createDirectories(tempDirChild); // GOOD: Windows doesn't share the temp directory between users
                }
            } catch (IOException exception) {
                throw new UncheckedIOException("Failed to create temp dir", exception);
            }
        }
    }

    ```

    ## References
    * OWASP: [Insecure Temporary File](https://owasp.org/www-community/vulnerabilities/Insecure_Temporary_File).
    * CERT: [FIO00-J. Do not operate on files in shared directories](https://wiki.sei.cmu.edu/confluence/display/java/FIO00-J.+Do+not+operate+on+files+in+shared+directories).
    * Common Weakness Enumeration: [CWE-200](https://cwe.mitre.org/data/definitions/200.html).
    * Common Weakness Enumeration: [CWE-732](https://cwe.mitre.org/data/definitions/732.html).
 -
  pack: codeql/java-queries#0
  relativeQueryPath: Security/CWE/CWE-209/SensitiveDataExposureThroughErrorMessage.ql
  relativeBqrsPath: codeql/java-queries/Security/CWE/CWE-209/SensitiveDataExposureThroughErrorMessage.bqrs
  metadata:
    name: Information exposure through an error message
    description: |-
      Information from an error message propagates to an external user.
                    Error messages can unintentionally reveal implementation details
                    that are useful to an attacker for developing a subsequent exploit.
    kind: problem
    problem.severity: error
    security-severity: 5.4
    precision: high
    id: java/error-message-exposure
    tags: |-
      security
             external/cwe/cwe-209
  queryHelp: "# Information exposure through an error message\nThe error message at\
    \ the top of a stack trace can include information such as server-side file names\
    \ and SQL code that the application relies on, allowing an attacker to fine-tune\
    \ a subsequent injection attack.\n\n\n## Recommendation\nSend the user a more\
    \ generic error message that reveals less information. Either suppress the error\
    \ message entirely, or log it only on the server.\n\n\n## Example\nIn the following\
    \ example, an exception is handled in two different ways. In the first version,\
    \ labeled BAD, the exception is sent back to the remote user using the `getMessage()`\
    \ method. As such, the user is able to see a detailed error message, which may\
    \ contain sensitive information. In the second version, the error message is logged\
    \ only on the server. That way, the developers can still access and use the error\
    \ log, but remote users will not see the information.\n\n\n```java\nprotected\
    \ void doGet(HttpServletRequest request, HttpServletResponse response) {\n\ttry\
    \ {\n\t\tdoSomeWork();\n\t} catch (NullPointerException ex) {\n\t\t// BAD: printing\
    \ a exception message back to the response\n\t\tresponse.sendError(\n\t\t\tHttpServletResponse.SC_INTERNAL_SERVER_ERROR,\n\
    \t\t\tex.getMessage());\n\t\treturn;\n\t}\n\n\ttry {\n\t\tdoSomeWork();\n\t} catch\
    \ (NullPointerException ex) {\n\t\t// GOOD: log the exception message, and send\
    \ back a non-revealing response\n\t\tlog(\"Exception occurred\", ex.getMessage);\n\
    \t\tresponse.sendError(\n\t\t\tHttpServletResponse.SC_INTERNAL_SERVER_ERROR,\n\
    \t\t\t\"Exception occurred\");\n\t\treturn;\n\t}\n}\n\n```\n\n## References\n\
    * OWASP: [Improper Error Handling](https://owasp.org/www-community/Improper_Error_Handling).\n\
    * CERT Java Coding Standard: [ERR01-J. Do not allow exceptions to expose sensitive\
    \ information](https://www.securecoding.cert.org/confluence/display/java/ERR01-J.+Do+not+allow+exceptions+to+expose+sensitive+information).\n\
    * Common Weakness Enumeration: [CWE-209](https://cwe.mitre.org/data/definitions/209.html).\n"
 -
  pack: codeql/java-queries#0
  relativeQueryPath: Security/CWE/CWE-209/StackTraceExposure.ql
  relativeBqrsPath: codeql/java-queries/Security/CWE/CWE-209/StackTraceExposure.bqrs
  metadata:
    name: Information exposure through a stack trace
    description: |-
      Information from a stack trace propagates to an external user.
                    Stack traces can unintentionally reveal implementation details
                    that are useful to an attacker for developing a subsequent exploit.
    kind: problem
    problem.severity: error
    security-severity: 5.4
    precision: high
    id: java/stack-trace-exposure
    tags: |-
      security
             external/cwe/cwe-209
             external/cwe/cwe-497
  queryHelp: "# Information exposure through a stack trace\nSoftware developers often\
    \ add stack traces to error messages, as a debugging aid. Whenever that error\
    \ message occurs for an end user, the developer can use the stack trace to help\
    \ identify how to fix the problem. In particular, stack traces can tell the developer\
    \ more about the sequence of events that led to a failure, as opposed to merely\
    \ the final state of the software when the error occurred.\n\nUnfortunately, the\
    \ same information can be useful to an attacker. The sequence of class names in\
    \ a stack trace can reveal the structure of the application as well as any internal\
    \ components it relies on.\n\n\n## Recommendation\nSend the user a more generic\
    \ error message that reveals less information. Either suppress the stack trace\
    \ entirely, or log it only on the server.\n\n\n## Example\nIn the following example,\
    \ an exception is handled in two different ways. In the first version, labeled\
    \ BAD, the exception is sent back to the remote user using the `sendError()` method.\
    \ As such, the user is able to see a detailed stack trace, which may contain sensitive\
    \ information. In the second version, the error message is logged only on the\
    \ server. That way, the developers can still access and use the error log, but\
    \ remote users will not see the information.\n\n\n```java\nprotected void doGet(HttpServletRequest\
    \ request, HttpServletResponse response) {\n\ttry {\n\t\tdoSomeWork();\n\t} catch\
    \ (NullPointerException ex) {\n\t\t// BAD: printing a stack trace back to the\
    \ response\n\t\tex.printStackTrace(response.getWriter());\n\t\treturn;\n\t}\n\n\
    \ttry {\n\t\tdoSomeWork();\n\t} catch (NullPointerException ex) {\n\t\t// GOOD:\
    \ log the stack trace, and send back a non-revealing response\n\t\tlog(\"Exception\
    \ occurred\", ex);\n\t\tresponse.sendError(\n\t\t\tHttpServletResponse.SC_INTERNAL_SERVER_ERROR,\n\
    \t\t\t\"Exception occurred\");\n\t\treturn;\n\t}\n}\n\n```\n\n## References\n\
    * OWASP: [Improper Error Handling](https://owasp.org/www-community/Improper_Error_Handling).\n\
    * CERT Java Coding Standard: [ERR01-J. Do not allow exceptions to expose sensitive\
    \ information](https://www.securecoding.cert.org/confluence/display/java/ERR01-J.+Do+not+allow+exceptions+to+expose+sensitive+information).\n\
    * Common Weakness Enumeration: [CWE-209](https://cwe.mitre.org/data/definitions/209.html).\n\
    * Common Weakness Enumeration: [CWE-497](https://cwe.mitre.org/data/definitions/497.html).\n"
 -
  pack: codeql/java-queries#0
  relativeQueryPath: Security/CWE/CWE-266/IntentUriPermissionManipulation.ql
  relativeBqrsPath: codeql/java-queries/Security/CWE/CWE-266/IntentUriPermissionManipulation.bqrs
  metadata:
    name: Intent URI permission manipulation
    description: |-
      Returning an externally provided Intent via 'setResult' may allow a malicious
                    application to access arbitrary content providers of the vulnerable application.
    kind: path-problem
    problem.severity: error
    security-severity: 7.8
    precision: high
    id: java/android/intent-uri-permission-manipulation
    tags: |-
      security
             external/cwe/cwe-266
             external/cwe/cwe-926
  queryHelp: |
    # Intent URI permission manipulation
    When an Android component expects a result from an Activity, `startActivityForResult` can be used. The started Activity can then use `setResult` to return the appropriate data to the calling component.

    If an Activity obtains the incoming, user-provided Intent and directly returns it via `setResult` without any checks, the application may be unintentionally giving arbitrary access to its content providers, even if they are not exported, as long as they are configured with the attribute `android:grantUriPermissions="true"`. This happens because the attacker adds the appropriate URI permission flags to the provided Intent, which take effect once the Intent is reflected back.


    ## Recommendation
    Avoid returning user-provided or untrusted Intents via `setResult`. Use a new Intent instead.

    If it is required to use the received Intent, make sure that it does not contain URI permission flags, either by checking them with `Intent.getFlags` or removing them with `Intent.removeFlags`.


    ## Example
    The following sample contains three examples. In the first example, a user-provided Intent is obtained and directly returned back with `setResult`, which is dangerous. In the second example, a new Intent is created to safely return the desired data. The third example shows how the obtained Intent can be sanitized by removing dangerous flags before using it to return data to the calling component.


    ```java
    public class IntentUriPermissionManipulation extends Activity {

        // BAD: the user-provided Intent is returned as-is
        public void dangerous() {
            Intent intent = getIntent();
            intent.putExtra("result", "resultData");
            setResult(intent);
        }

        // GOOD: a new Intent is created and returned
        public void safe() {
            Intent intent = new Intent();
            intent.putExtra("result", "resultData");
            setResult(intent);
        }

        // GOOD: the user-provided Intent is sanitized before being returned
        public void sanitized() {
            Intent intent = getIntent();
            intent.putExtra("result", "resultData");
            intent.removeFlags(
                    Intent.FLAG_GRANT_WRITE_URI_PERMISSION | Intent.FLAG_GRANT_READ_URI_PERMISSION);
            setResult(intent);
        }
    }

    ```

    ## References
    * Google Help: [Remediation for Intent Redirection Vulnerability](https://support.google.com/faqs/answer/9267555?hl=en).
    * Common Weakness Enumeration: [CWE-266](https://cwe.mitre.org/data/definitions/266.html).
    * Common Weakness Enumeration: [CWE-926](https://cwe.mitre.org/data/definitions/926.html).
 -
  pack: codeql/java-queries#0
  relativeQueryPath: Security/CWE/CWE-273/UnsafeCertTrust.ql
  relativeBqrsPath: codeql/java-queries/Security/CWE/CWE-273/UnsafeCertTrust.bqrs
  metadata:
    name: Unsafe certificate trust
    description: |-
      SSLSocket/SSLEngine ignores all SSL certificate validation
                    errors when establishing an HTTPS connection, thereby making
                    the app vulnerable to man-in-the-middle attacks.
    kind: problem
    problem.severity: warning
    security-severity: 9.8
    precision: medium
    id: java/unsafe-cert-trust
    tags: |-
      security
             external/cwe/cwe-273
  queryHelp: "# Unsafe certificate trust\nJava offers two mechanisms for SSL authentication\
    \ - trust manager and hostname verifier (the later is checked by the `java/insecure-hostname-verifier`\
    \ query). The trust manager validates the peer's certificate chain while hostname\
    \ verification establishes that the hostname in the URL matches the hostname in\
    \ the server's identification.\n\nWhen `SSLSocket` or `SSLEngine` are created\
    \ without a secure `setEndpointIdentificationAlgorithm`, hostname verification\
    \ is disabled by default.\n\nThis query checks whether `setEndpointIdentificationAlgorithm`\
    \ is missing, thereby making the application vulnerable to man-in-the-middle attacks.\
    \ The query also covers insecure configurations of `com.rabbitmq.client.ConnectionFactory`.\n\
    \n\n## Recommendation\nValidate SSL certificates in SSL authentication.\n\n\n\
    ## Example\nThe following two examples show two ways of configuring SSLSocket/SSLEngine.\
    \ In the 'BAD' case, `setEndpointIdentificationAlgorithm` is not called, thus\
    \ no hostname verification takes place. In the 'GOOD' case, `setEndpointIdentificationAlgorithm`\
    \ is called.\n\n\n```java\npublic static void main(String[] args) {\n\n\t{\n\t\
    \tSSLContext sslContext = SSLContext.getInstance(\"TLS\");\n\t\tSSLEngine sslEngine\
    \ = sslContext.createSSLEngine();\n\t\tSSLParameters sslParameters = sslEngine.getSSLParameters();\n\
    \t\tsslParameters.setEndpointIdentificationAlgorithm(\"HTTPS\"); //GOOD: Set a\
    \ valid endpointIdentificationAlgorithm for SSL engine to trigger hostname verification\n\
    \t\tsslEngine.setSSLParameters(sslParameters);\n\t}\n\n\t{\n\t\tSSLContext sslContext\
    \ = SSLContext.getInstance(\"TLS\");\n\t\tSSLEngine sslEngine = sslContext.createSSLEngine();\
    \  //BAD: No endpointIdentificationAlgorithm set\n\t}\n\n\t{\n\t\tSSLContext sslContext\
    \ = SSLContext.getInstance(\"TLS\");\n\t\tfinal SSLSocketFactory socketFactory\
    \ = sslContext.getSocketFactory();\n\t\tSSLSocket socket = (SSLSocket) socketFactory.createSocket(\"\
    www.example.com\", 443); \n\t\tSSLParameters sslParameters = sslEngine.getSSLParameters();\n\
    \t\tsslParameters.setEndpointIdentificationAlgorithm(\"HTTPS\"); //GOOD: Set a\
    \ valid endpointIdentificationAlgorithm for SSL socket to trigger hostname verification\n\
    \t\tsocket.setSSLParameters(sslParameters);\n\t}\n\n\t{\n\t\tcom.rabbitmq.client.ConnectionFactory\
    \ connectionFactory = new com.rabbitmq.client.ConnectionFactory();\n\t\tconnectionFactory.useSslProtocol();\n\
    \t\tconnectionFactory.enableHostnameVerification();  //GOOD: Enable hostname verification\
    \ for rabbitmq ConnectionFactory\n\t}\n\n\t{\n\t\tcom.rabbitmq.client.ConnectionFactory\
    \ connectionFactory = new com.rabbitmq.client.ConnectionFactory();\n\t\tconnectionFactory.useSslProtocol();\
    \ //BAD: Hostname verification for rabbitmq ConnectionFactory is not enabled\n\
    \t}\n}\n```\n\n## References\n* [Testing Endpoint Identify Verification (MSTG-NETWORK-3)](https://github.com/OWASP/owasp-mstg/blob/master/Document/0x05g-Testing-Network-Communication.md).\n\
    * [SSLParameters.setEndpointIdentificationAlgorithm documentation](https://docs.oracle.com/en/java/javase/11/docs/api/java.base/javax/net/ssl/SSLParameters.html#setEndpointIdentificationAlgorithm(java.lang.String)).\n\
    * RabbitMQ: [ConnectionFactory.enableHostnameVerification documentation](https://rabbitmq.github.io/rabbitmq-java-client/api/current/com/rabbitmq/client/ConnectionFactory.html#enableHostnameVerification()).\n\
    * RabbitMQ: [Using TLS in the Java Client](https://www.rabbitmq.com/ssl.html#java-client).\n\
    * [CVE-2018-17187: Apache Qpid Proton-J transport issue with hostname verification](https://github.com/advisories/GHSA-xvch-r4wf-h8w9).\n\
    * [CVE-2018-8034: Apache Tomcat - host name verification when using TLS with the\
    \ WebSocket client](https://github.com/advisories/GHSA-46j3-r4pj-4835).\n* [CVE-2018-11087:\
    \ Pivotal Spring AMQP vulnerability due to lack of hostname validation](https://github.com/advisories/GHSA-w4g2-9hj6-5472).\n\
    * [CVE-2018-11775: TLS hostname verification issue when using the Apache ActiveMQ\
    \ Client](https://github.com/advisories/GHSA-m9w8-v359-9ffr).\n* Common Weakness\
    \ Enumeration: [CWE-273](https://cwe.mitre.org/data/definitions/273.html).\n"
 -
  pack: codeql/java-queries#0
  relativeQueryPath: Security/CWE/CWE-287/AndroidInsecureKeys.ql
  relativeBqrsPath: codeql/java-queries/Security/CWE/CWE-287/AndroidInsecureKeys.bqrs
  metadata:
    name: Insecurely generated keys for local authentication
    description: Generation of keys with insecure parameters for local biometric authentication
      can allow attackers with physical access to bypass authentication checks.
    kind: problem
    problem.severity: warning
    security-severity: 4.4
    precision: medium
    id: java/android/insecure-local-key-gen
    tags: |-
      security
             external/cwe/cwe-287
  queryHelp: "# Insecurely generated keys for local authentication\nBiometric authentication,\
    \ such as fingerprint recognition, can be used alongside cryptographic keys stored\
    \ in the Android `KeyStore` to protect sensitive parts of the application. However,\
    \ when a key generated for this purpose has certain parameters set insecurely,\
    \ an attacker with physical access can bypass the authentication check using application\
    \ hooking tools such as Frida.\n\n\n## Recommendation\nWhen generating a key for\
    \ use with biometric authentication, ensure that the following parameters of `KeyGenParameterSpec.Builder`\
    \ are set:\n\n* `setUserAuthenticationRequired` should be set to `true`; otherwise,\
    \ the key can be used without user authentication.\n* `setInvalidatedByBiometricEnrollment`\
    \ should be set to `true` (the default); otherwise, an attacker can use the key\
    \ by enrolling additional biometrics on the device.\n* `setUserAuthenticationValidityDurationSeconds`,\
    \ if used, should be set to `-1`; otherwise, non-biometric (less secure) credentials\
    \ can be used to access the key. We recommend using `setUserAuthenticationParameters`\
    \ instead to explicitly set both the timeout and the types of credentials that\
    \ may be used.\n\n## Example\nThe following example demonstrates a key that is\
    \ configured with secure paramaters:\n\n\n```java\nprivate void generateSecretKey()\
    \ {\n    KeyGenParameterSpec keyGenParameterSpec = new KeyGenParameterSpec.Builder(\n\
    \        \"MySecretKey\",\n        KeyProperties.PURPOSE_ENCRYPT | KeyProperties.PURPOSE_DECRYPT)\n\
    \        .setBlockModes(KeyProperties.BLOCK_MODE_CBC)\n        .setEncryptionPaddings(KeyProperties.ENCRYPTION_PADDING_PKCS7)\n\
    \        // GOOD: Secure parameters are used to generate a key for biometric authentication.\n\
    \        .setUserAuthenticationRequired(true)\n        .setInvalidatedByBiometricEnrollment(true)\n\
    \        .setUserAuthenticationParameters(0, KeyProperties.AUTH_BIOMETRIC_STRONG)\n\
    \        .build();\n    KeyGenerator keyGenerator = KeyGenerator.getInstance(\n\
    \            KeyProperties.KEY_ALGORITHM_AES, \"AndroidKeyStore\");\n    keyGenerator.init(keyGenParameterSpec);\n\
    \    keyGenerator.generateKey();\n}\n```\nIn each of the following cases, a parameter\
    \ is set insecurely:\n\n\n```java\nprivate void generateSecretKey() {\n    KeyGenParameterSpec\
    \ keyGenParameterSpec = new KeyGenParameterSpec.Builder(\n        \"MySecretKey\"\
    ,\n        KeyProperties.PURPOSE_ENCRYPT | KeyProperties.PURPOSE_DECRYPT)\n  \
    \      .setBlockModes(KeyProperties.BLOCK_MODE_CBC)\n        .setEncryptionPaddings(KeyProperties.ENCRYPTION_PADDING_PKCS7)\n\
    \        // BAD: User authentication is not required to use this key.\n      \
    \  .setUserAuthenticationRequired(false)\n        .build();\n    KeyGenerator\
    \ keyGenerator = KeyGenerator.getInstance(\n            KeyProperties.KEY_ALGORITHM_AES,\
    \ \"AndroidKeyStore\");\n    keyGenerator.init(keyGenParameterSpec);\n    keyGenerator.generateKey();\n\
    }\n\nprivate void generateSecretKey() {\n    KeyGenParameterSpec keyGenParameterSpec\
    \ = new KeyGenParameterSpec.Builder(\n        \"MySecretKey\",\n        KeyProperties.PURPOSE_ENCRYPT\
    \ | KeyProperties.PURPOSE_DECRYPT)\n        .setBlockModes(KeyProperties.BLOCK_MODE_CBC)\n\
    \        .setEncryptionPaddings(KeyProperties.ENCRYPTION_PADDING_PKCS7)\n    \
    \    .setUserAuthenticationRequired(true)\n        // BAD: An attacker can access\
    \ this key by enrolling additional biometrics.\n        .setInvalidatedByBiometricEnrollment(false)\n\
    \        .build();\n    KeyGenerator keyGenerator = KeyGenerator.getInstance(\n\
    \            KeyProperties.KEY_ALGORITHM_AES, \"AndroidKeyStore\");\n    keyGenerator.init(keyGenParameterSpec);\n\
    \    keyGenerator.generateKey();\n}\n\nprivate void generateSecretKey() {\n  \
    \  KeyGenParameterSpec keyGenParameterSpec = new KeyGenParameterSpec.Builder(\n\
    \        \"MySecretKey\",\n        KeyProperties.PURPOSE_ENCRYPT | KeyProperties.PURPOSE_DECRYPT)\n\
    \        .setBlockModes(KeyProperties.BLOCK_MODE_CBC)\n        .setEncryptionPaddings(KeyProperties.ENCRYPTION_PADDING_PKCS7)\n\
    \        .setUserAuthenticationRequired(true)\n        .setInvalidatedByBiometricEnrollment(true)\n\
    \        // BAD: This key can be accessed using non-biometric credentials. \n\
    \        .setUserAuthenticationValidityDurationSeconds(30)\n        .build();\n\
    \    KeyGenerator keyGenerator = KeyGenerator.getInstance(\n            KeyProperties.KEY_ALGORITHM_AES,\
    \ \"AndroidKeyStore\");\n    keyGenerator.init(keyGenParameterSpec);\n    keyGenerator.generateKey();\n\
    }\n```\n\n## References\n* WithSecure: [How Secure is your Android Keystore Authentication?](https://labs.withsecure.com/publications/how-secure-is-your-android-keystore-authentication).\n\
    * Android Developers: [KeyGenParameterSpec.Builder](https://developer.android.com/reference/android/security/keystore/KeyGenParameterSpec.Builder).\n\
    * Common Weakness Enumeration: [CWE-287](https://cwe.mitre.org/data/definitions/287.html).\n"
 -
  pack: codeql/java-queries#0
  relativeQueryPath: Security/CWE/CWE-287/AndroidInsecureLocalAuthentication.ql
  relativeBqrsPath: codeql/java-queries/Security/CWE/CWE-287/AndroidInsecureLocalAuthentication.bqrs
  metadata:
    name: Insecure local authentication
    description: Local authentication that does not make use of a `CryptoObject` can
      be bypassed.
    kind: problem
    problem.severity: warning
    security-severity: 4.4
    precision: high
    id: java/android/insecure-local-authentication
    tags: |-
      security
             external/cwe/cwe-287
  queryHelp: |
    # Insecure local authentication
    Biometric local authentication such as fingerprint recognition can be used to protect sensitive data or actions within an application. However, if this authentication does not use a `KeyStore`-backed key, it can be bypassed by a privileged malicious application, or by an attacker with physical access using application hooking tools such as Frida.


    ## Recommendation
    Generate a secure key in the Android `KeyStore`. Ensure that the `onAuthenticationSuccess` callback for a biometric prompt uses it in a way that is required for the sensitive parts of the application to function, such as by using it to decrypt sensitive data or credentials.


    ## Example
    In the following (bad) case, no `CryptoObject` is required for the biometric prompt to grant access, so it can be bypassed.


    ```java
    biometricPrompt.authenticate(
        cancellationSignal,
        executor,
        new BiometricPrompt.AuthenticationCallback {
            @Override
            // BAD: This authentication callback does not make use of a `CryptoObject` from the `result`.
            public void onAuthenticationSucceeded(BiometricPrompt.AuthenticationResult result) {
                grantAccess()
            }
        }
    )
    ```
    In the following (good) case, a secret key is generated in the Android `KeyStore`. The application requires this secret key for access, using it to decrypt data.


    ```java
    private void generateSecretKey() {
        KeyGenParameterSpec keyGenParameterSpec = new KeyGenParameterSpec.Builder(
            "MySecretKey",
            KeyProperties.PURPOSE_ENCRYPT | KeyProperties.PURPOSE_DECRYPT)
            .setBlockModes(KeyProperties.BLOCK_MODE_CBC)
            .setEncryptionPaddings(KeyProperties.ENCRYPTION_PADDING_PKCS7)
            .setUserAuthenticationRequired(true)
            .setInvalidatedByBiometricEnrollment(true)
            .build();
        KeyGenerator keyGenerator = KeyGenerator.getInstance(
                KeyProperties.KEY_ALGORITHM_AES, "AndroidKeyStore");
        keyGenerator.init(keyGenParameterSpec);
        keyGenerator.generateKey();
    }


    private SecretKey getSecretKey() {
        KeyStore keyStore = KeyStore.getInstance("AndroidKeyStore");
        keyStore.load(null);
        return ((SecretKey)keyStore.getKey("MySecretKey", null));
    }

    private Cipher getCipher() {
        return Cipher.getInstance(KeyProperties.KEY_ALGORITHM_AES + "/"
                + KeyProperties.BLOCK_MODE_CBC + "/"
                + KeyProperties.ENCRYPTION_PADDING_PKCS7);
    }

    public prompt(byte[] encryptedData) {
        Cipher cipher = getCipher();
        SecretKey secretKey = getSecretKey();
        cipher.init(Cipher.DECRYPT_MODE, secretKey);

        biometricPrompt.authenticate(
            new BiometricPrompt.CryptoObject(cipher),
            cancellationSignal,
            executor,
            new BiometricPrompt.AuthenticationCallback() {
                @Override
                // GOOD: This authentication callback uses the result to decrypt some data.
                public void onAuthenticationSucceeded(BiometricPrompt.AuthenticationResult result) {
                    Cipher cipher = result.getCryptoObject().getCipher();
                    byte[] decryptedData = cipher.doFinal(encryptedData);
                    grantAccessWithData(decryptedData);
                }
            }
        );
    }
    ```

    ## References
    * OWASP Mobile Application Security: [Android Local Authentication](https://mas.owasp.org/MASTG/Android/0x05f-Testing-Local-Authentication/)
    * OWASP Mobile Application Security: [Testing Biometric Authentication](https://mas.owasp.org/MASTG/tests/android/MASVS-AUTH/MASTG-TEST-0018/)
    * WithSecure: [How Secure is your Android Keystore Authentication?](https://labs.withsecure.com/publications/how-secure-is-your-android-keystore-authentication)
    * Android Developers: [Biometric Authentication](https://developer.android.com/training/sign-in/biometric-auth)
    * Common Weakness Enumeration: [CWE-287](https://cwe.mitre.org/data/definitions/287.html).
 -
  pack: codeql/java-queries#0
  relativeQueryPath: Security/CWE/CWE-295/AndroidMissingCertificatePinning.ql
  relativeBqrsPath: codeql/java-queries/Security/CWE/CWE-295/AndroidMissingCertificatePinning.bqrs
  metadata:
    name: Android missing certificate pinning
    description: Network connections that do not use certificate pinning may allow
      attackers to eavesdrop on communications.
    kind: problem
    problem.severity: warning
    security-severity: 5.9
    precision: medium
    id: java/android/missing-certificate-pinning
    tags: |-
      security
             external/cwe/cwe-295
  queryHelp: "# Android missing certificate pinning\nCertificate pinning is the practice\
    \ of only trusting a specific set of SSL certificates, rather than those that\
    \ the device trusts by default. In Android applications, it is reccomended to\
    \ use certificate pinning when communicating over the network, in order to minimize\
    \ the risk of machine-in-the-middle attacks from a compromised CA.\n\n\n## Recommendation\n\
    The easiest way to implement certificate pinning is to declare your pins in a\
    \ `network-security-config` XML file. This will automatically provide certificate\
    \ pinning for any network connection made by the app.\n\nAnother way to implement\
    \ certificate pinning is to use the \\`CertificatePinner\\` class from the \\\
    `okhttp\\` library.\n\nA final way to implement certificate pinning is to use\
    \ a `TrustManager`, initialized from a `KeyStore` loaded with only the necessary\
    \ certificates.\n\n\n## Example\nIn the first (bad) case below, a network call\
    \ is performed with no certificate pinning implemented. The other (good) cases\
    \ demonstrate the different ways to implement certificate pinning.\n\n\n```java\n\
    // BAD - By default, this network call does not use certificate pinning\nURLConnection\
    \ conn = new URL(\"https://example.com\").openConnection();\n```\n\n```xml\n<!--\
    \ GOOD: Certificate pinning implemented via a Network Security Config file -->\n\
    \n<!-- In AndroidManifest.xml -->\n<manifest xmlns:android=\"http://schemas.android.com/apk/res/android\"\
    \n    package=\"com.example.app\">\n\n    <application android:networkSecurityConfig=\"\
    @xml/NetworkSecurityConfig\">\n        ...\n    </application>\n\n</manifest>\n\
    \n<!-- In res/xml/NetworkSecurityConfig.xml -->\n<network-security-config>\n \
    \   <domain-config>\n        <domain>good.example.com</domain>\n        <pin-set\
    \ expiration=\"2038/1/19\">\n            <pin digest=\"SHA-256\">...</pin>\n \
    \       </pin-set>\n    </domain-config>\n</network-security-config>\n```\n\n\
    ```java\n// GOOD: Certificate pinning implemented via okhttp3.CertificatePinner\
    \ \nCertificatePinner certificatePinner = new CertificatePinner.Builder()\n  \
    \  .add(\"example.com\", \"sha256/AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA=\"\
    )\n    .build();\nOkHttpClient client = new OkHttpClient.Builder()\n    .certificatePinner(certificatePinner)\n\
    \    .build();\n\nclient.newCall(new Request.Builder().url(\"https://example.com\"\
    ).build()).execute();\n\n\n\n// GOOD: Certificate pinning implemented via a TrustManager\n\
    KeyStore keyStore = KeyStore.getInstance(\"BKS\");\nkeyStore.load(resources.openRawResource(R.raw.cert),\
    \ null);\n\nTrustManagerFactory tmf = TrustManagerFactory.getInstance(TrustManagerFactory.getDefaultAlgorithm());\n\
    tmf.init(keyStore);\n\nSSLContext sslContext = SSLContext.getInstance(\"TLS\"\
    );\nsslContext.init(null, tmf.getTrustManagers(), null);\n\nURL url = new URL(\"\
    http://www.example.com/\");\nHttpsURLConnection urlConnection = (HttpsURLConnection)\
    \ url.openConnection(); \n\nurlConnection.setSSLSocketFactory(sslContext.getSocketFactory());\n\
    ```\n\n## References\n* OWASP Mobile Security: [Testing Custom Certificate Stores\
    \ and Certificate Pinning (MSTG-NETWORK-4)](https://mobile-security.gitbook.io/mobile-security-testing-guide/android-testing-guide/0x05g-testing-network-communication#testing-custom-certificate-stores-and-certificate-pinning-mstg-network-4).\n\
    * Android Developers: [Network security configuration](https://developer.android.com/training/articles/security-config).\n\
    * OkHttp: [CertificatePinner](https://square.github.io/okhttp/4.x/okhttp/okhttp3/-certificate-pinner/).\n\
    * Common Weakness Enumeration: [CWE-295](https://cwe.mitre.org/data/definitions/295.html).\n"
 -
  pack: codeql/java-queries#0
  relativeQueryPath: Security/CWE/CWE-295/ImproperWebViewCertificateValidation.ql
  relativeBqrsPath: codeql/java-queries/Security/CWE/CWE-295/ImproperWebViewCertificateValidation.bqrs
  metadata:
    name: Android `WebView` that accepts all certificates
    description: Trusting all certificates allows an attacker to perform a machine-in-the-middle
      attack.
    kind: problem
    problem.severity: error
    security-severity: 7.5
    precision: high
    id: java/improper-webview-certificate-validation
    tags: |-
      security
             external/cwe/cwe-295
  queryHelp: "# Android `WebView` that accepts all certificates\nIf the `onReceivedSslError`\
    \ method of an Android `WebViewClient` always calls `proceed` on the given `SslErrorHandler`,\
    \ it trusts any certificate. This allows an attacker to perform a machine-in-the-middle\
    \ attack against the application, therefore breaking any security Transport Layer\
    \ Security (TLS) gives.\n\nAn attack might look like this:\n\n1. The vulnerable\
    \ application connects to `https://example.com`.\n1. The attacker intercepts this\
    \ connection and presents a valid, self-signed certificate for `https://example.com`.\n\
    1. The vulnerable application calls the `onReceivedSslError` method to check whether\
    \ it should trust the certificate.\n1. The `onReceivedSslError` method of your\
    \ `WebViewClient` calls `SslErrorHandler.proceed`.\n1. The vulnerable application\
    \ accepts the certificate and proceeds with the connection since your `WevViewClient`\
    \ trusted it by proceeding.\n1. The attacker can now read the data your application\
    \ sends to `https://example.com` and/or alter its replies while the application\
    \ thinks the connection is secure.\n\n## Recommendation\nDo not use a call `SslerrorHandler.proceed`\
    \ unconditionally. If you have to use a self-signed certificate, only accept that\
    \ certificate, not all certificates.\n\n\n## Example\nIn the first (bad) example,\
    \ the `WebViewClient` trusts all certificates by always calling `SslErrorHandler.proceed`.\
    \ In the second (good) example, only certificates signed by a certain public key\
    \ are accepted.\n\n\n```java\nclass Bad extends WebViewClient {\n    // BAD: All\
    \ certificates are trusted.\n    public void onReceivedSslError (WebView view,\
    \ SslErrorHandler handler, SslError error) { // $hasResult\n        handler.proceed();\
    \ \n    }\n}\n\nclass Good extends WebViewClient {\n    PublicKey myPubKey = ...;\n\
    \n    // GOOD: Only certificates signed by a certain public key are trusted.\n\
    \    public void onReceivedSslError (WebView view, SslErrorHandler handler, SslError\
    \ error) { // $hasResult\n        try {\n            X509Certificate cert = error.getCertificate().getX509Certificate();\n\
    \            cert.verify(this.myPubKey);\n            handler.proceed();\n   \
    \     }\n        catch (CertificateException|NoSuchAlgorithmException|InvalidKeyException|NoSuchProviderException|SignatureException\
    \ e) {\n            handler.cancel();\n        }\n    }    \n}\n```\n\n## References\n\
    * [WebViewClient.onReceivedSslError documentation](https://developer.android.com/reference/android/webkit/WebViewClient?hl=en#onReceivedSslError(android.webkit.WebView,%20android.webkit.SslErrorHandler,%20android.net.http.SslError)).\n\
    * Common Weakness Enumeration: [CWE-295](https://cwe.mitre.org/data/definitions/295.html).\n"
 -
  pack: codeql/java-queries#0
  relativeQueryPath: Security/CWE/CWE-295/InsecureTrustManager.ql
  relativeBqrsPath: codeql/java-queries/Security/CWE/CWE-295/InsecureTrustManager.bqrs
  metadata:
    name: '`TrustManager` that accepts all certificates'
    description: Trusting all certificates allows an attacker to perform a machine-in-the-middle
      attack.
    kind: path-problem
    problem.severity: error
    security-severity: 7.5
    precision: high
    id: java/insecure-trustmanager
    tags: |-
      security
             external/cwe/cwe-295
  queryHelp: "# `TrustManager` that accepts all certificates\nIf the `checkServerTrusted`\
    \ method of a `TrustManager` never throws a `CertificateException`, it trusts\
    \ every certificate. This allows an attacker to perform a machine-in-the-middle\
    \ attack against the application, therefore breaking any security Transport Layer\
    \ Security (TLS) gives.\n\nAn attack might look like this:\n\n1. The vulnerable\
    \ program connects to `https://example.com`.\n1. The attacker intercepts this\
    \ connection and presents a valid, self-signed certificate for `https://example.com`.\n\
    1. The vulnerable program calls the `checkServerTrusted` method to check whether\
    \ it should trust the certificate.\n1. The `checkServerTrusted` method of your\
    \ `TrustManager` does not throw a `CertificateException`.\n1. The vulnerable program\
    \ accepts the certificate and proceeds with the connection since your `TrustManager`\
    \ implicitly trusted it by not throwing an exception.\n1. The attacker can now\
    \ read the data your program sends to `https://example.com` and/or alter its replies\
    \ while the program thinks the connection is secure.\n\n## Recommendation\nDo\
    \ not use a custom `TrustManager` that trusts any certificate. If you have to\
    \ use a self-signed certificate, don't trust every certificate, but instead only\
    \ trust this specific certificate. See below for an example of how to do this.\n\
    \n\n## Example\nIn the first (bad) example, the `TrustManager` never throws a\
    \ `CertificateException` and therefore implicitly trusts any certificate. This\
    \ allows an attacker to perform a machine-in-the-middle attack. In the second\
    \ (good) example, the self-signed certificate that should be trusted is loaded\
    \ into a `KeyStore`. This explicitly defines the certificate as trusted and there\
    \ is no need to create a custom `TrustManager`.\n\n\n```java\npublic static void\
    \ main(String[] args) throws Exception {\n    {\n        class InsecureTrustManager\
    \ implements X509TrustManager {\n            @Override\n            public X509Certificate[]\
    \ getAcceptedIssuers() {\n                return null;\n            }\n\n    \
    \        @Override\n            public void checkServerTrusted(X509Certificate[]\
    \ chain, String authType) throws CertificateException {\n                // BAD:\
    \ Does not verify the certificate chain, allowing any certificate.\n         \
    \   }\n\n            @Override\n            public void checkClientTrusted(X509Certificate[]\
    \ chain, String authType) throws CertificateException {\n\n            }\n   \
    \     }\n        SSLContext context = SSLContext.getInstance(\"TLS\");\n     \
    \   TrustManager[] trustManager = new TrustManager[] { new InsecureTrustManager()\
    \ };\n        context.init(null, trustManager, null);\n    }\n    {\n        SSLContext\
    \ context = SSLContext.getInstance(\"TLS\");\n        File certificateFile = new\
    \ File(\"path/to/self-signed-certificate\");\n        // Create a `KeyStore` with\
    \ default type\n        KeyStore keyStore = KeyStore.getInstance(KeyStore.getDefaultType());\n\
    \        // `keyStore` is initially empty\n        keyStore.load(null, null);\n\
    \        X509Certificate generatedCertificate;\n        try (InputStream cert\
    \ = new FileInputStream(certificateFile)) {\n            generatedCertificate\
    \ = (X509Certificate) CertificateFactory.getInstance(\"X509\")\n             \
    \       .generateCertificate(cert);\n        }\n        // Add the self-signed\
    \ certificate to the key store\n        keyStore.setCertificateEntry(certificateFile.getName(),\
    \ generatedCertificate);\n        // Get default `TrustManagerFactory`\n     \
    \   TrustManagerFactory tmf = TrustManagerFactory.getInstance(TrustManagerFactory.getDefaultAlgorithm());\n\
    \        // Use it with our key store that trusts our self-signed certificate\n\
    \        tmf.init(keyStore);\n        TrustManager[] trustManagers = tmf.getTrustManagers();\n\
    \        context.init(null, trustManagers, null);\n        // GOOD, we are not\
    \ using a custom `TrustManager` but instead have\n        // added the self-signed\
    \ certificate we want to trust to the key\n        // store. Note, the `trustManagers`\
    \ will **only** trust this one\n        // certificate.\n        \n        URL\
    \ url = new URL(\"https://self-signed.badssl.com/\");\n        HttpsURLConnection\
    \ conn = (HttpsURLConnection) url.openConnection();\n        conn.setSSLSocketFactory(context.getSocketFactory());\n\
    \    }\n}\n\n```\n\n## References\n* Android Developers: [Security with HTTPS\
    \ and SSL](https://developer.android.com/training/articles/security-ssl).\n* Common\
    \ Weakness Enumeration: [CWE-295](https://cwe.mitre.org/data/definitions/295.html).\n"
 -
  pack: codeql/java-queries#0
  relativeQueryPath: Security/CWE/CWE-297/InsecureJavaMail.ql
  relativeBqrsPath: codeql/java-queries/Security/CWE/CWE-297/InsecureJavaMail.bqrs
  metadata:
    name: Insecure JavaMail SSL Configuration
    description: |-
      Configuring a Java application to use authenticated mail session
                    over SSL without certificate validation
                    makes the session susceptible to a man-in-the-middle attack.
    kind: problem
    problem.severity: warning
    security-severity: 5.9
    precision: medium
    id: java/insecure-smtp-ssl
    tags: |-
      security
             external/cwe/cwe-297
  queryHelp: "# Insecure JavaMail SSL Configuration\nJavaMail is commonly used in\
    \ Java applications to send emails. There are popular third-party libraries like\
    \ Apache Commons Email which are built on JavaMail and facilitate integration.\
    \ Authenticated mail sessions require user credentials and mail sessions can require\
    \ SSL/TLS authentication. It is a common security vulnerability that host-specific\
    \ certificate data is not validated or is incorrectly validated. Failing to validate\
    \ the certificate makes the SSL session susceptible to a man-in-the-middle attack.\n\
    \nThis query checks whether the SSL certificate is validated when credentials\
    \ are used and SSL is enabled in email communications.\n\nThe query has code for\
    \ both plain JavaMail invocation and mailing through Apache SimpleMail to make\
    \ it more comprehensive.\n\n\n## Recommendation\nValidate SSL certificate when\
    \ sensitive information is sent in email communications.\n\n\n## Example\nThe\
    \ following two examples show two ways of configuring secure emails through JavaMail\
    \ or Apache SimpleMail. In the 'BAD' case, credentials are sent in an SSL session\
    \ without certificate validation. In the 'GOOD' case, the certificate is validated.\n\
    \n\n```java\nimport java.util.Properties;\n\nimport javax.activation.DataSource;\n\
    import javax.mail.Authenticator;\nimport javax.mail.Message;\nimport javax.mail.MessagingException;\n\
    import javax.mail.PasswordAuthentication;\nimport javax.mail.Session;\n\nimport\
    \ org.apache.logging.log4j.util.PropertiesUtil;\n\nclass JavaMail {\n    public\
    \ static void main(String[] args) {\n      // BAD: Don't have server certificate\
    \ check\n      {\n\t\tfinal Properties properties = PropertiesUtil.getSystemProperties();\n\
    \t\tproperties.put(\"mail.transport.protocol\", \"protocol\");\n\t\tproperties.put(\"\
    mail.smtp.host\", \"hostname\");\n\t\tproperties.put(\"mail.smtp.socketFactory.class\"\
    , \"classname\");\n\n\t\tfinal Authenticator authenticator = buildAuthenticator(\"\
    username\", \"password\");\n\t\tif (null != authenticator) {\n\t\t\tproperties.put(\"\
    mail.smtp.auth\", \"true\");\n\t\t}\n\t\tfinal Session session = Session.getInstance(properties,\
    \ authenticator);\n      }\n\n      // GOOD: Have server certificate check\n \
    \     {\n\t\tfinal Properties properties = PropertiesUtil.getSystemProperties();\n\
    \t\tproperties.put(\"mail.transport.protocol\", \"protocol\");\n\t\tproperties.put(\"\
    mail.smtp.host\", \"hostname\");\n\t\tproperties.put(\"mail.smtp.socketFactory.class\"\
    , \"classname\");\n\n\t\tfinal Authenticator authenticator = buildAuthenticator(\"\
    username\", \"password\");\n\t\tif (null != authenticator) {\n\t\t\tproperties.put(\"\
    mail.smtp.auth\", \"true\");\n\t\t\tproperties.put(\"mail.smtp.ssl.checkserveridentity\"\
    , \"true\");\n\t\t}\n\t\tfinal Session session = Session.getInstance(properties,\
    \ authenticator);\n      }\n    }\n}\n```\n\n```java\nimport org.apache.commons.mail.DefaultAuthenticator;\n\
    import org.apache.commons.mail.Email;\nimport org.apache.commons.mail.EmailException;\n\
    import org.apache.commons.mail.SimpleEmail;\n\nclass SimpleMail {\n    public\
    \ static void main(String[] args) throws EmailException {\n      // BAD: Don't\
    \ have setSSLCheckServerIdentity set or set as false    \n      {\n        Email\
    \ email = new SimpleEmail();\n        email.setHostName(\"hostName\");\n     \
    \   email.setSmtpPort(25);\n        email.setAuthenticator(new DefaultAuthenticator(\"\
    username\", \"password\"));\n        email.setSSLOnConnect(true);\n        \n\
    \        //email.setSSLCheckServerIdentity(false);\n        email.setFrom(\"fromAddress\"\
    );\n        email.setSubject(\"subject\");\n        email.setMsg(\"body\");\n\
    \        email.addTo(\"toAddress\");\n        email.send();\n      }\n\n     \
    \ // GOOD: Have setSSLCheckServerIdentity set to true\n      {\n        Email\
    \ email = new SimpleEmail();\n        email.setHostName(\"hostName\");\n     \
    \   email.setSmtpPort(25);\n        email.setAuthenticator(new DefaultAuthenticator(\"\
    username\", \"password\"));\n        email.setSSLOnConnect(true);\n\n        email.setSSLCheckServerIdentity(true);\n\
    \        email.setFrom(\"fromAddress\");\n        email.setSubject(\"subject\"\
    );\n        email.setMsg(\"body\");\n        email.addTo(\"toAddress\");\n   \
    \     email.send();\n      }\n    }\n}\n```\n\n## References\n* Jakarta Mail:\
    \ [SSL Notes](https://eclipse-ee4j.github.io/mail/docs/SSLNOTES.txt).\n* Apache\
    \ Commons: [Email security](https://commons.apache.org/proper/commons-email/userguide.html#Security).\n\
    * Log4j2: [Add support for specifying an SSL configuration for SmtpAppender (CVE-2020-9488)](https://issues.apache.org/jira/browse/LOG4J2-2819).\n\
    * Common Weakness Enumeration: [CWE-297](https://cwe.mitre.org/data/definitions/297.html).\n"
 -
  pack: codeql/java-queries#0
  relativeQueryPath: Security/CWE/CWE-297/UnsafeHostnameVerification.ql
  relativeBqrsPath: codeql/java-queries/Security/CWE/CWE-297/UnsafeHostnameVerification.bqrs
  metadata:
    name: Unsafe hostname verification
    description: Marking a certificate as valid for a host without checking the certificate
      hostname allows an attacker to perform a machine-in-the-middle attack.
    kind: path-problem
    problem.severity: error
    security-severity: 5.9
    precision: high
    id: java/unsafe-hostname-verification
    tags: |-
      security
             external/cwe/cwe-297
  queryHelp: "# Unsafe hostname verification\nIf a `HostnameVerifier` always returns\
    \ `true` it will not verify the hostname at all. This stops Transport Layer Security\
    \ (TLS) providing any security and allows an attacker to perform a man-in-the-middle\
    \ attack against the application.\n\nAn attack might look like this:\n\n1. The\
    \ program connects to `https://example.com`.\n1. The attacker intercepts this\
    \ connection and presents an apparently-valid certificate of their choosing.\n\
    1. The `TrustManager` of the program verifies that the certificate has been issued\
    \ by a trusted certificate authority.\n1. The Java HTTPS library checks whether\
    \ the certificate has been issued for the host `example.com`. This check fails\
    \ because the certificate has been issued for a domain controlled by the attacker,\
    \ for example: `malicious.domain`.\n1. The HTTPS library wants to reject the certificate\
    \ because the hostname does not match. Before doing this it checks whether a `HostnameVerifier`\
    \ exists.\n1. Your `HostnameVerifier` is called which returns `true` for any certificate\
    \ so also for this one.\n1. The program proceeds with the connection since your\
    \ `HostnameVerifier` accepted it.\n1. The attacker can now read the data your\
    \ program sends to `https://example.com` and/or alter its replies while the program\
    \ thinks the connection is secure.\n\n## Recommendation\nDo not use an open `HostnameVerifier`.\
    \ If you have a configuration problem with TLS/HTTPS, you should always solve\
    \ the configuration problem instead of using an open verifier.\n\n\n## Example\n\
    In the first (bad) example, the `HostnameVerifier` always returns `true`. This\
    \ allows an attacker to perform a man-in-the-middle attack, because any certificate\
    \ is accepted despite an incorrect hostname. In the second (good) example, the\
    \ `HostnameVerifier` only returns `true` when the certificate has been correctly\
    \ checked.\n\n\n```java\npublic static void main(String[] args) {\n\n\t{\n\t\t\
    HostnameVerifier verifier = new HostnameVerifier() {\n\t\t\t@Override\n\t\t\t\
    public boolean verify(String hostname, SSLSession session) {\n\t\t\t\treturn true;\
    \ // BAD: accept even if the hostname doesn't match\n\t\t\t}\n\t\t};\n\t\tHttpsURLConnection.setDefaultHostnameVerifier(verifier);\n\
    \t}\n\n\t{\n\t\tHostnameVerifier verifier = new HostnameVerifier() {\n\t\t\t@Override\n\
    \t\t\tpublic boolean verify(String hostname, SSLSession session) {\n\t\t\t\ttry\
    \ { // GOOD: verify the certificate\n\t\t\t\t\tCertificate[] certs = session.getPeerCertificates();\n\
    \t\t\t\t\tX509Certificate x509 = (X509Certificate) certs[0];\n\t\t\t\t\tcheck(new\
    \ String[]{host}, x509);\n\t\t\t\t\treturn true;\n\t\t\t\t} catch (SSLException\
    \ e) {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t}\n\t\t};\n\t\tHttpsURLConnection.setDefaultHostnameVerifier(verifier);\n\
    \t}\n\n}\n```\n\n## References\n* Android developers: [Security with HTTPS and\
    \ SSL](https://developer.android.com/training/articles/security-ssl).\n* Terse\
    \ systems blog: [Fixing Hostname Verification](https://tersesystems.com/blog/2014/03/23/fixing-hostname-verification/).\n\
    * Common Weakness Enumeration: [CWE-297](https://cwe.mitre.org/data/definitions/297.html).\n"
 -
  pack: codeql/java-queries#0
  relativeQueryPath: Security/CWE/CWE-312/AllowBackupAttributeEnabled.ql
  relativeBqrsPath: codeql/java-queries/Security/CWE/CWE-312/AllowBackupAttributeEnabled.bqrs
  metadata:
    name: Application backup allowed
    description: Allowing application backups may allow an attacker to extract sensitive
      data.
    kind: problem
    problem.severity: recommendation
    security-severity: 7.5
    id: java/android/backup-enabled
    tags: |-
      security
             external/cwe/cwe-312
    precision: very-high
  queryHelp: |
    # Application backup allowed
    In the Android manifest file, you can use the `android:allowBackup` attribute of the `application` element to define whether the application will have automatic backups or not.

    If your application uses any sensitive data, you should disable automatic backups to prevent attackers from extracting it.


    ## Recommendation
    For Android applications which process sensitive data, set `android:allowBackup` to `false` in the manifest file.

    Note: Since Android 6.0 (Marshmallow), automatic backups for applications are switched on by default.


    ## Example
    In the following two (bad) examples, the `android:allowBackup` setting is enabled:


    ```xml
    <manifest ... >
        <!-- BAD: 'android:allowBackup' set to 'true' -->
        <application
            android:allowBackup="true">
            <activity ... >
            </activity>
        </application>
    </manifest>

    ```

    ```xml
    <manifest ... >
        <!-- BAD: no 'android:allowBackup' set, defaults to 'true' -->
        <application>
            <activity ... >
            </activity>
        </application>
    </manifest>

    ```
    In the following (good) example, `android:allowBackup` is set to `false`:


    ```xml
    <manifest ... >
        <!-- GOOD: 'android:allowBackup' set to 'false' -->
        <application
            android:allowBackup="false">
            <activity ... >
            </activity>
        </application>
    </manifest>

    ```

    ## References
    * Android Documentation: [Back up user data with Auto Backup](https://developer.android.com/guide/topics/data/autobackup#EnablingAutoBackup)
    * OWASP Mobile Security Testing Guide: [ Android Backups ](https://github.com/OWASP/owasp-mstg/blob/b7a93a2e5e0557cc9a12e55fc3f6675f6986bb86/Document/0x05d-Testing-Data-Storage.md#backups)
    * Common Weakness Enumeration: [CWE-312](https://cwe.mitre.org/data/definitions/312.html).
 -
  pack: codeql/java-queries#0
  relativeQueryPath: Security/CWE/CWE-312/CleartextStorageAndroidDatabase.ql
  relativeBqrsPath: codeql/java-queries/Security/CWE/CWE-312/CleartextStorageAndroidDatabase.bqrs
  metadata:
    name: Cleartext storage of sensitive information using a local database on Android
    description: |-
      Cleartext Storage of Sensitive Information using
                    a local database on Android allows access for users with root
                    privileges or unexpected exposure from chained vulnerabilities.
    kind: problem
    problem.severity: warning
    security-severity: 7.5
    precision: medium
    id: java/android/cleartext-storage-database
    tags: |-
      security
             external/cwe/cwe-312
  queryHelp: "# Cleartext storage of sensitive information using a local database\
    \ on Android\nSQLite is a lightweight database engine commonly used in Android\
    \ devices to store data. By itself, SQLite does not offer any encryption mechanism\
    \ by default and stores all data in cleartext, which introduces a risk if sensitive\
    \ data like credentials, authentication tokens or personal identifiable information\
    \ (PII) are directly stored in a SQLite database. The information could be accessed\
    \ by any process or user in rooted devices, or can be disclosed through chained\
    \ vulnerabilities, like unexpected access to the private storage through exposed\
    \ components.\n\n\n## Recommendation\nUse `SQLCipher` or similar libraries to\
    \ add encryption capabilities to SQLite. Alternatively, encrypt sensitive data\
    \ using cryptographically secure algorithms before storing it in the database.\n\
    \n\n## Example\nIn the first example, sensitive user information is stored in\
    \ cleartext.\n\nIn the second and third examples, the code encrypts sensitive\
    \ information before saving it to the database.\n\n\n```java\npublic void sqliteStorageUnsafe(Context\
    \ ctx, String name, String password) {\n\t// BAD - sensitive information saved\
    \ in cleartext.\n\tSQLiteDatabase db = ctx.openOrCreateDatabase(\"test\", Context.MODE_PRIVATE,\
    \ null);\n\tdb.execSQL(\"INSERT INTO users VALUES (?, ?)\", new String[] {name,\
    \ password});\n}\n\npublic void sqliteStorageSafe(Context ctx, String name, String\
    \ password) {\n\t// GOOD - sensitive information encrypted with a custom method.\n\
    \tSQLiteDatabase db = ctx.openOrCreateDatabase(\"test\", Context.MODE_PRIVATE,\
    \ null);\n\tdb.execSQL(\"INSERT INTO users VALUES (?, ?)\", new String[] {name,\
    \ encrypt(password)});\n}\n\npublic void sqlCipherStorageSafe(String name, String\
    \ password, String databasePassword) {\n\t// GOOD - sensitive information saved\
    \ using SQLCipher.\n\tnet.sqlcipher.database.SQLiteDatabase db = \n\t\tnet.sqlcipher.database.SQLiteDatabase.openOrCreateDatabase(\"\
    test\", databasePassword, null);\n\tdb.execSQL(\"INSERT INTO users VALUES (?,\
    \ ?)\", new String[] {name, password});\n}\n\nprivate static String encrypt(String\
    \ cleartext) {\n    // Use an encryption or strong hashing algorithm in the real\
    \ world.\n    // The example below just returns a SHA-256 hash.\n    MessageDigest\
    \ digest = MessageDigest.getInstance(\"SHA-256\");\n    byte[] hash = digest.digest(cleartext.getBytes(StandardCharsets.UTF_8));\n\
    \    String encoded = Base64.getEncoder().encodeToString(hash);\n    return encoded;\n\
    }\n```\n\n## References\n* Android Developers: [Work with data more securely](https://developer.android.com/topic/security/data)\n\
    * SQLCipher: [Android Application Integration](https://www.zetetic.net/sqlcipher/sqlcipher-for-android/)\n\
    * Common Weakness Enumeration: [CWE-312](https://cwe.mitre.org/data/definitions/312.html).\n"
 -
  pack: codeql/java-queries#0
  relativeQueryPath: Security/CWE/CWE-312/CleartextStorageAndroidFilesystem.ql
  relativeBqrsPath: codeql/java-queries/Security/CWE/CWE-312/CleartextStorageAndroidFilesystem.bqrs
  metadata:
    name: Cleartext storage of sensitive information in the Android filesystem
    description: |-
      Cleartext storage of sensitive information in the Android filesystem
                    allows access for users with root privileges or unexpected exposure
                    from chained vulnerabilities.
    kind: problem
    problem.severity: warning
    security-severity: 7.5
    precision: medium
    id: java/android/cleartext-storage-filesystem
    tags: |-
      security
             external/cwe/cwe-312
  queryHelp: "# Cleartext storage of sensitive information in the Android filesystem\n\
    Android applications with the appropriate permissions can write files either to\
    \ the device external storage or the application internal storage, depending on\
    \ the application's needs. However, sensitive information should not be saved\
    \ in cleartext. Otherwise it can be accessed by any process or user in rooted\
    \ devices, or can be disclosed through chained vulnerabilities, like unexpected\
    \ access to the private storage through exposed components.\n\n\n## Recommendation\n\
    Consider using the `EncryptedFile` class to work with files containing sensitive\
    \ data. Alternatively, use encryption algorithms to encrypt the sensitive data\
    \ being stored.\n\n\n## Example\nIn the first example, sensitive user information\
    \ is stored in cleartext using a local file.\n\nIn the second and third examples,\
    \ the code encrypts sensitive information before saving it to the filesystem.\n\
    \n\n```java\npublic void fileSystemStorageUnsafe(String name, String password)\
    \ {\n\t// BAD - sensitive data stored in cleartext\n    FileWriter fw = new FileWriter(\"\
    some_file.txt\");\n    fw.write(name + \":\" + password);\n    fw.close();\n}\n\
    \npublic void filesystemStorageEncryptedFileSafe(Context context, String name,\
    \ String password) {\n\t// GOOD - the whole file is encrypted with androidx.security.crypto.EncryptedFile\n\
    \    File file = new File(\"some_file.txt\");\n    String masterKeyAlias = MasterKeys.getOrCreate(MasterKeys.AES256_GCM_SPEC);\n\
    \    EncryptedFile encryptedFile = new EncryptedFile.Builder(\n        file,\n\
    \        context,\n        masterKeyAlias,\n        EncryptedFile.FileEncryptionScheme.AES256_GCM_HKDF_4KB\n\
    \    ).build();\n\tFileOutputStream encryptedOutputStream = encryptedFile.openFileOutput();\n\
    \tencryptedOutputStream.write(name + \":\" + password);\n}\n\npublic void fileSystemStorageSafe(String\
    \ name, String password) {\n\t// GOOD - sensitive data is encrypted using a custom\
    \ method\n    FileWriter fw = new FileWriter(\"some_file.txt\");\n    fw.write(name\
    \ + \":\" + encrypt(password));\n    fw.close();\n}\n\nprivate static String encrypt(String\
    \ cleartext) {\n    // Use an encryption or strong hashing algorithm in the real\
    \ world.\n    // The example below just returns a SHA-256 hash.\n    MessageDigest\
    \ digest = MessageDigest.getInstance(\"SHA-256\");\n    byte[] hash = digest.digest(cleartext.getBytes(StandardCharsets.UTF_8));\n\
    \    String encoded = Base64.getEncoder().encodeToString(hash);\n    return encoded;\n\
    }\n\n```\n\n## References\n* Android Developers: [Work with data more securely](https://developer.android.com/topic/security/data)\n\
    * Android Developers: [EncryptedFile](https://developer.android.com/reference/androidx/security/crypto/EncryptedFile)\n\
    * Common Weakness Enumeration: [CWE-312](https://cwe.mitre.org/data/definitions/312.html).\n"
 -
  pack: codeql/java-queries#0
  relativeQueryPath: Security/CWE/CWE-312/CleartextStorageClass.ql
  relativeBqrsPath: codeql/java-queries/Security/CWE/CWE-312/CleartextStorageClass.bqrs
  metadata:
    name: Cleartext storage of sensitive information using storable class
    description: Storing sensitive information in cleartext can expose it to an attacker.
    kind: problem
    problem.severity: recommendation
    security-severity: 7.5
    precision: medium
    id: java/cleartext-storage-in-class
    tags: |-
      security
             external/cwe/cwe-499
             external/cwe/cwe-312
  queryHelp: "# Cleartext storage of sensitive information using storable class\n\
    Sensitive information that is stored unencrypted is accessible to an attacker\
    \ who gains access to the storage.\n\n\n## Recommendation\nEnsure that sensitive\
    \ information is always encrypted before being stored. It may be wise to encrypt\
    \ information before it is put into a heap data structure (such as `Java.util.Properties`)\
    \ that may be written to disk later. Objects that are serializable or marshallable\
    \ should also always contain encrypted information unless you are certain that\
    \ they are not ever going to be serialized.\n\nIn general, decrypt sensitive information\
    \ only at the point where it is necessary for it to be used in cleartext.\n\n\n\
    ## Example\nThe following example shows two ways of storing user credentials in\
    \ a cookie. In the 'BAD' case, the credentials are simply stored in cleartext.\
    \ In the 'GOOD' case, the credentials are hashed before storing them.\n\n\n```java\n\
    public static void main(String[] args) {\n\t{\n\t\tString data;\n\t\tPasswordAuthentication\
    \ credentials =\n\t\t\t\tnew PasswordAuthentication(\"user\", \"BP@ssw0rd\".toCharArray());\n\
    \t\tdata = credentials.getUserName() + \":\" + new String(credentials.getPassword());\n\
    \t\n\t\t// BAD: store data in a cookie in cleartext form\n\t\tresponse.addCookie(new\
    \ Cookie(\"auth\", data));\n\t}\n\t\n\t{\n\t\tString data;\n\t\tPasswordAuthentication\
    \ credentials =\n\t\t\t\tnew PasswordAuthentication(\"user\", \"GP@ssw0rd\".toCharArray());\n\
    \t\tString salt = \"ThisIsMySalt\";\n\t\tMessageDigest messageDigest = MessageDigest.getInstance(\"\
    SHA-512\");\n\t\tmessageDigest.reset();\n\t\tString credentialsToHash =\n\t\t\t\
    \tcredentials.getUserName() + \":\" + credentials.getPassword();\n\t\tbyte[] hashedCredsAsBytes\
    \ =\n\t\t\t\tmessageDigest.digest((salt+credentialsToHash).getBytes(\"UTF-8\"\
    ));\n\t\tdata = bytesToString(hashedCredsAsBytes);\n\t\t\n\t\t// GOOD: store data\
    \ in a cookie in encrypted form\n\t\tresponse.addCookie(new Cookie(\"auth\", data));\n\
    \t}\n}\n\n```\n\n## References\n* SEI CERT Oracle Coding Standard for Java: [SER03-J.\
    \ Do not serialize unencrypted, sensitive data](https://wiki.sei.cmu.edu/confluence/display/java/SER03-J.+Do+not+serialize+unencrypted+sensitive+data).\n\
    * M. Dowd, J. McDonald and J. Schuhm, *The Art of Software Security Assessment*,\
    \ 1st Edition, Chapter 2 - 'Common Vulnerabilities of Encryption', p. 43. Addison\
    \ Wesley, 2006.\n* M. Howard and D. LeBlanc, *Writing Secure Code*, 2nd Edition,\
    \ Chapter 9 - 'Protecting Secret Data', p. 299. Microsoft, 2002.\n* Common Weakness\
    \ Enumeration: [CWE-499](https://cwe.mitre.org/data/definitions/499.html).\n*\
    \ Common Weakness Enumeration: [CWE-312](https://cwe.mitre.org/data/definitions/312.html).\n"
 -
  pack: codeql/java-queries#0
  relativeQueryPath: Security/CWE/CWE-312/CleartextStorageCookie.ql
  relativeBqrsPath: codeql/java-queries/Security/CWE/CWE-312/CleartextStorageCookie.bqrs
  metadata:
    name: Cleartext storage of sensitive information in cookie
    description: Storing sensitive information in cleartext can expose it to an attacker.
    kind: problem
    problem.severity: error
    security-severity: 5.0
    precision: high
    id: java/cleartext-storage-in-cookie
    tags: |-
      security
             external/cwe/cwe-315
  queryHelp: "# Cleartext storage of sensitive information in cookie\nSensitive information\
    \ that is stored unencrypted is accessible to an attacker who gains access to\
    \ the storage.\n\n\n## Recommendation\nEnsure that sensitive information is always\
    \ encrypted before being stored. It may be wise to encrypt information before\
    \ it is put into a heap data structure (such as `Java.util.Properties`) that may\
    \ be written to disk later. Objects that are serializable or marshallable should\
    \ also always contain encrypted information unless you are certain that they are\
    \ not ever going to be serialized.\n\nIn general, decrypt sensitive information\
    \ only at the point where it is necessary for it to be used in cleartext.\n\n\n\
    ## Example\nThe following example shows two ways of storing user credentials in\
    \ a cookie. In the 'BAD' case, the credentials are simply stored in cleartext.\
    \ In the 'GOOD' case, the credentials are hashed before storing them.\n\n\n```java\n\
    public static void main(String[] args) {\n\t{\n\t\tString data;\n\t\tPasswordAuthentication\
    \ credentials =\n\t\t\t\tnew PasswordAuthentication(\"user\", \"BP@ssw0rd\".toCharArray());\n\
    \t\tdata = credentials.getUserName() + \":\" + new String(credentials.getPassword());\n\
    \t\n\t\t// BAD: store data in a cookie in cleartext form\n\t\tresponse.addCookie(new\
    \ Cookie(\"auth\", data));\n\t}\n\t\n\t{\n\t\tString data;\n\t\tPasswordAuthentication\
    \ credentials =\n\t\t\t\tnew PasswordAuthentication(\"user\", \"GP@ssw0rd\".toCharArray());\n\
    \t\tString salt = \"ThisIsMySalt\";\n\t\tMessageDigest messageDigest = MessageDigest.getInstance(\"\
    SHA-512\");\n\t\tmessageDigest.reset();\n\t\tString credentialsToHash =\n\t\t\t\
    \tcredentials.getUserName() + \":\" + credentials.getPassword();\n\t\tbyte[] hashedCredsAsBytes\
    \ =\n\t\t\t\tmessageDigest.digest((salt+credentialsToHash).getBytes(\"UTF-8\"\
    ));\n\t\tdata = bytesToString(hashedCredsAsBytes);\n\t\t\n\t\t// GOOD: store data\
    \ in a cookie in encrypted form\n\t\tresponse.addCookie(new Cookie(\"auth\", data));\n\
    \t}\n}\n\n```\n\n## References\n* SEI CERT Oracle Coding Standard for Java: [SER03-J.\
    \ Do not serialize unencrypted, sensitive data](https://wiki.sei.cmu.edu/confluence/display/java/SER03-J.+Do+not+serialize+unencrypted+sensitive+data).\n\
    * M. Dowd, J. McDonald and J. Schuhm, *The Art of Software Security Assessment*,\
    \ 1st Edition, Chapter 2 - 'Common Vulnerabilities of Encryption', p. 43. Addison\
    \ Wesley, 2006.\n* M. Howard and D. LeBlanc, *Writing Secure Code*, 2nd Edition,\
    \ Chapter 9 - 'Protecting Secret Data', p. 299. Microsoft, 2002.\n* Common Weakness\
    \ Enumeration: [CWE-315](https://cwe.mitre.org/data/definitions/315.html).\n"
 -
  pack: codeql/java-queries#0
  relativeQueryPath: Security/CWE/CWE-312/CleartextStorageProperties.ql
  relativeBqrsPath: codeql/java-queries/Security/CWE/CWE-312/CleartextStorageProperties.bqrs
  metadata:
    name: Cleartext storage of sensitive information using 'Properties' class
    description: Storing sensitive information in cleartext can expose it to an attacker.
    kind: problem
    problem.severity: warning
    security-severity: 7.5
    precision: medium
    id: java/cleartext-storage-in-properties
    tags: |-
      security
             external/cwe/cwe-313
  queryHelp: "# Cleartext storage of sensitive information using 'Properties' class\n\
    Sensitive information that is stored unencrypted is accessible to an attacker\
    \ who gains access to the storage.\n\n\n## Recommendation\nEnsure that sensitive\
    \ information is always encrypted before being stored. It may be wise to encrypt\
    \ information before it is put into a heap data structure (such as `Java.util.Properties`)\
    \ that may be written to disk later. Objects that are serializable or marshallable\
    \ should also always contain encrypted information unless you are certain that\
    \ they are not ever going to be serialized.\n\nIn general, decrypt sensitive information\
    \ only at the point where it is necessary for it to be used in cleartext.\n\n\n\
    ## Example\nThe following example shows two ways of storing user credentials in\
    \ a cookie. In the 'BAD' case, the credentials are simply stored in cleartext.\
    \ In the 'GOOD' case, the credentials are hashed before storing them.\n\n\n```java\n\
    public static void main(String[] args) {\n\t{\n\t\tString data;\n\t\tPasswordAuthentication\
    \ credentials =\n\t\t\t\tnew PasswordAuthentication(\"user\", \"BP@ssw0rd\".toCharArray());\n\
    \t\tdata = credentials.getUserName() + \":\" + new String(credentials.getPassword());\n\
    \t\n\t\t// BAD: store data in a cookie in cleartext form\n\t\tresponse.addCookie(new\
    \ Cookie(\"auth\", data));\n\t}\n\t\n\t{\n\t\tString data;\n\t\tPasswordAuthentication\
    \ credentials =\n\t\t\t\tnew PasswordAuthentication(\"user\", \"GP@ssw0rd\".toCharArray());\n\
    \t\tString salt = \"ThisIsMySalt\";\n\t\tMessageDigest messageDigest = MessageDigest.getInstance(\"\
    SHA-512\");\n\t\tmessageDigest.reset();\n\t\tString credentialsToHash =\n\t\t\t\
    \tcredentials.getUserName() + \":\" + credentials.getPassword();\n\t\tbyte[] hashedCredsAsBytes\
    \ =\n\t\t\t\tmessageDigest.digest((salt+credentialsToHash).getBytes(\"UTF-8\"\
    ));\n\t\tdata = bytesToString(hashedCredsAsBytes);\n\t\t\n\t\t// GOOD: store data\
    \ in a cookie in encrypted form\n\t\tresponse.addCookie(new Cookie(\"auth\", data));\n\
    \t}\n}\n\n```\n\n## References\n* SEI CERT Oracle Coding Standard for Java: [SER03-J.\
    \ Do not serialize unencrypted, sensitive data](https://wiki.sei.cmu.edu/confluence/display/java/SER03-J.+Do+not+serialize+unencrypted+sensitive+data).\n\
    * M. Dowd, J. McDonald and J. Schuhm, *The Art of Software Security Assessment*,\
    \ 1st Edition, Chapter 2 - 'Common Vulnerabilities of Encryption', p. 43. Addison\
    \ Wesley, 2006.\n* M. Howard and D. LeBlanc, *Writing Secure Code*, 2nd Edition,\
    \ Chapter 9 - 'Protecting Secret Data', p. 299. Microsoft, 2002.\n* Common Weakness\
    \ Enumeration: [CWE-313](https://cwe.mitre.org/data/definitions/313.html).\n"
 -
  pack: codeql/java-queries#0
  relativeQueryPath: Security/CWE/CWE-312/CleartextStorageSharedPrefs.ql
  relativeBqrsPath: codeql/java-queries/Security/CWE/CWE-312/CleartextStorageSharedPrefs.bqrs
  metadata:
    name: Cleartext storage of sensitive information using `SharedPreferences` on
      Android
    description: |-
      Cleartext Storage of Sensitive Information using
                    SharedPreferences on Android allows access for users with root
                    privileges or unexpected exposure from chained vulnerabilities.
    kind: problem
    problem.severity: warning
    security-severity: 7.5
    precision: medium
    id: java/android/cleartext-storage-shared-prefs
    tags: |-
      security
             external/cwe/cwe-312
  queryHelp: "# Cleartext storage of sensitive information using `SharedPreferences`\
    \ on Android\n`SharedPreferences` is an Android API that stores application preferences\
    \ using simple sets of data values. It allows you to easily save, alter, and retrieve\
    \ the values stored in a user's profile. However, sensitive information should\
    \ not be saved in cleartext. Otherwise it can be accessed by any process or user\
    \ in rooted devices, or can be disclosed through chained vulnerabilities, like\
    \ unexpected access to the private storage through exposed components.\n\n\n##\
    \ Recommendation\nUse the `EncryptedSharedPreferences` API or other encryption\
    \ algorithms for storing sensitive information.\n\n\n## Example\nIn the first\
    \ example, sensitive user information is stored in cleartext.\n\nIn the second\
    \ and third examples, the code encrypts sensitive information before saving it\
    \ to the device.\n\n\n```java\npublic void testSetSharedPrefs(Context context,\
    \ String name, String password)\n{\n\t{\n\t\t// BAD - sensitive information saved\
    \ in cleartext.\n\t\tSharedPreferences sharedPrefs = context.getSharedPreferences(\"\
    user_prefs\", Context.MODE_PRIVATE);\n\t\tEditor editor = sharedPrefs.edit();\n\
    \t\teditor.putString(\"name\", name);\n\t\teditor.putString(\"password\", password);\n\
    \t\teditor.commit();\n\t}\n\n\t{\n\t\t// GOOD - save sensitive information encrypted\
    \ with a custom method.\n\t\tSharedPreferences sharedPrefs = context.getSharedPreferences(\"\
    user_prefs\", Context.MODE_PRIVATE);\n\t\tEditor editor = sharedPrefs.edit();\n\
    \t\teditor.putString(\"name\", encrypt(name));\n\t\teditor.putString(\"password\"\
    , encrypt(password));\n\t\teditor.commit();\n\t}\n\n\t{\n\t\t// GOOD - sensitive\
    \ information saved using the built-in `EncryptedSharedPreferences` class in androidx.\n\
    \t\tMasterKey masterKey = new MasterKey.Builder(context, MasterKey.DEFAULT_MASTER_KEY_ALIAS)\n\
    \t\t\t.setKeyScheme(MasterKey.KeyScheme.AES256_GCM)\n\t\t\t.build();\n\n\t\tSharedPreferences\
    \ sharedPreferences = EncryptedSharedPreferences.create(\n\t\t\tcontext,\n\t\t\
    \t\"secret_shared_prefs\",\n\t\t\tmasterKey,\n\t\t\tEncryptedSharedPreferences.PrefKeyEncryptionScheme.AES256_SIV,\n\
    \t\t\tEncryptedSharedPreferences.PrefValueEncryptionScheme.AES256_GCM);\n\n\t\t\
    SharedPreferences.Editor editor = sharedPreferences.edit();\n\t\teditor.putString(\"\
    name\", name);\n\t\teditor.putString(\"password\", password);\n\t\teditor.commit();\n\
    \t}\n}\n\nprivate static String encrypt(String cleartext) throws Exception {\n\
    \t// Use an encryption or hashing algorithm in real world. The demo below just\
    \ returns its\n\t// hash.\n\tMessageDigest digest = MessageDigest.getInstance(\"\
    SHA-256\");\n\tbyte[] hash = digest.digest(cleartext.getBytes(StandardCharsets.UTF_8));\n\
    \tString encoded = Base64.getEncoder().encodeToString(hash);\n\treturn encoded;\n\
    }\n\n```\n\n## References\n* Android Developers: [Work with data more securely](https://developer.android.com/topic/security/data)\n\
    * ProAndroidDev: [Encrypted Preferences in Android](https://proandroiddev.com/encrypted-preferences-in-android-af57a89af7c8)\n\
    * Common Weakness Enumeration: [CWE-312](https://cwe.mitre.org/data/definitions/312.html).\n"
 -
  pack: codeql/java-queries#0
  relativeQueryPath: Security/CWE/CWE-319/HttpsUrls.ql
  relativeBqrsPath: codeql/java-queries/Security/CWE/CWE-319/HttpsUrls.bqrs
  metadata:
    name: Failure to use HTTPS URLs
    description: Non-HTTPS connections can be intercepted by third parties.
    kind: path-problem
    problem.severity: recommendation
    security-severity: 7.5
    precision: medium
    id: java/non-https-url
    tags: |-
      security
             external/cwe/cwe-319
             external/cwe/cwe-345
  queryHelp: "# Failure to use HTTPS URLs\nConstructing URLs with the HTTP protocol\
    \ can lead to unsecured connections.\n\nFurthermore, constructing URLs with the\
    \ HTTP protocol can create problems if other parts of the code expect HTTPS URLs.\
    \ A typical pattern is to cast the `URLConnection` that is produced by `url.getConnection()`\
    \ to an `HttpsURLConnection`. This is impossible if the URL that has been constructed\
    \ uses HTTP rather than HTTPS, and results in a run-time `ClassCastException`.\n\
    \n\n## Recommendation\nWhen you construct a URL using `java.net.URL`, ensure that\
    \ you use an HTTPS URL rather than an HTTP URL. Then, any connections that are\
    \ made using that URL are secure SSL connections.\n\n\n## Example\nThe following\
    \ example shows two ways of opening a connection using a URL. When the connection\
    \ is opened using an HTTP URL rather than an HTTPS URL, the connection is unsecured,\
    \ and in this case a `ClassCastException` is caused. When the connection is opened\
    \ using an HTTPS URL, the connection is a secure SSL connection.\n\n\n```java\n\
    public static void main(String[] args) {\n\t{\n\t\ttry {\n\t\t\tString protocol\
    \ = \"http://\";\n\t\t\tURL u = new URL(protocol + \"www.secret.example.org/\"\
    );\n\t\t\t// BAD: This causes a 'ClassCastException' at runtime, because the\n\
    \t\t\t// HTTP URL cannot be used to make an 'HttpsURLConnection', \n\t\t\t// which\
    \ enforces SSL.\n\t\t\tHttpsURLConnection hu = (HttpsURLConnection) u.openConnection();\n\
    \t\t\thu.setRequestMethod(\"PUT\");\n\t\t\thu.connect();\n\t\t\tOutputStream os\
    \ = hu.getOutputStream();\n\t\t\thu.disconnect();\n\t\t}\n\t\tcatch (IOException\
    \ e) {\n\t\t\t// fail\n\t\t}\n\t}\n\t\n\t{\n\t\ttry {\n\t\t\tString protocol =\
    \ \"https://\";\n\t\t\tURL u = new URL(protocol + \"www.secret.example.org/\"\
    );\n\t\t\t// GOOD: Opening a connection to a URL using HTTPS enforces SSL.\n\t\
    \t\tHttpsURLConnection hu = (HttpsURLConnection) u.openConnection();\n\t\t\thu.setRequestMethod(\"\
    PUT\");\n\t\t\thu.connect();\n\t\t\tOutputStream os = hu.getOutputStream();\n\t\
    \t\thu.disconnect();\n\t\t}\n\t\tcatch (IOException e) {\n\t\t\t// fail\n\t\t\
    }\n\t}\n}\n```\n\n## References\n* SEI CERT Oracle Coding Standard for Java: [SER03-J.\
    \ Do not serialize unencrypted, sensitive data](https://wiki.sei.cmu.edu/confluence/display/java/SER03-J.+Do+not+serialize+unencrypted+sensitive+data).\n\
    * Java API Specification: [ Class HttpsURLConnection](https://docs.oracle.com/en/java/javase/11/docs/api/java.base/javax/net/ssl/HttpsURLConnection.html).\n\
    * OWASP: [Transport Layer Protection Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/Transport_Layer_Protection_Cheat_Sheet.html).\n\
    * Common Weakness Enumeration: [CWE-319](https://cwe.mitre.org/data/definitions/319.html).\n\
    * Common Weakness Enumeration: [CWE-345](https://cwe.mitre.org/data/definitions/345.html).\n"
 -
  pack: codeql/java-queries#0
  relativeQueryPath: Security/CWE/CWE-319/UseSSL.ql
  relativeBqrsPath: codeql/java-queries/Security/CWE/CWE-319/UseSSL.bqrs
  metadata:
    name: Failure to use SSL
    description: Non-SSL connections can be intercepted by third parties.
    kind: problem
    problem.severity: recommendation
    security-severity: 7.5
    precision: medium
    id: java/non-ssl-connection
    tags: |-
      security
             external/cwe/cwe-319
  queryHelp: "# Failure to use SSL\nUsing a stream that is derived from a non-SSL\
    \ connection or socket can result in an unsecured connection that is vulnerable\
    \ to interception.\n\n\n## Recommendation\nUse `javax.net.ssl.HttpsURLConnection`\
    \ and `javax.net.ssl.SSLSocket` instead of the corresponding unsecured versions\
    \ in `java.net`. If necessary, downcast from an `HttpURLConnection` to an `HttpsURLConnection`\
    \ to enforce the use of SSL. In addition, when you construct a `java.net.URL`,\
    \ ensure that you use the HTTPS protocol, to avoid exceptions when trying to make\
    \ HTTPS connections to the URL.\n\n\n## Example\nThe following example shows two\
    \ ways of opening an output stream. When the stream is opened using `httpcon`,\
    \ which is an `HttpURLConnection`, the connection does not use SSL, and therefore\
    \ is vulnerable to attack. When the stream is opened using `httpscon`, the connection\
    \ is a secured SSL connection.\n\n\n```java\npublic static void main(String[]\
    \ args) {\n\t{\n\t\ttry {\n\t\t\tURL u = new URL(\"http://www.secret.example.org/\"\
    );\n\t\t\tHttpURLConnection httpcon = (HttpURLConnection) u.openConnection();\n\
    \t\t\thttpcon.setRequestMethod(\"PUT\");\n\t\t\thttpcon.connect();\n\t\t\t// BAD:\
    \ output stream from non-HTTPS connection\n\t\t\tOutputStream os = httpcon.getOutputStream();\n\
    \t\t\thttpcon.disconnect();\n\t\t}\n\t\tcatch (IOException e) {\n\t\t\t// fail\n\
    \t\t}\n\t}\n\t\n\t{\n\t\ttry {\n\t\t\tURL u = new URL(\"https://www.secret.example.org/\"\
    );\n\t\t\tHttpsURLConnection httpscon = (HttpsURLConnection) u.openConnection();\n\
    \t\t\thttpscon.setRequestMethod(\"PUT\");\n\t\t\thttpscon.connect();\n\t\t\t//\
    \ GOOD: output stream from HTTPS connection\n\t\t\tOutputStream os = httpscon.getOutputStream();\n\
    \t\t\thttpscon.disconnect();\n\t\t}\n\t\tcatch (IOException e) {\n\t\t\t// fail\n\
    \t\t}\n\t}\n}\n```\n\n## References\n* SEI CERT Oracle Coding Standard for Java:\
    \ [SER03-J. Do not serialize unencrypted, sensitive data](https://wiki.sei.cmu.edu/confluence/display/java/SER03-J.+Do+not+serialize+unencrypted+sensitive+data).\n\
    * Java API Specification: [ Class HttpsURLConnection](https://docs.oracle.com/en/java/javase/11/docs/api/java.base/javax/net/ssl/HttpsURLConnection.html).\n\
    * Java API Specification: [ Class SSLSocket](https://docs.oracle.com/en/java/javase/11/docs/api/java.base/javax/net/ssl/SSLSocket.html).\n\
    * OWASP: [Transport Layer Protection Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/Transport_Layer_Protection_Cheat_Sheet.html).\n\
    * Common Weakness Enumeration: [CWE-319](https://cwe.mitre.org/data/definitions/319.html).\n"
 -
  pack: codeql/java-queries#0
  relativeQueryPath: Security/CWE/CWE-319/UseSSLSocketFactories.ql
  relativeBqrsPath: codeql/java-queries/Security/CWE/CWE-319/UseSSLSocketFactories.bqrs
  metadata:
    name: Failure to use SSL socket factories
    description: |-
      Connections that are specified by non-SSL socket factories can be intercepted by
                    third parties.
    kind: problem
    problem.severity: recommendation
    security-severity: 7.5
    precision: medium
    id: java/non-ssl-socket-factory
    tags: |-
      security
             external/cwe/cwe-319
  queryHelp: |
    # Failure to use SSL socket factories
    Various networking and Remote Method Invocation (RMI) methods may use `SocketFactories` to specify the kind of connections to use. Using the default factory or a non-SSL factory leads to vulnerable connections.


    ## Recommendation
    Use SSL factories instead of the default factories. SSL factories can be found in `javax.net.ssl` or `java.rmi.ssl`. If you want to define your own custom factories, consider inheriting from one of the SSL factories.


    ## Example
    The following example shows two ways of using RMI to export an object. The first use of `exportObject` uses the default socket factories. The second use of `exportObject` uses explicit SSL factories, which are preferable.


    ```java
    public static void main(String[] args) {
        {
            try {
                TestImpl obj = new TestImpl();

                // BAD: default socket factory is used
                Test stub = (Test) UnicastRemoteObject.exportObject(obj, 0);
            } catch (Exception e) {
                // fail
            }
        }

        {
            try {
                TestImpl obj = new TestImpl();
                SslRMIClientSocketFactory csf = new SslRMIClientSocketFactory();
                SslRMIServerSocketFactory ssf = new SslRMIServerSocketFactory();

                // GOOD: SSL factories are used
                Test stub = (Test) UnicastRemoteObject.exportObject(obj, 0, csf, ssf);
            } catch (Exception e) {
                // fail
            }
        }
    }

    ```

    ## References
    * SEI CERT Oracle Coding Standard for Java: [SER03-J. Do not serialize unencrypted, sensitive data](https://wiki.sei.cmu.edu/confluence/display/java/SER03-J.+Do+not+serialize+unencrypted+sensitive+data).
    * Java API Specification: [ Class SSLSocketFactory](https://docs.oracle.com/en/java/javase/11/docs/api/java.base/javax/net/ssl/SSLSocketFactory.html).
    * OWASP: [Transport Layer Protection Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/Transport_Layer_Protection_Cheat_Sheet.html).
    * Common Weakness Enumeration: [CWE-319](https://cwe.mitre.org/data/definitions/319.html).
 -
  pack: codeql/java-queries#0
  relativeQueryPath: Security/CWE/CWE-326/InsufficientKeySize.ql
  relativeBqrsPath: codeql/java-queries/Security/CWE/CWE-326/InsufficientKeySize.bqrs
  metadata:
    name: Use of a cryptographic algorithm with insufficient key size
    description: |-
      Using cryptographic algorithms with too small a key size can
                    allow an attacker to compromise security.
    kind: path-problem
    problem.severity: warning
    security-severity: 7.5
    precision: high
    id: java/insufficient-key-size
    tags: |-
      security
             external/cwe/cwe-326
  queryHelp: |
    # Use of a cryptographic algorithm with insufficient key size
    Modern encryption relies on the computational infeasibility of breaking a cipher and decoding its message without the key. As computational power increases, the ability to break ciphers grows, and key sizes need to become larger as a result. Cryptographic algorithms that use too small of a key size are vulnerable to brute force attacks, which can reveal sensitive data.


    ## Recommendation
    Use a key of the recommended size or larger. The key size should be at least 128 bits for AES encryption, 256 bits for elliptic-curve cryptography (ECC), and 2048 bits for RSA, DSA, or DH encryption.


    ## Example
    The following code uses cryptographic algorithms with insufficient key sizes.


    ```java
        KeyPairGenerator keyPairGen1 = KeyPairGenerator.getInstance("RSA");
        keyPairGen1.initialize(1024); // BAD: Key size is less than 2048

        KeyPairGenerator keyPairGen2 = KeyPairGenerator.getInstance("DSA");
        keyPairGen2.initialize(1024); // BAD: Key size is less than 2048

        KeyPairGenerator keyPairGen3 = KeyPairGenerator.getInstance("DH");
        keyPairGen3.initialize(1024); // BAD: Key size is less than 2048

        KeyPairGenerator keyPairGen4 = KeyPairGenerator.getInstance("EC");
        ECGenParameterSpec ecSpec = new ECGenParameterSpec("secp112r1"); // BAD: Key size is less than 256
        keyPairGen4.initialize(ecSpec);

        KeyGenerator keyGen = KeyGenerator.getInstance("AES");
        keyGen.init(64); // BAD: Key size is less than 128

    ```
    To fix the code, change the key sizes to be the recommended size or larger for each algorithm.


    ## References
    * Wikipedia: [Key size](http://en.wikipedia.org/wiki/Key_size).
    * Wikipedia: [Strong cryptography](https://en.wikipedia.org/wiki/Strong_cryptography).
    * OWASP: [ Cryptographic Storage Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/Cryptographic_Storage_Cheat_Sheet.html#algorithms).
    * OWASP: [ Testing for Weak Encryption](https://owasp.org/www-project-web-security-testing-guide/stable/4-Web_Application_Security_Testing/09-Testing_for_Weak_Cryptography/04-Testing_for_Weak_Encryption).
    * NIST: [ Transitioning the Use of Cryptographic Algorithms and Key Lengths](https://nvlpubs.nist.gov/nistpubs/SpecialPublications/NIST.SP.800-131Ar2.pdf).
    * Common Weakness Enumeration: [CWE-326](https://cwe.mitre.org/data/definitions/326.html).
 -
  pack: codeql/java-queries#0
  relativeQueryPath: Security/CWE/CWE-327/BrokenCryptoAlgorithm.ql
  relativeBqrsPath: codeql/java-queries/Security/CWE/CWE-327/BrokenCryptoAlgorithm.bqrs
  metadata:
    name: Use of a broken or risky cryptographic algorithm
    description: Using broken or weak cryptographic algorithms can allow an attacker
      to compromise security.
    kind: path-problem
    problem.severity: warning
    security-severity: 7.5
    precision: high
    id: java/weak-cryptographic-algorithm
    tags: |-
      security
             external/cwe/cwe-327
             external/cwe/cwe-328
  queryHelp: "# Use of a broken or risky cryptographic algorithm\nUsing broken or\
    \ weak cryptographic algorithms can leave data vulnerable to being decrypted.\n\
    \nMany cryptographic algorithms provided by cryptography libraries are known to\
    \ be weak, or flawed. Using such an algorithm means that an attacker may be able\
    \ to easily decrypt the encrypted data.\n\n\n## Recommendation\nEnsure that you\
    \ use a strong, modern cryptographic algorithm. Use at least AES-128 or RSA-2048.\
    \ Do not use the ECB encryption mode since it is vulnerable to replay and other\
    \ attacks.\n\n\n## Example\nThe following code shows an example of using a java\
    \ `Cipher` to encrypt some data. When creating a `Cipher` instance, you must specify\
    \ the encryption algorithm to use. The first example uses DES, which is an older\
    \ algorithm that is now considered weak. The second example uses AES, which is\
    \ a strong modern algorithm.\n\n\n```java\n// BAD: DES is a weak algorithm \n\
    Cipher des = Cipher.getInstance(\"DES\");\ncipher.init(Cipher.ENCRYPT_MODE, secretKeySpec);\n\
    \nbyte[] encrypted = cipher.doFinal(input.getBytes(\"UTF-8\"));\n\n// ...\n\n\
    // GOOD: AES is a strong algorithm\nCipher aes = Cipher.getInstance(\"AES\");\n\
    \n// ...\n\n```\n\n## References\n* NIST, FIPS 140 Annex a: [ Approved Security\
    \ Functions](http://csrc.nist.gov/publications/fips/fips140-2/fips1402annexa.pdf).\n\
    * NIST, SP 800-131A: [ Transitions: Recommendation for Transitioning the Use of\
    \ Cryptographic Algorithms and Key Lengths](http://nvlpubs.nist.gov/nistpubs/SpecialPublications/NIST.SP.800-131Ar1.pdf).\n\
    * Common Weakness Enumeration: [CWE-327](https://cwe.mitre.org/data/definitions/327.html).\n\
    * Common Weakness Enumeration: [CWE-328](https://cwe.mitre.org/data/definitions/328.html).\n"
 -
  pack: codeql/java-queries#0
  relativeQueryPath: Security/CWE/CWE-327/MaybeBrokenCryptoAlgorithm.ql
  relativeBqrsPath: codeql/java-queries/Security/CWE/CWE-327/MaybeBrokenCryptoAlgorithm.bqrs
  metadata:
    name: Use of a potentially broken or risky cryptographic algorithm
    description: Using broken or weak cryptographic algorithms can allow an attacker
      to compromise security.
    kind: path-problem
    problem.severity: warning
    security-severity: 7.5
    precision: medium
    id: java/potentially-weak-cryptographic-algorithm
    tags: |-
      security
             external/cwe/cwe-327
             external/cwe/cwe-328
  queryHelp: "# Use of a potentially broken or risky cryptographic algorithm\nUsing\
    \ broken or weak cryptographic algorithms can leave data vulnerable to being decrypted.\n\
    \nMany cryptographic algorithms provided by cryptography libraries are known to\
    \ be weak, or flawed. Using such an algorithm means that an attacker may be able\
    \ to easily decrypt the encrypted data.\n\n\n## Recommendation\nEnsure that you\
    \ use a strong, modern cryptographic algorithm. Use at least AES-128 or RSA-2048.\
    \ Do not use the ECB encryption mode since it is vulnerable to replay and other\
    \ attacks.\n\n\n## Example\nThe following code shows an example of using a java\
    \ `Cipher` to encrypt some data. When creating a `Cipher` instance, you must specify\
    \ the encryption algorithm to use. The first example uses DES, which is an older\
    \ algorithm that is now considered weak. The second example uses AES, which is\
    \ a strong modern algorithm.\n\n\n```java\n// BAD: DES is a weak algorithm \n\
    Cipher des = Cipher.getInstance(\"DES\");\ncipher.init(Cipher.ENCRYPT_MODE, secretKeySpec);\n\
    \nbyte[] encrypted = cipher.doFinal(input.getBytes(\"UTF-8\"));\n\n// ...\n\n\
    // GOOD: AES is a strong algorithm\nCipher aes = Cipher.getInstance(\"AES\");\n\
    \n// ...\n\n```\n\n## References\n* NIST, FIPS 140 Annex a: [ Approved Security\
    \ Functions](http://csrc.nist.gov/publications/fips/fips140-2/fips1402annexa.pdf).\n\
    * NIST, SP 800-131A: [ Transitions: Recommendation for Transitioning the Use of\
    \ Cryptographic Algorithms and Key Lengths](http://nvlpubs.nist.gov/nistpubs/SpecialPublications/NIST.SP.800-131Ar1.pdf).\n\
    * Common Weakness Enumeration: [CWE-327](https://cwe.mitre.org/data/definitions/327.html).\n\
    * Common Weakness Enumeration: [CWE-328](https://cwe.mitre.org/data/definitions/328.html).\n"
 -
  pack: codeql/java-queries#0
  relativeQueryPath: Security/CWE/CWE-330/InsecureRandomness.ql
  relativeBqrsPath: codeql/java-queries/Security/CWE/CWE-330/InsecureRandomness.bqrs
  metadata:
    name: Insecure randomness
    description: |-
      Using a cryptographically Insecure pseudo-random number generator to generate a
                    security-sensitive value may allow an attacker to predict what value will
                    be generated.
    kind: path-problem
    problem.severity: warning
    security-severity: 7.8
    precision: high
    id: java/insecure-randomness
    tags: |-
      security
            external/cwe/cwe-330
            external/cwe/cwe-338
  queryHelp: |
    # Insecure randomness
    If you use a cryptographically weak pseudo-random number generator to generate security-sensitive values, such as passwords, attackers can more easily predict those values.

    Pseudo-random number generators generate a sequence of numbers that only approximates the properties of random numbers. The sequence is not truly random because it is completely determined by a relatively small set of initial values (the seed). If the random number generator is cryptographically weak, then this sequence may be easily predictable through outside observations.


    ## Recommendation
    The `java.util.Random` random number generator is not cryptographically secure. Use a secure random number generator such as `java.security.SecureRandom` instead.

    Use a cryptographically secure pseudo-random number generator if the output is to be used in a security-sensitive context. As a general rule, a value should be considered "security-sensitive" if predicting it would allow the attacker to perform an action that they would otherwise be unable to perform. For example, if an attacker could predict the random password generated for a new user, they would be able to log in as that new user.


    ## Example
    The following examples show different ways of generating a cookie with a random value.

    In the first (BAD) case, we generate a fresh cookie by appending a random integer to the end of a static string. The random number generator used (`Random`) is not cryptographically secure, so it may be possible for an attacker to predict the generated cookie.


    ```java
    Random r = new Random();

    byte[] bytes = new byte[16];
    r.nextBytes(bytes);

    String cookieValue = encode(bytes);

    Cookie cookie = new Cookie("name", cookieValue);
    response.addCookie(cookie);

    ```
    In the second (GOOD) case, we generate a fresh cookie by appending a random integer to the end of a static string. The random number generator used (`SecureRandom`) is cryptographically secure, so it is not possible for an attacker to predict the generated cookie.


    ```java
    SecureRandom r = new SecureRandom();

    byte[] bytes = new byte[16];
    r.nextBytes(bytes);

    String cookieValue = encode(bytes);

    Cookie cookie = new Cookie("name", cookieValue);
    response.addCookie(cookie);

    ```

    ## References
    * Wikipedia: [Pseudo-random number generator](http://en.wikipedia.org/wiki/Pseudorandom_number_generator).
    * Java Docs: [Random](http://docs.oracle.com/javase/8/docs/api/java/util/Random.html).
    * Java Docs: [SecureRandom](http://docs.oracle.com/javase/8/docs/api/java/security/SecureRandom.html).
    * Common Weakness Enumeration: [CWE-330](https://cwe.mitre.org/data/definitions/330.html).
    * Common Weakness Enumeration: [CWE-338](https://cwe.mitre.org/data/definitions/338.html).
 -
  pack: codeql/java-queries#0
  relativeQueryPath: Security/CWE/CWE-335/PredictableSeed.ql
  relativeBqrsPath: codeql/java-queries/Security/CWE/CWE-335/PredictableSeed.bqrs
  metadata:
    name: Use of a predictable seed in a secure random number generator
    description: Using a predictable seed in a pseudo-random number generator can
      lead to predictability of the numbers generated by it.
    kind: problem
    problem.severity: error
    security-severity: 9.8
    precision: high
    id: java/predictable-seed
    tags: |-
      security
             external/cwe/cwe-335
             external/cwe/cwe-337
  queryHelp: |
    # Use of a predictable seed in a secure random number generator
    Using a predictable seed in a pseudo-random number generator can lead to predictability of the numbers generated by it.


    ## Recommendation
    If the predictability of the pseudo-random number generator does not matter then consider using the faster `Random` class from `java.util`. If it is important that the pseudo-random number generator produces completely unpredictable values then either let the generator securely seed itself by not specifying a seed or specify a randomly generated, unpredictable seed.


    ## Example
    In the first example shown here, a constant value is used as a seed. Depending on the implementation of ` SecureRandom`, this could lead to the same random number being generated each time the code is executed.

    In the second example shown here, the system time is used as a seed. Depending on the implementation of ` SecureRandom`, if an attacker knows what time the code was run, they could predict the generated random number.

    In the third example shown here, the random number generator is allowed to generate its own seed, which it will do in a secure way.


    ```java
    SecureRandom prng = new SecureRandom();
    int randomData = 0;

    // BAD: Using a constant value as a seed for a random number generator means all numbers it generates are predictable.
    prng.setSeed(12345L);
    randomData = prng.next(32);

    // BAD: System.currentTimeMillis() returns the system time which is predictable.
    prng.setSeed(System.currentTimeMillis());
    randomData = prng.next(32);

    // GOOD: SecureRandom implementations seed themselves securely by default.
    prng = new SecureRandom();
    randomData = prng.next(32);

    ```

    ## References
    * Common Weakness Enumeration: [CWE-335](https://cwe.mitre.org/data/definitions/335.html).
    * Common Weakness Enumeration: [CWE-337](https://cwe.mitre.org/data/definitions/337.html).
 -
  pack: codeql/java-queries#0
  relativeQueryPath: Security/CWE/CWE-338/JHipsterGeneratedPRNG.ql
  relativeBqrsPath: codeql/java-queries/Security/CWE/CWE-338/JHipsterGeneratedPRNG.bqrs
  metadata:
    name: Detect JHipster Generator Vulnerability CVE-2019-16303
    description: Using a vulnerable version of JHipster to generate random numbers
      makes it easier for attackers to take over accounts.
    kind: problem
    problem.severity: error
    security-severity: 7.8
    precision: very-high
    id: java/jhipster-prng
    tags: |-
      security
             external/cwe/cwe-338
  queryHelp: |
    # Detect JHipster Generator Vulnerability CVE-2019-16303
    This query detects instances of `RandomUtil.java` that were generated by a [JHipster](https://www.jhipster.tech/) version that is vulnerable to [CVE-2019-16303](https://github.com/jhipster/jhipster-kotlin/security/advisories/GHSA-j3rh-8vwq-wh84).

    If an app uses `RandomUtil.java` generated by a vulnerable version of JHipster, attackers can request a password reset token and use this to predict the value of future reset tokens generated by this server. Using this information, they can create a reset link that allows them to take over any account.

    This vulnerability has a [ CVSS v3.0 Base Score of 9.8/10 ](https://nvd.nist.gov/vuln-metrics/cvss/v3-calculator?name=CVE-2019-16303&vector=AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H&version=3.1&source=NIST).


    ## Example
    The example below shows the vulnerable `RandomUtil` class generated by [JHipster prior to version 6.3.0](https://www.jhipster.tech/2019/09/13/jhipster-release-6.3.0.html).


    ```java
    import org.apache.commons.lang3.RandomStringUtils;

    /**
     * Utility class for generating random Strings.
     */
    public final class RandomUtil {

        private static final int DEF_COUNT = 20;

        private RandomUtil() {
        }

        /**
         * Generate a password.
         *
         * @return the generated password.
         */
        public static String generatePassword() {
            return RandomStringUtils.randomAlphanumeric(DEF_COUNT); // BAD: RandomStringUtils does not use SecureRandom
        }

        /**
         * Generate an activation key.
         *
         * @return the generated activation key.
         */
        public static String generateActivationKey() {
            return RandomStringUtils.randomNumeric(DEF_COUNT); // BAD: RandomStringUtils does not use SecureRandom
        }

        /**
         * Generate a reset key.
         *
         * @return the generated reset key.
         */
        public static String generateResetKey() {
            return RandomStringUtils.randomNumeric(DEF_COUNT); // BAD: RandomStringUtils does not use SecureRandom
        }

        /**
         * Generate a unique series to validate a persistent token, used in the
         * authentication remember-me mechanism.
         *
         * @return the generated series data.
         */
        public static String generateSeriesData() {
            return RandomStringUtils.randomAlphanumeric(DEF_COUNT); // BAD: RandomStringUtils does not use SecureRandom
        }

        /**
         * Generate a persistent token, used in the authentication remember-me mechanism.
         *
         * @return the generated token data.
         */
        public static String generateTokenData() {
            return RandomStringUtils.randomAlphanumeric(DEF_COUNT); // BAD: RandomStringUtils does not use SecureRandom
        }
    }

    ```
    Below is a fixed version of the `RandomUtil` class.


    ```java
    import org.apache.commons.lang3.RandomStringUtils;

    import java.security.SecureRandom;

    /**
     * Utility class for generating random Strings.
     */
    public final class RandomUtil {
        private static final SecureRandom SECURE_RANDOM = new SecureRandom(); // GOOD: Using SecureRandom

        private static final int DEF_COUNT = 20;

        static {
            SECURE_RANDOM.nextBytes(new byte[64]);
        }

        private RandomUtil() {
        }

        private static String generateRandomAlphanumericString() {
            // GOOD: Passing Secure Random to RandomStringUtils::random
            return RandomStringUtils.random(DEF_COUNT, 0, 0, true, true, null, SECURE_RANDOM);
        }

        /**
         * Generate a password.
         *
         * @return the generated password.
         */
        public static String generatePassword() {
            return generateRandomAlphanumericString();
        }

        /**
         * Generate an activation key.
         *
         * @return the generated activation key.
         */
        public static String generateActivationKey() {
            return generateRandomAlphanumericString();
        }

        /**
         * Generate a reset key.
         *
         * @return the generated reset key.
         */
        public static String generateResetKey() {
            return generateRandomAlphanumericString();
        }

        /**
         * Generate a unique series to validate a persistent token, used in the
         * authentication remember-me mechanism.
         *
         * @return the generated series data.
         */
        public static String generateSeriesData() {
            return generateRandomAlphanumericString();
        }

        /**
         * Generate a persistent token, used in the authentication remember-me mechanism.
         *
         * @return the generated token data.
         */
        public static String generateTokenData() {
            return generateRandomAlphanumericString();
        }
    }

    ```

    ## Recommendation
    You should refactor the `RandomUtil` class and replace every call to `RandomStringUtils.randomAlphaNumeric`. You could regenerate the class using the latest version of JHipster, or use an automated refactoring. For example, using the [Patching JHipster CWE-338](https://github.com/moderneinc/jhipster-cwe-338) for the [Rewrite project](https://github.com/openrewrite/rewrite).


    ## References
    * Cloudflare Blog: [ Why secure systems require random numbers ](https://blog.cloudflare.com/why-randomness-matters/)
    * Hacker News: [ How I Hacked Hacker News (with arc security advisory) ](https://news.ycombinator.com/item?id=639976)
    * Posts by Pucara Information Security Team: [ The Java Soothsayer: A practical application for insecure randomness. (Includes free 0day) ](https://blog.pucarasec.com/2020/05/09/the-java-soothsayer-a-practical-application-for-insecure-randomness-includes-free-0day/)
    * Common Weakness Enumeration: [CWE-338](https://cwe.mitre.org/data/definitions/338.html).
 -
  pack: codeql/java-queries#0
  relativeQueryPath: Security/CWE/CWE-347/MissingJWTSignatureCheck.ql
  relativeBqrsPath: codeql/java-queries/Security/CWE/CWE-347/MissingJWTSignatureCheck.bqrs
  metadata:
    name: Missing JWT signature check
    description: Failing to check the Json Web Token (JWT) signature may allow an
      attacker to forge their own tokens.
    kind: path-problem
    problem.severity: error
    security-severity: 7.8
    precision: high
    id: java/missing-jwt-signature-check
    tags: |-
      security
             external/cwe/cwe-347
  queryHelp: |
    # Missing JWT signature check
    A JSON Web Token (JWT) consists of three parts: header, payload, and signature. The `io.jsonwebtoken.jjwt` library is one of many libraries used for working with JWTs. It offers different methods for parsing tokens like `parse`, `parseClaimsJws`, and `parsePlaintextJws`. The last two correctly verify that the JWT is properly signed. This is done by computing the signature of the combination of header and payload and comparing the locally computed signature with the signature part of the JWT.

    Therefore it is necessary to provide the `JwtParser` with a key that is used for signature validation. Unfortunately the `parse` method **accepts** a JWT whose signature is empty although a signing key has been set for the parser. This means that an attacker can create arbitrary JWTs that will be accepted if this method is used.


    ## Recommendation
    Always verify the signature by using either the `parseClaimsJws` and `parsePlaintextJws` methods or by overriding the `onPlaintextJws` or `onClaimsJws` of `JwtHandlerAdapter`.


    ## Example
    The following example shows four cases where a signing key is set for a parser. In the first 'BAD' case the `parse` method is used, which will not validate the signature. The second 'BAD' case uses a `JwtHandlerAdapter` where the `onPlaintextJwt` method is overriden, so it will not validate the signature. The third and fourth 'GOOD' cases use `parseClaimsJws` method or override the `onPlaintextJws` method.


    ```java
    public void badJwt(String token) {
        Jwts.parserBuilder()
                    .setSigningKey("someBase64EncodedKey").build()
                    .parse(token); // BAD: Does not verify the signature
    }

    public void badJwtHandler(String token) {
        Jwts.parserBuilder()
                    .setSigningKey("someBase64EncodedKey").build()
                    .parse(plaintextJwt, new JwtHandlerAdapter<Jwt<Header, String>>() {
                        @Override
                        public Jwt<Header, String> onPlaintextJwt(Jwt<Header, String> jwt) {
                            return jwt;
                        }
                    }); // BAD: The handler is called on an unverified JWT
    }

    public void goodJwt(String token) {
        Jwts.parserBuilder()
                    .setSigningKey("someBase64EncodedKey").build()
                    .parseClaimsJws(token) // GOOD: Verify the signature
                    .getBody();
    }

    public void goodJwtHandler(String token) {
        Jwts.parserBuilder()
                    .setSigningKey("someBase64EncodedKey").build()
                    .parse(plaintextJwt, new JwtHandlerAdapter<Jws<String>>() {
                        @Override
                        public Jws<String> onPlaintextJws(Jws<String> jws) {
                            return jws;
                        }
                    }); // GOOD: The handler is called on a verified JWS
    }
    ```

    ## References
    * zofrex: [How I Found An alg=none JWT Vulnerability in the NHS Contact Tracing App](https://www.zofrex.com/blog/2020/10/20/alg-none-jwt-nhs-contact-tracing-app/).
    * Common Weakness Enumeration: [CWE-347](https://cwe.mitre.org/data/definitions/347.html).
 -
  pack: codeql/java-queries#0
  relativeQueryPath: Security/CWE/CWE-352/SpringCSRFProtection.ql
  relativeBqrsPath: codeql/java-queries/Security/CWE/CWE-352/SpringCSRFProtection.bqrs
  metadata:
    name: Disabled Spring CSRF protection
    description: |-
      Disabling CSRF protection makes the application vulnerable to
                    a Cross-Site Request Forgery (CSRF) attack.
    kind: problem
    problem.severity: error
    security-severity: 8.8
    precision: high
    id: java/spring-disabled-csrf-protection
    tags: |-
      security
             external/cwe/cwe-352
  queryHelp: "# Disabled Spring CSRF protection\nWhen you set up a web server to receive\
    \ a request from a client without any mechanism for verifying that it was intentionally\
    \ sent, then it is vulnerable to attack. An attacker can trick a client into making\
    \ an unintended request to the web server that will be treated as an authentic\
    \ request. This can be done via a URL, image load, XMLHttpRequest, etc. and can\
    \ result in exposure of data or unintended code execution.\n\n\n## Recommendation\n\
    When you use Spring, Cross-Site Request Forgery (CSRF) protection is enabled by\
    \ default. Spring's recommendation is to use CSRF protection for any request that\
    \ could be processed by a browser client by normal users.\n\n\n## Example\nThe\
    \ following example shows the Spring Java configuration with CSRF protection disabled.\
    \ This type of configuration should only be used if you are creating a service\
    \ that is used only by non-browser clients.\n\n\n```java\nimport org.springframework.context.annotation.Configuration;\n\
    import org.springframework.security.config.annotation.web.builders.HttpSecurity;\n\
    import org.springframework.security.config.annotation.web.configuration.EnableWebSecurity;\n\
    import org.springframework.security.config.annotation.web.configuration.WebSecurityConfigurerAdapter;\n\
    \n@EnableWebSecurity\n@Configuration\npublic class WebSecurityConfig extends WebSecurityConfigurerAdapter\
    \ {\n  @Override\n  protected void configure(HttpSecurity http) throws Exception\
    \ {\n    http\n      .csrf(csrf ->\n        // BAD - CSRF protection shouldn't\
    \ be disabled\n        csrf.disable() \n      );\n  }\n}\n\n```\n\n## References\n\
    * OWASP: [Cross-Site Request Forgery (CSRF)](https://www.owasp.org/index.php/Cross-Site_Request_Forgery_(CSRF)).\n\
    * Spring Security Reference: [ Cross Site Request Forgery (CSRF) ](https://docs.spring.io/spring-security/reference/servlet/exploits/csrf.html).\n\
    * Common Weakness Enumeration: [CWE-352](https://cwe.mitre.org/data/definitions/352.html).\n"
 -
  pack: codeql/java-queries#0
  relativeQueryPath: Security/CWE/CWE-367/TOCTOURace.ql
  relativeBqrsPath: codeql/java-queries/Security/CWE/CWE-367/TOCTOURace.bqrs
  metadata:
    name: Time-of-check time-of-use race condition
    description: |-
      Using a resource after an unsynchronized state check can lead to a race condition,
                    if the state may be changed between the check and use.
    kind: problem
    problem.severity: warning
    security-severity: 7.7
    precision: medium
    id: java/toctou-race-condition
    tags: |-
      security
             external/cwe/cwe-367
  queryHelp: "# Time-of-check time-of-use race condition\nOften it is necessary to\
    \ check the state of a resource before using it. If the resource is accessed concurrently,\
    \ then the check and the use need to be performed atomically, otherwise the state\
    \ of the resource may change between the check and the use. This can lead to a\
    \ \"time-of-check/time-of-use\" (TOCTOU) race condition.\n\nIn Java, classes may\
    \ present state inspection methods and operation methods which are synchronized.\
    \ This prevents multiple threads from executing those methods simultaneously,\
    \ but it does not prevent a state change in between separate method invocations.\n\
    \n\n## Recommendation\nWhen calling a series of methods which require a consistent\
    \ view of an object, make sure to synchronize on a monitor that will prevent any\
    \ other access to the object during your operations.\n\nIf the class that you\
    \ are using has a well-designed interface, then synchronizing on the object itself\
    \ will prevent its state being changed inappropriately.\n\n\n## Example\nThe following\
    \ example shows a resource which has a readiness state, and an action that is\
    \ only valid if the resource is ready.\n\nIn the bad case, the caller checks the\
    \ readiness state and then acts, but does not synchronize around the two calls,\
    \ so the readiness state may be changed by another thread.\n\nIn the good case,\
    \ the caller jointly synchronizes the check and the use on the resource, so no\
    \ other thread can modify the state before the use.\n\n\n```java\nclass Resource\
    \ {\n\tpublic synchronized boolean isReady() { ... }\n\n\tpublic synchronized\
    \ void setReady(boolean ready) { ... }\n\t\n\tpublic synchronized void act() {\
    \ \n\t\tif (!isReady())\n\t\t\tthrow new IllegalStateException();\n\t\t...\n\t\
    }\n}\n\t\npublic synchronized void bad(Resource r) {\n\tif (r.isReady()) {\n\t\
    \t// r might no longer be ready, another thread might\n\t\t// have called setReady(false)\n\
    \t\tr.act();\n\t}\n}\n\npublic synchronized void good(Resource r) {\n\tsynchronized(r)\
    \ {\n\t\tif (r.isReady()) {\n\t\t\tr.act();\n\t\t}\n\t}\n}\n```\n\n## References\n\
    * Common Weakness Enumeration: [CWE-367](https://cwe.mitre.org/data/definitions/367.html).\n"
 -
  pack: codeql/java-queries#0
  relativeQueryPath: Security/CWE/CWE-421/SocketAuthRace.ql
  relativeBqrsPath: codeql/java-queries/Security/CWE/CWE-421/SocketAuthRace.bqrs
  metadata:
    name: Race condition in socket authentication
    description: Opening a socket after authenticating via a different channel may
      allow an attacker to connect to the port first.
    kind: problem
    problem.severity: warning
    security-severity: 7.2
    precision: medium
    id: java/socket-auth-race-condition
    tags: |-
      security
             external/cwe/cwe-421
  queryHelp: "# Race condition in socket authentication\nA common pattern is to have\
    \ a channel of communication open with a user, and then to open another channel,\
    \ for example to transfer data. However, if user authentication is done over the\
    \ original channel rather than the alternate channel, then an attacker may be\
    \ able to connect to the alternate channel before the legitimate user does. This\
    \ allows the attacker to impersonate the user by \"piggybacking\" on any previous\
    \ authentication.\n\n\n## Recommendation\nWhen opening an alternate channel for\
    \ an authenticated user (for example, a Java `Socket`), always authenticate the\
    \ user over the new channel.\n\n\n## Example\nThis example shows two ways of opening\
    \ a connection for a user. In the first example, authentication is determined\
    \ based on materials that the user has already provided (for example, their username\
    \ and/or password), and then a new channel is opened. However, no authentication\
    \ is done over the new channel, and so an attacker could connect to it before\
    \ the user connects.\n\nIn the second example, authentication is done over the\
    \ socket channel itself, which verifies that the newly connected user is in fact\
    \ the user that was expected.\n\n\n```java\npublic void doConnect(int desiredPort,\
    \ String username) {\n\tServerSocket listenSocket = new ServerSocket(desiredPort);\n\
    \n\tif (isAuthenticated(username)) {\n\t\tSocket connection1 = listenSocket.accept();\n\
    \t\t// BAD: no authentication over the socket connection\n\t\tconnection1.getOutputStream().write(secretData);\n\
    \t}\n}\n\npublic void doConnect(int desiredPort, String username) {\n\tServerSocket\
    \ listenSocket = new ServerSocket(desiredPort);\n\n\tSocket connection2 = listenSocket.accept();\n\
    \t// GOOD: authentication happens over the socket\n\tif (doAuthenticate(connection2,\
    \ username)) {\n\t\tconnection2.getOutputStream().write(secretData);\n\t}\n}\n\
    ```\n\n## References\n* Common Weakness Enumeration: [CWE-421](https://cwe.mitre.org/data/definitions/421.html).\n"
 -
  pack: codeql/java-queries#0
  relativeQueryPath: Security/CWE/CWE-441/UnsafeContentUriResolution.ql
  relativeBqrsPath: codeql/java-queries/Security/CWE/CWE-441/UnsafeContentUriResolution.bqrs
  metadata:
    name: Uncontrolled data used in content resolution
    description: |-
      Resolving externally-provided content URIs without validation can allow an attacker
                    to access unexpected resources.
    kind: path-problem
    problem.severity: warning
    security-severity: 7.5
    precision: high
    id: java/android/unsafe-content-uri-resolution
    tags: |-
      security
           external/cwe/cwe-441
           external/cwe/cwe-610
  queryHelp: |
    # Uncontrolled data used in content resolution
    When an Android application wants to access data in a content provider, it uses the `ContentResolver` object. `ContentResolver`s communicate with an instance of a class that implements the `ContentProvider` interface via URIs with the `content://` scheme. The authority part (the first path segment) of the URI, passed as parameter to the `ContentResolver`, determines which content provider is contacted for the operation. Specific operations that act on files also support the `file://` scheme, in which case the local filesystem is queried instead. If an external component, like a malicious or compromised application, controls the URI for a `ContentResolver` operation, it can trick the vulnerable application into accessing its own private files or non-exported content providers. The attacking application might be able to get access to the file by forcing it to be copied to a public directory, like external storage, or tamper with the contents by making the application overwrite the file with unexpected data.


    ## Recommendation
    If possible, avoid using externally-provided data to determine the URI for a `ContentResolver` to use. If that is not an option, validate that the incoming URI can only reference trusted components, like an allow list of content providers and/or applications, or alternatively make sure that the URI does not reference private directories like `/data/`.


    ## Example
    This example shows three ways of opening a file using a `ContentResolver`. In the first case, externally-provided data from an intent is used directly in the file-reading operation. This allows an attacker to provide a URI of the form `/data/data/(vulnerable app package)/(private file)` to trick the application into reading it and copying it to the external storage. In the second case, an insufficient check is performed on the externally-provided URI, still leaving room for exploitation. In the third case, the URI is correctly validated before being used, making sure it does not reference any internal application files.


    ```java
    import android.content.ContentResolver;
    import android.net.Uri;

    public class Example extends Activity {
        public void onCreate() {
            // BAD: Externally-provided URI directly used in content resolution
            {
                ContentResolver contentResolver = getContentResolver();
                Uri uri = (Uri) getIntent().getParcelableExtra("URI_EXTRA");
                InputStream is = contentResolver.openInputStream(uri);
                copyToExternalCache(is);
            }
            // BAD: input URI is not normalized, and check can be bypassed with ".." characters
            {
                ContentResolver contentResolver = getContentResolver();
                Uri uri = (Uri) getIntent().getParcelableExtra("URI_EXTRA");
                String path = uri.getPath();
                if (path.startsWith("/data"))
                    throw new SecurityException();
                InputStream is = contentResolver.openInputStream(uri);
                copyToExternalCache(is);
            }
            // GOOD: URI is properly validated to block access to internal files
            {
                ContentResolver contentResolver = getContentResolver();
                Uri uri = (Uri) getIntent().getParcelableExtra("URI_EXTRA");
                String path = uri.getPath();
                java.nio.file.Path normalized =
                        java.nio.file.FileSystems.getDefault().getPath(path).normalize();
                if (normalized.startsWith("/data"))
                    throw new SecurityException();
                InputStream is = contentResolver.openInputStream(uri);
                copyToExternalCache(is);
            }
        }

        private void copyToExternalCache(InputStream is) {
            // Reads the contents of is and writes a file in the app's external
            // cache directory, which can be read publicly by applications in the same device.
        }
    }

    ```

    ## References
    * Android developers: [Content provider basics](https://developer.android.com/guide/topics/providers/content-provider-basics)
    * [The ContentResolver class](https://developer.android.com/reference/android/content/ContentResolver)
    * Common Weakness Enumeration: [CWE-441](https://cwe.mitre.org/data/definitions/441.html).
    * Common Weakness Enumeration: [CWE-610](https://cwe.mitre.org/data/definitions/610.html).
 -
  pack: codeql/java-queries#0
  relativeQueryPath: Security/CWE/CWE-470/FragmentInjection.ql
  relativeBqrsPath: codeql/java-queries/Security/CWE/CWE-470/FragmentInjection.bqrs
  metadata:
    name: Android fragment injection
    description: |-
      Instantiating an Android fragment from a user-provided value
                    may allow a malicious application to bypass access controls,  exposing the application to unintended effects.
    kind: path-problem
    problem.severity: error
    security-severity: 9.8
    precision: high
    id: java/android/fragment-injection
    tags: |-
      security
             external/cwe/cwe-470
  queryHelp: |
    # Android fragment injection
    When fragments are instantiated with externally provided names, this exposes any exported activity that dynamically creates and hosts the fragment to fragment injection. A malicious application could provide the name of an arbitrary fragment, even one not designed to be externally accessible, and inject it into the activity. This can bypass access controls and expose the application to unintended effects.

    Fragments are reusable parts of an Android application's user interface. Even though a fragment controls its own lifecycle and layout, and handles its input events, it cannot exist on its own: it must be hosted either by an activity or another fragment. This means that, normally, a fragment will be accessible by third-party applications (that is, exported) only if its hosting activity is itself exported.


    ## Recommendation
    In general, do not instantiate classes (including fragments) with user-provided names unless the name has been properly validated. Also, if an exported activity is extending the `PreferenceActivity` class, make sure that the `isValidFragment` method is overriden and only returns `true` when the provided `fragmentName` points to an intended fragment.


    ## Example
    The following example shows two cases: in the first one, untrusted data is used to instantiate and add a fragment to an activity, while in the second one, a fragment is safely added with a static name.


    ```java
    public class MyActivity extends FragmentActivity {

        @Override
        protected void onCreate(Bundle savedInstance) {
            try {
                super.onCreate(savedInstance);
                // BAD: Fragment instantiated from user input without validation
                {
                    String fName = getIntent().getStringExtra("fragmentName");
                    getFragmentManager().beginTransaction().replace(com.android.internal.R.id.prefs,
                            Fragment.instantiate(this, fName, null)).commit();
                }
                // GOOD: Fragment instantiated statically
                {
                    getFragmentManager().beginTransaction()
                            .replace(com.android.internal.R.id.prefs, new MyFragment()).commit();
                }
            } catch (Exception e) {
            }
        }

    }

    ```
    The next example shows two activities that extend `PreferenceActivity`. The first activity overrides `isValidFragment`, but it wrongly returns `true` unconditionally. The second activity correctly overrides `isValidFragment` so that it only returns `true` when `fragmentName` is a trusted fragment name.


    ```java
    class UnsafeActivity extends PreferenceActivity {

        @Override
        protected boolean isValidFragment(String fragmentName) {
            // BAD: any Fragment name can be provided.
            return true;
        }
    }


    class SafeActivity extends PreferenceActivity {
        @Override
        protected boolean isValidFragment(String fragmentName) {
            // Good: only trusted Fragment names are allowed.
            return SafeFragment1.class.getName().equals(fragmentName)
                    || SafeFragment2.class.getName().equals(fragmentName)
                    || SafeFragment3.class.getName().equals(fragmentName);
        }

    }


    ```

    ## References
    * Google Help: [How to fix Fragment Injection vulnerability](https://support.google.com/faqs/answer/7188427?hl=en).
    * IBM Security Systems: [Android collapses into Fragments](https://securityintelligence.com/wp-content/uploads/2013/12/android-collapses-into-fragments.pdf).
    * Android Developers: [Fragments](https://developer.android.com/guide/fragments)
    * Common Weakness Enumeration: [CWE-470](https://cwe.mitre.org/data/definitions/470.html).
 -
  pack: codeql/java-queries#0
  relativeQueryPath: Security/CWE/CWE-470/FragmentInjectionInPreferenceActivity.ql
  relativeBqrsPath: codeql/java-queries/Security/CWE/CWE-470/FragmentInjectionInPreferenceActivity.bqrs
  metadata:
    name: Android fragment injection in PreferenceActivity
    description: |-
      An insecure implementation of the 'isValidFragment' method
                    of the 'PreferenceActivity' class may allow a malicious application to bypass access controls,
                    exposing the application to unintended effects.
    kind: problem
    problem.severity: error
    security-severity: 9.8
    precision: high
    id: java/android/fragment-injection-preference-activity
    tags: |-
      security
             external/cwe/cwe-470
  queryHelp: |
    # Android fragment injection in PreferenceActivity
    When fragments are instantiated with externally provided names, this exposes any exported activity that dynamically creates and hosts the fragment to fragment injection. A malicious application could provide the name of an arbitrary fragment, even one not designed to be externally accessible, and inject it into the activity. This can bypass access controls and expose the application to unintended effects.

    Fragments are reusable parts of an Android application's user interface. Even though a fragment controls its own lifecycle and layout, and handles its input events, it cannot exist on its own: it must be hosted either by an activity or another fragment. This means that, normally, a fragment will be accessible by third-party applications (that is, exported) only if its hosting activity is itself exported.


    ## Recommendation
    In general, do not instantiate classes (including fragments) with user-provided names unless the name has been properly validated. Also, if an exported activity is extending the `PreferenceActivity` class, make sure that the `isValidFragment` method is overriden and only returns `true` when the provided `fragmentName` points to an intended fragment.


    ## Example
    The following example shows two cases: in the first one, untrusted data is used to instantiate and add a fragment to an activity, while in the second one, a fragment is safely added with a static name.


    ```java
    public class MyActivity extends FragmentActivity {

        @Override
        protected void onCreate(Bundle savedInstance) {
            try {
                super.onCreate(savedInstance);
                // BAD: Fragment instantiated from user input without validation
                {
                    String fName = getIntent().getStringExtra("fragmentName");
                    getFragmentManager().beginTransaction().replace(com.android.internal.R.id.prefs,
                            Fragment.instantiate(this, fName, null)).commit();
                }
                // GOOD: Fragment instantiated statically
                {
                    getFragmentManager().beginTransaction()
                            .replace(com.android.internal.R.id.prefs, new MyFragment()).commit();
                }
            } catch (Exception e) {
            }
        }

    }

    ```
    The next example shows two activities that extend `PreferenceActivity`. The first activity overrides `isValidFragment`, but it wrongly returns `true` unconditionally. The second activity correctly overrides `isValidFragment` so that it only returns `true` when `fragmentName` is a trusted fragment name.


    ```java
    class UnsafeActivity extends PreferenceActivity {

        @Override
        protected boolean isValidFragment(String fragmentName) {
            // BAD: any Fragment name can be provided.
            return true;
        }
    }


    class SafeActivity extends PreferenceActivity {
        @Override
        protected boolean isValidFragment(String fragmentName) {
            // Good: only trusted Fragment names are allowed.
            return SafeFragment1.class.getName().equals(fragmentName)
                    || SafeFragment2.class.getName().equals(fragmentName)
                    || SafeFragment3.class.getName().equals(fragmentName);
        }

    }


    ```

    ## References
    * Google Help: [How to fix Fragment Injection vulnerability](https://support.google.com/faqs/answer/7188427?hl=en).
    * IBM Security Systems: [Android collapses into Fragments](https://securityintelligence.com/wp-content/uploads/2013/12/android-collapses-into-fragments.pdf).
    * Android Developers: [Fragments](https://developer.android.com/guide/fragments)
    * Common Weakness Enumeration: [CWE-470](https://cwe.mitre.org/data/definitions/470.html).
 -
  pack: codeql/java-queries#0
  relativeQueryPath: Security/CWE/CWE-489/DebuggableAttributeEnabled.ql
  relativeBqrsPath: codeql/java-queries/Security/CWE/CWE-489/DebuggableAttributeEnabled.bqrs
  metadata:
    name: Android debuggable attribute enabled
    description: An enabled debugger can allow for entry points in the application
      or reveal sensitive information.
    kind: problem
    problem.severity: warning
    security-severity: 7.2
    id: java/android/debuggable-attribute-enabled
    tags: |-
      security
             external/cwe/cwe-489
    precision: very-high
  queryHelp: |
    # Android debuggable attribute enabled
    The Android manifest file defines configuration settings for Android applications. In this file, the `android:debuggable` attribute of the `application` element can be used to define whether or not the application can be debugged. When set to `true`, this attribute will allow the application to be debugged even when running on a device in user mode.

    When a debugger is enabled, it could allow for entry points in the application or reveal sensitive information. As a result, `android:debuggable` should only be enabled during development and should be disabled in production builds.


    ## Recommendation
    In Android applications, either set the `android:debuggable` attribute to `false`, or do not include it in the manifest. The default value, when not included, is `false`.


    ## Example
    In the example below, the `android:debuggable` attribute is set to `true`.


    ```xml
    <manifest ... >
        <!-- BAD: 'android:debuggable' set to 'true' -->
        <application
            android:debuggable="true">
            <activity ... >
            </activity>
        </application>
    </manifest>

    ```
    The corrected version sets the `android:debuggable` attribute to `false`.


    ```xml
    <manifest ... >
        <!-- GOOD: 'android:debuggable' set to 'false' -->
        <application
            android:debuggable="false">
            <activity ... >
            </activity>
        </application>
    </manifest>

    ```

    ## References
    * Android Developers: [App Manifest Overview](https://developer.android.com/guide/topics/manifest/manifest-intro).
    * Android Developers: [The android:debuggable attribute](https://developer.android.com/guide/topics/manifest/application-element#debug).
    * Android Developers: [Enable debugging](https://developer.android.com/studio/debug#enable-debug).
    * Common Weakness Enumeration: [CWE-489](https://cwe.mitre.org/data/definitions/489.html).
 -
  pack: codeql/java-queries#0
  relativeQueryPath: Security/CWE/CWE-489/WebviewDebuggingEnabled.ql
  relativeBqrsPath: codeql/java-queries/Security/CWE/CWE-489/WebviewDebuggingEnabled.bqrs
  metadata:
    name: Android Webview debugging enabled
    description: Enabling Webview debugging in production builds can expose entry
      points or leak sensitive information.
    kind: path-problem
    problem.severity: warning
    security-severity: 7.2
    id: java/android/webview-debugging-enabled
    tags: |-
      security
             external/cwe/cwe-489
    precision: high
  queryHelp: "# Android Webview debugging enabled\nThe `WebView.setWebContentsDebuggingEnabled`\
    \ method enables or disables the contents of any `WebView` in the application\
    \ to be debugged.\n\nYou should only enable debugging features during development.\
    \ When you create a production build, you should disable it. If you enable debugging\
    \ features, this can make your code vulnerable by adding entry points, or leaking\
    \ sensitive information.\n\n\n## Recommendation\nEnsure that debugging features\
    \ are not enabled in production builds, such as by guarding calls to `WebView.setWebContentsDebuggingEnabled(true)`\
    \ by a flag that is only enabled in debug builds.\n\n\n## Example\nIn the first\
    \ (bad) example, WebView debugging is always enabled. whereas the GOOD case only\
    \ enables it if the `android:debuggable` attribute is set to `true`.\n\n\n```java\n\
    // BAD - debugging is always enabled \nWebView.setWebContentsDebuggingEnabled(true);\n\
    \n// GOOD - debugging is only enabled when this is a debug build, as indicated\
    \ by the debuggable flag being set.\nif (0 != (getApplicationInfo().flags & ApplicationInfo.FLAG_DEBUGGABLE))\
    \ {\n    WebView.setWebContentsDebuggingEnabled(true);\n}\n```\n\n## References\n\
    * Android Developers: [setWebContentsDebuggingEnabled](https://developer.android.com/reference/android/webkit/WebView.html#setWebContentsDebuggingEnabled(boolean)).\n\
    * Android Developers: [Remote debugging WebViews](https://developer.chrome.com/docs/devtools/remote-debugging/webviews/).\n\
    * Common Weakness Enumeration: [CWE-489](https://cwe.mitre.org/data/definitions/489.html).\n"
 -
  pack: codeql/java-queries#0
  relativeQueryPath: Security/CWE/CWE-501/TrustBoundaryViolation.ql
  relativeBqrsPath: codeql/java-queries/Security/CWE/CWE-501/TrustBoundaryViolation.bqrs
  metadata:
    id: java/trust-boundary-violation
    name: Trust boundary violation
    description: Modifying the HTTP session attributes based on data from an untrusted
      source may violate a trust boundary.
    kind: path-problem
    problem.severity: error
    security-severity: 8.8
    precision: medium
    tags: |-
      security
            external/cwe/cwe-501
  queryHelp: |
    # Trust boundary violation
    A trust boundary violation occurs when a value is passed from a less trusted context to a more trusted context.

    For example, a value that is generated by a less trusted source, such as a user, may be passed to a more trusted source, such as a system process. If the less trusted source is malicious, then the value may be crafted to exploit the more trusted source.

    Trust boundary violations are often caused by a failure to validate input. For example, if a web application accepts a cookie from a user, then the application should validate the cookie before using it. If the cookie is not validated, then the user may be able to craft a malicious cookie that exploits the application.


    ## Recommendation
    To maintain a trust boundary, validate data from less trusted sources before use.


    ## Example
    In the first (bad) example, the server accepts a parameter from the user, then uses it to set the username without validation.


    ```java
    public void doGet(HttpServletRequest request, HttpServletResponse response) {
        String username = request.getParameter("username");

        // BAD: The input is written to the session without being sanitized.
        request.getSession().setAttribute("username", username);
    }
    ```
    In the second (good) example, the server validates the parameter from the user, then uses it to set the username.


    ```java
    public void doGet(HttpServletRequest request, HttpServletResponse response) {
        String username = request.getParameter("username");

        if (validator.isValidInput("HTTP parameter", username, "username", 20, false)) {
            // GOOD: The input is sanitized before being written to the session.
            request.getSession().setAttribute("username", username);
        }
    }
    ```

    ## References
    * Wikipedia: [Trust boundary](http://en.wikipedia.org/wiki/Trust_boundary).
    * Common Weakness Enumeration: [CWE-501](https://cwe.mitre.org/data/definitions/501.html).
 -
  pack: codeql/java-queries#0
  relativeQueryPath: Security/CWE/CWE-502/UnsafeDeserialization.ql
  relativeBqrsPath: codeql/java-queries/Security/CWE/CWE-502/UnsafeDeserialization.bqrs
  metadata:
    name: Deserialization of user-controlled data
    description: |-
      Deserializing user-controlled data may allow attackers to
                    execute arbitrary code.
    kind: path-problem
    problem.severity: error
    security-severity: 9.8
    precision: high
    id: java/unsafe-deserialization
    tags: |-
      security
             external/cwe/cwe-502
  queryHelp: |
    # Deserialization of user-controlled data
    Deserializing untrusted data using any deserialization framework that allows the construction of arbitrary serializable objects is easily exploitable and in many cases allows an attacker to execute arbitrary code. Even before a deserialized object is returned to the caller of a deserialization method a lot of code may have been executed, including static initializers, constructors, and finalizers. Automatic deserialization of fields means that an attacker may craft a nested combination of objects on which the executed initialization code may have unforeseen effects, such as the execution of arbitrary code.

    There are many different serialization frameworks. This query currently supports Kryo, XmlDecoder, XStream, SnakeYaml, JYaml, JsonIO, YAMLBeans, HessianBurlap, Castor, Burlap, Jackson, Jabsorb, Jodd JSON, Flexjson, Gson, JMS, and Java IO serialization through `ObjectInputStream`/`ObjectOutputStream`.


    ## Recommendation
    Avoid deserialization of untrusted data if at all possible. If the architecture permits it then use other formats instead of serialized objects, for example JSON or XML. However, these formats should not be deserialized into complex objects because this provides further opportunities for attack. For example, XML-based deserialization attacks are possible through libraries such as XStream and XmlDecoder.

    Alternatively, a tightly controlled whitelist can limit the vulnerability of code, but be aware of the existence of so-called Bypass Gadgets, which can circumvent such protection measures.

    Recommendations specific to particular frameworks supported by this query:

    **FastJson** - `com.alibaba:fastjson`

    * **Secure by Default**: Partially
    * **Recommendation**: Call `com.alibaba.fastjson.parser.ParserConfig#setSafeMode` with the argument `true` before deserializing untrusted data.


    **FasterXML** - `com.fasterxml.jackson.core:jackson-databind`

    * **Secure by Default**: Yes
    * **Recommendation**: Don't call `com.fasterxml.jackson.databind.ObjectMapper#enableDefaultTyping` and don't annotate any object fields with `com.fasterxml.jackson.annotation.JsonTypeInfo` passing either the `CLASS` or `MINIMAL_CLASS` values to the annotation. Read [this guide](https://cowtowncoder.medium.com/jackson-2-10-safe-default-typing-2d018f0ce2ba).


    **Kryo** - `com.esotericsoftware:kryo` and `com.esotericsoftware:kryo5`

    * **Secure by Default**: Yes for `com.esotericsoftware:kryo5` and for `com.esotericsoftware:kryo` &gt;= v5.0.0
    * **Recommendation**: Don't call `com.esotericsoftware.kryo(5).Kryo#setRegistrationRequired` with the argument `false` on any `Kryo` instance that may deserialize untrusted data.


    **ObjectInputStream** - `Java Standard Library`

    * **Secure by Default**: No
    * **Recommendation**: Use a validating input stream, such as `org.apache.commons.io.serialization.ValidatingObjectInputStream`.


    **SnakeYAML** - `org.yaml:snakeyaml`

    * **Secure by Default**: No
    * **Recommendation**: Pass an instance of `org.yaml.snakeyaml.constructor.SafeConstructor` to `org.yaml.snakeyaml.Yaml`'s constructor before using it to deserialize untrusted data.


    **XML Decoder** - `Standard Java Library`

    * **Secure by Default**: No
    * **Recommendation**: Do not use with untrusted user input.


    **ObjectMesssage** - `Java EE/Jakarta EE`

    * **Secure by Default**: Depends on the JMS implementation.
    * **Recommendation**: Do not use with untrusted user input.



    ## Example
    The following example calls `readObject` directly on an `ObjectInputStream` that is constructed from untrusted data, and is therefore inherently unsafe.


    ```java
    public MyObject {
      public int field;
      MyObject(int field) {
        this.field = field;
      }
    }

    public MyObject deserialize(Socket sock) {
      try(ObjectInputStream in = new ObjectInputStream(sock.getInputStream())) {
        return (MyObject)in.readObject(); // unsafe
      }
    }

    ```
    Rewriting the communication protocol to only rely on reading primitive types from the input stream removes the vulnerability.


    ```java
    public MyObject deserialize(Socket sock) {
      try(DataInputStream in = new DataInputStream(sock.getInputStream())) {
        return new MyObject(in.readInt());
      }
    }

    ```

    ## References
    * OWASP vulnerability description: [Deserialization of untrusted data](https://www.owasp.org/index.php/Deserialization_of_untrusted_data).
    * OWASP guidance on deserializing objects: [Deserialization Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/Deserialization_Cheat_Sheet.html).
    * Talks by Chris Frohoff &amp; Gabriel Lawrence: [ AppSecCali 2015: Marshalling Pickles - how deserializing objects will ruin your day](http://frohoff.github.io/appseccali-marshalling-pickles/), [OWASP SD: Deserialize My Shorts: Or How I Learned to Start Worrying and Hate Java Object Deserialization](http://frohoff.github.io/owaspsd-deserialize-my-shorts/).
    * Alvaro Muoz &amp; Christian Schneider, RSAConference 2016: [Serial Killer: Silently Pwning Your Java Endpoints](https://speakerdeck.com/pwntester/serial-killer-silently-pwning-your-java-endpoints).
    * SnakeYaml documentation on deserialization: [SnakeYaml deserialization](https://bitbucket.org/snakeyaml/snakeyaml/wiki/Documentation#markdown-header-loading-yaml).
    * Hessian deserialization and related gadget chains: [Hessian deserialization](https://paper.seebug.org/1137/).
    * Castor and Hessian java deserialization vulnerabilities: [Castor and Hessian deserialization](https://securitylab.github.com/research/hessian-java-deserialization-castor-vulnerabilities/).
    * Remote code execution in JYaml library: [JYaml deserialization](https://www.cybersecurity-help.cz/vdb/SB2020022512).
    * JsonIO deserialization vulnerabilities: [JsonIO deserialization](https://klezvirus.github.io/Advanced-Web-Hacking/Serialisation/).
    * Research by Moritz Bechler: [Java Unmarshaller Security - Turning your data into code execution](https://www.github.com/mbechler/marshalsec/blob/master/marshalsec.pdf?raw=true)
    * Blog posts by the developer of Jackson libraries: [On Jackson CVEs: Dont Panic  Here is what you need to know](https://cowtowncoder.medium.com/on-jackson-cves-dont-panic-here-is-what-you-need-to-know-54cd0d6e8062) [Jackson 2.10: Safe Default Typing](https://cowtowncoder.medium.com/jackson-2-10-safe-default-typing-2d018f0ce2ba)
    * Jabsorb documentation on deserialization: [Jabsorb JSON Serializer](https://github.com/Servoy/jabsorb/blob/master/src/org/jabsorb/).
    * Jodd JSON documentation on deserialization: [JoddJson Parser](https://json.jodd.org/parser).
    * RCE in Flexjson: [Flexjson deserialization](https://codewhitesec.blogspot.com/2020/03/liferay-portal-json-vulns.html).
    * Android Intent deserialization vulnerabilities with GSON parser: [Insecure use of JSON parsers](https://blog.oversecured.com/Exploiting-memory-corruption-vulnerabilities-on-Android/#insecure-use-of-json-parsers).
    * Research by Matthias Kaiser: [Pwning Your Java Messaging With Deserialization Vulnerabilities](https://www.blackhat.com/docs/us-16/materials/us-16-Kaiser-Pwning-Your-Java-Messaging-With-Deserialization-Vulnerabilities.pdf).
    * Common Weakness Enumeration: [CWE-502](https://cwe.mitre.org/data/definitions/502.html).
 -
  pack: codeql/java-queries#0
  relativeQueryPath: Security/CWE/CWE-522/InsecureBasicAuth.ql
  relativeBqrsPath: codeql/java-queries/Security/CWE/CWE-522/InsecureBasicAuth.bqrs
  metadata:
    name: Insecure basic authentication
    description: |-
      Basic authentication only obfuscates username/password in
                    Base64 encoding, which can be easily recognized and reversed.
                    Transmitting sensitive information without using HTTPS makes
                    the data vulnerable to packet sniffing.
    kind: path-problem
    problem.severity: warning
    security-severity: 8.8
    precision: medium
    id: java/insecure-basic-auth
    tags: |-
      security
             external/cwe/cwe-522
             external/cwe/cwe-319
  queryHelp: |
    # Insecure basic authentication
    Basic authentication only obfuscates usernames and passwords in Base64 encoding, which can be easily recognized and reversed, thus it must not be transmitted over the cleartext HTTP channel. Transmitting sensitive information without using HTTPS makes the data vulnerable to packet sniffing.


    ## Recommendation
    Either use a more secure authentication mechanism like digest authentication or federated authentication, or use the HTTPS communication protocol.


    ## Example
    The following example shows two ways of using basic authentication. In the 'BAD' case, the credentials are transmitted over HTTP. In the 'GOOD' case, the credentials are transmitted over HTTPS.


    ```java
    public class InsecureBasicAuth {
      /**
       * Test basic authentication with Apache HTTP request.
       */
      public void testApacheHttpRequest(String username, String password) {

        // BAD: basic authentication over HTTP
        String url = "http://www.example.com/rest/getuser.do?uid=abcdx";

        // GOOD: basic authentication over HTTPS
        url = "https://www.example.com/rest/getuser.do?uid=abcdx";

        HttpPost post = new HttpPost(url);
        post.setHeader("Accept", "application/json");
        post.setHeader("Content-type", "application/json");

        String authString = username + ":" + password;
        byte[] authEncBytes = Base64.getEncoder().encode(authString.getBytes());
        String authStringEnc = new String(authEncBytes);

        post.addHeader("Authorization", "Basic " + authStringEnc);
      }

      /**
       * Test basic authentication with Java HTTP URL connection.
       */
      public void testHttpUrlConnection(String username, String password) {

        // BAD: basic authentication over HTTP
        String urlStr = "http://www.example.com/rest/getuser.do?uid=abcdx";

        // GOOD: basic authentication over HTTPS
        urlStr = "https://www.example.com/rest/getuser.do?uid=abcdx";

        String authString = username + ":" + password;
        String encoding = Base64.getEncoder().encodeToString(authString.getBytes("UTF-8"));
        URL url = new URL(urlStr);
        HttpURLConnection conn = (HttpURLConnection) url.openConnection();
        conn.setRequestMethod("POST");
        conn.setDoOutput(true);
        conn.setRequestProperty("Authorization", "Basic " + encoding);
      }
    }

    ```

    ## References
    * SonarSource rule: [Basic authentication should not be used](https://rules.sonarsource.com/java/tag/owasp/RSPEC-2647).
    * Acunetix: [WEB VULNERABILITIES INDEX - Basic authentication over HTTP](https://www.acunetix.com/vulnerabilities/web/basic-authentication-over-http/).
    * Common Weakness Enumeration: [CWE-522](https://cwe.mitre.org/data/definitions/522.html).
    * Common Weakness Enumeration: [CWE-319](https://cwe.mitre.org/data/definitions/319.html).
 -
  pack: codeql/java-queries#0
  relativeQueryPath: Security/CWE/CWE-522/InsecureLdapAuth.ql
  relativeBqrsPath: codeql/java-queries/Security/CWE/CWE-522/InsecureLdapAuth.bqrs
  metadata:
    name: Insecure LDAP authentication
    description: LDAP authentication with credentials sent in cleartext makes sensitive
      information vulnerable to remote attackers
    kind: path-problem
    problem.severity: error
    security-severity: 8.8
    precision: high
    id: java/insecure-ldap-auth
    tags: |-
      security
             external/cwe/cwe-522
             external/cwe/cwe-319
  queryHelp: |
    # Insecure LDAP authentication
    When using the Java LDAP API to perform LDAPv3-style extended operations and controls, a context with connection properties including user credentials is started. Transmission of LDAP credentials in cleartext allows remote attackers to obtain sensitive information by sniffing the network.


    ## Recommendation
    Use the `ldaps://` protocol to send credentials through SSL or use SASL authentication.


    ## Example
    In the following (bad) example, a `ldap://` URL is used and credentials will be sent in plaintext.


    ```java
    String ldapUrl = "ldap://ad.your-server.com:389";
    Hashtable<String, String> environment = new Hashtable<String, String>();
    environment.put(Context.INITIAL_CONTEXT_FACTORY, "com.sun.jndi.ldap.LdapCtxFactory");
    environment.put(Context.PROVIDER_URL, ldapUrl);
    environment.put(Context.REFERRAL, "follow");
    environment.put(Context.SECURITY_AUTHENTICATION, "simple");
    environment.put(Context.SECURITY_PRINCIPAL, ldapUserName);
    environment.put(Context.SECURITY_CREDENTIALS, password);
    DirContext dirContext = new InitialDirContext(environment);

    ```
    In the following (good) example, a `ldaps://` URL is used so credentials will be encrypted with SSL.


    ```java
    String ldapUrl = "ldaps://ad.your-server.com:636";
    Hashtable<String, String> environment = new Hashtable<String, String>();
    environment.put(Context.INITIAL_CONTEXT_FACTORY, "com.sun.jndi.ldap.LdapCtxFactory");
    environment.put(Context.PROVIDER_URL, ldapUrl);
    environment.put(Context.REFERRAL, "follow");
    environment.put(Context.SECURITY_AUTHENTICATION, "simple");
    environment.put(Context.SECURITY_PRINCIPAL, ldapUserName);
    environment.put(Context.SECURITY_CREDENTIALS, password);
    DirContext dirContext = new InitialDirContext(environment);

    ```
    In the following (good) example, a `ldap://` URL is used, but SASL authentication is enabled so that the credentials will be encrypted.


    ```java
    String ldapUrl = "ldap://ad.your-server.com:389";
    Hashtable<String, String> environment = new Hashtable<String, String>();
    environment.put(Context.INITIAL_CONTEXT_FACTORY, "com.sun.jndi.ldap.LdapCtxFactory");
    environment.put(Context.PROVIDER_URL, ldapUrl);
    environment.put(Context.REFERRAL, "follow");
    environment.put(Context.SECURITY_AUTHENTICATION, "DIGEST-MD5 GSSAPI");
    environment.put(Context.SECURITY_PRINCIPAL, ldapUserName);
    environment.put(Context.SECURITY_CREDENTIALS, password);
    DirContext dirContext = new InitialDirContext(environment);

    ```

    ## References
    * Oracle: [LDAP and LDAPS URLs](https://docs.oracle.com/javase/jndi/tutorial/ldap/misc/url.html)
    * Oracle: [Simple authentication](https://docs.oracle.com/javase/tutorial/jndi/ldap/simple.html)
    * Common Weakness Enumeration: [CWE-522](https://cwe.mitre.org/data/definitions/522.html).
    * Common Weakness Enumeration: [CWE-319](https://cwe.mitre.org/data/definitions/319.html).
 -
  pack: codeql/java-queries#0
  relativeQueryPath: Security/CWE/CWE-524/SensitiveKeyboardCache.ql
  relativeBqrsPath: codeql/java-queries/Security/CWE/CWE-524/SensitiveKeyboardCache.bqrs
  metadata:
    name: Android sensitive keyboard cache
    description: Allowing the keyboard to cache sensitive information may result in
      information leaks to other applications.
    kind: problem
    problem.severity: warning
    security-severity: 8.1
    id: java/android/sensitive-keyboard-cache
    tags: |-
      security
             external/cwe/cwe-524
    precision: medium
  queryHelp: "# Android sensitive keyboard cache\nWhen a user enters information in\
    \ a text input field on an Android application, their input is saved to a keyboard\
    \ cache which provides autocomplete suggestions and predictions. There is a risk\
    \ that sensitive user data, such as passwords or banking information, may be leaked\
    \ to other applications via the keyboard cache.\n\n\n## Recommendation\nFor input\
    \ fields expected to accept sensitive information, use input types such as `\"\
    textNoSuggestions\"` (or `\"textPassword\"` for a password) to ensure the input\
    \ does not get stored in the keyboard cache.\n\nOptionally, instead of declaring\
    \ an input type through XML, you can set the input type in your code using `TextView.setInputType()`.\n\
    \n\n## Example\nIn the following example, the field labeled BAD allows the password\
    \ to be saved to the keyboard cache, whereas the field labeled GOOD uses the `\"\
    textPassword\"` input type to ensure the password is not cached.\n\n\n```xml\n\
    <?xml version=\"1.0\" encoding=\"utf-8\"?>\n<LinearLayout\n    xmlns:android=\"\
    http://schemas.android.com/apk/res/android\"\n    xmlns:app=\"http://schemas.android.com/apk/res-auto\"\
    >\n\n    <!-- BAD: This password field uses the `text` input type, which allows\
    \ the input to be saved to the keyboard cache. -->\n    <EditText\n        android:id=\"\
    @+id/password_bad\"\n        android:inputType=\"text\"/> \n\n    <!-- GOOD: This\
    \ password field uses the `textPassword` input type, which ensures that the input\
    \ is not saved to the keyboard cache. -->\n    <EditText\n        android:id=\"\
    @+id/password_good\"\n        android:inputType=\"textPassword\"/>  \n</LinearLayout>\n\
    ```\n\n## References\n* OWASP Mobile Application Security Testing Guide: [Determining\
    \ Whether the Keyboard Cache Is Disabled for Text Input Fields](https://github.com/OWASP/owasp-mastg/blob/b7a93a2e5e0557cc9a12e55fc3f6675f6986bb86/Document/0x05d-Testing-Data-Storage.md#determining-whether-the-keyboard-cache-is-disabled-for-text-input-fields-mstg-storage-5).\n\
    * Android Developers: [android:inputType attribute documentation.](https://developer.android.com/reference/android/widget/TextView#attr_android:inputType)\n\
    * Common Weakness Enumeration: [CWE-524](https://cwe.mitre.org/data/definitions/524.html).\n"
 -
  pack: codeql/java-queries#0
  relativeQueryPath: Security/CWE/CWE-532/SensitiveInfoLog.ql
  relativeBqrsPath: codeql/java-queries/Security/CWE/CWE-532/SensitiveInfoLog.bqrs
  metadata:
    name: Insertion of sensitive information into log files
    description: |-
      Writing sensitive information to log files can allow that
                    information to be leaked to an attacker more easily.
    kind: path-problem
    problem.severity: warning
    security-severity: 7.5
    precision: medium
    id: java/sensitive-log
    tags: |-
      security
             external/cwe/cwe-532
  queryHelp: "# Insertion of sensitive information into log files\nInformation written\
    \ to log files can be of a sensitive nature and give valuable guidance to an attacker\
    \ or expose sensitive user information. Third-party logging utilities like Log4J\
    \ and SLF4J are widely used in Java projects. When sensitive information is written\
    \ to logs without properly set logging levels, it is accessible to potential attackers\
    \ who can use it to gain access to file storage.\n\n\n## Recommendation\nDo not\
    \ write secrets into the log files and enforce proper logging level control.\n\
    \n\n## Example\nThe following example shows two ways of logging sensitive information.\
    \ In the 'BAD' case, the credentials are simply written to a debug log. In the\
    \ 'GOOD' case, the credentials are never written to debug logs.\n\n\n```java\n\
    public static void main(String[] args) {\n    {\n        private static final\
    \ Logger logger = LogManager.getLogger(SensitiveInfoLog.class);\n\n        String\
    \ password = \"Pass@0rd\";\n\n        // BAD: user password is written to debug\
    \ log\n        logger.debug(\"User password is \"+password);\n    }\n\t\n    {\n\
    \        private static final Logger logger = LogManager.getLogger(SensitiveInfoLog.class);\n\
    \  \n        String password = \"Pass@0rd\";\n\n        // GOOD: user password\
    \ is never written to debug log\n        logger.debug(\"User password changed\"\
    )\n    }\n}\n\n```\n\n## References\n* [OWASP Logging Guide](https://cheatsheetseries.owasp.org/cheatsheets/Logging_Cheat_Sheet.html)\n\
    * Common Weakness Enumeration: [CWE-532](https://cwe.mitre.org/data/definitions/532.html).\n"
 -
  pack: codeql/java-queries#0
  relativeQueryPath: Security/CWE/CWE-552/UrlForward.ql
  relativeBqrsPath: codeql/java-queries/Security/CWE/CWE-552/UrlForward.bqrs
  metadata:
    name: URL forward from a remote source
    description: |-
      URL forward based on unvalidated user input
                    may cause file information disclosure.
    kind: path-problem
    problem.severity: error
    security-severity: 7.5
    precision: high
    id: java/unvalidated-url-forward
    tags: |-
      security
             external/cwe/cwe-552
  queryHelp: "# URL forward from a remote source\nDirectly incorporating user input\
    \ into a URL forward request without validating the input can cause file information\
    \ disclosure by allowing an attacker to access unauthorized URLs.\n\n\n## Recommendation\n\
    To guard against untrusted URL forwarding, you should avoid putting user input\
    \ directly into a forwarded URL. Instead, you should maintain a list of authorized\
    \ URLs on the server, then choose from that list based on the user input provided.\n\
    \n\n## Example\nThe following example shows an HTTP request parameter being used\
    \ directly in a URL forward without validating the input, which may cause file\
    \ information disclosure. It also shows how to remedy the problem by validating\
    \ the user input against a known fixed string.\n\n\n```java\npublic class UrlForward\
    \ extends HttpServlet {\n\tprivate static final String VALID_FORWARD = \"https://cwe.mitre.org/data/definitions/552.html\"\
    ;\n\n\tprotected void doGet(HttpServletRequest request, HttpServletResponse response)\n\
    \t\t\tthrows ServletException, IOException {\n\t\tServletConfig cfg = getServletConfig();\n\
    \t\tServletContext sc = cfg.getServletContext();\n\n\t\t// BAD: a request parameter\
    \ is incorporated without validation into a URL forward\n\t\tsc.getRequestDispatcher(request.getParameter(\"\
    target\")).forward(request, response);\n\n\t\t// GOOD: the request parameter is\
    \ validated against a known fixed string\n\t\tif (VALID_FORWARD.equals(request.getParameter(\"\
    target\"))) {\n\t\t\tsc.getRequestDispatcher(VALID_FORWARD).forward(request, response);\n\
    \t\t}\n\t}\n}\n\n```\n\n## References\n* OWASP: [Unvalidated Redirects and Forwards\
    \ Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/Unvalidated_Redirects_and_Forwards_Cheat_Sheet.html).\n\
    * Common Weakness Enumeration: [CWE-552](https://cwe.mitre.org/data/definitions/552.html).\n"
 -
  pack: codeql/java-queries#0
  relativeQueryPath: Security/CWE/CWE-601/UrlRedirect.ql
  relativeBqrsPath: codeql/java-queries/Security/CWE/CWE-601/UrlRedirect.bqrs
  metadata:
    name: URL redirection from remote source
    description: |-
      URL redirection based on unvalidated user-input
                    may cause redirection to malicious web sites.
    kind: path-problem
    problem.severity: error
    security-severity: 6.1
    precision: high
    id: java/unvalidated-url-redirection
    tags: |-
      security
             external/cwe/cwe-601
  queryHelp: |
    # URL redirection from remote source
    Directly incorporating user input into a URL redirect request without validating the input can facilitate phishing attacks. In these attacks, unsuspecting users can be redirected to a malicious site that looks very similar to the real site they intend to visit, but which is controlled by the attacker.


    ## Recommendation
    To guard against untrusted URL redirection, it is advisable to avoid putting user input directly into a redirect URL. Instead, maintain a list of authorized redirects on the server; then choose from that list based on the user input provided.

    If this is not possible, then the user input should be validated in some other way, for example, by verifying that the target URL is on the same host as the current page.


    ## Example
    The following example shows an HTTP request parameter being used directly in a URL redirect without validating the input, which facilitates phishing attacks:


    ```java
    public class UrlRedirect extends HttpServlet {
      protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {
        // BAD: a request parameter is incorporated without validation into a URL redirect
        response.sendRedirect(request.getParameter("target"));
      }
    }
    ```
    One way to remedy the problem is to validate the user input against a known fixed string before doing the redirection:


    ```java
    public class UrlRedirect extends HttpServlet {
      private static final List<String> VALID_REDIRECTS = Arrays.asList(
        "http://cwe.mitre.org/data/definitions/601.html",
        "http://cwe.mitre.org/data/definitions/79.html"
      );

      protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {
        // GOOD: the request parameter is validated against a known list of strings
        String target = request.getParameter("target");
        if (VALID_REDIRECTS.contains(target)) {
            response.sendRedirect(target);
        } else {
            response.sendRedirect("/error.html");
        }
      }
    }
    ```
    Alternatively, we can check that the target URL does not redirect to a different host by checking that the URL is either relative or on a known good host:


    ```java
    public class UrlRedirect extends HttpServlet {
      protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {
        try {
          String urlString = request.getParameter("page");
          URI url = new URI(urlString);

          if (!url.isAbsolute()) {
            response.sendRedirect(url.toString()); // GOOD: The redirect is to a relative URL
          }

          if ("example.org".equals(url.getHost())) {
            response.sendRedirect(url.toString()); // GOOD: The redirect is to a known host
          }
        } catch (URISyntaxException e) {
            // handle exception
        }
      }
    }
    ```
    Note that as written, the above code will allow redirects to URLs on `example.com`, which is harmless but perhaps not intended. You can substitute your own domain (if known) for `example.com` to prevent this.


    ## References
    * OWASP: [ Unvalidated Redirects and Forwards Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/Unvalidated_Redirects_and_Forwards_Cheat_Sheet.html).
    * Microsoft Docs: [Preventing Open Redirection Attacks (C\#)](https://docs.microsoft.com/en-us/aspnet/mvc/overview/security/preventing-open-redirection-attacks).
    * Common Weakness Enumeration: [CWE-601](https://cwe.mitre.org/data/definitions/601.html).
 -
  pack: codeql/java-queries#0
  relativeQueryPath: Security/CWE/CWE-611/XXE.ql
  relativeBqrsPath: codeql/java-queries/Security/CWE/CWE-611/XXE.bqrs
  metadata:
    name: Resolving XML external entity in user-controlled data
    description: |-
      Parsing user-controlled XML documents and allowing expansion of external entity
       references may lead to disclosure of confidential data or denial of service.
    kind: path-problem
    problem.severity: error
    security-severity: 9.1
    precision: high
    id: java/xxe
    tags: |-
      security
             external/cwe/cwe-611
             external/cwe/cwe-776
             external/cwe/cwe-827
  queryHelp: |
    # Resolving XML external entity in user-controlled data
    Parsing untrusted XML files with a weakly configured XML parser may lead to an XML External Entity (XXE) attack. This type of attack uses external entity references to access arbitrary files on a system, carry out denial of service, or server side request forgery. Even when the result of parsing is not returned to the user, out-of-band data retrieval techniques may allow attackers to steal sensitive data. Denial of services can also be carried out in this situation.

    There are many XML parsers for Java, and most of them are vulnerable to XXE because their default settings enable parsing of external entities. This query currently identifies vulnerable XML parsing from the following parsers: `javax.xml.parsers.DocumentBuilder`, `javax.xml.stream.XMLStreamReader`, `org.jdom.input.SAXBuilder`/`org.jdom2.input.SAXBuilder`, `javax.xml.parsers.SAXParser`,`org.dom4j.io.SAXReader`, `org.xml.sax.XMLReader`, `javax.xml.transform.sax.SAXSource`, `javax.xml.transform.TransformerFactory`, `javax.xml.transform.sax.SAXTransformerFactory`, `javax.xml.validation.SchemaFactory`, `javax.xml.bind.Unmarshaller` and `javax.xml.xpath.XPathExpression`.


    ## Recommendation
    The best way to prevent XXE attacks is to disable the parsing of any Document Type Declarations (DTDs) in untrusted data. If this is not possible you should disable the parsing of external general entities and external parameter entities. This improves security but the code will still be at risk of denial of service and server side request forgery attacks. Protection against denial of service attacks may also be implemented by setting entity expansion limits, which is done by default in recent JDK and JRE implementations. We recommend visiting OWASP's [XML Entity Prevention Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/XML_External_Entity_Prevention_Cheat_Sheet.html#java), finding the specific XML parser, and applying the mitigation listed there. Other mitigations might be sufficient in some cases, but manual verification will be needed, as the query will continue to flag the parser as potentially dangerous.


    ## Example
    The following example calls `parse` on a `DocumentBuilder` that is not safely configured on untrusted data, and is therefore inherently unsafe.


    ```java
    public void parse(Socket sock) throws Exception {
      DocumentBuilderFactory factory = DocumentBuilderFactory.newInstance();
      DocumentBuilder builder = factory.newDocumentBuilder();
      builder.parse(sock.getInputStream()); //unsafe
    }

    ```
    In this example, the `DocumentBuilder` is created with DTD disabled, securing it against XXE attack.


    ```java
    public void disableDTDParse(Socket sock) throws Exception {
      DocumentBuilderFactory factory = DocumentBuilderFactory.newInstance();
      factory.setFeature("http://apache.org/xml/features/disallow-doctype-decl", true);
      DocumentBuilder builder = factory.newDocumentBuilder();
      builder.parse(sock.getInputStream()); //safe
    }

    ```

    ## References
    * OWASP vulnerability description: [XML External Entity (XXE) Processing](https://www.owasp.org/index.php/XML_External_Entity_(XXE)_Processing).
    * OWASP guidance on parsing xml files: [XXE Prevention Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/XML_External_Entity_Prevention_Cheat_Sheet.html#java).
    * Paper by Timothy Morgen: [XML Schema, DTD, and Entity Attacks](https://research.nccgroup.com/2014/05/19/xml-schema-dtd-and-entity-attacks-a-compendium-of-known-techniques/)
    * Out-of-band data retrieval: Timur Yunusov &amp; Alexey Osipov, Black hat EU 2013: [XML Out-Of-Band Data Retrieval](https://www.slideshare.net/qqlan/bh-ready-v4).
    * Denial of service attack (Billion laughs): [Billion Laughs.](https://en.wikipedia.org/wiki/Billion_laughs)
    * The Java Tutorials: [Processing Limit Definitions.](https://docs.oracle.com/javase/tutorial/jaxp/limits/limits.html)
    * Common Weakness Enumeration: [CWE-611](https://cwe.mitre.org/data/definitions/611.html).
    * Common Weakness Enumeration: [CWE-776](https://cwe.mitre.org/data/definitions/776.html).
    * Common Weakness Enumeration: [CWE-827](https://cwe.mitre.org/data/definitions/827.html).
 -
  pack: codeql/java-queries#0
  relativeQueryPath: Security/CWE/CWE-614/InsecureCookie.ql
  relativeBqrsPath: codeql/java-queries/Security/CWE/CWE-614/InsecureCookie.bqrs
  metadata:
    name: Failure to use secure cookies
    description: |-
      Insecure cookies may be sent in cleartext, which makes them vulnerable to
                    interception.
    kind: problem
    problem.severity: error
    security-severity: 5.0
    precision: high
    id: java/insecure-cookie
    tags: |-
      security
             external/cwe/cwe-614
  queryHelp: "# Failure to use secure cookies\nFailing to set the 'secure' flag on\
    \ a cookie can cause it to be sent in cleartext. This makes it easier for an attacker\
    \ to intercept.\n\n\n## Recommendation\nAlways use `setSecure` to set the 'secure'\
    \ flag on a cookie before adding it to an `HttpServletResponse`.\n\n\n## Example\n\
    This example shows two ways of adding a cookie to an `HttpServletResponse`. The\
    \ first way leaves out the setting of the 'secure' flag; the second way includes\
    \ the setting of the flag.\n\n\n```java\npublic static void test(HttpServletRequest\
    \ request, HttpServletResponse response) {\n\t{\n\t\tCookie cookie = new Cookie(\"\
    secret\", \"fakesecret\");\n\t\t\n\t\t// BAD: 'secure' flag not set\n\t\tresponse.addCookie(cookie);\n\
    \t}\n\n\t{\n\t\tCookie cookie = new Cookie(\"secret\", \"fakesecret\");\n\t\t\n\
    \t\t// GOOD: set 'secure' flag\n\t\tcookie.setSecure(true);\n\t\tresponse.addCookie(cookie);\n\
    \t}\n}\n```\n\n## References\n* SEI CERT Oracle Coding Standard for Java: [SER03-J.\
    \ Do not serialize unencrypted, sensitive data](https://wiki.sei.cmu.edu/confluence/display/java/SER03-J.+Do+not+serialize+unencrypted+sensitive+data).\n\
    * Java Platform, Enterprise Edition (Java EE) 7, API Specification: [Class Cookie](https://docs.oracle.com/javaee/7/api/javax/servlet/http/Cookie.html).\n\
    * Common Weakness Enumeration: [CWE-614](https://cwe.mitre.org/data/definitions/614.html).\n"
 -
  pack: codeql/java-queries#0
  relativeQueryPath: Security/CWE/CWE-643/XPathInjection.ql
  relativeBqrsPath: codeql/java-queries/Security/CWE/CWE-643/XPathInjection.bqrs
  metadata:
    name: XPath injection
    description: |-
      Building an XPath expression from user-controlled sources is vulnerable to insertion of
                    malicious code by the user.
    kind: path-problem
    problem.severity: error
    security-severity: 9.8
    precision: high
    id: java/xml/xpath-injection
    tags: |-
      security
             external/cwe/cwe-643
  queryHelp: "# XPath injection\nIf an XPath expression is built using string concatenation,\
    \ and the components of the concatenation include user input, it makes it very\
    \ easy for a user to create a malicious XPath expression.\n\n\n## Recommendation\n\
    If user input must be included in an XPath expression, either sanitize the data\
    \ or pre-compile the query and use variable references to include the user input.\n\
    \nXPath injection can also be prevented by using XQuery.\n\n\n## Example\nIn the\
    \ first three examples, the code accepts a name and password specified by the\
    \ user, and uses this unvalidated and unsanitized value in an XPath expression.\
    \ This is vulnerable to the user providing special characters or string sequences\
    \ that change the meaning of the XPath expression to search for different values.\n\
    \nIn the fourth example, the code uses `setXPathVariableResolver` which prevents\
    \ XPath injection.\n\nThe final two examples are for dom4j. They show an example\
    \ of XPath injection and one method of preventing it.\n\n\n```java\nfinal String\
    \ xmlStr = \"<users>\" + \n                        \"   <user name=\\\"aaa\\\"\
    \ pass=\\\"pass1\\\"></user>\" + \n                        \"   <user name=\\\"\
    bbb\\\" pass=\\\"pass2\\\"></user>\" + \n                        \"</users>\"\
    ;\ntry {\n    DocumentBuilderFactory domFactory = DocumentBuilderFactory.newInstance();\n\
    \    domFactory.setNamespaceAware(true);\n    DocumentBuilder builder = domFactory.newDocumentBuilder();\n\
    \    //Document doc = builder.parse(\"user.xml\");\n    Document doc = builder.parse(new\
    \ InputSource(new StringReader(xmlStr)));\n\n    XPathFactory factory = XPathFactory.newInstance();\n\
    \    XPath xpath = factory.newXPath();\n\n    // Injectable data\n    String user\
    \ = request.getParameter(\"user\");\n    String pass = request.getParameter(\"\
    pass\");\n    if (user != null && pass != null) {\n        boolean isExist = false;\n\
    \n        // Bad expression\n        String expression1 = \"/users/user[@name='\"\
    \ + user + \"' and @pass='\" + pass + \"']\";\n        isExist = (boolean)xpath.evaluate(expression1,\
    \ doc, XPathConstants.BOOLEAN);\n        System.out.println(isExist);\n\n    \
    \    // Bad expression\n        XPathExpression expression2 = xpath.compile(\"\
    /users/user[@name='\" + user + \"' and @pass='\" + pass + \"']\");\n        isExist\
    \ = (boolean)expression2.evaluate(doc, XPathConstants.BOOLEAN);\n        System.out.println(isExist);\n\
    \n        // Bad expression\n        StringBuffer sb = new StringBuffer(\"/users/user[@name=\"\
    );\n        sb.append(user);\n        sb.append(\"' and @pass='\");\n        sb.append(pass);\n\
    \        sb.append(\"']\");\n        String query = sb.toString();\n        XPathExpression\
    \ expression3 = xpath.compile(query);\n        isExist = (boolean)expression3.evaluate(doc,\
    \ XPathConstants.BOOLEAN);\n        System.out.println(isExist);\n\n        //\
    \ Good expression\n        String expression4 = \"/users/user[@name=$user and\
    \ @pass=$pass]\";\n        xpath.setXPathVariableResolver(v -> {\n        switch\
    \ (v.getLocalPart()) {\n            case \"user\":\n                return user;\n\
    \            case \"pass\":\n                return pass;\n            default:\n\
    \                throw new IllegalArgumentException();\n            }\n      \
    \  });\n        isExist = (boolean)xpath.evaluate(expression4, doc, XPathConstants.BOOLEAN);\n\
    \        System.out.println(isExist);\n\n\n        // Bad Dom4j \n        org.dom4j.io.SAXReader\
    \ reader = new org.dom4j.io.SAXReader();\n        org.dom4j.Document document\
    \ = reader.read(new InputSource(new StringReader(xmlStr)));\n        isExist =\
    \ document.selectSingleNode(\"/users/user[@name='\" + user + \"' and @pass='\"\
    \ + pass + \"']\") != null;\n        // or document.selectNodes\n        System.out.println(isExist);\n\
    \n        // Good Dom4j\n        org.jaxen.SimpleVariableContext svc = new org.jaxen.SimpleVariableContext();\n\
    \        svc.setVariableValue(\"user\", user);\n        svc.setVariableValue(\"\
    pass\", pass);\n        String xpathString = \"/users/user[@name=$user and @pass=$pass]\"\
    ;\n        org.dom4j.XPath safeXPath = document.createXPath(xpathString);\n  \
    \      safeXPath.setVariableContext(svc);\n        isExist = safeXPath.selectSingleNode(document)\
    \ != null;\n        System.out.println(isExist);\n    }\n} catch (ParserConfigurationException\
    \ e) {\n\n} catch (SAXException e) {\n\n} catch (XPathExpressionException e) {\n\
    \n} catch (org.dom4j.DocumentException e) {\n\n}\n```\n\n## References\n* OWASP:\
    \ [Testing for XPath Injection](https://owasp.org/www-project-web-security-testing-guide/latest/4-Web_Application_Security_Testing/07-Input_Validation_Testing/09-Testing_for_XPath_Injection).\n\
    * OWASP: [XPath Injection](https://owasp.org/www-community/attacks/XPATH_Injection).\n\
    * Common Weakness Enumeration: [CWE-643](https://cwe.mitre.org/data/definitions/643.html).\n"
 -
  pack: codeql/java-queries#0
  relativeQueryPath: Security/CWE/CWE-676/PotentiallyDangerousFunction.ql
  relativeBqrsPath: codeql/java-queries/Security/CWE/CWE-676/PotentiallyDangerousFunction.bqrs
  metadata:
    name: Use of a potentially dangerous function
    description: Certain standard library routines are dangerous to call.
    kind: problem
    problem.severity: warning
    security-severity: 10.0
    precision: medium
    id: java/potentially-dangerous-function
    tags: |-
      reliability
             security
             external/cwe/cwe-676
  queryHelp: |
    # Use of a potentially dangerous function
    This rule finds calls to methods that are dangerous to use. Currently, it checks for calls to `Thread.stop`.

    Stopping a thread with `Thread.stop` causes it to receive a `ThreadDeath` exception. That exception propagates up the stack, releasing all monitors that the thread was holding. In some cases the relevant code will be protected by catching the `ThreadDeath` exception and cleaning up, but because the exception can potentially be thrown from so very many locations, it is impractical to catch all such cases. As a result, calling `Thread.stop` is likely to result in corrupt data.


    ## Recommendation
    The best solution is usually to provide an alternate communication mechanism for the thread that might need to be interrupted early. For example, Oracle gives the following example of using a volatile variable to communicate whether the worker thread should exit:


    ```java
    private volatile Thread blinker;

    public void stop() {
        blinker = null;
    }

    public void run() {
        Thread thisThread = Thread.currentThread();
        while (blinker == thisThread) {
            try {
                Thread.sleep(interval);
            } catch (InterruptedException e){
            }
            repaint();
        }
    }

    ```
    It is also possible to use `Thread.interrupt` and to catch and handle `InterruptedException` when it occurs. However, it can be difficult to handle an `InterruptedException` everywhere it might occur; for example, the sample code above simply discards the exception rather than actually exiting the thread.

    Another strategy is to use message passing, for example via a `BlockingQueue`. In addition to passing the worker thread its ordinary work via such a message queue, the worker can be asked to exit by a particular kind of message being sent on the queue.


    ## References
    * SEI CERT Oracle Coding Standard for Java: [THI05-J. Do not use Thread.stop() to terminate threads](https://wiki.sei.cmu.edu/confluence/display/java/THI05-J.+Do+not+use+Thread.stop()+to+terminate+threads).
    * Java API Specification: [Java Thread Primitive Deprecation](https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/lang/doc-files/threadPrimitiveDeprecation.html).
    * Java API Specification: [Thread.interrupt](https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/lang/Thread.html#interrupt()), [BlockingQueue](https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/util/concurrent/BlockingQueue.html).
    * Common Weakness Enumeration: [CWE-676](https://cwe.mitre.org/data/definitions/676.html).
 -
  pack: codeql/java-queries#0
  relativeQueryPath: Security/CWE/CWE-681/NumericCastTainted.ql
  relativeBqrsPath: codeql/java-queries/Security/CWE/CWE-681/NumericCastTainted.bqrs
  metadata:
    name: User-controlled data in numeric cast
    description: |-
      Casting user-controlled numeric data to a narrower type without validation
                    can cause unexpected truncation.
    kind: path-problem
    problem.severity: error
    security-severity: 9.0
    precision: high
    id: java/tainted-numeric-cast
    tags: |-
      security
             external/cwe/cwe-197
             external/cwe/cwe-681
  queryHelp: "# User-controlled data in numeric cast\nCasting a user-controlled numeric\
    \ value to a narrower type can result in truncated values unless the input is\
    \ validated.\n\nNarrowing conversions may cause potentially unintended results.\
    \ For example, casting the positive integer value `128` to type `byte` yields\
    \ the negative value `-128`.\n\n\n## Recommendation\nGuard against unexpected\
    \ truncation of user-controlled arithmetic data by doing one of the following:\n\
    \n* Validate the user input.\n* Define a guard on the cast expression, so that\
    \ the cast is performed only if the input is known to be within the range of the\
    \ resulting type.\n* Avoid casting to a narrower type, and instead continue to\
    \ use a wider type.\n\n## Example\nIn this example, a value is read from standard\
    \ input into a `long`. Because the value is a user-controlled value, it could\
    \ be extremely large. Casting this value to a narrower type could therefore cause\
    \ unexpected truncation. The `scaled2` example uses a guard to avoid this problem\
    \ and checks the range of the input before performing the cast. If the value is\
    \ too large to cast to type `int` it is rejected as invalid.\n\n\n```java\nclass\
    \ Test {\n\tpublic static void main(String[] args) throws IOException {\n\t\t\
    {\n\t\t\tlong data;\n\n\t\t\tBufferedReader readerBuffered = new BufferedReader(\n\
    \t\t\t\t\tnew InputStreamReader(System.in, \"UTF-8\"));\n\t\t\tString stringNumber\
    \ = readerBuffered.readLine();\n\t\t\tif (stringNumber != null) {\n\t\t\t\tdata\
    \ = Long.parseLong(stringNumber.trim());\n\t\t\t} else {\n\t\t\t\tdata = 0;\n\t\
    \t\t}\n\n\t\t\t// AVOID: potential truncation if input data is very large,\n\t\
    \t\t// for example 'Long.MAX_VALUE'\n\t\t\tint scaled = (int)data;\n\n\t\t\t//...\n\
    \n\t\t\t// GOOD: use a guard to ensure no truncation occurs\n\t\t\tint scaled2;\n\
    \t\t\tif (data > Integer.MIN_VALUE && data < Integer.MAX_VALUE)\n\t\t\t\tscaled2\
    \ = (int)data;\n\t\t\telse\n\t\t\t\tthrow new IllegalArgumentException(\"Invalid\
    \ input\");\n\t\t}\n\t}\n}\n```\n\n## References\n* SEI CERT Oracle Coding Standard\
    \ for Java: [NUM12-J. Ensure conversions of numeric types to narrower types do\
    \ not result in lost or misinterpreted data](https://wiki.sei.cmu.edu/confluence/display/java/NUM12-J.+Ensure+conversions+of+numeric+types+to+narrower+types+do+not+result+in+lost+or+misinterpreted+data).\n\
    * Common Weakness Enumeration: [CWE-197](https://cwe.mitre.org/data/definitions/197.html).\n\
    * Common Weakness Enumeration: [CWE-681](https://cwe.mitre.org/data/definitions/681.html).\n"
 -
  pack: codeql/java-queries#0
  relativeQueryPath: Security/CWE/CWE-730/PolynomialReDoS.ql
  relativeBqrsPath: codeql/java-queries/Security/CWE/CWE-730/PolynomialReDoS.bqrs
  metadata:
    name: Polynomial regular expression used on uncontrolled data
    description: |-
      A regular expression that can require polynomial time
                    to match may be vulnerable to denial-of-service attacks.
    kind: path-problem
    problem.severity: warning
    security-severity: 7.5
    precision: high
    id: java/polynomial-redos
    tags: |-
      security
             external/cwe/cwe-1333
             external/cwe/cwe-730
             external/cwe/cwe-400
  queryHelp: "# Polynomial regular expression used on uncontrolled data\nSome regular\
    \ expressions take a long time to match certain input strings to the point where\
    \ the time it takes to match a string of length *n* is proportional to *n<sup>k</sup>*\
    \ or even *2<sup>n</sup>*. Such regular expressions can negatively affect performance,\
    \ or even allow a malicious user to perform a Denial of Service (\"DoS\") attack\
    \ by crafting an expensive input string for the regular expression to match.\n\
    \nThe regular expression engine provided by Java uses a backtracking non-deterministic\
    \ finite automata to implement regular expression matching. While this approach\
    \ is space-efficient and allows supporting advanced features like capture groups,\
    \ it is not time-efficient in general. The worst-case time complexity of such\
    \ an automaton can be polynomial or even exponential, meaning that for strings\
    \ of a certain shape, increasing the input length by ten characters may make the\
    \ automaton about 1000 times slower.\n\nTypically, a regular expression is affected\
    \ by this problem if it contains a repetition of the form `r*` or `r+` where the\
    \ sub-expression `r` is ambiguous in the sense that it can match some string in\
    \ multiple ways. More information about the precise circumstances can be found\
    \ in the references.\n\nNote that Java versions 9 and above have some mitigations\
    \ against ReDoS; however they aren't perfect and more complex regular expressions\
    \ can still be affected by this problem.\n\n\n## Recommendation\nModify the regular\
    \ expression to remove the ambiguity, or ensure that the strings matched with\
    \ the regular expression are short enough that the time-complexity does not matter.\
    \ Alternatively, an alternate regex library that guarantees linear time execution,\
    \ such as Google's RE2J, may be used.\n\n\n## Example\nConsider this use of a\
    \ regular expression, which removes all leading and trailing whitespace in a string:\n\
    \n```java\n\nPattern.compile(\"^\\\\s+|\\\\s+$\").matcher(text).replaceAll(\"\"\
    ) // BAD\n```\nThe sub-expression `\"\\\\s+$\"` will match the whitespace characters\
    \ in `text` from left to right, but it can start matching anywhere within a whitespace\
    \ sequence. This is problematic for strings that do **not** end with a whitespace\
    \ character. Such a string will force the regular expression engine to process\
    \ each whitespace sequence once per whitespace character in the sequence.\n\n\
    This ultimately means that the time cost of trimming a string is quadratic in\
    \ the length of the string. So a string like `\"a b\"` will take milliseconds\
    \ to process, but a similar string with a million spaces instead of just one will\
    \ take several minutes.\n\nAvoid this problem by rewriting the regular expression\
    \ to not contain the ambiguity about when to start matching whitespace sequences.\
    \ For instance, by using a negative look-behind (`\"^\\\\s+|(?<!\\\\s)\\\\s+$\"\
    `), or just by using the built-in trim method (`text.trim()`).\n\nNote that the\
    \ sub-expression `\"^\\\\s+\"` is **not** problematic as the `^` anchor restricts\
    \ when that sub-expression can start matching, and as the regular expression engine\
    \ matches from left to right.\n\n\n## Example\nAs a similar, but slightly subtler\
    \ problem, consider the regular expression that matches lines with numbers, possibly\
    \ written using scientific notation:\n\n```java\n\n\"^0\\\\.\\\\d+E?\\\\d+$\"\"\
    \ \n```\nThe problem with this regular expression is in the sub-expression `\\\
    d+E?\\d+` because the second `\\d+` can start matching digits anywhere after the\
    \ first match of the first `\\d+` if there is no `E` in the input string.\n\n\
    This is problematic for strings that do **not** end with a digit. Such a string\
    \ will force the regular expression engine to process each digit sequence once\
    \ per digit in the sequence, again leading to a quadratic time complexity.\n\n\
    To make the processing faster, the regular expression should be rewritten such\
    \ that the two `\\d+` sub-expressions do not have overlapping matches: `\"^0\\\
    \\.\\\\d+(E\\\\d+)?$\"`.\n\n\n## Example\nSometimes it is unclear how a regular\
    \ expression can be rewritten to avoid the problem. In such cases, it often suffices\
    \ to limit the length of the input string. For instance, the following regular\
    \ expression is used to match numbers, and on some non-number inputs it can have\
    \ quadratic time complexity:\n\n```java\n\nPattern.matches(\"^(\\\\+|-)?(\\\\\
    d+|(\\\\d*\\\\.\\\\d*))?(E|e)?([-+])?(\\\\d+)?$\", str); \n```\nIt is not immediately\
    \ obvious how to rewrite this regular expression to avoid the problem. However,\
    \ you can mitigate performance issues by limiting the length to 1000 characters,\
    \ which will always finish in a reasonable amount of time.\n\n```java\n\nif (str.length()\
    \ > 1000) {\n    throw new IllegalArgumentException(\"Input too long\");\n}\n\n\
    Pattern.matches(\"^(\\\\+|-)?(\\\\d+|(\\\\d*\\\\.\\\\d*))?(E|e)?([-+])?(\\\\d+)?$\"\
    , str); \n```\n\n## References\n* OWASP: [Regular expression Denial of Service\
    \ - ReDoS](https://www.owasp.org/index.php/Regular_expression_Denial_of_Service_-_ReDoS).\n\
    * Wikipedia: [ReDoS](https://en.wikipedia.org/wiki/ReDoS).\n* Wikipedia: [Time\
    \ complexity](https://en.wikipedia.org/wiki/Time_complexity).\n* James Kirrage,\
    \ Asiri Rathnayake, Hayo Thielecke: [Static Analysis for Regular Expression Denial-of-Service\
    \ Attack](https://arxiv.org/abs/1301.0849).\n* Common Weakness Enumeration: [CWE-1333](https://cwe.mitre.org/data/definitions/1333.html).\n\
    * Common Weakness Enumeration: [CWE-730](https://cwe.mitre.org/data/definitions/730.html).\n\
    * Common Weakness Enumeration: [CWE-400](https://cwe.mitre.org/data/definitions/400.html).\n"
 -
  pack: codeql/java-queries#0
  relativeQueryPath: Security/CWE/CWE-730/ReDoS.ql
  relativeBqrsPath: codeql/java-queries/Security/CWE/CWE-730/ReDoS.bqrs
  metadata:
    name: Inefficient regular expression
    description: |-
      A regular expression that requires exponential time to match certain inputs
                    can be a performance bottleneck, and may be vulnerable to denial-of-service
                    attacks.
    kind: problem
    problem.severity: error
    security-severity: 7.5
    precision: high
    id: java/redos
    tags: |-
      security
             external/cwe/cwe-1333
             external/cwe/cwe-730
             external/cwe/cwe-400
  queryHelp: |
    # Inefficient regular expression
    Some regular expressions take a long time to match certain input strings to the point where the time it takes to match a string of length *n* is proportional to *n<sup>k</sup>* or even *2<sup>n</sup>*. Such regular expressions can negatively affect performance, or even allow a malicious user to perform a Denial of Service ("DoS") attack by crafting an expensive input string for the regular expression to match.

    The regular expression engine provided by Java uses a backtracking non-deterministic finite automata to implement regular expression matching. While this approach is space-efficient and allows supporting advanced features like capture groups, it is not time-efficient in general. The worst-case time complexity of such an automaton can be polynomial or even exponential, meaning that for strings of a certain shape, increasing the input length by ten characters may make the automaton about 1000 times slower.

    Typically, a regular expression is affected by this problem if it contains a repetition of the form `r*` or `r+` where the sub-expression `r` is ambiguous in the sense that it can match some string in multiple ways. More information about the precise circumstances can be found in the references.

    Note that Java versions 9 and above have some mitigations against ReDoS; however they aren't perfect and more complex regular expressions can still be affected by this problem.


    ## Recommendation
    Modify the regular expression to remove the ambiguity, or ensure that the strings matched with the regular expression are short enough that the time-complexity does not matter. Alternatively, an alternate regex library that guarantees linear time execution, such as Google's RE2J, may be used.


    ## Example
    Consider this regular expression:

    ```java

    ^_(__|.)+_$
    ```
    Its sub-expression `"(__|.)+?"` can match the string `"__"` either by the first alternative `"__"` to the left of the `"|"` operator, or by two repetitions of the second alternative `"."` to the right. Thus, a string consisting of an odd number of underscores followed by some other character will cause the regular expression engine to run for an exponential amount of time before rejecting the input.

    This problem can be avoided by rewriting the regular expression to remove the ambiguity between the two branches of the alternative inside the repetition:

    ```java

    ^_(__|[^_])+_$
    ```

    ## References
    * OWASP: [Regular expression Denial of Service - ReDoS](https://www.owasp.org/index.php/Regular_expression_Denial_of_Service_-_ReDoS).
    * Wikipedia: [ReDoS](https://en.wikipedia.org/wiki/ReDoS).
    * Wikipedia: [Time complexity](https://en.wikipedia.org/wiki/Time_complexity).
    * James Kirrage, Asiri Rathnayake, Hayo Thielecke: [Static Analysis for Regular Expression Denial-of-Service Attack](https://arxiv.org/abs/1301.0849).
    * Common Weakness Enumeration: [CWE-1333](https://cwe.mitre.org/data/definitions/1333.html).
    * Common Weakness Enumeration: [CWE-730](https://cwe.mitre.org/data/definitions/730.html).
    * Common Weakness Enumeration: [CWE-400](https://cwe.mitre.org/data/definitions/400.html).
 -
  pack: codeql/java-queries#0
  relativeQueryPath: Security/CWE/CWE-730/RegexInjection.ql
  relativeBqrsPath: codeql/java-queries/Security/CWE/CWE-730/RegexInjection.bqrs
  metadata:
    name: Regular expression injection
    description: |-
      User input should not be used in regular expressions without first being escaped,
                    otherwise a malicious user may be able to provide a regex that could require
                    exponential time on certain inputs.
    kind: path-problem
    problem.severity: error
    security-severity: 7.5
    precision: high
    id: java/regex-injection
    tags: |-
      security
             external/cwe/cwe-730
             external/cwe/cwe-400
  queryHelp: |
    # Regular expression injection
    Constructing a regular expression with unsanitized user input is dangerous as a malicious user may be able to modify the meaning of the expression. In particular, such a user may be able to provide a regular expression fragment that takes exponential time in the worst case, and use that to perform a Denial of Service attack.


    ## Recommendation
    Before embedding user input into a regular expression, use a sanitization function such as `Pattern.quote` to escape meta-characters that have special meaning.


    ## Example
    The following example shows an HTTP request parameter that is used to construct a regular expression.

    In the first case the user-provided regex is not escaped. If a malicious user provides a regex whose worst-case performance is exponential, then this could lead to a Denial of Service.

    In the second case, the user input is escaped using `Pattern.quote` before being included in the regular expression. This ensures that the user cannot insert characters which have a special meaning in regular expressions.


    ```java
    import java.util.regex.Pattern;
    import javax.servlet.http.HttpServlet;
    import javax.servlet.http.HttpServletRequest;

    public class RegexInjectionDemo extends HttpServlet {

      public boolean badExample(javax.servlet.http.HttpServletRequest request) {
        String regex = request.getParameter("regex");
        String input = request.getParameter("input");

        // BAD: Unsanitized user input is used to construct a regular expression
        return input.matches(regex);
      }

      public boolean goodExample(javax.servlet.http.HttpServletRequest request) {
        String regex = request.getParameter("regex");
        String input = request.getParameter("input");

        // GOOD: User input is sanitized before constructing the regex
        return input.matches(Pattern.quote(regex));
      }
    }

    ```

    ## References
    * OWASP: [Regular expression Denial of Service - ReDoS](https://www.owasp.org/index.php/Regular_expression_Denial_of_Service_-_ReDoS).
    * Wikipedia: [ReDoS](https://en.wikipedia.org/wiki/ReDoS).
    * Java API Specification: [Pattern.quote](https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/util/regex/Pattern.html#quote(java.lang.String)).
    * Common Weakness Enumeration: [CWE-730](https://cwe.mitre.org/data/definitions/730.html).
    * Common Weakness Enumeration: [CWE-400](https://cwe.mitre.org/data/definitions/400.html).
 -
  pack: codeql/java-queries#0
  relativeQueryPath: Security/CWE/CWE-732/ReadingFromWorldWritableFile.ql
  relativeBqrsPath: codeql/java-queries/Security/CWE/CWE-732/ReadingFromWorldWritableFile.bqrs
  metadata:
    name: Reading from a world writable file
    description: |-
      Reading from a file which is set as world writable is dangerous because
                    the file may be modified or removed by external actors.
    kind: problem
    problem.severity: error
    security-severity: 7.8
    precision: high
    id: java/world-writable-file-read
    tags: |-
      security
             external/cwe/cwe-732
  queryHelp: |
    # Reading from a world writable file
    Reading from a world-writable file is dangerous on a multi-user system because other users may be able to affect program execution by modifying or deleting the file.


    ## Recommendation
    Do not make files explicitly world writable unless the file is intended to be written by multiple users on a multi-user system. In many cases, the file may only need to be writable for the current user.

    For some file systems, there may be alternatives to setting the file to be world writable. For example, POSIX file systems support "groups" which may be used to ensure that only subset of all the users can write to the file. Access Control Lists (ACLs) are available for many operating system and file system combinations, and can provide fine-grained read and write support without resorting to world writable permissions.


    ## Example
    In the following example, we are loading some configuration parameters from a file:

    ```java

    private void readConfig(File configFile) {
      if (!configFile.exists()) {
        // Create an empty config file
        configFile.createNewFile();
        // Make the file writable for all
        configFile.setWritable(true, false);
      }
      // Now read the config
      loadConfig(configFile);
    }

    ```
    If the configuration file does not yet exist, an empty file is created. Creating an empty file can simplify the later code and is a convenience for the user. However, by setting the file to be world writable, we allow any user on the system to modify the configuration, not just the current user. If there may be untrusted users on the system, this is potentially dangerous.


    ## References
    * SEI CERT Oracle Coding Standard for Java: [FIO01-J. Create files with appropriate access permissions](https://wiki.sei.cmu.edu/confluence/display/java/FIO01-J.+Create+files+with+appropriate+access+permissions).
    * Common Weakness Enumeration: [CWE-732](https://cwe.mitre.org/data/definitions/732.html).
 -
  pack: codeql/java-queries#0
  relativeQueryPath: Security/CWE/CWE-749/UnsafeAndroidAccess.ql
  relativeBqrsPath: codeql/java-queries/Security/CWE/CWE-749/UnsafeAndroidAccess.bqrs
  metadata:
    name: Unsafe resource fetching in Android WebView
    description: |-
      JavaScript rendered inside WebViews can access protected
                    application files and web resources from any origin exposing them to attack.
    kind: path-problem
    problem.severity: warning
    security-severity: 6.1
    precision: medium
    id: java/android/unsafe-android-webview-fetch
    tags: |-
      security
             external/cwe/cwe-749
             external/cwe/cwe-079
  queryHelp: "# Unsafe resource fetching in Android WebView\nAndroid WebViews that\
    \ allow externally controlled URLs to be loaded, and whose JavaScript interface\
    \ is enabled, are potentially vulnerable to cross-site scripting and sensitive\
    \ resource disclosure attacks.\n\nA `WebView` whose `WebSettings` object has called\
    \ `setAllowFileAccessFromFileURLs(true)` or `setAllowUniversalAccessFromFileURLs(true)`\
    \ must not load any untrusted web content.\n\nEnabling these settings allows malicious\
    \ scripts loaded in a `file://` context to launch cross-site scripting attacks,\
    \ accessing arbitrary local files including WebView cookies, session tokens, private\
    \ app data or even credentials used on arbitrary web sites.\n\nThis query detects\
    \ the following two scenarios:\n\n1. A vulnerability introduced by WebViews when\
    \ JavaScript is enabled and remote inputs are allowed.\n1. A more severe vulnerability\
    \ when \"allow cross-origin resource access\" is also enabled. This setting was\
    \ deprecated in API level 30 (Android 11), but most devices are still affected,\
    \ especially since some Android phones are updated slowly or no longer updated\
    \ at all.\n\n## Recommendation\nOnly allow trusted web content to be displayed\
    \ in WebViews when JavaScript is enabled. Disallow cross-origin resource access\
    \ in WebSettings to reduce the attack surface.\n\n\n## Example\nThe following\
    \ example shows both 'BAD' and 'GOOD' configurations. In the 'BAD' configuration,\
    \ JavaScript and the allow access setting are enabled and URLs are loaded from\
    \ externally controlled inputs. In the 'GOOD' configuration, JavaScript is disabled\
    \ or only trusted web content is allowed to be loaded.\n\n\n```java\npublic class\
    \ UnsafeAndroidAccess extends Activity {\n\tpublic void onCreate(Bundle savedInstanceState)\
    \ {\n\t\tsuper.onCreate(savedInstanceState);\n\t\tsetContentView(R.layout.webview);\n\
    \n\t\t// BAD: Have both JavaScript and cross-origin resource access enabled in\
    \ webview while\n\t\t// taking remote user inputs\n\t\t{\n\t\t\tWebView wv = (WebView)\
    \ findViewById(R.id.my_webview);\n\t\t\tWebSettings webSettings = wv.getSettings();\n\
    \n\t\t\twebSettings.setJavaScriptEnabled(true);\n\t\t\twebSettings.setAllowUniversalAccessFromFileURLs(true);\n\
    \n\t\t\twv.setWebViewClient(new WebViewClient() {\n\t\t\t\t@Override\n\t\t\t\t\
    public boolean shouldOverrideUrlLoading(WebView view, String url) {\n\t\t\t\t\t\
    view.loadUrl(url);\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t});\n\n\t\t\tString\
    \ thisUrl = getIntent().getExtras().getString(\"url\"); // dangerous remote input\
    \ from  the intent's Bundle of extras\n\t\t\twv.loadUrl(thisUrl);\n\t\t}\n\n\t\
    \t// BAD: Have both JavaScript and cross-origin resource access enabled in webview\
    \ while\n\t\t// taking remote user inputs\n\t\t{\n\t\t\tWebView wv = (WebView)\
    \ findViewById(R.id.my_webview);\n\t\t\tWebSettings webSettings = wv.getSettings();\n\
    \n\t\t\twebSettings.setJavaScriptEnabled(true);\n\t\t\twebSettings.setAllowUniversalAccessFromFileURLs(true);\n\
    \n\t\t\twv.setWebViewClient(new WebViewClient() {\n\t\t\t\t@Override\n\t\t\t\t\
    public boolean shouldOverrideUrlLoading(WebView view, String url) {\n\t\t\t\t\t\
    view.loadUrl(url);\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t});\n\n\t\t\tString\
    \ thisUrl = getIntent().getStringExtra(\"url\"); //dangerous remote input from\
    \ intent extra\n\t\t\twv.loadUrl(thisUrl);\n\t\t}\n\n\t\t// GOOD: Have JavaScript\
    \ and cross-origin resource access disabled by default on modern Android (Jellybean+)\
    \ while taking remote user inputs\n\t\t{\n\t\t\tWebView wv = (WebView) findViewById(-1);\n\
    \t\t\tWebSettings webSettings = wv.getSettings();\n\n\t\t\twv.setWebViewClient(new\
    \ WebViewClient() {\n\t\t\t\t@Override\n\t\t\t\tpublic boolean shouldOverrideUrlLoading(WebView\
    \ view, String url) {\n\t\t\t\t\tview.loadUrl(url);\n\t\t\t\t\treturn true;\n\t\
    \t\t\t}\n\t\t\t});\n\n\t\t\tString thisUrl = getIntent().getExtras().getString(\"\
    url\"); // remote input\n\t\t\twv.loadUrl(thisUrl);\n\t\t}\n\n\t\t// GOOD: Have\
    \ JavaScript enabled in webview but remote user input is not allowed\n\t\t{\n\t\
    \t\tWebView wv = (WebView) findViewById(-1);\n\t\t\tWebSettings webSettings =\
    \ wv.getSettings();\n\n\t\t\twebSettings.setJavaScriptEnabled(true);\n\n\t\t\t\
    wv.setWebViewClient(new WebViewClient() {\n\t\t\t\t@Override\n\t\t\t\tpublic boolean\
    \ shouldOverrideUrlLoading(WebView view, String url) {\n\t\t\t\t\tview.loadUrl(url);\n\
    \t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t});\n\n\t\t\twv.loadUrl(\"https://www.mycorp.com\"\
    );\n\t\t}\n\t}\n}\n```\n\n## References\n* Google Help: [Fixing a File-based XSS\
    \ Vulnerability](https://support.google.com/faqs/answer/7668153?hl=en)\n* OWASP:\
    \ [Testing JavaScript Execution in WebViews (MSTG-PLATFORM-5)](https://github.com/OWASP/owasp-mstg/blob/master/Document/0x05h-Testing-Platform-Interaction.md#testing-javascript-execution-in-webviews-mstg-platform-5)\n\
    * OWASP: [Testing WebView Protocol Handlers (MSTG-PLATFORM-6)](https://github.com/OWASP/owasp-mstg/blob/master/Document/0x05h-Testing-Platform-Interaction.md#testing-webview-protocol-handlers-mstg-platform-6)\n\
    * Common Weakness Enumeration: [CWE-749](https://cwe.mitre.org/data/definitions/749.html).\n\
    * Common Weakness Enumeration: [CWE-79](https://cwe.mitre.org/data/definitions/79.html).\n"
 -
  pack: codeql/java-queries#0
  relativeQueryPath: Security/CWE/CWE-780/RsaWithoutOaep.ql
  relativeBqrsPath: codeql/java-queries/Security/CWE/CWE-780/RsaWithoutOaep.bqrs
  metadata:
    name: Use of RSA algorithm without OAEP
    description: "Using RSA encryption without OAEP padding can result in a padding\
      \ oracle attack, leading to a weaker encryption."
    kind: path-problem
    problem.severity: warning
    security-severity: 7.5
    precision: high
    id: java/rsa-without-oaep
    tags: |-
      security
             external/cwe/cwe-780
  queryHelp: |
    # Use of RSA algorithm without OAEP
    Cryptographic algorithms often use padding schemes to make the plaintext less predictable. The OAEP (Optimal Asymmetric Encryption Padding) scheme should be used with RSA encryption. Using an outdated padding scheme such as PKCS1, or no padding at all, can weaken the encryption by making it vulnerable to a padding oracle attack.


    ## Recommendation
    Use the OAEP scheme when using RSA encryption.


    ## Example
    In the following example, the BAD case shows no padding being used, whereas the GOOD case shows an OAEP scheme being used.


    ```java
    // BAD: No padding scheme is used
    Cipher rsa = Cipher.getInstance("RSA/ECB/NoPadding");
    ...

    //GOOD: OAEP padding is used
    Cipher rsa = Cipher.getInstance("RSA/ECB/OAEPWithSHA-1AndMGF1Padding");
    ...
    ```

    ## References
    * [Mobile Security Testing Guide](https://github.com/MobSF/owasp-mstg/blob/master/Document/0x04g-Testing-Cryptography.md#padding-oracle-attacks-due-to-weaker-padding-or-block-operation-implementations).
    * [The Padding Oracle Attack](https://robertheaton.com/2013/07/29/padding-oracle-attack/).
    * Common Weakness Enumeration: [CWE-780](https://cwe.mitre.org/data/definitions/780.html).
 -
  pack: codeql/java-queries#0
  relativeQueryPath: Security/CWE/CWE-798/HardcodedCredentialsApiCall.ql
  relativeBqrsPath: codeql/java-queries/Security/CWE/CWE-798/HardcodedCredentialsApiCall.bqrs
  metadata:
    name: Hard-coded credential in API call
    description: Using a hard-coded credential in a call to a sensitive Java API may
      compromise security.
    kind: path-problem
    problem.severity: error
    security-severity: 9.8
    precision: medium
    id: java/hardcoded-credential-api-call
    tags: |-
      security
             external/cwe/cwe-798
  queryHelp: |
    # Hard-coded credential in API call
    Including unencrypted hard-coded authentication credentials in source code is dangerous because the credentials may be easily discovered. For example, the code may be open source, or it may be leaked or accidentally revealed, making the credentials visible to an attacker. This, in turn, might enable them to gain unauthorized access, or to obtain privileged information.


    ## Recommendation
    Remove hard-coded credentials, such as user names, passwords and certificates, from source code. Instead, place them in configuration files, environment variables or other data stores if necessary. If possible, store configuration files including credential data separately from the source code, in a secure location with restricted access.


    ## Example
    The following code example connects to a database using a hard-coded user name and password:


    ```java
    private static final String p = "123456"; // hard-coded credential

    public static void main(String[] args) throws SQLException {
        String url = "jdbc:mysql://localhost/test";
        String u = "admin"; // hard-coded credential

        getConn(url, u, p);
    }

    public static void getConn(String url, String v, String q) throws SQLException {
        DriverManager.getConnection(url, v, q); // sensitive call
    }

    ```
    Instead, the user name and password could be supplied through environment variables, which can be set externally without hard-coding credentials in the source code.


    ## References
    * OWASP: [Use of hard-coded password](https://www.owasp.org/index.php/Use_of_hard-coded_password).
    * Common Weakness Enumeration: [CWE-798](https://cwe.mitre.org/data/definitions/798.html).
 -
  pack: codeql/java-queries#0
  relativeQueryPath: Security/CWE/CWE-798/HardcodedCredentialsComparison.ql
  relativeBqrsPath: codeql/java-queries/Security/CWE/CWE-798/HardcodedCredentialsComparison.bqrs
  metadata:
    name: Hard-coded credential comparison
    description: Comparing a parameter to a hard-coded credential may compromise security.
    kind: problem
    problem.severity: error
    security-severity: 9.8
    precision: low
    id: java/hardcoded-credential-comparison
    tags: |-
      security
             external/cwe/cwe-798
  queryHelp: |
    # Hard-coded credential comparison
    Including unencrypted hard-coded authentication credentials in source code is dangerous because the credentials may be easily discovered. For example, the code may be open source, or it may be leaked or accidentally revealed, making the credentials visible to an attacker. This, in turn, might enable them to gain unauthorized access, or to obtain privileged information.


    ## Recommendation
    Remove hard-coded credentials, such as user names, passwords and certificates, from source code. Instead, place them in configuration files, environment variables or other data stores if necessary. If possible, store configuration files including credential data separately from the source code, in a secure location with restricted access.


    ## Example
    The following code example connects to a database using a hard-coded user name and password:


    ```java
    private static final String p = "123456"; // hard-coded credential

    public static void main(String[] args) throws SQLException {
        String url = "jdbc:mysql://localhost/test";
        String u = "admin"; // hard-coded credential

        getConn(url, u, p);
    }

    public static void getConn(String url, String v, String q) throws SQLException {
        DriverManager.getConnection(url, v, q); // sensitive call
    }

    ```
    Instead, the user name and password could be supplied through environment variables, which can be set externally without hard-coding credentials in the source code.


    ## References
    * OWASP: [Use of hard-coded password](https://www.owasp.org/index.php/Use_of_hard-coded_password).
    * Common Weakness Enumeration: [CWE-798](https://cwe.mitre.org/data/definitions/798.html).
 -
  pack: codeql/java-queries#0
  relativeQueryPath: Security/CWE/CWE-798/HardcodedCredentialsSourceCall.ql
  relativeBqrsPath: codeql/java-queries/Security/CWE/CWE-798/HardcodedCredentialsSourceCall.bqrs
  metadata:
    name: Hard-coded credential in sensitive call
    description: Using a hard-coded credential in a sensitive call may compromise
      security.
    kind: path-problem
    problem.severity: error
    security-severity: 9.8
    precision: low
    id: java/hardcoded-credential-sensitive-call
    tags: |-
      security
             external/cwe/cwe-798
  queryHelp: |
    # Hard-coded credential in sensitive call
    Including unencrypted hard-coded authentication credentials in source code is dangerous because the credentials may be easily discovered. For example, the code may be open source, or it may be leaked or accidentally revealed, making the credentials visible to an attacker. This, in turn, might enable them to gain unauthorized access, or to obtain privileged information.


    ## Recommendation
    Remove hard-coded credentials, such as user names, passwords and certificates, from source code. Instead, place them in configuration files, environment variables or other data stores if necessary. If possible, store configuration files including credential data separately from the source code, in a secure location with restricted access.


    ## Example
    The following code example connects to a database using a hard-coded user name and password:


    ```java
    private static final String p = "123456"; // hard-coded credential

    public static void main(String[] args) throws SQLException {
        String url = "jdbc:mysql://localhost/test";
        String u = "admin"; // hard-coded credential

        getConn(url, u, p);
    }

    public static void getConn(String url, String v, String q) throws SQLException {
        DriverManager.getConnection(url, v, q); // sensitive call
    }

    ```
    Instead, the user name and password could be supplied through environment variables, which can be set externally without hard-coding credentials in the source code.


    ## References
    * OWASP: [Use of hard-coded password](https://www.owasp.org/index.php/Use_of_hard-coded_password).
    * Common Weakness Enumeration: [CWE-798](https://cwe.mitre.org/data/definitions/798.html).
 -
  pack: codeql/java-queries#0
  relativeQueryPath: Security/CWE/CWE-798/HardcodedPasswordField.ql
  relativeBqrsPath: codeql/java-queries/Security/CWE/CWE-798/HardcodedPasswordField.bqrs
  metadata:
    name: Hard-coded password field
    description: Hard-coding a password string may compromise security.
    kind: problem
    problem.severity: error
    security-severity: 9.8
    precision: low
    id: java/hardcoded-password-field
    tags: |-
      security
             external/cwe/cwe-798
  queryHelp: |
    # Hard-coded password field
    Including unencrypted hard-coded authentication credentials in source code is dangerous because the credentials may be easily discovered. For example, the code may be open source, or it may be leaked or accidentally revealed, making the credentials visible to an attacker. This, in turn, might enable them to gain unauthorized access, or to obtain privileged information.


    ## Recommendation
    Remove hard-coded credentials, such as user names, passwords and certificates, from source code. Instead, place them in configuration files, environment variables or other data stores if necessary. If possible, store configuration files including credential data separately from the source code, in a secure location with restricted access.


    ## Example
    The following code example connects to a database using a hard-coded user name and password:


    ```java
    private static final String p = "123456"; // hard-coded credential

    public static void main(String[] args) throws SQLException {
        String url = "jdbc:mysql://localhost/test";
        String u = "admin"; // hard-coded credential

        getConn(url, u, p);
    }

    public static void getConn(String url, String v, String q) throws SQLException {
        DriverManager.getConnection(url, v, q); // sensitive call
    }

    ```
    Instead, the user name and password could be supplied through environment variables, which can be set externally without hard-coding credentials in the source code.


    ## References
    * OWASP: [Use of hard-coded password](https://www.owasp.org/index.php/Use_of_hard-coded_password).
    * Common Weakness Enumeration: [CWE-798](https://cwe.mitre.org/data/definitions/798.html).
 -
  pack: codeql/java-queries#0
  relativeQueryPath: Security/CWE/CWE-807/ConditionalBypass.ql
  relativeBqrsPath: codeql/java-queries/Security/CWE/CWE-807/ConditionalBypass.bqrs
  metadata:
    name: User-controlled bypass of sensitive method
    description: |-
      User-controlled bypassing of sensitive methods may allow attackers to avoid
                    passing through authentication systems.
    kind: path-problem
    problem.severity: error
    security-severity: 7.8
    precision: medium
    id: java/user-controlled-bypass
    tags: |-
      security
             external/cwe/cwe-807
             external/cwe/cwe-290
  queryHelp: "# User-controlled bypass of sensitive method\nMany Java constructs enable\
    \ code statements to be executed conditionally, for example `if` statements and\
    \ `for` statements. If these statements contain important authentication or login\
    \ code, and the decision about whether to execute this code is based on user-controlled\
    \ data, it may be possible for an attacker to bypass security systems by preventing\
    \ this code from executing.\n\n\n## Recommendation\nNever decide whether to authenticate\
    \ a user based on data that may be controlled by that user. If necessary, ensure\
    \ that the data is validated extensively when it is input before any authentication\
    \ checks are performed.\n\nIt is still possible to have a system that \"remembers\"\
    \ users, thus not requiring the user to login on every interaction. For example,\
    \ personalization settings can be applied without authentication because this\
    \ is not sensitive information. However, users should be allowed to take sensitive\
    \ actions only when they have been fully authenticated.\n\n\n## Example\nThis\
    \ example shows two ways of deciding whether to authenticate a user. The first\
    \ way shows a decision that is based on the value of a cookie. Cookies can be\
    \ easily controlled by the user, and so this allows a user to become authenticated\
    \ without providing valid credentials. The second, more secure way shows a decision\
    \ that is based on looking up the user in a security database.\n\n\n```java\n\
    public boolean doLogin(String user, String password) {\n\tCookie adminCookie =\
    \ getCookies()[0];\n\n\t// BAD: login is executed only if the value of 'adminCookie'\
    \ is 'false', \n\t// but 'adminCookie' is controlled by the user\n\tif(adminCookie.getValue()==\"\
    false\")\n\t\treturn login(user, password);\n\t\n\treturn true;\n}\n\npublic boolean\
    \ doLogin(String user, String password) {\n\tCookie adminCookie = getCookies()[0];\n\
    \t\n\t// GOOD: use server-side information based on the credentials to decide\n\
    \t// whether user has privileges\n\tboolean isAdmin = queryDbForAdminStatus(user,\
    \ password);\n\tif(!isAdmin)\n\t\treturn login(user, password);\n\t\n\treturn\
    \ true;\n}\n```\n\n## References\n* SEI CERT Oracle Coding Standard for Java:\
    \ [SEC02-J. Do not base security checks on untrusted sources](https://wiki.sei.cmu.edu/confluence/display/java/SEC02-J.+Do+not+base+security+checks+on+untrusted+sources).\n\
    * Common Weakness Enumeration: [CWE-807](https://cwe.mitre.org/data/definitions/807.html).\n\
    * Common Weakness Enumeration: [CWE-290](https://cwe.mitre.org/data/definitions/290.html).\n"
 -
  pack: codeql/java-queries#0
  relativeQueryPath: Security/CWE/CWE-807/TaintedPermissionsCheck.ql
  relativeBqrsPath: codeql/java-queries/Security/CWE/CWE-807/TaintedPermissionsCheck.bqrs
  metadata:
    name: User-controlled data used in permissions check
    description: |-
      Using user-controlled data in a permissions check may result in inappropriate
                    permissions being granted.
    kind: path-problem
    problem.severity: error
    security-severity: 7.8
    precision: high
    id: java/tainted-permissions-check
    tags: |-
      security
             external/cwe/cwe-807
             external/cwe/cwe-290
  queryHelp: "# User-controlled data used in permissions check\nUsing user-controlled\
    \ data in a permissions check may allow a user to gain unauthorized access to\
    \ protected functionality or data.\n\n\n## Recommendation\nWhen checking whether\
    \ a user is authorized for a particular activity, do not use data that is controlled\
    \ by that user in the permissions check. If necessary, always validate the input,\
    \ ideally against a fixed list of expected values.\n\nSimilarly, do not decide\
    \ which permission to check for based on user data. In particular, avoid using\
    \ computation to decide which permissions to check for. Use fixed permissions\
    \ for particular actions, rather than generating the permission to check for.\n\
    \n\n## Example\nThis example, using the Apache Shiro security framework, shows\
    \ two ways to specify the permissions to check. The first way uses a string, `whatDoTheyWantToDo`,\
    \ to specify the permissions to check. However, this string is built from user\
    \ input. This can allow an attacker to force a check against a permission that\
    \ they know they have, rather than the permission that should be checked. For\
    \ example, while trying to access the account details of another user, the attacker\
    \ could force the system to check whether they had permissions to access their\
    \ *own* account details, which is incorrect, and would allow them to perform the\
    \ action. The second, more secure way uses a fixed check that does not depend\
    \ on data that is controlled by the user.\n\n\n```java\npublic static void main(String[]\
    \ args) {\n\tString whatDoTheyWantToDo = args[0];\n\tSubject subject = SecurityUtils.getSubject();\n\
    \n\t// BAD: permissions decision made using tainted data\n\tif(subject.isPermitted(\"\
    domain:sublevel:\" + whatDoTheyWantToDo))\n\t\tdoIt();\n\n\t// GOOD: use fixed\
    \ checks\n\tif(subject.isPermitted(\"domain:sublevel:whatTheMethodDoes\"))\n\t\
    \tdoIt();\n}\n```\n\n## References\n* SEI CERT Oracle Coding Standard for Java:\
    \ [SEC02-J. Do not base security checks on untrusted sources](https://wiki.sei.cmu.edu/confluence/display/java/SEC02-J.+Do+not+base+security+checks+on+untrusted+sources).\n\
    * Common Weakness Enumeration: [CWE-807](https://cwe.mitre.org/data/definitions/807.html).\n\
    * Common Weakness Enumeration: [CWE-290](https://cwe.mitre.org/data/definitions/290.html).\n"
 -
  pack: codeql/java-queries#0
  relativeQueryPath: Security/CWE/CWE-829/InsecureDependencyResolution.ql
  relativeBqrsPath: codeql/java-queries/Security/CWE/CWE-829/InsecureDependencyResolution.bqrs
  metadata:
    name: Failure to use HTTPS or SFTP URL in Maven artifact upload/download
    description: Non-HTTPS connections can be intercepted by third parties.
    kind: problem
    problem.severity: error
    security-severity: 8.1
    precision: very-high
    id: java/maven/non-https-url
    tags: |-
      security
             external/cwe/cwe-300
             external/cwe/cwe-319
             external/cwe/cwe-494
             external/cwe/cwe-829
  queryHelp: |
    # Failure to use HTTPS or SFTP URL in Maven artifact upload/download
    Using an insecure protocol like HTTP or FTP to download your dependencies leaves your Maven build vulnerable to a [Man in the Middle (MITM)](https://en.wikipedia.org/wiki/Man-in-the-middle_attack). This can allow attackers to inject malicious code into the artifacts that you are resolving and infect build artifacts that are being produced. This can be used by attackers to perform a [Supply chain attack](https://en.wikipedia.org/wiki/Supply_chain_attack) against your project's users.

    This vulnerability has a [ CVSS v3.1 base score of 8.1/10 ](https://nvd.nist.gov/vuln-metrics/cvss/v3-calculator?vector=AV:N/AC:H/PR:N/UI:N/S:U/C:H/I:H/A:H&version=3.1).


    ## Recommendation
    Always use HTTPS or SFTP to download artifacts from artifact servers.


    ## Example
    These examples show examples of locations in Maven POM files where artifact repository upload/download is configured. The first shows the use of HTTP, the second shows the use of HTTPS.


    ```xml
    <?xml version="1.0" encoding="UTF-8"?>
    <project xmlns="http://maven.apache.org/POM/4.0.0"
             xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
             xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd">

        <modelVersion>4.0.0</modelVersion>

        <groupId>com.semmle</groupId>
        <artifactId>parent</artifactId>
        <version>1.0</version>
        <packaging>pom</packaging>

        <name>Security Testing</name>
        <description>An example of insecure download and upload of dependencies</description>

        <distributionManagement>
            <repository>
                <id>insecure-releases</id>
                <name>Insecure Repository Releases</name>
                <!-- BAD! Use HTTPS -->
                <url>http://insecure-repository.example</url>
            </repository>
            <snapshotRepository>
                <id>insecure-snapshots</id>
                <name>Insecure Repository Snapshots</name>
                <!-- BAD! Use HTTPS -->
                <url>http://insecure-repository.example</url>
            </snapshotRepository>
        </distributionManagement>
        <repositories>
            <repository>
                <id>insecure</id>
                <name>Insecure Repository</name>
                <!-- BAD! Use HTTPS -->
                <url>http://insecure-repository.example</url>
            </repository>
        </repositories>
        <pluginRepositories>
            <pluginRepository>
                <id>insecure-plugins</id>
                <name>Insecure Repository Releases</name>
                <!-- BAD! Use HTTPS -->
                <url>http://insecure-repository.example</url>
            </pluginRepository>
        </pluginRepositories>
    </project>

    ```

    ```xml
    <?xml version="1.0" encoding="UTF-8"?>
    <project xmlns="http://maven.apache.org/POM/4.0.0"
             xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
             xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd">

        <modelVersion>4.0.0</modelVersion>

        <groupId>com.semmle</groupId>
        <artifactId>parent</artifactId>
        <version>1.0</version>
        <packaging>pom</packaging>

        <name>Security Testing</name>
        <description>An example of secure download and upload of dependencies</description>

        <distributionManagement>
            <repository>
                <id>insecure-releases</id>
                <name>Secure Repository Releases</name>
                <!-- GOOD! Use HTTPS -->
                <url>https://insecure-repository.example</url>
            </repository>
            <snapshotRepository>
                <id>insecure-snapshots</id>
                <name>Secure Repository Snapshots</name>
                <!-- GOOD! Use HTTPS -->
                <url>https://insecure-repository.example</url>
            </snapshotRepository>
        </distributionManagement>
        <repositories>
            <repository>
                <id>insecure</id>
                <name>Secure Repository</name>
                <!-- GOOD! Use HTTPS -->
                <url>https://insecure-repository.example</url>
            </repository>
        </repositories>
        <pluginRepositories>
            <pluginRepository>
                <id>insecure-plugins</id>
                <name>Secure Repository Releases</name>
                <!-- GOOD! Use HTTPS -->
                <url>https://insecure-repository.example</url>
            </pluginRepository>
        </pluginRepositories>
    </project>

    ```

    ## References
    * Research: [ Want to take over the Java ecosystem? All you need is a MITM! ](https://medium.com/bugbountywriteup/want-to-take-over-the-java-ecosystem-all-you-need-is-a-mitm-1fc329d898fb?source=friends_link&sk=3c99970c55a899ad9ef41f126efcde0e)
    * Research: [ How to take over the computer of any Java (or Closure or Scala) Developer. ](https://max.computer/blog/how-to-take-over-the-computer-of-any-java-or-clojure-or-scala-developer/)
    * Proof of Concept: [ mveytsman/dilettante ](https://github.com/mveytsman/dilettante)
    * Additional Gradle &amp; Maven plugin: [ Announcing nohttp ](https://spring.io/blog/2019/06/10/announcing-nohttp)
    * Java Ecosystem Announcement: [ HTTP Decommission Artifact Server Announcements ](https://gist.github.com/JLLeitschuh/789e49e3d34092a005031a0a1880af99)
    * Common Weakness Enumeration: [CWE-300](https://cwe.mitre.org/data/definitions/300.html).
    * Common Weakness Enumeration: [CWE-319](https://cwe.mitre.org/data/definitions/319.html).
    * Common Weakness Enumeration: [CWE-494](https://cwe.mitre.org/data/definitions/494.html).
    * Common Weakness Enumeration: [CWE-829](https://cwe.mitre.org/data/definitions/829.html).
 -
  pack: codeql/java-queries#0
  relativeQueryPath: Security/CWE/CWE-833/LockOrderInconsistency.ql
  relativeBqrsPath: codeql/java-queries/Security/CWE/CWE-833/LockOrderInconsistency.bqrs
  metadata:
    name: Lock order inconsistency
    description: Acquiring multiple locks in a different order may cause deadlock.
    kind: problem
    problem.severity: recommendation
    security-severity: 5.0
    precision: medium
    id: java/lock-order-inconsistency
    tags: |-
      security
             external/cwe/cwe-833
  queryHelp: "# Lock order inconsistency\nAcquiring two locks in an inconsistent order\
    \ may result in deadlock if two threads simultaneously attempt to acquire the\
    \ locks, and each thread succeeds in acquiring one lock prior to being able to\
    \ acquire the other lock.\n\n\n## Recommendation\nTo guard against deadlock, use\
    \ one of the following alternatives:\n\n* Define an ordering on locks, and ensure\
    \ that clients respect that ordering when acquiring locks.\n* Simplify the code\
    \ to only use a single lock, where possible.\n* Use `ReentrantLock`s and acquire\
    \ locks using `tryLock()` instead of `lock()`.\n\n## Example\nIn the following\
    \ example, one method acquires `primaryLock` followed by `savingsLock`, and another\
    \ method acquires these locks in reverse order. This may result in deadlock if\
    \ the two methods are invoked by two threads simultaneously, and each thread acquires\
    \ one of the two locks prior to being able to acquire the other one.\n\n\n```java\n\
    class Test {\n\tprivate int primaryAccountBalance;\n\tprivate Object primaryLock\
    \ = new Object();\n\tprivate int savingsAccountBalance;\n\tprivate Object savingsLock\
    \ = new Object();\n\n\tpublic boolean transferToSavings(int amount) {\n\t\tsynchronized(primaryLock)\
    \ {\n\t\t\tsynchronized(savingsLock) {\n\t\t\t\tif (amount>0 && primaryAccountBalance>=amount)\
    \ {\n\t\t\t\t\tprimaryAccountBalance -= amount;\n\t\t\t\t\tsavingsAccountBalance\
    \ += amount;\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn false;\n\
    \t}\n\tpublic boolean transferToPrimary(int amount) {\n\t\t// AVOID: lock order\
    \ is different from \"transferToSavings\"\n\t\t// and may result in deadlock\n\
    \t\tsynchronized(savingsLock) {\n\t\t\tsynchronized(primaryLock) {\n\t\t\t\tif\
    \ (amount>0 && savingsAccountBalance>=amount) {\n\t\t\t\t\tsavingsAccountBalance\
    \ -= amount;\n\t\t\t\t\tprimaryAccountBalance += amount;\n\t\t\t\t\treturn true;\n\
    \t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}\n}\n\n```\nOne way to address\
    \ the issue in the above example is to reverse the lock order in `transferToPrimary`\
    \ to match the lock order in `transferToSecondary`.\n\n\n## References\n* SEI\
    \ CERT Oracle Coding Standard for Java: [LCK07-J. Avoid deadlock by requesting\
    \ and releasing locks in the same order](https://wiki.sei.cmu.edu/confluence/display/java/LCK07-J.+Avoid+deadlock+by+requesting+and+releasing+locks+in+the+same+order).\n\
    * Java Language Specification: [Synchronization](https://docs.oracle.com/javase/specs/jls/se11/html/jls-17.html#jls-17.1).\n\
    * Java API Specification: [ReentrantLock](https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/util/concurrent/locks/ReentrantLock.html).\n\
    * Common Weakness Enumeration: [CWE-833](https://cwe.mitre.org/data/definitions/833.html).\n"
 -
  pack: codeql/java-queries#0
  relativeQueryPath: Security/CWE/CWE-835/InfiniteLoop.ql
  relativeBqrsPath: codeql/java-queries/Security/CWE/CWE-835/InfiniteLoop.bqrs
  metadata:
    name: Loop with unreachable exit condition
    description: |-
      An iteration or loop with an exit condition that cannot be
                    reached is an indication of faulty logic and can likely lead to infinite
                    looping.
    kind: problem
    problem.severity: warning
    security-severity: 7.5
    precision: medium
    id: java/unreachable-exit-in-loop
    tags: |-
      security
             external/cwe/cwe-835
  queryHelp: |
    # Loop with unreachable exit condition
    Loops can contain multiple exit conditions, either directly in the loop condition or as guards around `break` or `return` statements. If an exit condition cannot be satisfied, then the code is misleading at best, and the loop might not terminate.


    ## Recommendation
    When writing a loop that is intended to terminate, make sure that all the necessary exit conditions can be satisfied and that loop termination is clear.


    ## Example
    The following example shows a potentially infinite loop, since the inner loop condition is constantly true. Of course, the loop may or may not be infinite depending on the behavior of `shouldBreak`, but if this was intended as the only exit condition the loop should be rewritten to make this clear.


    ```java
    for (int i=0; i<10; i++) {
        for (int j=0; i<10; j++) {
            // do stuff
            if (shouldBreak()) break;
        }
    }

    ```
    To fix the loop the condition is corrected to check the right variable.


    ```java
    for (int i=0; i<10; i++) {
        for (int j=0; j<10; j++) {
            // do stuff
            if (shouldBreak()) break;
        }
    }

    ```

    ## References
    * Java Language Specification: [Blocks and Statements](https://docs.oracle.com/javase/specs/jls/se11/html/jls-14.html).
    * Common Weakness Enumeration: [CWE-835](https://cwe.mitre.org/data/definitions/835.html).
 -
  pack: codeql/java-queries#0
  relativeQueryPath: Security/CWE/CWE-917/OgnlInjection.ql
  relativeBqrsPath: codeql/java-queries/Security/CWE/CWE-917/OgnlInjection.bqrs
  metadata:
    name: OGNL Expression Language statement with user-controlled input
    description: |-
      Evaluation of OGNL Expression Language statement with user-controlled input can
                      lead to execution of arbitrary code.
    kind: path-problem
    problem.severity: error
    security-severity: 9.8
    precision: high
    id: java/ognl-injection
    tags: |-
      security
             external/cwe/cwe-917
  queryHelp: "# OGNL Expression Language statement with user-controlled input\nObject-Graph\
    \ Navigation Language (OGNL) is an open-source Expression Language (EL) for Java.\
    \ OGNL can create or change executable code, consequently it can introduce critical\
    \ security flaws to any application that uses it. Evaluation of unvalidated expressions\
    \ is a common flaw in OGNL. This exposes the properties of Java objects to modification\
    \ by an attacker and may allow them to execute arbitrary code.\n\n\n## Recommendation\n\
    The general recommendation is to avoid evaluating untrusted ONGL expressions.\
    \ If user-provided OGNL expressions must be evaluated, do this in a sandbox and\
    \ validate the expressions before evaluation.\n\n\n## Example\nIn the following\
    \ examples, the code accepts an OGNL expression from the user and evaluates it.\n\
    \nIn the first example, the user-provided OGNL expression is parsed and evaluated.\n\
    \nThe second example validates the expression and evaluates it inside a sandbox.\
    \ You can add a sandbox by setting a system property, as shown in the example,\
    \ or by adding `-Dognl.security.manager` to JVM arguments.\n\n\n```java\nimport\
    \ ognl.Ognl;\nimport ognl.OgnlException;\n\npublic void evaluate(HttpServletRequest\
    \ request, Object root) throws OgnlException {\n  String expression = request.getParameter(\"\
    expression\");\n\n  // BAD: User provided expression is evaluated\n  Ognl.getValue(expression,\
    \ root);\n  \n  // GOOD: The name is validated and expression is evaluated in\
    \ sandbox\n  System.setProperty(\"ognl.security.manager\", \"\"); // Or add -Dognl.security.manager\
    \ to JVM args\n  if (isValid(expression)) {\n    Ognl.getValue(expression, root);\n\
    \  } else {\n    // Reject the request\n  }\n}\n\npublic void isValid(Strig expression)\
    \ {\n  // Custom method to validate the expression.\n  // For instance, make sure\
    \ it doesn't include unexpected code.\n}\n\n```\n\n## References\n* Apache Commons:\
    \ [Apache Commons OGNL](https://commons.apache.org/proper/commons-ognl/).\n* Struts\
    \ security: [Proactively protect from OGNL Expression Injections attacks](https://struts.apache.org/security/#proactively-protect-from-ognl-expression-injections-attacks-if-easily-applicable).\n\
    * Common Weakness Enumeration: [CWE-917](https://cwe.mitre.org/data/definitions/917.html).\n"
 -
  pack: codeql/java-queries#0
  relativeQueryPath: Security/CWE/CWE-918/RequestForgery.ql
  relativeBqrsPath: codeql/java-queries/Security/CWE/CWE-918/RequestForgery.bqrs
  metadata:
    name: Server-side request forgery
    description: |-
      Making web requests based on unvalidated user-input
                    may cause the server to communicate with malicious servers.
    kind: path-problem
    problem.severity: error
    security-severity: 9.1
    precision: high
    id: java/ssrf
    tags: |-
      security
             external/cwe/cwe-918
  queryHelp: "# Server-side request forgery\nDirectly incorporating user input into\
    \ an HTTP request without validating the input can facilitate server-side request\
    \ forgery (SSRF) attacks. In these attacks, the server may be tricked into making\
    \ a request and interacting with an attacker-controlled server.\n\n\n## Recommendation\n\
    To guard against SSRF attacks, you should avoid putting user-provided input directly\
    \ into a request URL. Instead, maintain a list of authorized URLs on the server;\
    \ then choose from that list based on the input provided. Alternatively, ensure\
    \ requests constructed from user input are limited to a particular host or more\
    \ restrictive URL prefix.\n\n\n## Example\nThe following example shows an HTTP\
    \ request parameter being used directly to form a new request without validating\
    \ the input, which facilitates SSRF attacks. It also shows how to remedy the problem\
    \ by validating the user input against a known fixed string.\n\n\n```java\nimport\
    \ java.net.http.HttpClient;\n\npublic class SSRF extends HttpServlet {\n\tprivate\
    \ static final String VALID_URI = \"http://lgtm.com\";\n\tprivate HttpClient client\
    \ = HttpClient.newHttpClient();\n\n\tprotected void doGet(HttpServletRequest request,\
    \ HttpServletResponse response)\n\t\tthrows ServletException, IOException {\n\t\
    \tURI uri = new URI(request.getParameter(\"uri\"));\n\t\t// BAD: a request parameter\
    \ is incorporated without validation into a Http request\n\t\tHttpRequest r =\
    \ HttpRequest.newBuilder(uri).build();\n\t\tclient.send(r, null);\n\n\t\t// GOOD:\
    \ the request parameter is validated against a known fixed string\n\t\tif (VALID_URI.equals(request.getParameter(\"\
    uri\"))) {\n\t\t\tHttpRequest r2 = HttpRequest.newBuilder(uri).build();\n\t\t\t\
    client.send(r2, null);\n\t\t}\n\t}\n}\n\n```\n\n## References\n* [OWASP SSRF](https://owasp.org/www-community/attacks/Server_Side_Request_Forgery)\n\
    * Common Weakness Enumeration: [CWE-918](https://cwe.mitre.org/data/definitions/918.html).\n"
 -
  pack: codeql/java-queries#0
  relativeQueryPath: Security/CWE/CWE-925/ImproperIntentVerification.ql
  relativeBqrsPath: codeql/java-queries/Security/CWE/CWE-925/ImproperIntentVerification.bqrs
  metadata:
    name: Improper verification of intent by broadcast receiver
    description: A broadcast receiver that does not verify intents it receives may
      be susceptible to unintended behavior by third party applications sending it
      explicit intents.
    kind: problem
    problem.severity: warning
    security-severity: 8.2
    precision: high
    id: java/improper-intent-verification
    tags: |-
      security
             external/cwe/cwe-925
  queryHelp: |
    # Improper verification of intent by broadcast receiver
    When an Android application uses a `BroadcastReceiver` to receive intents, it is also able to receive explicit intents that are sent directly to it, regardless of its filter. Certain intent actions are only able to be sent by the operating system, not third-party applications. However, a `BroadcastReceiver` that is registered to receive system intents is still able to receive intents from a third-party application, so it should check that the intent received has the expected action. Otherwise, a third-party application could impersonate the system this way to cause unintended behavior, such as a denial of service.


    ## Example
    In the following code, the `ShutdownReceiver` initiates a shutdown procedure upon receiving an intent, without checking that the received action is indeed `ACTION_SHUTDOWN`. This allows third-party applications to send explicit intents to this receiver to cause a denial of service.


    ```java
    public class ShutdownReceiver extends BroadcastReceiver {
        @Override
        public void onReceive(final Context context, final Intent intent) {
            mainActivity.saveLocalData();
            mainActivity.stopActivity();
        }
    }
    ```

    ```xml
    <manifest xmlns:android="http://schemas.android.com/apk/res/android" package="test">
        <application>
            <receiver android:name=".BootReceiverXml">
                <intent-filter>
                    <action android:name="android.intent.action.BOOT_COMPLETED" />
                </intent-filter>
            </receiver>
        </application>
    </manifest>
    ```

    ## Recommendation
    In the `onReceive` method of a `BroadcastReceiver`, the action of the received Intent should be checked. The following code demonstrates this.


    ```java
    public class ShutdownReceiver extends BroadcastReceiver {
        @Override
        public void onReceive(final Context context, final Intent intent) {
            if (!intent.getAction().equals(Intent.ACTION_SHUTDOWN)) {
                return;
            }
            mainActivity.saveLocalData();
            mainActivity.stopActivity();
        }
    }
    ```

    ## References
    * Common Weakness Enumeration: [CWE-925](https://cwe.mitre.org/data/definitions/925.html).
 -
  pack: codeql/java-queries#0
  relativeQueryPath: Security/CWE/CWE-926/ContentProviderIncompletePermissions.ql
  relativeBqrsPath: codeql/java-queries/Security/CWE/CWE-926/ContentProviderIncompletePermissions.bqrs
  metadata:
    name: Missing read or write permission in a content provider
    description: Android content providers which do not configure both read and write
      permissions can allow permission bypass.
    kind: problem
    problem.severity: warning
    security-severity: 8.2
    id: java/android/incomplete-provider-permissions
    tags: |-
      security
             external/cwe/cwe-926
    precision: medium
  queryHelp: |
    # Missing read or write permission in a content provider
    The Android manifest file specifies the content providers for the application using `provider` elements. The `provider` element specifies the explicit permissions an application requires in order to access a resource using that provider. You specify the permissions using the `android:readPermission`, `android:writePermission`, or `android:permission` attributes. If you do not specify the permission required to perform an operation, the application will implicitly have access to perform that operation. For example, if you specify only `android:readPermission`, the application must have explicit permission to read data, but requires no permission to write data.


    ## Recommendation
    To prevent permission bypass, you should create `provider` elements that either specify both the `android:readPermission` and `android:writePermission` attributes, or specify the `android:permission` attribute.


    ## Example
    In the following two (bad) examples, the provider is configured with only read or write permissions. This allows a malicious application to bypass the permission check by requesting access to the unrestricted operation.


    ```xml
    <manifest ... >
        <application ...>
          <!-- BAD: only 'android:readPermission' is set -->
          <provider
              android:name=".MyContentProvider"
              android:authorities="table"
              android:enabled="true"
              android:exported="true"
              android:readPermission="android.permission.MANAGE_DOCUMENTS">
          </provider>
        </application>
    </manifest>

    ```

    ```xml
    <manifest ... >
        <application ...>
          <!-- BAD: only 'android:writePermission' is set -->
          <provider
              android:name=".MyContentProvider"
              android:authorities="table"
              android:enabled="true"
              android:exported="true"
              android:writePermission="android.permission.MANAGE_DOCUMENTS">
          </provider>
        </application>
    </manifest>

    ```
    In the following (good) examples, the provider is configured with full permissions, protecting it from a permissions bypass.


    ```xml
    <manifest ... >
        <application ...>
          <!-- Good: both 'android:readPermission' and 'android:writePermission' are set -->
          <provider
              android:name=".MyContentProvider"
              android:authorities="table"
              android:enabled="true"
              android:exported="true"
              android:writePermission="android.permission.MANAGE_DOCUMENTS"
              android:readPermission="android.permission.MANAGE_DOCUMENTS">
          </provider>
        </application>
    </manifest>

    ```

    ```xml
    <manifest ... >
        <application ...>
          <!-- Good: 'android:permission' is set  -->
          <provider
              android:name=".MyContentProvider"
              android:authorities="table"
              android:enabled="true"
              android:exported="true"
              android:permission="android.permission.MANAGE_DOCUMENTS">
          </provider>
        </application>
    </manifest>

    ```

    ## References
    * Android Documentation: [Provider element](https://developer.android.com/guide/topics/manifest/provider-element)
    * CVE-2021-41166: [Insufficient permission control in Nextcloud Android app](https://nvd.nist.gov/vuln/detail/CVE-2021-41166)
    * GitHub Security Lab Research: [Insufficient permission control in Nextcloud Android app](https://securitylab.github.com/advisories/GHSL-2021-1007-Nextcloud_Android_app/#issue-2-permission-bypass-in-disklruimagecachefileprovider-ghsl-2021-1008)
    * Common Weakness Enumeration: [CWE-926](https://cwe.mitre.org/data/definitions/926.html).
 -
  pack: codeql/java-queries#0
  relativeQueryPath: Security/CWE/CWE-926/ImplicitlyExportedAndroidComponent.ql
  relativeBqrsPath: codeql/java-queries/Security/CWE/CWE-926/ImplicitlyExportedAndroidComponent.bqrs
  metadata:
    name: Implicitly exported Android component
    description: "Android components with an '<intent-filter>' and no 'android:exported'\
      \ attribute are implicitly exported, which can allow for improper access to\
      \ the components themselves and to their data."
    kind: problem
    problem.severity: warning
    security-severity: 8.2
    id: java/android/implicitly-exported-component
    tags: |-
      security
             external/cwe/cwe-926
    precision: high
  queryHelp: |
    # Implicitly exported Android component
    The Android manifest file defines configuration settings for Android applications. In this file, components can be declared with intent filters which specify what the components can do and what types of intents the components can respond to. If the `android:exported` attribute is omitted from the component when an intent filter is included, then the component will be implicitly exported.

    An implicitly exported component could allow for improper access to the component and its data.


    ## Recommendation
    Explicitly set the `android:exported` attribute for every component or use permissions to limit access to the component.


    ## Example
    In the example below, the `android:exported` attribute is omitted when an intent filter is used.


    ```xml
    <manifest ... >
        <application ...
            <!-- BAD: this component is implicitly exported -->
            <activity>
                android:name=".Activity">
                <intent-filter>
                    <action android:name="android.intent.action.VIEW" />
                </intent-filter>
            </activity>
        </application>
    </manifest>

    ```
    A corrected version sets the `android:exported` attribute to `false`.


    ```xml
    <manifest ... >
        <application ...
            <!-- GOOD: this component is not exported due to 'android:exported' explicitly set to 'false'-->
            <activity>
                android:name=".Activity">
                android:exported="false"
                <intent-filter>
                    <action android:name="android.intent.action.VIEW" />
                </intent-filter>
            </activity>
        </application>
    </manifest>

    ```

    ## References
    * Android Developers: [App Manifest Overview](https://developer.android.com/guide/topics/manifest/manifest-intro).
    * Android Developers: [The &lt;intent-filter&gt; element](https://developer.android.com/guide/topics/manifest/intent-filter-element).
    * Android Developers: [The android:exported attribute](https://developer.android.com/guide/topics/manifest/activity-element#exported).
    * Android Developers: [The android:permission attribute](https://developer.android.com/guide/topics/manifest/activity-element#prmsn).
    * Android Developers: [Safer component exporting](https://developer.android.com/about/versions/12/behavior-changes-12#exported).
    * Common Weakness Enumeration: [CWE-926](https://cwe.mitre.org/data/definitions/926.html).
 -
  pack: codeql/java-queries#0
  relativeQueryPath: Security/CWE/CWE-927/ImplicitPendingIntents.ql
  relativeBqrsPath: codeql/java-queries/Security/CWE/CWE-927/ImplicitPendingIntents.bqrs
  metadata:
    name: Use of implicit PendingIntents
    description: |-
      Sending an implicit and mutable 'PendingIntent' to an unspecified third party
                    component may provide an attacker with access to internal components of the
                    application or cause other unintended effects.
    kind: path-problem
    problem.severity: error
    security-severity: 8.2
    precision: high
    id: java/android/implicit-pendingintents
    tags: |-
      security
             external/cwe/cwe-927
  queryHelp: "# Use of implicit PendingIntents\nA `PendingIntent` is used to wrap\
    \ an `Intent` that will be supplied and executed by another application. When\
    \ the `Intent` is executed, it behaves as if it were run directly by the supplying\
    \ application, using the privileges of that application.\n\nIf a `PendingIntent`\
    \ is configured to be mutable, the fields of its internal `Intent` can be changed\
    \ by the receiving application if they were not previously set. This means that\
    \ a mutable `PendingIntent` that has not defined a destination component (that\
    \ is, an implicit `PendingIntent`) can be altered to execute an arbitrary action\
    \ with the privileges of the application that created it.\n\nA malicious application\
    \ can access an implicit `PendingIntent` as follows:\n\n* It is wrapped and sent\
    \ as an extra of another implicit `Intent`.\n* It is sent as the action of a `Slide`.\n\
    * It is sent as the action of a `Notification`.\n\n\nOn gaining access, the attacker\
    \ can modify the underlying `Intent` and execute an arbitrary action with elevated\
    \ privileges. This could give the malicious application access to private components\
    \ of the victim application, or the ability to perform actions without having\
    \ the necessary permissions.\n\n\n## Recommendation\nAvoid creating implicit `PendingIntent`s.\
    \ This means that the underlying `Intent` should always have an explicit destination\
    \ component.\n\nWhen you add the `PendingIntent` as an extra of another `Intent`,\
    \ make sure that this second `Intent` also has an explicit destination component,\
    \ so that it is not delivered to untrusted applications.\n\nCreate the `PendingIntent`\
    \ using the flag `FLAG_IMMUTABLE` whenever possible, to prevent the destination\
    \ component from modifying empty fields of the underlying `Intent`.\n\n\n## Example\n\
    In the following examples, a `PendingIntent` is created and wrapped as an extra\
    \ of another `Intent`.\n\nIn the first example, both the `PendingIntent` and the\
    \ `Intent` it is wrapped in are implicit, making them vulnerable to attack.\n\n\
    In the second example, the issue is avoided by adding explicit destination components\
    \ to the `PendingIntent` and the wrapping `Intent`.\n\nThe third example uses\
    \ the `FLAG_IMMUTABLE` flag to prevent the underlying `Intent` from being modified\
    \ by the destination component.\n\n\n```java\nimport android.app.Activity;\nimport\
    \ android.app.PendingIntent;\nimport android.content.Intent;\nimport android.os.Bundle;\n\
    \npublic class ImplicitPendingIntents extends Activity {\n\n\tpublic void onCreate(Bundle\
    \ savedInstance) {\n\t\t{\n\t\t\t// BAD: an implicit Intent is used to create\
    \ a PendingIntent.\n\t\t\t// The PendingIntent is then added to another implicit\
    \ Intent\n\t\t\t// and started.\n\t\t\tIntent baseIntent = new Intent();\n\t\t\
    \tPendingIntent pi =\n\t\t\t\t\tPendingIntent.getActivity(this, 0, baseIntent,\
    \ PendingIntent.FLAG_ONE_SHOT);\n\t\t\tIntent fwdIntent = new Intent(\"SOME_ACTION\"\
    );\n\t\t\tfwdIntent.putExtra(\"fwdIntent\", pi);\n\t\t\tsendBroadcast(fwdIntent);\n\
    \t\t}\n\n\t\t{\n\t\t\t// GOOD: both the PendingIntent and the wrapping Intent\
    \ are explicit.\n\t\t\tIntent safeIntent = new Intent(this, AnotherActivity.class);\n\
    \t\t\tPendingIntent pi =\n\t\t\t\t\tPendingIntent.getActivity(this, 0, safeIntent,\
    \ PendingIntent.FLAG_ONE_SHOT);\n\t\t\tIntent fwdIntent = new Intent();\n\t\t\t\
    fwdIntent.setClassName(\"destination.package\", \"DestinationClass\");\n\t\t\t\
    fwdIntent.putExtra(\"fwdIntent\", pi);\n\t\t\tstartActivity(fwdIntent);\n\t\t\
    }\n\n\t\t{\n\t\t\t// GOOD: The PendingIntent is created with FLAG_IMMUTABLE.\n\
    \t\t\tIntent baseIntent = new Intent(\"SOME_ACTION\");\n\t\t\tPendingIntent pi\
    \ =\n\t\t\t\t\tPendingIntent.getActivity(this, 0, baseIntent, PendingIntent.FLAG_IMMUTABLE);\n\
    \t\t\tIntent fwdIntent = new Intent();\n\t\t\tfwdIntent.setClassName(\"destination.package\"\
    , \"DestinationClass\");\n\t\t\tfwdIntent.putExtra(\"fwdIntent\", pi);\n\t\t\t\
    startActivity(fwdIntent);\n\t\t}\n\t}\n}\n\n```\n\n## References\n* Google Help:\
    \ [ Remediation for Implicit PendingIntent Vulnerability ](https://support.google.com/faqs/answer/10437428?hl=en)\n\
    * University of Potsdam: [ PIAnalyzer: A precise approach for PendingIntent vulnerability\
    \ analysis ](https://www.cs.uni-potsdam.de/se/papers/esorics18.pdf)\n* Common\
    \ Weakness Enumeration: [CWE-927](https://cwe.mitre.org/data/definitions/927.html).\n"
 -
  pack: codeql/java-queries#0
  relativeQueryPath: Security/CWE/CWE-927/SensitiveCommunication.ql
  relativeBqrsPath: codeql/java-queries/Security/CWE/CWE-927/SensitiveCommunication.bqrs
  metadata:
    name: Leaking sensitive information through an implicit Intent
    description: |-
      An Android application uses implicit Intents containing sensitive data
                    in a way that exposes it to arbitrary applications on the device.
    kind: path-problem
    problem.severity: warning
    security-severity: 8.2
    precision: medium
    id: java/android/sensitive-communication
    tags: |-
      security
             external/cwe/cwe-927
  queryHelp: "# Leaking sensitive information through an implicit Intent\nWhen an\
    \ implicit Intent is used with a method such as `startActivity`, `startService`,\
    \ or `sendBroadcast`, it may be read by other applications on the device.\n\n\
    This means that sensitive data in these Intents may be leaked.\n\n\n## Recommendation\n\
    For `sendBroadcast` methods, a receiver permission may be specified so that only\
    \ applications with a certain permission may receive the Intent; or a `LocalBroadcastManager`\
    \ may be used. Otherwise, ensure that Intents containing sensitive data have an\
    \ explicit receiver class set.\n\n\n## Example\nThe following example shows two\
    \ ways of broadcasting Intents. In the 'BAD' case, no \"receiver permission\"\
    \ is specified. In the 'GOOD' case, \"receiver permission\" or \"receiver application\"\
    \ is specified.\n\n\n```java\npublic void sendBroadcast1(Context context, String\
    \ token, String refreshToken) \n{\n    {\n        // BAD: broadcast sensitive\
    \ information to all listeners\n        Intent intent = new Intent();\n      \
    \  intent.setAction(\"com.example.custom_action\");\n        intent.putExtra(\"\
    token\", token);\n        intent.putExtra(\"refreshToken\", refreshToken);\n \
    \       context.sendBroadcast(intent);\n    }\n\n    {\n        // GOOD: broadcast\
    \ sensitive information only to those with permission\n        Intent intent =\
    \ new Intent();\n        intent.setAction(\"com.example.custom_action\");\n  \
    \      intent.putExtra(\"token\", token);\n        intent.putExtra(\"refreshToken\"\
    , refreshToken);\n        context.sendBroadcast(intent, \"com.example.user_permission\"\
    );\n    }\n\n    {\n        // GOOD: broadcast sensitive information to a specific\
    \ application\n        Intent intent = new Intent();\n        intent.setAction(\"\
    com.example.custom_action\");\n        intent.setClassName(\"com.example2\", \"\
    com.example2.UserInfoHandler\");\n        intent.putExtra(\"token\", token);\n\
    \        intent.putExtra(\"refreshToken\", refreshToken);\n        context.sendBroadcast(intent);\n\
    \    }\n}\n```\n\n## References\n* Android Developers: [Security considerations\
    \ and best practices for sending and receiving broadcasts](https://developer.android.com/guide/components/broadcasts)\n\
    * SonarSource: [Broadcasting intents is security-sensitive](https://rules.sonarsource.com/java/type/Security%20Hotspot/RSPEC-5320)\n\
    * Android Developer Fundamentals: [Restricting broadcasts](https://google-developer-training.github.io/android-developer-fundamentals-course-concepts-v2/unit-3-working-in-the-background/lesson-7-background-tasks/7-3-c-broadcasts/7-3-c-broadcasts.html)\n\
    * Carnegie Mellon University: [DRD03-J. Do not broadcast sensitive information\
    \ using an implicit intent](https://wiki.sei.cmu.edu/confluence/display/android/DRD03-J.+Do+not+broadcast+sensitive+information+using+an+implicit+intent)\n\
    * Android Developers: [Android LiveData Overview](https://developer.android.com/topic/libraries/architecture/livedata)\n\
    * Oversecured: [Interception of Android implicit intents](https://blog.oversecured.com/Interception-of-Android-implicit-intents/)\n\
    * Common Weakness Enumeration: [CWE-927](https://cwe.mitre.org/data/definitions/927.html).\n"
 -
  pack: codeql/java-queries#0
  relativeQueryPath: Security/CWE/CWE-927/SensitiveResultReceiver.ql
  relativeBqrsPath: codeql/java-queries/Security/CWE/CWE-927/SensitiveResultReceiver.bqrs
  metadata:
    name: Leaking sensitive information through a ResultReceiver
    description: |-
      Sending sensitive data to a 'ResultReceiver' obtained from an untrusted source
                    can allow malicious actors access to your information.
    kind: path-problem
    problem.severity: error
    security-severity: 8.2
    precision: medium
    id: java/android/sensitive-result-receiver
    tags: |-
      security
             external/cwe/cwe-927
  queryHelp: "# Leaking sensitive information through a ResultReceiver\nIf a `ResultReceiver`\
    \ is obtained from an untrusted source, such as an `Intent` received by an exported\
    \ component, do not send it sensitive data. Otherwise, the information may be\
    \ leaked to a malicious application.\n\n\n## Recommendation\nDo not send sensitive\
    \ data to an untrusted `ResultReceiver`.\n\n\n## Example\nIn the following (bad)\
    \ example, sensitive data is sent to an untrusted `ResultReceiver`.\n\n\n```java\n\
    // BAD: Sensitive data is sent to an untrusted result receiver \nvoid bad(String\
    \ password) {\n    Intent intent = getIntent();\n    ResultReceiver rec = intent.getParcelableExtra(\"\
    Receiver\");\n    Bundle b = new Bundle();\n    b.putCharSequence(\"pass\", password);\n\
    \    rec.send(0, b); \n}\n```\n\n## References\n* Common Weakness Enumeration:\
    \ [CWE-927](https://cwe.mitre.org/data/definitions/927.html).\n"
 -
  pack: codeql/java-queries#0
  relativeQueryPath: Security/CWE/CWE-940/AndroidIntentRedirection.ql
  relativeBqrsPath: codeql/java-queries/Security/CWE/CWE-940/AndroidIntentRedirection.bqrs
  metadata:
    name: Android Intent redirection
    description: |-
      Starting Android components with user-provided Intents
                    can provide access to internal components of the application,
                    increasing the attack surface and potentially causing unintended effects.
    kind: path-problem
    problem.severity: error
    security-severity: 7.5
    precision: high
    id: java/android/intent-redirection
    tags: |-
      security
             external/cwe/cwe-926
             external/cwe/cwe-940
  queryHelp: "# Android Intent redirection\nAn exported Android component that obtains\
    \ a user-provided Intent and uses it to launch another component can be exploited\
    \ to obtain access to private, unexported components of the same app or to launch\
    \ other apps' components on behalf of the victim app.\n\n\n## Recommendation\n\
    Do not export components that start other components from a user-provided Intent.\
    \ They can be made private by setting the `android:exported` property to `false`\
    \ in the app's Android Manifest.\n\nIf this is not possible, restrict either which\
    \ apps can send Intents to the affected component, or which components can be\
    \ started from it.\n\n\n## Example\nThe following snippet contains three examples.\
    \ In the first example, an arbitrary component can be started from the externally\
    \ provided `forward_intent` Intent. In the second example, the destination component\
    \ of the Intent is first checked to make sure it is safe. In the third example,\
    \ the component that created the Intent is first checked to make sure it comes\
    \ from a trusted origin.\n\n\n```java\n// BAD: A user-provided Intent is used\
    \ to launch an arbitrary component\nIntent forwardIntent = (Intent) getIntent().getParcelableExtra(\"\
    forward_intent\");\nstartActivity(forwardIntent);\n\n// GOOD: The destination\
    \ component is checked before launching it\nIntent forwardIntent = (Intent) getIntent().getParcelableExtra(\"\
    forward_intent\");\nComponentName destinationComponent = forwardIntent.resolveActivity(getPackageManager());\n\
    if (destinationComponent.getPackageName().equals(\"safe.package\") && \n    destinationComponent.getClassName().equals(\"\
    SafeClass\")) {\n    startActivity(forwardIntent);\n}\n\n// GOOD: The component\
    \ that sent the Intent is checked before launching the destination component\n\
    Intent forwardIntent = (Intent) getIntent().getParcelableExtra(\"forward_intent\"\
    );\nComponentName originComponent = getCallingActivity();\nif (originComponent.getPackageName().equals(\"\
    trusted.package\") && originComponent.getClassName().equals(\"TrustedClass\"))\
    \ {\n    startActivity(forwardIntent);\n}\n\n```\n\n## References\n* Google: [Remediation\
    \ for Intent Redirection Vulnerability](https://support.google.com/faqs/answer/9267555?hl=en).\n\
    * OWASP Mobile Security Testing Guide: [Intents](https://mobile-security.gitbook.io/mobile-security-testing-guide/android-testing-guide/0x05a-platform-overview#intents).\n\
    * Android Developers: [The android:exported attribute](https://developer.android.com/guide/topics/manifest/activity-element#exported).\n\
    * Common Weakness Enumeration: [CWE-926](https://cwe.mitre.org/data/definitions/926.html).\n\
    * Common Weakness Enumeration: [CWE-940](https://cwe.mitre.org/data/definitions/940.html).\n"
 -
  pack: codeql/java-queries#0
  relativeQueryPath: Telemetry/DatabaseQualityDiagnostics.ql
  relativeBqrsPath: codeql/java-queries/Telemetry/DatabaseQualityDiagnostics.bqrs
  metadata:
    name: Low Java analysis quality
    description: Low Java analysis quality
    kind: diagnostic
    id: java/diagnostic/database-quality
 -
  pack: codeql/java-queries#0
  relativeQueryPath: Telemetry/ExternalLibraryUsage.ql
  relativeBqrsPath: codeql/java-queries/Telemetry/ExternalLibraryUsage.bqrs
  metadata:
    name: External libraries
    description: A list of external libraries used in the code
    kind: metric
    tags: summary telemetry
    id: java/telemetry/external-libs
 -
  pack: codeql/java-queries#0
  relativeQueryPath: Telemetry/ExtractorInformation.ql
  relativeBqrsPath: codeql/java-queries/Telemetry/ExtractorInformation.bqrs
  metadata:
    name: Java extraction information
    description: Information about the extraction for a Java database
    kind: metric
    tags: summary telemetry
    id: java/telemetry/extraction-information
 -
  pack: codeql/java-queries#0
  relativeQueryPath: Telemetry/SupportedExternalApis.ql
  relativeBqrsPath: codeql/java-queries/Telemetry/SupportedExternalApis.bqrs
  metadata:
    name: Usage of supported APIs coming from external libraries
    description: A list of supported 3rd party APIs used in the codebase. Excludes
      test and generated code.
    kind: metric
    tags: summary telemetry
    id: java/telemetry/supported-external-api
 -
  pack: codeql/java-queries#0
  relativeQueryPath: Telemetry/SupportedExternalSinks.ql
  relativeBqrsPath: codeql/java-queries/Telemetry/SupportedExternalSinks.bqrs
  metadata:
    name: Supported sinks in external libraries
    description: A list of 3rd party APIs detected as sinks. Excludes test and generated
      code.
    kind: metric
    tags: summary telemetry
    id: java/telemetry/supported-external-api-sinks
 -
  pack: codeql/java-queries#0
  relativeQueryPath: Telemetry/SupportedExternalSources.ql
  relativeBqrsPath: codeql/java-queries/Telemetry/SupportedExternalSources.bqrs
  metadata:
    name: Supported sources in external libraries
    description: A list of 3rd party APIs detected as sources. Excludes test and generated
      code.
    kind: metric
    tags: summary telemetry
    id: java/telemetry/supported-external-api-sources
 -
  pack: codeql/java-queries#0
  relativeQueryPath: Telemetry/SupportedExternalTaint.ql
  relativeBqrsPath: codeql/java-queries/Telemetry/SupportedExternalTaint.bqrs
  metadata:
    name: Supported flow steps in external libraries
    description: A list of 3rd party APIs detected as flow steps. Excludes test and
      generated code.
    kind: metric
    tags: summary telemetry
    id: java/telemetry/supported-external-api-taint
 -
  pack: codeql/java-queries#0
  relativeQueryPath: Telemetry/UnsupportedExternalAPIs.ql
  relativeBqrsPath: codeql/java-queries/Telemetry/UnsupportedExternalAPIs.bqrs
  metadata:
    name: Usage of unsupported APIs coming from external libraries
    description: A list of 3rd party APIs used in the codebase. Excludes test and
      generated code.
    kind: metric
    tags: summary telemetry
    id: java/telemetry/unsupported-external-api
 -
  pack: codeql/java-queries#0
  relativeQueryPath: Violations of Best Practice/Boolean Logic/SimplifyBoolExpr.ql
  relativeBqrsPath: codeql/java-queries/Violations of Best Practice/Boolean Logic/SimplifyBoolExpr.bqrs
  metadata:
    name: Unnecessarily complex boolean expression
    description: Boolean expressions that are unnecessarily complicated hinder readability.
    kind: problem
    problem.severity: recommendation
    precision: low
    id: java/complex-boolean-expression
    tags: readability
  queryHelp: "# Unnecessarily complex boolean expression\nThere are a number of boolean\
    \ expression patterns that can easily be rewritten to make them simpler. Boolean\
    \ expressions involving comparisons with boolean literals, ternary conditionals\
    \ with a boolean literal as one of the results, double negations, or negated comparisons\
    \ can all be changed to equivalent and simpler expressions.\n\n\n## Recommendation\n\
    If `A` and `B` are expressions of boolean type, you can simplify them using the\
    \ rewrites shown below. These rewrites are equally suitable for the primitive\
    \ type `boolean` and the boxed type `Boolean`.\n\n<table><tbody> <tr><th>Expression</th><th></th><th>Simplified\
    \ expression</th><th></th></tr> <tr><td><code>A == true</code></td><td></td><td><code>A</code></td><td>(\\\
    *)</td></tr> <tr><td><code>A != false</code></td><td></td><td><code>A</code></td><td>(\\\
    *)</td></tr> <tr><td><code>A == false</code></td><td></td><td><code>!A</code></td><td></td></tr>\
    \ <tr><td><code>A != true</code></td><td></td><td><code>!A</code></td><td></td></tr>\
    \ <tr><td><code>A ? true : B</code></td><td></td><td><code>A || B</code></td><td></td></tr>\
    \ <tr><td><code>A ? B : false</code></td><td></td><td><code>A &amp;&amp; B</code></td><td></td></tr>\
    \ <tr><td><code>A ? B : true</code></td><td></td><td><code>!A || B</code></td><td></td></tr>\
    \ <tr><td><code>A ? false : B</code></td><td></td><td><code>!A &amp;&amp; B</code></td><td></td></tr>\
    \ <tr><td><code>A ? true : false</code></td><td></td><td><code>A</code></td><td>(\\\
    *)</td></tr> <tr><td><code>A ? false : true</code></td><td></td><td><code>!A</code></td><td></td></tr>\
    \ <tr><td><code>!!A</code></td><td></td><td><code>A</code></td><td>(\\*)</td></tr>\
    \ </tbody></table>\nNote that all of these rewrites yield completely equivalent\
    \ code, except possibly for those marked with (\\*) when `A` has type `Boolean`.\
    \ These can depend on the context if `null` values are involved. This is because\
    \ a comparison or test of a `Boolean` will perform an automatic unboxing conversion\
    \ that throws a `NullPointerException` if `null` is encountered, so the rewrites\
    \ marked (\\*) are only completely equivalent if the surrounding context of the\
    \ expression unboxes the value, for example by occurring as the condition in an\
    \ `if` statement.\n\nIn addition to the rewrites above, negated comparisons can\
    \ also be simplified in the following way:\n\n<table><tbody> <tr><th>Expression</th><th></th><th>Simplified\
    \ expression</th></tr> <tr><td><code>!(A == B)</code></td><td></td><td><code>A\
    \ != B</code></td></tr> <tr><td><code>!(A != B)</code></td><td></td><td><code>A\
    \ == B</code></td></tr> <tr><td><code>!(A &lt; B)</code></td><td></td><td><code>A\
    \ &gt;= B</code></td></tr> <tr><td><code>!(A &gt; B)</code></td><td></td><td><code>A\
    \ &lt;= B</code></td></tr> <tr><td><code>!(A &lt;= B)</code></td><td></td><td><code>A\
    \ &gt; B</code></td></tr> <tr><td><code>!(A &gt;= B)</code></td><td></td><td><code>A\
    \ &lt; B</code></td></tr> </tbody></table>\n\n## Example\nIn the following example\
    \ the method `f2` is a straightforward simplification of `f1`; they will both\
    \ throw a `NullPointerException` if a `null` is encountered. A similar rewrite\
    \ of `g1` would however result in a method with a different meaning, and a rewrite\
    \ along the lines of `g2` might be more appropriate. In any case, care should\
    \ be taken to ensure correct behavior for `null` values when the boxed type `Boolean`\
    \ is used.\n\n\n```java\nboolean f1(List<Boolean> l) {\n\tfor(Boolean x : l) {\n\
    \t\tif (x == true) return true;\n\t}\n\treturn false;\n}\n\nboolean f2(List<Boolean>\
    \ l) {\n\tfor(Boolean x : l) {\n\t\tif (x) return true;\n\t}\n\treturn false;\n\
    }\n\nvoid g1(List<Boolean> l1) {\n\tList<Boolean> l2 = new ArrayList<Boolean>();\n\
    \tfor(Boolean x : l1) {\n\t\tl2.add(x == true);\n\t}\n}\n\nvoid g2(List<Boolean>\
    \ l1) {\n\tList<Boolean> l2 = new ArrayList<Boolean>();\n\tfor(Boolean x : l1)\
    \ {\n\t\tif (x == null) {\n\t\t\t// handle null case\n\t\t}\n\t\tl2.add(x);\n\t\
    }\n}\n\n```\n\n## References\n* Java Language Specification: [Logical Complement\
    \ Operator !](https://docs.oracle.com/javase/specs/jls/se11/html/jls-15.html#jls-15.15.6),\
    \ [Boolean Equality Operators == and !=](https://docs.oracle.com/javase/specs/jls/se11/html/jls-15.html#jls-15.21.2),\
    \ [Conditional-And Operator &amp;&amp;](https://docs.oracle.com/javase/specs/jls/se11/html/jls-15.html#jls-15.23),\
    \ [Conditional-Or Operator ||](https://docs.oracle.com/javase/specs/jls/se11/html/jls-15.html#jls-15.24),\
    \ [Conditional Operator ? :](https://docs.oracle.com/javase/specs/jls/se11/html/jls-15.html#jls-15.25).\n"
 -
  pack: codeql/java-queries#0
  relativeQueryPath: Violations of Best Practice/Boxed Types/BoxedVariable.ql
  relativeBqrsPath: codeql/java-queries/Violations of Best Practice/Boxed Types/BoxedVariable.bqrs
  metadata:
    name: Boxed variable is never null
    description: |-
      Using a boxed type for a variable that is never assigned 'null'
                    hinders readability because it implies that 'null' is a potential value.
    kind: problem
    problem.severity: warning
    precision: very-high
    id: java/non-null-boxed-variable
    tags: |-
      readability
             types
  queryHelp: |
    # Boxed variable is never null
    In Java all of the primitive types have boxed counterparts. The boxed types are objects and can therefore be `null`, whereas the primitive types can never be `null`. The names of the primitive and boxed types are similar except that primitive types start with a lower-case letter and boxed types start with an upper-case letter (also, for `char` and `int` the names of the boxed types are slightly longer, namely `Character` and `Integer`).

    Because the names are so similar and because Java performs automatic boxing and unboxing conversions, they can easily be confused. Furthermore, using a boxed type where a primitive type was intended leads to both readability issues and potentially superfluous allocation of objects.


    ## Recommendation
    If a variable is never assigned `null` it should use the primitive type, as this both directly shows the impossibility of `null` and also avoids unnecessary boxing and unboxing conversions.


    ## Example
    In the example below the variable `done` controls the loop exit. It is only set to `false` before the loop entry and set to `true` at some point during the loop iteration.


    ```java
    Boolean done = false;
    while (!done) {
      // ...
      done = true;
      // ...
    }

    ```
    Each of the assignments to `done` involves a boxing conversion and the check involves an unboxing conversion. Since `done` is never `null`, these conversions can be completely avoided, and the code made clearer, by using the primitive type instead. Therefore the code should be rewritten in the following way:


    ```java
    boolean done = false;
    while (!done) {
      // ...
      done = true;
      // ...
    }

    ```

    ## References
    * Java Language Specification: [Boxing Conversion](https://docs.oracle.com/javase/specs/jls/se11/html/jls-5.html#jls-5.1.7), [Unboxing Conversion](https://docs.oracle.com/javase/specs/jls/se11/html/jls-5.html#jls-5.1.8).
    * The Java Tutorials: [Autoboxing and Unboxing](https://docs.oracle.com/javase/tutorial/java/data/autoboxing.html).
 -
  pack: codeql/java-queries#0
  relativeQueryPath: Violations of Best Practice/Comments/CommentedCode.ql
  relativeBqrsPath: codeql/java-queries/Violations of Best Practice/Comments/CommentedCode.bqrs
  metadata:
    name: Commented-out code
    description: Commented-out code makes the remaining code more difficult to read.
    kind: problem
    problem.severity: warning
    precision: low
    id: java/commented-out-code
    tags: |-
      maintainability
             readability
             statistical
             non-attributable
  queryHelp: |
    # Commented-out code
    Commented-out code is distracting and confusing for developers who read the surrounding code, and its significance is often unclear. It will not get compiled or tested when the code around it changes, so it's likely to break over time. For these reasons, commented-out code should be avoided.


    ## Recommendation
    Remove or reinstate the commented-out code. If you want to include a snippet of example code in a comment, consider enclosing it in quotes or marking it up as appropriate for the source language.


    ## References
    * Mark Needham: [The danger of commenting out code](http://www.markhneedham.com/blog/2009/01/17/the-danger-of-commenting-out-code/).
    * Los Techies: [Commented Code == Technical Debt](http://lostechies.com/rodpaddock/2010/12/29/commented-code-technical-debt).
    * High Integrity C++ Coding Standard: [2.3.2 Do not comment out code](http://www.codingstandard.com/rule/2-3-2-do-not-comment-out-code/).
 -
  pack: codeql/java-queries#0
  relativeQueryPath: Violations of Best Practice/Comments/TodoComments.ql
  relativeBqrsPath: codeql/java-queries/Violations of Best Practice/Comments/TodoComments.bqrs
  metadata:
    name: TODO/FIXME comments
    description: |-
      A comment that contains 'TODO' or 'FIXME' may indicate code that is incomplete or
                    broken, or it may highlight an ambiguity in the software's specification.
    kind: problem
    problem.severity: recommendation
    precision: low
    id: java/todo-comment
    tags: |-
      maintainability
             readability
             external/cwe/cwe-546
  queryHelp: |
    # TODO/FIXME comments
    A comment that includes the word `TODO` or `FIXME` often marks a part of the code that is incomplete or broken, or highlights ambiguities in the software's specification.

    For example, this list of comments is typical of those found in real programs:

    * `TODO: move this code somewhere else`
    * `FIXME: handle this case`
    * `FIXME: find a better solution to this workaround`
    * `TODO: test this`

    ## Recommendation
    It is very important that `TODO` or `FIXME` comments are not just removed from the code. Each of them must be addressed in some way.

    Simpler comments can usually be immediately addressed by fixing the code, adding a test, doing some refactoring, or clarifying the intended behavior of a feature.

    In contrast, larger issues may require discussion, and a significant amount of work to address. In these cases it is a good idea to move the comment to an issue-tracking system, so that the issue can be tracked and prioritized relative to other defects and feature requests.


    ## References
    * Approxion: [TODO or not TODO](http://www.approxion.com/?p=39).
    * Wikipedia: [Comment tags](http://en.wikipedia.org/wiki/Comment_%28computer_programming%29#Tags), [Issue tracking system](http://en.wikipedia.org/wiki/Issue_tracking_system).
    * Common Weakness Enumeration: [CWE-546](https://cwe.mitre.org/data/definitions/546.html).
 -
  pack: codeql/java-queries#0
  relativeQueryPath: Violations of Best Practice/Dead Code/AssignmentInReturn.ql
  relativeBqrsPath: codeql/java-queries/Violations of Best Practice/Dead Code/AssignmentInReturn.bqrs
  metadata:
    name: Assignment in return statement
    description: Assigning to a local variable in a 'return' statement has no effect.
    kind: problem
    problem.severity: recommendation
    precision: low
    id: java/assignment-in-return
    tags: |-
      maintainability
             readability
  queryHelp: "# Assignment in return statement\nAn assignment is an expression. The\
    \ value of an assignment expression is the value assigned to the variable. This\
    \ can be useful, for example, when initializing two or more variables at once\
    \ (for example, `a = b = 0;`). However, assigning to a local variable in the expression\
    \ of a return statement is redundant because that value can never be read.\n\n\
    \n## Recommendation\nRemove the redundant assignment from the `return` statement,\
    \ leaving just the right-hand side of the assignment.\n\n\n## Example\nIn the\
    \ following example, consider the second assignment to `ret`. The variable goes\
    \ out of scope when the method returns, and the value assigned to it is never\
    \ read. Therefore, the assignment is redundant. Instead, the last line of the\
    \ method can be changed to `return Math.max(ret, c);`\n\n\n```java\npublic class\
    \ Utilities\n{\n\tpublic static int max(int a, int b, int c) {\n\t\tint ret =\
    \ Math.max(a, b)\n\t\treturn ret = Math.max(ret, c);  // Redundant assignment\n\
    \t}\n}\n```\n\n## References\n* Java Language Specification: [ 14.17 The return\
    \ Statement](https://docs.oracle.com/javase/specs/jls/se11/html/jls-14.html#jls-14.17),\
    \ [ 15.26 Assignment Operators](https://docs.oracle.com/javase/specs/jls/se11/html/jls-15.html#jls-15.26).\n"
 -
  pack: codeql/java-queries#0
  relativeQueryPath: Violations of Best Practice/Dead Code/CreatesEmptyZip.ql
  relativeBqrsPath: codeql/java-queries/Violations of Best Practice/Dead Code/CreatesEmptyZip.bqrs
  metadata:
    name: Creates empty ZIP file entry
    description: |-
      Omitting a call to 'ZipOutputStream.write' when writing a ZIP file to an output
                    stream means that an empty ZIP file entry is written.
    kind: problem
    problem.severity: warning
    precision: medium
    id: java/empty-zip-file-entry
    tags: |-
      reliability
             readability
  queryHelp: "# Creates empty ZIP file entry\nThe `ZipOutputStream` class is used\
    \ to write ZIP files to a file or other stream. A ZIP file consists of a number\
    \ of *entries*. Usually each entry corresponds to a file in the directory structure\
    \ being zipped. There is a method on `ZipOutputStream` that is slightly confusingly\
    \ named `putNextEntry`. Despite its name, it does not write a whole entry. Instead,\
    \ it writes the *metadata* for an entry. The content for that entry is then written\
    \ using the `write` method. Finally the entry is closed using `closeEntry`.\n\n\
    Therefore, if you call `putNextEntry` and `closeEntry` but omit the call to `write`,\
    \ an empty ZIP file entry is written to the output stream.\n\n\n## Recommendation\n\
    Ensure that you include a call to `ZipOutputStream.write`.\n\n\n## Example\nIn\
    \ the following example, the `archive` method calls `putNextEntry` and `closeEntry`\
    \ but the call to `write` is left out.\n\n\n```java\nclass Archive implements\
    \ Closeable\n{\n\tprivate ZipOutputStream zipStream;\n\n\tpublic Archive(File\
    \ zip) throws IOException {\n\t\tOutputStream stream = new FileOutputStream(zip);\n\
    \t\tstream = new BufferedOutputStream(stream);\n\t\tzipStream = new ZipOutputStream(stream);\n\
    \t}\n\n\tpublic void archive(String name, byte[] content) throws IOException {\n\
    \t\tZipEntry entry = new ZipEntry(name);\n\t\tzipStream.putNextEntry(entry);\n\
    \t\t// Missing call to 'write'\n\t\tzipStream.closeEntry();\n\t}\n\n\tpublic void\
    \ close() throws IOException {\n\t\tzipStream.close();\n\t}\n}\n```\n\n## References\n\
    * Java API Specification: [ ZipOutputStream](https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/util/zip/ZipOutputStream.html).\n"
 -
  pack: codeql/java-queries#0
  relativeQueryPath: Violations of Best Practice/Dead Code/DeadRefTypes.ql
  relativeBqrsPath: codeql/java-queries/Violations of Best Practice/Dead Code/DeadRefTypes.bqrs
  metadata:
    name: Unused classes and interfaces
    description: |-
      A non-public class or interface that is not used anywhere in the program wastes
                    programmer resources.
    kind: problem
    problem.severity: recommendation
    precision: high
    id: java/unused-reference-type
    tags: |-
      maintainability
             useless-code
             external/cwe/cwe-561
  queryHelp: |
    # Unused classes and interfaces
    A non-public class or interface that is not used anywhere in the program may cause a programmer to waste time and effort maintaining and documenting it.


    ## Recommendation
    Ensure that redundant types are removed from the program.


    ## References
    * Wikipedia: [Unreachable code](http://en.wikipedia.org/wiki/Unreachable_code).
    * Common Weakness Enumeration: [CWE-561](https://cwe.mitre.org/data/definitions/561.html).
 -
  pack: codeql/java-queries#0
  relativeQueryPath: Violations of Best Practice/Dead Code/DeadStoreOfLocal.ql
  relativeBqrsPath: codeql/java-queries/Violations of Best Practice/Dead Code/DeadStoreOfLocal.bqrs
  metadata:
    name: Assigned value is overwritten
    description: |-
      An assignment to a local variable that is not used before a further assignment is
                    made has no effect.
    kind: problem
    problem.severity: warning
    precision: low
    id: java/overwritten-assignment-to-local
    tags: |-
      maintainability
             useless-code
             readability
             external/cwe/cwe-563
  queryHelp: "# Assigned value is overwritten\nA value is assigned to a local variable,\
    \ but whenever the variable is subsequently read, there has been at least one\
    \ other assignment to that variable. This means that the original assignment is\
    \ suspect, because the state of the local variable that it creates is never used.\n\
    \n\n## Recommendation\nEnsure that you check the control and data flow in the\
    \ method carefully. If a value is really not needed, consider omitting the assignment.\
    \ Be careful, though: if the right-hand side has a side-effect (like performing\
    \ a method call), it is important to keep this to preserve the overall behavior.\n\
    \n\n## Example\nIn the following example, the value assigned to `result` on line\
    \ 5 is always overwritten (line 6) before being read (line 7). This is a strong\
    \ indicator that there is something wrong. By examining the code, we can see that\
    \ the loop in lines 3-5 seems to be left over from an old way of storing the list\
    \ of persons, and line 6 represents the new (and better-performing) way. Consequently,\
    \ we can delete lines 3-5 while preserving behavior.\n\n\n```java\nPerson find(String\
    \ name) {\n\tPerson result;\n\tfor (Person p : people.values())\n\t\tif (p.getName().equals(name))\n\
    \t\t\tresult = p;  // Redundant assignment\n\tresult = people.get(name);\n\treturn\
    \ result;\n```\n"
 -
  pack: codeql/java-queries#0
  relativeQueryPath: Violations of Best Practice/Dead Code/DeadStoreOfLocalUnread.ql
  relativeBqrsPath: codeql/java-queries/Violations of Best Practice/Dead Code/DeadStoreOfLocalUnread.bqrs
  metadata:
    name: Useless assignment to local variable
    description: Assigning a value to a local variable that is not later used has
      no effect.
    kind: problem
    problem.severity: recommendation
    precision: low
    id: java/useless-assignment-to-local
    tags: external/cwe/cwe-561
  queryHelp: |
    # Useless assignment to local variable
    A value is assigned to a local variable, but the local variable is only read before the assignment, not after it. This means that the assignment is suspect, because the state of the local variable that it creates is never used.


    ## Recommendation
    Ensure that you check the control and data flow in the method carefully. If a value is really not needed, consider omitting the assignment. Be careful, though: if the right-hand side has a side-effect (like performing a method call), it is important to keep this to preserve the overall behavior.


    ## References
    * Wikipedia: [Redundant code](https://en.wikipedia.org/wiki/Redundant_code).
    * CERT Java Coding Standard: [MSC56-J. Detect and remove superfluous code and values](https://www.securecoding.cert.org/confluence/display/java/MSC56-J.+Detect+and+remove+superfluous+code+and+values).
    * Common Weakness Enumeration: [CWE-561](https://cwe.mitre.org/data/definitions/561.html).
 -
  pack: codeql/java-queries#0
  relativeQueryPath: Violations of Best Practice/Dead Code/EmptyFinalize.ql
  relativeBqrsPath: codeql/java-queries/Violations of Best Practice/Dead Code/EmptyFinalize.bqrs
  metadata:
    name: Empty body of finalizer
    description: |-
      An empty 'finalize' method is useless and prevents its superclass's 'finalize'
                    method (if any) from being called.
    kind: problem
    problem.severity: recommendation
    precision: low
    id: java/empty-finalizer
    tags: |-
      reliability
             readability
             external/cwe/cwe-568
  queryHelp: "# Empty body of finalizer\nAn empty `finalize` method is useless and\
    \ may prevent finalization from working properly. This is because, unlike a constructor,\
    \ a finalizer does not implicitly call the finalizer of the superclass. Thus,\
    \ an empty finalizer prevents any finalization logic that is defined in any of\
    \ its superclasses from being executed.\n\n\n## Recommendation\nDo not include\
    \ an empty `finalize` method.\n\n\n## Example\nIn the following example, the empty\
    \ `finalize` method in class `ExtendedLog` prevents the `finalize` method in class\
    \ `Log` from being called. The result is that the log file is not closed. To fix\
    \ this, remove the empty `finalize` method.\n\n\n```java\nclass ExtendedLog extends\
    \ Log\n{\n\t// ...\n\n\tprotected void finalize() {\n\t\t// BAD: This empty 'finalize'\
    \ stops 'super.finalize' from being executed.\n\t}\n}\n\nclass Log implements\
    \ Closeable\n{\n\t// ...\n\n\tpublic void close() {\n\t\t// ...\n\t}\n\n\tprotected\
    \ void finalize() {\n\t\tclose();\n\t}\n}\n```\n\n## References\n* Java Language\
    \ Specification: [12.6 Finalization of Class Instances](https://docs.oracle.com/javase/specs/jls/se11/html/jls-12.html#jls-12.6).\n\
    * Common Weakness Enumeration: [CWE-568](https://cwe.mitre.org/data/definitions/568.html).\n"
 -
  pack: codeql/java-queries#0
  relativeQueryPath: Violations of Best Practice/Dead Code/FinalizerNullsFields.ql
  relativeBqrsPath: codeql/java-queries/Violations of Best Practice/Dead Code/FinalizerNullsFields.bqrs
  metadata:
    name: Finalizer nulls fields
    description: |-
      Setting fields to 'null' in a finalizer does not cause the object to be collected
                    by the garbage collector any earlier, and may adversely affect performance.
    kind: problem
    problem.severity: recommendation
    precision: low
    id: java/finalizer-nulls-fields
    tags: |-
      efficiency
             maintainability
  queryHelp: "# Finalizer nulls fields\nA finalizer does not need to set an object's\
    \ fields to `null` to help the garbage collector. At the point in the Java object\
    \ life-cycle when the `finalize` method is called, the object is no longer reachable\
    \ from the garbage collection roots. Explicitly setting the object's fields to\
    \ `null` does not cause the referenced objects to be collected by the garbage\
    \ collector any earlier, and may even adversely affect performance.\n\nThe life-cycle\
    \ of a Java object has 7 stages:\n\n* **Created** : Memory is allocated for the\
    \ object and the initializers and constructors have been run.\n* **In use** :\
    \ The object is reachable through a chain of strong references from a garbage\
    \ collection root. A garbage collection root is a special class of variable (which\
    \ includes variables on the stack of any thread, static variables of any class,\
    \ and references from Java Native Interface code).\n* **Invisible** : The object\
    \ has already gone out of scope, but the stack frame of the method that contained\
    \ the scope is still in memory. Not all objects transition into this state.\n\
    * **Unreachable** : The object is no longer reachable through a chain of strong\
    \ references. It becomes a candidate for garbage collection.\n* **Collected**\
    \ : The garbage collector has identified that the object can be deallocated. If\
    \ it has a finalizer, it is marked for finalization. Otherwise, it is deallocated.\n\
    * **Finalized** : An object with a `finalize` method transitions to this state\
    \ after the finalize method is completed and the object still remains unreachable.\n\
    * **Deallocated** : The object is a candidate for deallocation.\nThe call to the\
    \ `finalize` method occurs when the object is in the 'Collected' stage. At that\
    \ point, it is already unreachable from the garbage collection roots so any of\
    \ its references to other objects no longer contribute to their reference counts.\n\
    \n\n## Recommendation\nEnsure that the finalizer does not contain any `null` assignments\
    \ because they are unlikely to help garbage collection.\n\nIf a finalizer does\
    \ nothing but nullify an object's fields, it is best to completely remove the\
    \ finalizer. Objects with finalizers severely affect performance, and you should\
    \ avoid defining `finalize` where possible.\n\n\n## Example\nIn the following\
    \ example, `finalize` unnecessarily assigns the object's fields to null.\n\n\n\
    ```java\nclass FinalizedClass {\n\tObject o = new Object();\n\tString s = \"abcdefg\"\
    ;\n\tInteger i = Integer.valueOf(2);\n\t\n\t@Override\n\tprotected void finalize()\
    \ throws Throwable {\n\t\tsuper.finalize();\n\t\t//No need to nullify fields\n\
    \t\tthis.o = null;\n\t\tthis.s = null;\n\t\tthis.i = null;\n\t}\n}\n```\n\n##\
    \ References\n* J. Bloch, *Effective Java (second edition)*, Item 7. Addison-Wesley,\
    \ 2008.\n* IBM developerWorks: [Java theory and practice: Explicit nulling](https://web.archive.org/web/20201111184342/https://www.ibm.com/developerworks/java/library/j-jtp01274/index.html#3.2).\n\
    * Oracle Technology Network: [ How to Handle Java Finalization's Memory-Retention\
    \ Issues ](https://www.oracle.com/technical-resources/articles/javase/finalization.html).\n\
    * S. Wilson and J. Kesselman, *Java Platform Performance: Strategies and Tactics,\
    \ 1st ed.*, Appendix A. Prentice Hall, 2001.\n"
 -
  pack: codeql/java-queries#0
  relativeQueryPath: Violations of Best Practice/Dead Code/InterfaceCannotBeImplemented.ql
  relativeBqrsPath: codeql/java-queries/Violations of Best Practice/Dead Code/InterfaceCannotBeImplemented.bqrs
  metadata:
    name: Interface cannot be implemented
    description: |-
      An interface method that is incompatible with a protected method on
                    'java.lang.Object' means that the interface cannot be implemented.
    kind: problem
    problem.severity: warning
    precision: very-high
    id: java/unimplementable-interface
    tags: |-
      maintainability
             useless-code
  queryHelp: |
    # Interface cannot be implemented
    An interface that contains methods whose return types clash with protected methods on `java.lang.Object` can never be implemented, because methods cannot be overloaded based simply on their return type.


    ## Recommendation
    If the interface is useful, name methods so that they do not clash with methods in `Object`. Otherwise you should delete the interface.


    ## Example
    In the following example, the interface `I` is useless because the `clone` method must return type `java.lang.Object`:


    ```java
    interface I {
        int clone();
    }

    class C implements I {
        public int clone() {
            return 23;
        }
    }
    ```
    Any attempt to implement the interface produces an error:

    ```

    InterfaceCannotBeImplemented.java:6: clone() in C cannot override
      clone() in java.lang.Object; attempting to use incompatible return
      type
    found   : int
    required: java.lang.Object
      public int clone() {
                 ^
    1 error

    ```

    ## References
    * Help - Eclipse Platform: [Java Compiler Errors/Warnings Preferences](https://help.eclipse.org/2020-12/advanced/content.jsp?topic=/org.eclipse.jdt.doc.user/reference/preferences/java/compiler/ref-preferences-errors-warnings.htm).
    * Java Language Specification: [9.2 Interface Members](https://docs.oracle.com/javase/specs/jls/se11/html/jls-9.html#jls-9.2).
 -
  pack: codeql/java-queries#0
  relativeQueryPath: Violations of Best Practice/Dead Code/LocalInitialisedButNotUsed.ql
  relativeBqrsPath: codeql/java-queries/Violations of Best Practice/Dead Code/LocalInitialisedButNotUsed.bqrs
  metadata:
    name: Local variable is initialized but not used
    description: A local variable that is initialized but not subsequently used may
      indicate an error in the code.
    kind: problem
    problem.severity: recommendation
    precision: low
    id: java/unused-initialized-local
    tags: external/cwe/cwe-563
  queryHelp: |
    # Local variable is initialized but not used
    A local variable is initialized, but the variable is never read or written to subsequently. This suggests that the local variable is either unnecessary and should be removed, or that the value was intended to be used somewhere.


    ## Recommendation
    Ensure that you check the control and data flow in the method carefully. If a value is really not needed, consider removing the variable. Be careful, though: if the right-hand side has a side-effect (like performing a method call), it is important to keep this to preserve the overall behavior.


    ## References
    * Wikipedia: [Redundant code](https://en.wikipedia.org/wiki/Redundant_code).
    * CERT Java Coding Standard: [MSC56-J. Detect and remove superfluous code and values](https://www.securecoding.cert.org/confluence/display/java/MSC56-J.+Detect+and+remove+superfluous+code+and+values).
    * Common Weakness Enumeration: [CWE-563](https://cwe.mitre.org/data/definitions/563.html).
 -
  pack: codeql/java-queries#0
  relativeQueryPath: Violations of Best Practice/Dead Code/LocalNotRead.ql
  relativeBqrsPath: codeql/java-queries/Violations of Best Practice/Dead Code/LocalNotRead.bqrs
  metadata:
    name: Local variable is never read
    description: "A local variable is written to, but never read. Either the local\
      \ variable is useless, or its value was intended to be used but is not."
    kind: problem
    problem.severity: recommendation
    precision: low
    id: java/assigned-local-unread
  queryHelp: |+
    # Local variable is never read
    A local variable is assigned a value, but the variable is never read. This suggests that the local variable is either useless and should be removed, or that the value was intended to be used somewhere.


    ## Recommendation
    Ensure that you check the control and data flow in the method carefully. If a value is really not needed, consider removing the variable. Be careful, though: if the right-hand side has a side-effect (like performing a method call), it is important to keep this to preserve the overall behavior.

 -
  pack: codeql/java-queries#0
  relativeQueryPath: Violations of Best Practice/Dead Code/NonAssignedFields.ql
  relativeBqrsPath: codeql/java-queries/Violations of Best Practice/Dead Code/NonAssignedFields.bqrs
  metadata:
    name: Field is never assigned a non-null value
    description: |-
      A field that is never assigned a value (except possibly 'null') just returns the
                    default value when it is read.
    kind: problem
    problem.severity: warning
    precision: low
    id: java/unassigned-field
    tags: |-
      reliability
             maintainability
             useless-code
             external/cwe/cwe-457
  queryHelp: |+
    # Field is never assigned a non-null value
    It is good practice to initialize every field in a constructor explicitly. A field that is never assigned any value (except possibly `null`) just returns the default value when it is read, or throws a `NullPointerException`.


    ## Recommendation
    A field whose value is always `null` (or the corresponding default value for primitive types, for example `0`) is not particularly useful. Ensure that the code contains an assignment or initialization for each field. To help satisfy this rule, it is good practice to explicitly initialize every field in the constructor, even if the default value is acceptable.

    If the field is genuinely never expected to hold a non-default value, check the statements that read the field and ensure that they are not making incorrect assumptions about the value of the field. Consider completely removing the field and rewriting the statements that read it, as appropriate.


    ## Example
    In the following example, the private field `name` is not initialized in the constructor (and thus is implicitly set to `null`), but there is a getter method to access it.


    ```java
    class Person {
        private String name;
        private int age;

        public Person(String name, int age) {
            this.age = age;
        }

        public String getName() {
            return name;
        }

        public int getAge() {
            return age;
        }
    }

    ```
    Therefore, the following code throws a `NullPointerException`:

    ```java
    Person p = new Person("Arthur Dent", 30);
    int l = p.getName().length();
    ```
    To fix the code, `name` should be initialized in the constructor by adding the following line: `this.name = name;`

 -
  pack: codeql/java-queries#0
  relativeQueryPath: Violations of Best Practice/Dead Code/PointlessForwardingMethod.ql
  relativeBqrsPath: codeql/java-queries/Violations of Best Practice/Dead Code/PointlessForwardingMethod.bqrs
  metadata:
    name: Pointless forwarding method
    description: A method forwards calls to another method of the same name that is
      not called independently.
    kind: problem
    problem.severity: recommendation
    precision: low
    id: java/useless-forwarding-method
    tags: maintainability
  queryHelp: "# Pointless forwarding method\nIf a class contains two distinct methods\
    \ of the same name such that:\n\n1. One method is only ever called from the other\
    \ method.\n1. The calling method calls only the other method and nothing else.\n\
    Then the first method is no more than a forwarding method for the second and the\
    \ two methods can probably be merged.\n\nThere are several advantages to doing\
    \ this:\n\n* It reduces the cognitive overhead involved in keeping track of the\
    \ various different overloaded forms of a method.\n* If both methods are public,\
    \ it simplifies the API of their containing class, making it more discoverable\
    \ to other programmers.\n* It makes it clearer to other programmers that certain\
    \ methods are called and other methods are not.\n\n## Example\nIn this example,\
    \ the two `print` methods in `Bad` can be merged, as one is simply a forwarder\
    \ for the other. The two classes `Better1` and `Better2` show two alternative\
    \ ways of merging the methods.\n\n\n```java\nimport static java.lang.System.out;\n\
    \npublic class PointlessForwardingMethod {\n\tprivate static class Bad {\n\t\t\
    // Violation: This print does nothing but forward to the other one, which is not\n\
    \t\t// called independently.\n\t\tpublic void print(String firstName, String lastName)\
    \ {\n\t\t\tprint(firstName + \" \" + lastName);\n\t\t}\n\n\t\tpublic void print(String\
    \ fullName) {\n\t\t\tout.println(\"Pointless forwarding methods are bad, \"  +\
    \ fullName + \"...\");\n\t\t}\n\t}\n\n\tprivate static class Better1 {\n\t\t//\
    \ Better: Merge the methods, using local variables to replace the parameters in\n\
    \t\t// the original version.\n\t\tpublic void print(String firstName, String lastName)\
    \ {\n\t\t\tString fullName = firstName + \" \" + lastName;\n\t\t\tout.println(\"\
    Pointless forwarding methods are bad, \" + fullName + \"...\");\n\t\t}\n\t}\n\n\
    \tprivate static class Better2 {\n\t\t// Better: If there's no complicated logic,\
    \ you can often remove the extra\n\t\t// variables entirely.\n\t\tpublic void\
    \ print(String firstName, String lastName) {\n\t\t\tout.println(\n\t\t\t\t\"Pointless\
    \ forwarding methods are bad, \" +\n\t\t\t\tfirstName + \" \" + lastName + \"\
    ...\"\n\t\t\t);\n\t\t}\n\t}\n\n\tpublic static void main(String[] args) {\n\t\t\
    new Bad().print(\"Foo\", \"Bar\");\n\t\tnew Better1().print(\"Foo\", \"Bar\");\n\
    \t\tnew Better2().print(\"Foo\", \"Bar\");\n\t}\n}\n```\n"
 -
  pack: codeql/java-queries#0
  relativeQueryPath: Violations of Best Practice/Dead Code/UnreadLocal.ql
  relativeBqrsPath: codeql/java-queries/Violations of Best Practice/Dead Code/UnreadLocal.bqrs
  metadata:
    name: Unread local variable
    description: A local variable that is never read is redundant.
    kind: problem
    problem.severity: recommendation
    precision: high
    id: java/local-variable-is-never-read
    tags: |-
      maintainability
             useless-code
             external/cwe/cwe-561
  queryHelp: "# Unread local variable\nA local variable that is never read is useless.\n\
    \nAs a matter of good practice, there should be no unused or useless code. It\
    \ makes the program more difficult to understand and maintain, and can waste a\
    \ programmer's time.\n\n\n## Recommendation\nThis rule applies to variables that\
    \ are never used as well as variables that are only written to but never read.\
    \ In both cases, ensure that no operations are missing that would use the local\
    \ variable. If appropriate, simply remove the declaration. However, if the variable\
    \ is written to, ensure that any side-effects in the assignments are retained.\
    \ (For further details, see the example.)\n\n\n## Example\nIn the following example,\
    \ the local variable `oldQuantity` is assigned a value but never read. In the\
    \ fixed version of the example, the variable is removed but the call to `items.put`\
    \ in the assignment is retained.\n\n\n```java\n// Version containing unread local\
    \ variable\npublic class Cart {\n\tprivate Map<Item, Integer> items = ...;\n\t\
    public void add(Item i) {\n\t\tInteger quantity = items.get(i);\n\t\tif (quantity\
    \ = null)\n\t\t\tquantity = 1;\n\t\telse\n\t\t\tquantity++;\n\t\tInteger oldQuantity\
    \ = items.put(i, quantity);  // AVOID: Unread local variable\n\t}\n}\n\n// Version\
    \ with unread local variable removed\npublic class Cart {\n\tprivate Map<Item,\
    \ Integer> items = ...;\n\tpublic void add(Item i) {\n\t\tInteger quantity = items.get(i);\n\
    \t\tif (quantity = null)\n\t\t\tquantity = 1;\n\t\telse\n\t\t\tquantity++;\n\t\
    \titems.put(i, quantity);\n\t}\n}\n```\n\n## References\n* Help - Eclipse Platform:\
    \ [Java Compiler Errors/Warnings Preferences](https://help.eclipse.org/2020-12/advanced/content.jsp?topic=/org.eclipse.jdt.doc.user/reference/preferences/java/compiler/ref-preferences-errors-warnings.htm).\n\
    * Common Weakness Enumeration: [CWE-561](https://cwe.mitre.org/data/definitions/561.html).\n"
 -
  pack: codeql/java-queries#0
  relativeQueryPath: Violations of Best Practice/Dead Code/UnusedField.ql
  relativeBqrsPath: codeql/java-queries/Violations of Best Practice/Dead Code/UnusedField.bqrs
  metadata:
    name: Unused field
    description: A field that is never used is probably unnecessary.
    kind: problem
    problem.severity: recommendation
    precision: low
    id: java/unused-field
    tags: |-
      maintainability
             useless-code
             external/cwe/cwe-561
  queryHelp: |
    # Unused field
    A field that is neither public nor protected and never accessed is typically a leftover from old refactorings or a sign of incomplete or pending code changes.

    This rule does not apply to a field in a serializable class because it may be accessed during serialization and deserialization.

    Fields annotated with `@SuppressWarnings("unused")` are also not reported.


    ## Recommendation
    If an unused field is a leftover from old refactorings, you should just remove it. If it indicates incomplete or pending code changes, finish making the changes and remove the field if it is not needed.


    ## References
    * Help - Eclipse Platform: [Java Compiler Errors/Warnings Preferences](https://help.eclipse.org/2020-12/advanced/content.jsp?topic=/org.eclipse.jdt.doc.user/reference/preferences/java/compiler/ref-preferences-errors-warnings.htm).
    * Common Weakness Enumeration: [CWE-561](https://cwe.mitre.org/data/definitions/561.html).
 -
  pack: codeql/java-queries#0
  relativeQueryPath: Violations of Best Practice/Dead Code/UnusedLabel.ql
  relativeBqrsPath: codeql/java-queries/Violations of Best Practice/Dead Code/UnusedLabel.bqrs
  metadata:
    name: Unused label
    description: |-
      An unused label for a loop or 'switch' statement is either redundant or indicates
                    incorrect 'break' or 'continue' statements.
    kind: problem
    problem.severity: recommendation
    precision: high
    id: java/unused-label
    tags: |-
      maintainability
             useless-code
             external/cwe/cwe-561
  queryHelp: "# Unused label\nLoop and `switch` statements can be labeled. These labels\
    \ can serve as targets for `break` or `continue` statements, to specify which\
    \ loop or `switch` statement they refer to.\n\nApart from serving as such jump\
    \ targets, the labels have no effect on program behavior, which means that having\
    \ an unused label is suspicious.\n\n\n## Recommendation\nIf the label is used\
    \ to document the intended behavior of a loop or `switch` statement, remove it.\
    \ It is better to use comments for this purpose. However, an unused label may\
    \ indicate that something is wrong: that some of the nested `break` or `continue`\
    \ statements should be using the label. In this case, the current control flow\
    \ is probably wrong, and you should adjust some jumps to use the label after checking\
    \ the desired behavior.\n\n\n## Example\nThe following example uses a loop and\
    \ a nested loop to check whether any of the currently active shopping carts contains\
    \ a particular item. On line 4, the `carts:` label is unused. Inspecting the code,\
    \ we can see that the `break` statement on line 10 is inefficient because it only\
    \ breaks out of the nested loop. It could in fact break out of the outer loop,\
    \ which should improve performance in common cases. By changing the statement\
    \ on line 10 to read `break carts;`, the label is no longer unused and we improve\
    \ the code.\n\n\n```java\npublic class WebStore {\n\tpublic boolean itemIsBeingBought(Item\
    \ item) {\n\t\tboolean found = false;\n\t\tcarts:  // AVOID: Unused label\n\t\t\
    for (int i = 0; i < carts.size(); i++) {\n\t\t\tCart cart = carts.get(i);\n\t\t\
    \tfor (int j = 0; j < cart.numItems(); j++) {\n\t\t\t\tif (item.equals(cart.getItem(j)))\
    \ {\n\t\t\t\t\tfound = true;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\
    return found;\n\t}\n}\n```\n\n## References\n* Help - Eclipse Platform: [Java\
    \ Compiler Errors/Warnings Preferences](https://help.eclipse.org/2020-12/advanced/content.jsp?topic=/org.eclipse.jdt.doc.user/reference/preferences/java/compiler/ref-preferences-errors-warnings.htm).\n\
    * Common Weakness Enumeration: [CWE-561](https://cwe.mitre.org/data/definitions/561.html).\n"
 -
  pack: codeql/java-queries#0
  relativeQueryPath: Violations of Best Practice/Dead Code/UnusedLocal.ql
  relativeBqrsPath: codeql/java-queries/Violations of Best Practice/Dead Code/UnusedLocal.bqrs
  metadata:
    name: Unused local variable
    description: "A local variable that is not initialized, assigned, or read may\
      \ indicate incomplete code."
    kind: problem
    problem.severity: recommendation
    precision: low
    id: java/unused-local-variable
    tags: external/cwe/cwe-563
  queryHelp: |
    # Unused local variable
    A local variable that is not accessed or initialized is typically a sign of incomplete or pending code changes.


    ## Recommendation
    If an unused variable is no longer needed following refactoring, you should just remove it. If there are incomplete or pending code changes, finish making the changes, and then remove the variable if it is no longer needed.


    ## References
    * Wikipedia: [Redundant code](https://en.wikipedia.org/wiki/Redundant_code).
    * CERT Java Coding Standard: [MSC56-J. Detect and remove superfluous code and values](https://www.securecoding.cert.org/confluence/display/java/MSC56-J.+Detect+and+remove+superfluous+code+and+values).
    * Common Weakness Enumeration: [CWE-563](https://cwe.mitre.org/data/definitions/563.html).
 -
  pack: codeql/java-queries#0
  relativeQueryPath: Violations of Best Practice/Declarations/BreakInSwitchCase.ql
  relativeBqrsPath: codeql/java-queries/Violations of Best Practice/Declarations/BreakInSwitchCase.bqrs
  metadata:
    name: Unterminated switch case
    description: |-
      A 'case' statement that does not contain a 'break' statement allows execution to
                    'fall through' to the next 'case', which may not be intended.
    kind: problem
    problem.severity: warning
    precision: low
    id: java/switch-fall-through
    tags: |-
      reliability
             readability
             external/cwe/cwe-484
  queryHelp: "# Unterminated switch case\nIn a `switch` statement, execution 'falls\
    \ through' from one `case` to the next, unless the `case` ends with a `break`\
    \ statement. A common programming error is to forget to insert a `break` at the\
    \ end of a `case`.\n\n\n## Recommendation\nEnd each `case` with a `break` statement\
    \ or, if execution is supposed to fall through to the next `case`, comment the\
    \ last line of the `case` with the following comment: `/* falls through */`\n\n\
    Such comments are not required for a completely empty `case` that is supposed\
    \ to share the same implementation with the subsequent `case`.\n\n\n## Example\n\
    In the following example, the `PING` case is missing a `break` statement. As a\
    \ result, after `reply` is assigned the value of `Message.PONG`, execution falls\
    \ through to the `TIMEOUT` case. Then the value of `reply` is erroneously assigned\
    \ the value of `Message.PING`. To fix this, insert `break;` at the end of the\
    \ `PING` case.\n\n\n```java\nclass Server\n{\n\tpublic void respond(Event event)\n\
    \t{\n\t\tMessage reply = null;\n\t\tswitch (event) {\n\t\tcase PING:\n\t\t\treply\
    \ = Message.PONG;\n\t\t\t// Missing 'break' statement\n\t\tcase TIMEOUT:\n\t\t\
    \treply = Message.PING;\n\t\tcase PONG:\n\t\t\t// No reply needed\n\t\t}\n\t\t\
    if (reply != null)\n\t\t\tsend(reply);\n\t}\n\n\tprivate void send(Message message)\
    \ {\n\t\t// ...\n\t}\n}\n\nenum Event { PING, PONG, TIMEOUT }\nenum Message {\
    \ PING, PONG }\n```\n\n## References\n* J. Bloch and N. Gafter, *Java Puzzlers:\
    \ Traps, Pitfalls, and Corner Cases*, Puzzle 23. Addison-Wesley, 2005.\n* Code\
    \ Conventions for the Java Programming Language: [7.8 switch Statements](https://www.oracle.com/java/technologies/javase/codeconventions-statements.html#468).\n\
    * Help - Eclipse Platform: [Java Compiler Errors/Warnings Preferences](https://help.eclipse.org/2020-12/advanced/content.jsp?topic=/org.eclipse.jdt.doc.user/reference/preferences/java/compiler/ref-preferences-errors-warnings.htm).\n\
    * Common Weakness Enumeration: [CWE-484](https://cwe.mitre.org/data/definitions/484.html).\n"
 -
  pack: codeql/java-queries#0
  relativeQueryPath: Violations of Best Practice/Declarations/MakeImportsExplicit.ql
  relativeBqrsPath: codeql/java-queries/Violations of Best Practice/Declarations/MakeImportsExplicit.bqrs
  metadata:
    name: Implicit import
    description: |-
      An implicit import obscures the dependencies of a file and may cause confusing
                    compile-time errors.
    kind: problem
    problem.severity: recommendation
    precision: low
    id: java/implicit-import
    tags: maintainability
  queryHelp: "# Implicit import\nImports can be categorized as *explicit* (for example\
    \ `import java.util.List;`) or *implicit* (also known as 'on-demand', for example\
    \ `import java.util.*;`):\n\n* Implicit imports give access to all visible types\
    \ in the type (or package) that precedes the \".\\*\"; types imported in this\
    \ way never shadow other types.\n* Explicit imports give access to just the named\
    \ type; they can shadow other types that would normally be visible through an\
    \ implicit import, or through the normal package visibility rules.\nIt is often\
    \ considered bad practice to use implicit imports. The only advantage to doing\
    \ so is making the code more concise, and there are a number of disadvantages:\n\
    \n* The exact dependencies of a file are not visible at a glance.\n* Confusing\
    \ compile-time errors can be introduced if a type name is used that could originate\
    \ from several implicit imports.\n\n## Recommendation\nFor readability, it is\
    \ recommended to use explicit imports instead of implicit imports. Many modern\
    \ IDEs provide automatic functionality to help achieve this, typically under the\
    \ name \"Organize imports\". They can also fold away the import declarations,\
    \ and automatically manage imports: adding them when a particular type is auto-completed\
    \ by the editor, and removing them when they are not necessary. This functionality\
    \ makes implicit imports mainly redundant.\n\n\n## Example\nThe following example\
    \ uses implicit imports. This means that it is not clear to a programmer where\
    \ the `List` type on line 5 is imported from.\n\n\n```java\nimport java.util.*;\
    \  // AVOID: Implicit import statements\nimport java.awt.*;\n\npublic class Customers\
    \ {\n\tpublic List getCustomers() {  // Compiler error: 'List' is ambiguous.\n\
    \t\t...\n\t}\n}\n```\nTo improve readability, the implicit imports should be replaced\
    \ by explicit imports. For example, `import java.util.*;` should be replaced by\
    \ `import java.util.List;` on line 1.\n\n\n## References\n* Java Language Specification:\
    \ [6.4.1 Shadowing](https://docs.oracle.com/javase/specs/jls/se11/html/jls-6.html#jls-6.4.1),\
    \ [7.5.2 Type-Import-on-Demand Declarations](https://docs.oracle.com/javase/specs/jls/se11/html/jls-7.html#jls-7.5.2).\n"
 -
  pack: codeql/java-queries#0
  relativeQueryPath: Violations of Best Practice/Declarations/NoConstantsOnly.ql
  relativeBqrsPath: codeql/java-queries/Violations of Best Practice/Declarations/NoConstantsOnly.bqrs
  metadata:
    name: Constant interface anti-pattern
    description: |-
      Implementing an interface (or extending an abstract class)
                    only to put a number of constant definitions into scope is considered bad practice.
    kind: problem
    problem.severity: recommendation
    precision: high
    id: java/constants-only-interface
    tags: |-
      maintainability
             modularity
  queryHelp: "# Constant interface anti-pattern\nDefinitions of constants (meaning\
    \ static, final fields) should be placed in an appropriate class where they belong\
    \ logically. However, it is usually bad practice to implement an interface (or\
    \ extend an abstract class) only to put a number of constant definitions into\
    \ scope.\n\n\n## Recommendation\nThe preferred way of putting the constant definitions\
    \ into scope is to use the `import static` directive, which allows a compilation\
    \ unit to put any visible static members from other classes into scope.\n\nThis\
    \ issue is discussed in \\[Bloch\\]:\n\n> That a class uses some constants internally\
    \ is an implementation detail. Implementing a constant interface causes this implementation\
    \ detail to leak into the classes exported API. It is of no consequence to the\
    \ users of a class that the class implements a constant interface. In fact, it\
    \ may even confuse them. Worse, it represents a commitment: if in a future release\
    \ the class is modified so that it no longer needs to use the constants, it still\
    \ must implement the interface to ensure binary compatibility.\n\nTo prevent this\
    \ pollution of a class's binary interface, it is best to move the constant definitions\
    \ to whatever concrete class uses them most frequently. Users of the definitions\
    \ could use `import static` to access the relevant fields.\n\n\n## Example\nIn\
    \ the following example, the interface `MathConstants` has been defined only to\
    \ hold a constant.\n\n\n```java\npublic class NoConstantsOnly {\n\tstatic interface\
    \ MathConstants\n\t{\n\t    public static final Double Pi = 3.14;\n\t}\n\n\tstatic\
    \ class Circle implements MathConstants\n\t{\n\t    public double radius;\n\t\
    \    public double area()\n\t    {\n\t        return Math.pow(radius, 2) * Pi;\n\
    \t    }\n\t}\n}\n```\nInstead, the constant should be moved to the `Circle` class\
    \ or another class that uses the constant frequently.\n\n\n## References\n* J.\
    \ Bloch, *Effective Java (second edition)*, Item 19. Addison-Wesley, 2008.\n"
 -
  pack: codeql/java-queries#0
  relativeQueryPath: Violations of Best Practice/Exception Handling/DroppedExceptions.ql
  relativeBqrsPath: codeql/java-queries/Violations of Best Practice/Exception Handling/DroppedExceptions.bqrs
  metadata:
    name: Discarded exception
    description: |-
      Dropping an exception may allow an unusual program state to continue
                    without recovery.
    kind: problem
    problem.severity: warning
    precision: low
    id: java/discarded-exception
    tags: |-
      reliability
             correctness
             exceptions
             external/cwe/cwe-391
  queryHelp: "# Discarded exception\nYou should not drop an exception, because it\
    \ indicates that an unusual program state has been reached. This usually requires\
    \ corrective actions to be performed to recover from the exceptional state and\
    \ try to resume normal program operation.\n\n\n## Recommendation\nYou should do\
    \ one of the following:\n\n* Catch and handle the exception.\n* Throw the exception\
    \ to the outermost level of nesting.\nNote that usually you should catch and handle\
    \ a checked exception, but you can throw an unchecked exception to the outermost\
    \ level.\n\nThere is occasionally a valid reason for ignoring an exception. In\
    \ such cases, you should document the reason to improve the readability of the\
    \ code. Alternatively, you can implement a static method with an empty body to\
    \ handle these exceptions. Instead of dropping the exception altogether, you can\
    \ then pass it to the static method with a string explaining the reason for ignoring\
    \ it.\n\n\n## Examples\nThe following example shows a dropped exception.\n\n\n\
    ```java\n// Dropped exception, with no information on whether \n// the exception\
    \ is expected or not\nsynchronized void waitIfAutoSyncScheduled() {\n\ttry {\n\
    \t\twhile (isAutoSyncScheduled) {\n\t\t\tthis.wait(1000);\n\t\t}\n\t} catch (InterruptedException\
    \ e) {\n\t}\n}\n```\nThe following example adds a comment to document why the\
    \ exception may be ignored.\n\n\n```java\nsynchronized void waitIfAutoSyncScheduled()\
    \ {\n\ttry {\n\t\twhile (isAutoSyncScheduled) {\n\t\t\tthis.wait(1000);\n\t\t\
    }\n\t} catch (InterruptedException e) {\n\t\t// Expected exception. The file cannot\
    \ be synchronized yet.\n\t}\n}\n```\nThe following example shows how you can improve\
    \ code readability by defining a new utility method.\n\n\n```java\n// 'ignore'\
    \ method. This method does nothing, but can be called\n// to document the reason\
    \ why the exception can be ignored.\npublic static void ignore(Throwable e, String\
    \ message) {\n\n}\n```\nThe following example shows the exception being passed\
    \ to `ignore` with a comment.\n\n\n```java\n// Exception is passed to 'ignore'\
    \ method with a comment\nsynchronized void waitIfAutoSyncScheduled() {\n\ttry\
    \ {\n\t\twhile (isAutoSyncScheduled) {\n\t\t\tthis.wait(1000);\n\t\t}\n\t} catch\
    \ (InterruptedException e) {\n\t\tExceptions.ignore(e, \"Expected exception. The\
    \ file cannot be synchronized yet.\");\n\t}\n}\n```\n\n## References\n* J. Bloch,\
    \ *Effective Java (second edition)*, Item 65. Addison-Wesley, 2008.\n* The Java\
    \ Tutorials: [Unchecked Exceptions - The Controversy](https://docs.oracle.com/javase/tutorial/essential/exceptions/runtime.html).\n\
    * Common Weakness Enumeration: [CWE-391](https://cwe.mitre.org/data/definitions/391.html).\n"
 -
  pack: codeql/java-queries#0
  relativeQueryPath: Violations of Best Practice/Exception Handling/ExceptionCatch.ql
  relativeBqrsPath: codeql/java-queries/Violations of Best Practice/Exception Handling/ExceptionCatch.bqrs
  metadata:
    name: Overly-general catch clause
    description: |-
      Catching 'Throwable' or 'Exception' is dangerous because these can include
                    'Error' or 'RuntimeException'.
    kind: problem
    problem.severity: warning
    precision: low
    id: java/overly-general-catch
    tags: |-
      reliability
             external/cwe/cwe-396
  queryHelp: "# Overly-general catch clause\nCatching `Throwable` or `Exception` is\
    \ dangerous because these can include an `Error` such as `OutOfMemoryError` or\
    \ a `RuntimeException` such as `ArrayIndexOutOfBoundsException`. These should\
    \ normally be propagated to the outermost level because they generally indicate\
    \ a program state from which normal operation cannot be recovered.\n\n\n## Recommendation\n\
    It is usually best to ensure that exceptions that are caught in a `catch` clause\
    \ are as specific as possible to avoid inadvertently suppressing more serious\
    \ problems.\n\n\n## Example\nIn the following example, the `catch` clause in the\
    \ first `try` block catches `Throwable`. However, when performing read operations\
    \ on a `FileInputStream` within a `try` block, the corresponding `catch` clause\
    \ should normally catch `IOException` instead. This is shown in the second, modified\
    \ `try` block.\n\n\n```java\nFileInputStream fis = ...\ntry {\n\tfis.read();\n\
    } catch (Throwable e) {  // BAD: The exception is too general.\n\t// Handle this\
    \ exception\n}\n\nFileInputStream fis = ...\ntry {\n\tfis.read();\n} catch (IOException\
    \ e) {  // GOOD: The exception is specific. \n\t// Handle this exception\n}\n\n\
    ```\n\n## References\n* J. Bloch and N. Gafter, *Java Puzzlers: Traps, Pitfalls,\
    \ and Corner Cases*, Puzzle 44. Addison-Wesley, 2005.\n* Java API Specification:\
    \ [Throwable](https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/lang/Throwable.html),\
    \ [Error](https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/lang/Error.html),\
    \ [Exception](https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/lang/Exception.html),\
    \ [RuntimeException](https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/lang/RuntimeException.html).\n\
    * Common Weakness Enumeration: [CWE-396](https://cwe.mitre.org/data/definitions/396.html).\n"
 -
  pack: codeql/java-queries#0
  relativeQueryPath: Violations of Best Practice/Exception Handling/IgnoreExceptionalReturn.ql
  relativeBqrsPath: codeql/java-queries/Violations of Best Practice/Exception Handling/IgnoreExceptionalReturn.bqrs
  metadata:
    name: Ignored error status of call
    description: |-
      Ignoring an exceptional value that is returned by a method may cause subsequent
                    code to fail.
    kind: problem
    problem.severity: recommendation
    precision: high
    id: java/ignored-error-status-of-call
    tags: |-
      reliability
             correctness
             external/cwe/cwe-391
  queryHelp: |
    # Ignored error status of call
    Many methods in the Java Development Kit (for examples, see the references below) return status values (for example, as an `int`) to indicate whether the method execution finished normally. They may return an error code if the method did not finish normally. If the method result is not checked, exceptional method executions may cause subsequent code to fail.


    ## Recommendation
    You should insert additional code to check the return value and take appropriate action.


    ## Example
    The following example uses the `java.io.InputStream.read` method to read 16 bytes from an input stream and store them in an array. However, `read` may not actually be able to read as many bytes as requested, for example because the stream is exhausted. Therefore, the code should not simply rely on the array `b` being filled with precisely 16 bytes from the input stream. Instead, the code should check the method's return value, which indicates the number of bytes actually read.


    ```java
    java.io.InputStream is = (...);
    byte[] b = new byte[16];
    is.read(b);
    ```

    ## References
    * SEI CERT Oracle Coding Standard for Java: [ EXP00-J. Do not ignore values returned by methods](https://wiki.sei.cmu.edu/confluence/display/java/EXP00-J.+Do+not+ignore+values+returned+by+methods).
    * Java API Specification: [ java.util.Queue.offer](https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/util/Queue.html#offer(E)).
    * Java API Specification: [ java.util.concurrent.BlockingQueue.offer](https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/util/concurrent/BlockingQueue.html#offer(E,long,java.util.concurrent.TimeUnit)).
    * Java API Specification, java.util.concurrent.locks.Condition: [ await](https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/util/concurrent/locks/Condition.html#await(long,java.util.concurrent.TimeUnit)), [ awaitUntil](https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/util/concurrent/locks/Condition.html#awaitUntil(java.util.Date)), [ awaitNanos](https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/util/concurrent/locks/Condition.html#awaitNanos(long)).
    * Java API Specification, java.io.File: [ createNewFile](https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/io/File.html#createNewFile()), [ delete](https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/io/File.html#delete()), [ mkdir](https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/io/File.html#mkdir()), [ renameTo](https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/io/File.html#renameTo(java.io.File)), [ setLastModified](https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/io/File.html#setLastModified(long)), [ setReadOnly](https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/io/File.html#setReadOnly()), [ setWritable(boolean)](https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/io/File.html#setWritable(boolean)), [ setWritable(boolean, boolean)](https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/io/File.html#setWritable(boolean,boolean)).
    * Java API Specification, java.io.InputStream: [ skip](https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/io/InputStream.html#skip(long)), [ read(byte\[\])](https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/io/InputStream.html#read(byte%5B%5D)), [ read(byte\[\], int, int)](https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/io/InputStream.html#read(byte[],int,int)).
    * Common Weakness Enumeration: [CWE-391](https://cwe.mitre.org/data/definitions/391.html).
 -
  pack: codeql/java-queries#0
  relativeQueryPath: Violations of Best Practice/Exception Handling/NumberFormatException.ql
  relativeBqrsPath: codeql/java-queries/Violations of Best Practice/Exception Handling/NumberFormatException.bqrs
  metadata:
    name: Missing catch of NumberFormatException
    description: |-
      Calling a string to number conversion method without handling
                    'NumberFormatException' may cause unexpected runtime exceptions.
    kind: problem
    problem.severity: recommendation
    precision: high
    id: java/uncaught-number-format-exception
    tags: |-
      reliability
             external/cwe/cwe-248
  queryHelp: "# Missing catch of NumberFormatException\nMethods such as `Integer.parseInt`\
    \ that parse strings into numbers throw `NumberFormatException` if their arguments\
    \ cannot be parsed. This exception should be caught so that any parse errors can\
    \ be handled.\n\n\n## Recommendation\nIt is usually best to handle `NumberFormatException`\
    \ in a `catch` clause surrounding the call to the parsing method.\n\n\n## Example\n\
    In the following example, the first call to `Integer.parseInt` does not catch\
    \ the exception. The second call does.\n\n\n```java\nString s = ...;\nint n;\n\
    \nn = Integer.parseInt(s); // BAD: NumberFormatException is not caught.\n\ntry\
    \ {\n        n = Integer.parseInt(s);\n} catch (NumberFormatException e) {  //\
    \ GOOD: The exception is caught. \n        // Handle the exception\n}\n\n```\n\
    \n## References\n* Java API Specification: [Integer.valueOf](https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/lang/Integer.html#valueOf(java.lang.String)),\
    \ [Integer.parseInt](https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/lang/Integer.html#parseInt(java.lang.String)),\
    \ [Long.parseLong](https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/lang/Long.html#parseLong(java.lang.String)),\
    \ [NumberFormatException](https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/lang/NumberFormatException.html).\n\
    * Common Weakness Enumeration: [CWE-248](https://cwe.mitre.org/data/definitions/248.html).\n"
 -
  pack: codeql/java-queries#0
  relativeQueryPath: Violations of Best Practice/Implementation Hiding/AbstractToConcreteCollection.ql
  relativeBqrsPath: codeql/java-queries/Violations of Best Practice/Implementation
    Hiding/AbstractToConcreteCollection.bqrs
  metadata:
    name: Cast from abstract to concrete collection
    description: |-
      A cast from an abstract collection to a concrete implementation type makes the
                    code brittle.
    kind: problem
    problem.severity: warning
    precision: very-high
    id: java/abstract-to-concrete-cast
    tags: |-
      reliability
             maintainability
             modularity
             external/cwe/cwe-485
  queryHelp: "# Cast from abstract to concrete collection\nMost collections in the\
    \ Java standard library are defined by an abstract interface (for example `java.util.List`\
    \ or `java.util.Set`), which is implemented by a range of concrete classes and\
    \ a range of wrappers. Normally, except when constructing an object, it is better\
    \ to use the abstract types because this avoids assumptions about what the implementation\
    \ is.\n\nA cast from an abstract to a concrete collection makes the code brittle\
    \ by ensuring it works only for one possible implementation class and not others.\
    \ Usually, such casts are either an indication of over-reliance on concrete implementation\
    \ types, or of the fact that the wrong abstract type was used.\n\n\n## Recommendation\n\
    It is usually best to use the abstract type consistently in variable, field and\
    \ parameter declarations.\n\nThere may be individual exceptions. For example,\
    \ it is common to declare variables as `LinkedHashSet` rather than `Set` when\
    \ the iteration order matters and only the `LinkedHashSet` implementation provides\
    \ the right behavior.\n\n\n## Example\nThe following example illustrates a situation\
    \ where the wrong abstract type is used. The `List` interface does not provide\
    \ a `poll` method, so the original code casts `queue` down to the concrete type\
    \ `LinkedList`, which does. To avoid this downcasting, simply use the correct\
    \ abstract type for this method, namely `Queue`. This documents the intent of\
    \ the programmer and allows for various implementations of queues to be used by\
    \ clients of this method.\n\n\n```java\nCustomer getNext(List<Customer> queue)\
    \ {\n\tif (queue == null)\n\t\treturn null;\n\tLinkedList<Customer> myQueue =\
    \ (LinkedList<Customer>)queue;  // AVOID: Cast to concrete type.\n\treturn myQueue.poll();\n\
    }\n\nCustomer getNext(Queue<Customer> queue) {\n\tif (queue == null)\n\t\treturn\
    \ null;\n\treturn queue.poll();  // GOOD: Use abstract type.\n}\n\n```\n\n## References\n\
    * J. Bloch, *Effective Java (second edition)*, Item 52. Addison-Wesley, 2008.\n\
    * Java API Specification: [Collection](https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/util/Collection.html).\n\
    * Common Weakness Enumeration: [CWE-485](https://cwe.mitre.org/data/definitions/485.html).\n"
 -
  pack: codeql/java-queries#0
  relativeQueryPath: Violations of Best Practice/Implementation Hiding/ExposeRepresentation.ql
  relativeBqrsPath: codeql/java-queries/Violations of Best Practice/Implementation
    Hiding/ExposeRepresentation.bqrs
  metadata:
    name: Exposing internal representation
    description: |-
      An object that accidentally exposes its internal representation may allow the
                    object's fields to be modified in ways that the object is not prepared to handle.
    kind: problem
    problem.severity: recommendation
    precision: high
    id: java/internal-representation-exposure
    tags: |-
      reliability
             maintainability
             modularity
             external/cwe/cwe-485
  queryHelp: "# Exposing internal representation\nA subtle type of defect is caused\
    \ when an object accidentally exposes its internal representation to the code\
    \ outside the object, and the internal representation is then (deliberately or\
    \ accidentally) modified in ways that the object is not prepared to handle. Most\
    \ commonly, this happens when a getter returns a direct reference to a mutable\
    \ field within the object, or a setter just assigns a mutable argument to its\
    \ field.\n\n\n## Recommendation\nThere are three ways of addressing this problem:\n\
    \n* **Using immutable objects** : The fields store objects that are *immutable*,\
    \ which means that once constructed their value can never be changed. Examples\
    \ from the standard library are `String`, `Integer` or `Float`. Although such\
    \ an object may be aliased, or shared between several contexts, there can be no\
    \ unexpected changes to the internal state of the object because it cannot be\
    \ modified.\n* **Creating a read-only view** : The `java.util.Collections.unmodifiable*`\
    \ methods can be used to create a read-only view of a collection without copying\
    \ it. This tends to give better performance than creating copies of objects. Note\
    \ that this technique is not suitable for every situation, because any changes\
    \ to the underlying collection will spread to affect the view. This can lead to\
    \ unexpected results, and is a particular danger when writing multi-threaded code.\n\
    * **Making defensive copies** : Each setter (or constructor) makes a copy or clone\
    \ of the incoming parameter. In this way, it constructs an instance known only\
    \ internally, and no matter what happens with the object that was passed in, the\
    \ state stays consistent. Conversely, each getter for a field must also construct\
    \ a copy of the field's value to return.\n\n## Example\nIn the following example,\
    \ the private field `items` is returned directly by the getter `getItems`. Thus,\
    \ a caller obtains a reference to internal object state and can manipulate the\
    \ collection of items in the cart. In the example, each of the carts is emptied\
    \ when `countItems` is called.\n\n\n```java\npublic class Cart {\n\tprivate Set<Item>\
    \ items;\n\t// ...\n\t// AVOID: Exposes representation\n\tpublic Set<Item> getItems()\
    \ {\n\t\treturn items;\n\t}\n}\n....\nint countItems(Set<Cart> carts) {\n\tint\
    \ result = 0;\n\tfor (Cart cart : carts) {\n\t\tSet<Item> items = cart.getItems();\n\
    \t\tresult += items.size();\n\t\titems.clear(); // AVOID: Changes internal representation\n\
    \t}\n\treturn result;\n}\n```\nThe solution is for `getItems` to return a *copy*\
    \ of the actual field, for example `return new HashSet<Item>(items);`.\n\n\n##\
    \ References\n* J. Bloch, *Effective Java (second edition)*, Items 15 and 39.\
    \ Addison-Wesley, 2008.\n* Java API Specification: [Collections](https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/util/Collections.html).\n\
    * Common Weakness Enumeration: [CWE-485](https://cwe.mitre.org/data/definitions/485.html).\n"
 -
  pack: codeql/java-queries#0
  relativeQueryPath: Violations of Best Practice/Implementation Hiding/GetClassGetResource.ql
  relativeBqrsPath: codeql/java-queries/Violations of Best Practice/Implementation
    Hiding/GetClassGetResource.bqrs
  metadata:
    name: Unsafe use of getResource
    description: |-
      Calling 'this.getClass().getResource()' may yield unexpected results if called from a
                    subclass in another package.
    kind: problem
    problem.severity: warning
    precision: medium
    id: java/unsafe-get-resource
    tags: |-
      reliability
             maintainability
  queryHelp: |
    # Unsafe use of getResource
    Using the `Class.getResource` method is a common way of including some non-code resources with an application.

    There are problems when this is called using `x.getClass().getResource()`, for some variable `x`. This is not a safe way to retrieve a resource. The method `getClass` returns the *run-time* class of `x` (that is, its actual, "most derived" class, rather than its declared type), which causes two potential problems:

    * If the run-time type of the receiving object is a subclass of the declared type and is in a different package, the resource path may be interpreted differently. According to its contract, `Class.getResource` qualifies non-absolute paths with the current package name, thus potentially returning a different resource or failing to find the requested resource.
    * `Class.getResource` delegates finding the resource to the class loader that loaded the class. At run time, there is no guarantee that all subclasses of a particular type are loaded by the same class loader, resulting in resource lookup failures that are difficult to diagnose.

    ## Recommendation
    Rather than using the `getClass` method, which relies on dynamic dispatch and run-time types, use `class` literals instead. For example, instead of calling `getClass().getResource()` on an object of type `Foo`, call `Foo.class.getResource()`. Class literals always refer to the declared type they are used on, removing the dependency on run-time types.


    ## Example
    In the following example, the calls to `getPostalCodes` return different results, depending on which class the call is made on: the class `Address` is in the package `framework` and the class `UKAddress` is in the package `client`.


    ```java
    package framework;
    class Address {
        public URL getPostalCodes() {
            // AVOID: The call is made on the run-time type of 'this'.
            return this.getClass().getResource("postal-codes.csv");
        }
    }

    package client;
    class UKAddress extends Address {
        public void convert() {
            // Looks up "framework/postal-codes.csv"
            new Address().getPostalCodes();
            // Looks up "client/postal-codes.csv"
            new UKAddress().getPostalCodes();
        }
    }
    ```
    In the following corrected example, the implementation of `getPostalCodes` is changed so that it always calls `getResource` on the same class.


    ```java
    package framework;
    class Address {
        public URL getPostalCodes() {
            // GOOD: The call is always made on an object of the same type.
            return Address.class.getResource("postal-codes.csv");
        }
    }

    package client;
    class UKAddress extends Address {
        public void convert() {
            // Looks up "framework/postal-codes.csv"
            new Address().getPostalCodes();
            // Looks up "framework/postal-codes.csv"
            new UKAddress().getPostalCodes();
        }
    }
    ```

    ## References
    * Java API Specification: [Class.getResource()](https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/lang/Class.html#getResource(java.lang.String)).
 -
  pack: codeql/java-queries#0
  relativeQueryPath: Violations of Best Practice/Implementation Hiding/StaticArray.ql
  relativeBqrsPath: codeql/java-queries/Violations of Best Practice/Implementation
    Hiding/StaticArray.bqrs
  metadata:
    name: Array constant vulnerable to change
    description: Array constants are mutable and can be changed by malicious code
      or by accident.
    kind: problem
    problem.severity: warning
    precision: low
    id: java/static-array
    tags: |-
      maintainability
             modularity
             external/cwe/cwe-582
  queryHelp: "# Array constant vulnerable to change\nConstant values are typically\
    \ represented by public, static, final fields. When defining several related constants,\
    \ it is sometimes tempting to define a public, static, final field with an array\
    \ type, and initialize it with a list of all the different constant values.\n\n\
    However, the `final` keyword applies only to the field itself (that is, the array\
    \ reference), and not to the contents of the array. This means that the field\
    \ always refers to the same array instance, but each element of the array may\
    \ be modified freely. This possibly invalidates important assumptions of client\
    \ code.\n\n\n## Recommendation\nWhere possible, avoid declaring array constants.\
    \ If there are only a few constant values, consider using a named constant for\
    \ each one, or defining them in an `enum` type.\n\nIf you genuinely need to refer\
    \ to a long list of constants with the same name and an index, consider replacing\
    \ the array constant with a constant of type `List` to which you assign an unmodifiable\
    \ collection. See the example for ways of achieving this.\n\n\n## Example\nIn\
    \ the following example, `public static final` applies only to `RGB` itself, not\
    \ the constants that it contains.\n\n\n```java\npublic class Display {\n\t// AVOID:\
    \ Array constant is vulnerable to mutation.\n\tpublic static final String[] RGB\
    \ = {\n\t\t\"FF0000\", \"00FF00\", \"0000FF\"\n\t};\n\t\n\tvoid f() {\n\t\t//\
    \ Re-assigning the \"constant\" is legal.\n\t\tRGB[0] = \"00FFFF\";\n\t}\n}\n\
    ```\nThe following example shows examples of ways to declare constants that avoid\
    \ this problem.\n\n\n```java\n// Solution 1: Extract to individual constants\n\
    public class Display {\n    public static final String RED = \"FF0000\";\n   \
    \ public static final String GREEN = \"00FF00\";\n    public static final String\
    \ BLUE = \"0000FF\";\n}\n\n// Solution 2: Define constants using in an enum type\n\
    public enum Display\n{\n    RED (\"FF0000\"), GREEN (\"00FF00\"), BLUE (\"0000FF\"\
    );\n\n    private String rgb;\n    private Display(int rgb) {\n        this.rgb\
    \ = rgb;\n    }\n    public String getRGB(){\n        return rgb;\n    }\n}\n\n\
    // Solution 3: Use an unmodifiable collection\npublic class Display {\n    public\
    \ static final List<String> RGB =\n            Collections.unmodifiableList(\n\
    \                    Arrays.asList(\"FF0000\",\n                            \"\
    00FF00\",\n                            \"0000FF\"));\n}\n\n// Solution 4: Use\
    \ a utility method\npublic class Utils {\n    public static <T> List<T> constList(T...\
    \ values) {\n        return Collections.unmodifiableList(\n                Arrays.asList(values));\n\
    \    }\n}\n\npublic class Display {\n    public static final List<String> RGB\
    \ =\n            Utils.constList(\"FF0000\", \"00FF00\", \"0000FF\");\n}\n\n```\n\
    \n## References\n* J. Bloch, *Effective Java (second edition)*, p. 70. Addison-Wesley,\
    \ 2008.\n* Java Language Specification: [4.12.4 final Variables](https://docs.oracle.com/javase/specs/jls/se11/html/jls-4.html#jls-4.12.4).\n\
    * Common Weakness Enumeration: [CWE-582](https://cwe.mitre.org/data/definitions/582.html).\n"
 -
  pack: codeql/java-queries#0
  relativeQueryPath: Violations of Best Practice/Magic Constants/MagicConstantsNumbers.ql
  relativeBqrsPath: codeql/java-queries/Violations of Best Practice/Magic Constants/MagicConstantsNumbers.bqrs
  metadata:
    name: Magic numbers
    description: A magic number makes code less readable and maintainable.
    kind: problem
    problem.severity: recommendation
    precision: low
    id: java/magic-number
    tags: |-
      maintainability
             readability
             statistical
             non-attributable
  queryHelp: "# Magic numbers\nA *magic number* is a numeric literal (for example,\
    \ `8080`, `2048`) that is used in the middle of a block of code without explanation.\
    \ It is considered bad practice to use magic numbers because:\n\n* A number in\
    \ isolation can be difficult for other programmers to understand.\n* It can be\
    \ difficult to update the code if the requirements change. For example, if the\
    \ magic number represents the number of guests allowed, adding one more guest\
    \ means that you must change every occurrence of the magic number.\n\n## Recommendation\n\
    Assign the magic number to a new named constant, and use this instead. This overcomes\
    \ the two problems with magic numbers:\n\n* A named constant (such as `MAX_GUESTS`)\
    \ is more easily understood by other programmers.\n* Using the same named constant\
    \ in many places makes the code much easier to update if the requirements change,\
    \ because you have to update the number in only one place.\n\n## Example\nThe\
    \ following example shows a magic number `timeout`. This should be replaced by\
    \ a new named constant, as shown in the fixed version.\n\n\n```java\n// Problem\
    \ version\npublic class MagicConstants\n{\n\tpublic static final String IP = \"\
    127.0.0.1\";\n\tpublic static final int PORT = 8080;\n\tpublic static final String\
    \ USERNAME = \"test\";\n\n\tpublic void serve(String ip, int port, String user,\
    \ int timeout) {\n\t\t// ...\n\t}\n\n\tpublic static void main(String[] args)\
    \ {\n\t\tint timeout = 60000;  // AVOID: Magic number\n\n\t\tnew MagicConstants().serve(IP,\
    \ PORT, USERNAME, timeout);\n\t}\n}\n\n\n// Fixed version\npublic class MagicConstants\n\
    {\n\tpublic static final String IP = \"127.0.0.1\";\n\tpublic static final int\
    \ PORT = 8080;\n\tpublic static final String USERNAME = \"test\";\n\tpublic static\
    \ final int TIMEOUT = 60000;  // Magic number is replaced by named constant\n\n\
    \tpublic void serve(String ip, int port, String user, int timeout) {\n\t\t// ...\n\
    \t}\n\n\tpublic static void main(String[] args) {\n\t\tnew MagicConstants().serve(IP,\
    \ PORT, USERNAME, TIMEOUT);  // Use 'TIMEOUT' constant\n\t}\n}\n```\n\n## References\n\
    * R. C. Martin, *Clean Code: A Handbook of Agile Software Craftsmanship*, &sect;17.G25.\
    \ Prentice Hall, 2008.\n"
 -
  pack: codeql/java-queries#0
  relativeQueryPath: Violations of Best Practice/Magic Constants/MagicConstantsString.ql
  relativeBqrsPath: codeql/java-queries/Violations of Best Practice/Magic Constants/MagicConstantsString.bqrs
  metadata:
    name: Magic strings
    description: A magic string makes code less readable and maintainable.
    kind: problem
    problem.severity: recommendation
    precision: low
    id: java/magic-string
    tags: |-
      maintainability
             readability
             statistical
             non-attributable
  queryHelp: "# Magic strings\nA *magic string* is a string literal (for example,\
    \ `\"SELECT\"`, `\"127.0.0.1\"`) that is used in the middle of a block of code\
    \ without explanation. It is considered bad practice to use magic strings because:\n\
    \n* A string in isolation can be difficult for other programmers to understand.\n\
    * It can be difficult to update the code if the requirements change. For example,\
    \ if the magic string represents a protocol, changing the protocol means that\
    \ you must change every occurrence of the protocol.\n\n## Recommendation\nAssign\
    \ the magic string to a new named constant, and use this instead. This overcomes\
    \ the two problems with magic strings:\n\n* A named constant (such as `SMTP_HELO`)\
    \ is more easily understood by other programmers.\n* Using the same named constant\
    \ in many places makes the code much easier to update if the requirements change,\
    \ because you have to update the string in only one place.\n\n## Example\nThe\
    \ following example shows a magic string `username`. This should be replaced by\
    \ a new named constant, as shown in the fixed version.\n\n\n```java\n// Problem\
    \ version\npublic class MagicConstants\n{\n\tpublic static final String IP = \"\
    127.0.0.1\";\n\tpublic static final int PORT = 8080;\n\tpublic static final int\
    \ TIMEOUT = 60000;\n\n\tpublic void serve(String ip, int port, String user, int\
    \ timeout) {\n\t\t// ...\n\t}\n\n\tpublic static void main(String[] args) {\n\t\
    \tString username = \"test\";  // AVOID: Magic string\n\n\t\tnew MagicConstants().serve(IP,\
    \ PORT, username, TIMEOUT);\n\t}\n}\n\n\n// Fixed version\npublic class MagicConstants\n\
    {\n\tpublic static final String IP = \"127.0.0.1\";\n\tpublic static final int\
    \ PORT = 8080;\n\tpublic static final int USERNAME = \"test\";  // Magic string\
    \ is replaced by named constant\n\tpublic static final int TIMEOUT = 60000;\n\n\
    \tpublic void serve(String ip, int port, String user, int timeout) {\n\t\t// ...\n\
    \t}\n\n\tpublic static void main(String[] args) {\n\t\tnew MagicConstants().serve(IP,\
    \ PORT, USERNAME, TIMEOUT);  // Use 'USERNAME' constant\n\t}\n}\n```\n\n## References\n\
    * R. C. Martin, *Clean Code: A Handbook of Agile Software Craftsmanship*, &sect;17.G25.\
    \ Prentice Hall, 2008.\n"
 -
  pack: codeql/java-queries#0
  relativeQueryPath: Violations of Best Practice/Magic Constants/MagicNumbersUseConstant.ql
  relativeBqrsPath: codeql/java-queries/Violations of Best Practice/Magic Constants/MagicNumbersUseConstant.bqrs
  metadata:
    name: "Magic numbers: use defined constant"
    description: |-
      A magic number, which is used instead of an existing named constant, makes code less
                    readable and maintainable.
    kind: problem
    problem.severity: recommendation
    precision: low
    id: java/use-number-constant
    tags: |-
      maintainability
             readability
  queryHelp: "# Magic numbers: use defined constant\nA *magic number* is a numeric\
    \ literal (for example, `8080`, `2048`) that is used in the middle of a block\
    \ of code without explanation. It is considered bad practice to use magic numbers\
    \ because:\n\n* A number in isolation can be difficult for other programmers to\
    \ understand.\n* It can be difficult to update the code if the requirements change.\
    \ For example, if the magic number represents the number of guests allowed, adding\
    \ one more guest means that you must change every occurrence of the magic number.\n\
    \n## Recommendation\nReplace the magic number with the existing named constant.\
    \ This overcomes the two problems with magic numbers:\n\n* A named constant (such\
    \ as `MAX_GUESTS`) is more easily understood by other programmers.\n* Using the\
    \ same named constant in many places makes the code much easier to update if the\
    \ requirements change, because you have to update the number in only one place.\n\
    \n## Example\nThe following example shows a magic number `internalPort`. This\
    \ should be replaced by the existing named constant, as shown in the fixed version.\n\
    \n\n```java\n// Problem version\npublic class MagicConstants\n{\n\tpublic static\
    \ final String IP = \"127.0.0.1\";\n\tpublic static final int PORT = 8080;\n\t\
    public static final String USERNAME = \"test\";\n\tpublic static final int TIMEOUT\
    \ = 60000;\n\n\tpublic void serve(String ip, int port, String user, int timeout)\
    \ {\n\t\t// ...\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tint internalPort\
    \ = 8080;  // AVOID: Magic number\n\n\t\tnew MagicConstants().serve(IP, internalPort,\
    \ USERNAME, TIMEOUT);\n\t}\n}\n\n\n// Fixed version\npublic class MagicConstants\n\
    {\n\tpublic static final String IP = \"127.0.0.1\";\n\tpublic static final int\
    \ PORT = 8080;\n\tpublic static final String USERNAME = \"test\";\n\tpublic static\
    \ final int TIMEOUT = 60000;\n\n\tpublic void serve(String ip, int port, String\
    \ user, int timeout) {\n\t\t// ...\n\t}\n\n\tpublic static void main(String[]\
    \ args) {\n\t\tnew MagicConstants().serve(IP, PORT, USERNAME, TIMEOUT);  // Use\
    \ 'PORT' constant\n\t}\n}\n```\n\n## References\n* R. C. Martin, *Clean Code:\
    \ A Handbook of Agile Software Craftsmanship*, &sect;17.G25. Prentice Hall, 2008.\n"
 -
  pack: codeql/java-queries#0
  relativeQueryPath: Violations of Best Practice/Magic Constants/MagicStringsUseConstant.ql
  relativeBqrsPath: codeql/java-queries/Violations of Best Practice/Magic Constants/MagicStringsUseConstant.bqrs
  metadata:
    name: "Magic strings: use defined constant"
    description: |-
      A magic string, which is used instead of an existing named constant, makes code less
                    readable and maintainable.
    kind: problem
    problem.severity: recommendation
    precision: low
    id: java/use-string-constant
    tags: |-
      maintainability
             readability
  queryHelp: "# Magic strings: use defined constant\nA *magic string* is a string\
    \ literal (for example, `\"SELECT\"`, `\"127.0.0.1\"`) that is used in the middle\
    \ of a block of code without explanation. It is considered bad practice to use\
    \ magic strings because:\n\n* A string in isolation can be difficult for other\
    \ programmers to understand.\n* It can be difficult to update the code if the\
    \ requirements change. For example, if the magic string represents a protocol,\
    \ changing the protocol means that you must change every occurrence of the protocol.\n\
    \n## Recommendation\nReplace the magic string with the existing named constant.\
    \ This overcomes the two problems with magic strings:\n\n* A named constant (such\
    \ as `SMTP_HELO`) is more easily understood by other programmers.\n* Using the\
    \ same named constant in many places makes the code much easier to update if the\
    \ requirements change, because you have to update the string in only one place.\n\
    \n## Example\nThe following example shows a magic string `internalIp`. This should\
    \ be replaced by the existing named constant, as shown in the fixed version.\n\
    \n\n```java\n// Problem version\npublic class MagicConstants\n{\n\tpublic static\
    \ final String IP = \"127.0.0.1\";\n\tpublic static final int PORT = 8080;\n\t\
    public static final String USERNAME = \"test\";\n\tpublic static final int TIMEOUT\
    \ = 60000;\n\n\tpublic void serve(String ip, int port, String user, int timeout)\
    \ {\n\t\t// ...\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tString\
    \ internalIp = \"127.0.0.1\";  // AVOID: Magic string\n\n\t\tnew MagicConstants().serve(internalIp,\
    \ PORT, USERNAME, TIMEOUT);\n\t}\n}\n\n\n// Fixed version\npublic class MagicConstants\n\
    {\n\tpublic static final String IP = \"127.0.0.1\";\n\tpublic static final int\
    \ PORT = 8080;\n\tpublic static final String USERNAME = \"test\";\n\tpublic static\
    \ final int TIMEOUT = 60000;\n\n\tpublic void serve(String ip, int port, String\
    \ user, int timeout) {\n\t\t// ...\n\t}\n\n\tpublic static void main(String[]\
    \ args) {\n\t\tnew MagicConstants().serve(IP, PORT, USERNAME, TIMEOUT);  //Use\
    \ 'IP' constant\n\t}\n}\n```\n\n## References\n* R. C. Martin, *Clean Code: A\
    \ Handbook of Agile Software Craftsmanship*, &sect;17.G25. Prentice Hall, 2008.\n"
 -
  pack: codeql/java-queries#0
  relativeQueryPath: Violations of Best Practice/Naming Conventions/AmbiguousOuterSuper.ql
  relativeBqrsPath: codeql/java-queries/Violations of Best Practice/Naming Conventions/AmbiguousOuterSuper.bqrs
  metadata:
    name: Subtle call to inherited method
    description: |-
      An unqualified call to a method that exists with the same signature in both a
                    superclass and an outer class is ambiguous.
    kind: problem
    problem.severity: warning
    precision: very-high
    id: java/subtle-inherited-call
    tags: |-
      reliability
             readability
  queryHelp: "# Subtle call to inherited method\nIf a call is made to a method from\
    \ an inner class A, and a method of that name is defined in both a superclass\
    \ of A and an outer class of A, it is not clear to a programmer which method is\
    \ intended to be called.\n\n\n## Example\nIn the following example, it is not\
    \ clear whether the call to `printMessage` calls the method that is defined in\
    \ `Outer` or `Super`.\n\n\n```java\npublic class Outer\n{\n\tvoid printMessage()\
    \ {\n\t\tSystem.out.println(\"Outer\");\n\t}\n\t\n\tclass Inner extends Super\n\
    \t{\n\t\tvoid ambiguous() {\n\t\t\tprintMessage();  // Ambiguous call\n\t\t}\n\
    \t}\n\t\n\tpublic static void main(String[] args) {\n\t\tnew Outer().new Inner().ambiguous();\n\
    \t}\n}\n\nclass Super\n{\n\tvoid printMessage() {\n\t\tSystem.out.println(\"Super\"\
    );\n\t}\n}\n\n```\nInherited methods take precedence over methods in outer classes,\
    \ so the method in the superclass is called. However, such situations are a potential\
    \ cause of confusion and defects.\n\n\n## Recommendation\nResolve the ambiguity\
    \ by explicitly qualifying the method call:\n\n* To specify the outer class, prefix\
    \ the method with `Outer.this.`.\n* To specify the superclass, prefix the method\
    \ with `super.`.\nIn the above example, the call to `printMessage` could be replaced\
    \ by either `Outer.this.printMessage` or `super.printMessage`, depending on which\
    \ method you intend to call. To preserve the behavior in the example, use `super.printMessage`.\n\
    \n\n## References\n* Inner Classes Specification: [What are top-level classes\
    \ and inner classes?](http://www.cis.upenn.edu/~bcpierce/courses/629/jdkdocs/guide/innerclasses/spec/innerclasses.doc1.html).\n"
 -
  pack: codeql/java-queries#0
  relativeQueryPath: Violations of Best Practice/Naming Conventions/ConfusingMethodNames.ql
  relativeBqrsPath: codeql/java-queries/Violations of Best Practice/Naming Conventions/ConfusingMethodNames.bqrs
  metadata:
    name: Confusing method names because of capitalization
    description: |-
      Methods in the same class whose names differ only in capitalization are
                    confusing.
    kind: problem
    problem.severity: recommendation
    precision: high
    id: java/confusing-method-name
    tags: |-
      maintainability
             readability
             naming
  queryHelp: "# Confusing method names because of capitalization\nIt is bad practice\
    \ to have methods in a class with names that differ only in their capitalization.\
    \ This can be confusing and lead to mistakes.\n\n\n## Recommendation\nName the\
    \ methods to make the distinction between them clear.\n\n\n## Example\nThe following\
    \ example shows a class that contains two methods: `toUri` and `toURI`. One or\
    \ both of them should be renamed.\n\n\n```java\npublic class InternetResource\n\
    {\n\tprivate String protocol;\n\tprivate String host;\n\tprivate String path;\n\
    \n\t// ...\n\n\tpublic String toUri() {\n\t\treturn protocol + \"://\" + host\
    \ + \"/\" + path;\n\t}\n\n\t// ...\n\n\tpublic String toURI() {\n\t\treturn toUri();\n\
    \t}\n}\n```\n\n## References\n* R. C. Martin, *Clean Code: A Handbook of Agile\
    \ Software Craftsmanship*, 17.N4. Prentice Hall, 2008.\n"
 -
  pack: codeql/java-queries#0
  relativeQueryPath: Violations of Best Practice/Naming Conventions/ConfusingOverloading.ql
  relativeBqrsPath: codeql/java-queries/Violations of Best Practice/Naming Conventions/ConfusingOverloading.bqrs
  metadata:
    name: Confusing overloading of methods
    description: |-
      Overloaded methods that have the same number of parameters, where each pair of
                    corresponding parameter types is convertible by casting or autoboxing, may be
                    confusing.
    kind: problem
    problem.severity: recommendation
    precision: high
    id: java/confusing-method-signature
    tags: |-
      maintainability
             readability
             naming
  queryHelp: |
    # Confusing overloading of methods
    Overloaded method declarations that have the same number of parameters may be confusing if none of the corresponding pairs of parameter types is substantially different. A pair of parameter types A and B is substantially different if A cannot be cast to B and B cannot be cast to A. If the parameter types are not substantially different then the programmer may assume that the method with parameter type A is called when in fact the method with parameter type B is called.


    ## Recommendation
    It is generally best to avoid declaring overloaded methods with the same number of parameters, unless at least one of the corresponding parameter pairs is substantially different.


    ## Example
    Declaring overloaded methods `process(Object obj)` and `process(String s)` is confusing because the parameter types are not substantially different. It is clearer to declare methods with different names: `processObject(Object obj)` and `processString(String s)`.

    In contrast, declaring overloaded methods `process(Object obj, String s)` and `process(String s, int i)` is not as confusing because the second parameters of each method are substantially different.


    ## References
    * J. Bloch, *Effective Java (second edition)*, Item 41. Addison-Wesley, 2008.
    * Java Language Specification: [15.12 Method Invocation Expressions](https://docs.oracle.com/javase/specs/jls/se11/html/jls-15.html#jls-15.12).
 -
  pack: codeql/java-queries#0
  relativeQueryPath: Violations of Best Practice/Naming Conventions/ConfusingOverridesNames.ql
  relativeBqrsPath: codeql/java-queries/Violations of Best Practice/Naming Conventions/ConfusingOverridesNames.bqrs
  metadata:
    name: Confusing method names because of overriding
    description: |-
      A method that would override another method but does not, because the name is
                    capitalized differently, is confusing and may be a mistake.
    kind: problem
    problem.severity: warning
    precision: low
    id: java/confusing-override-name
    tags: |-
      maintainability
             readability
             naming
  queryHelp: "# Confusing method names because of overriding\nIf a method that would\
    \ override another method but does not because the name is capitalized differently,\
    \ there are two possibilities:\n\n* The programmer intends the method to override\
    \ the other method, and the difference in capitalization is a typographical error.\n\
    * The programmer does not intend the method to override the other method, in which\
    \ case the similarity of the names is very confusing.\n\n## Recommendation\nIf\
    \ overriding *is* intended, make the capitalization of the two methods the same.\n\
    \nIf overriding is *not* intended, consider naming the methods to make the distinction\
    \ between them clear.\n\n\n## Example\nIn the following example, `toString` has\
    \ been wrongly capitalized as `tostring`. This means that objects of type `Customer`\
    \ do not print correctly.\n\n\n```java\npublic class Customer\n{\n\tprivate String\
    \ title;\n\tprivate String forename;\n\tprivate String surname;\n\n\t// ...\n\n\
    \tpublic String tostring() {  // Incorrect capitalization of 'toString'\n\t\t\
    return title + \" \" + forename + \" \" + surname;\n\t}\n}\n```\n\n## References\n\
    * R. C. Martin, *Clean Code: A Handbook of Agile Software Craftsmanship*, &sect;17.N4.\
    \ Prentice Hall, 2008.\n"
 -
  pack: codeql/java-queries#0
  relativeQueryPath: Violations of Best Practice/Naming Conventions/FieldMasksSuperField.ql
  relativeBqrsPath: codeql/java-queries/Violations of Best Practice/Naming Conventions/FieldMasksSuperField.bqrs
  metadata:
    name: Field masks field in super class
    description: |-
      Hiding a field in a superclass by redeclaring it in a subclass might be
                    unintentional, especially if references to the hidden field are not qualified using
                    'super'.
    kind: problem
    problem.severity: warning
    precision: medium
    id: java/field-masks-super-field
    tags: |-
      maintainability
             readability
  queryHelp: |
    # Field masks field in super class
    A field that has the same name as a field in a superclass *hides* the field in the superclass. Such hiding might be unintentional, especially if there are no references to the hidden field using the `super` qualifier. In any case, it makes code more difficult to read.


    ## Recommendation
    Ensure that any hiding is intentional. For clarity, it may be better to rename the field in the subclass.


    ## Example
    In the following example, the programmer unintentionally added an `age` field to `Employee`, which hides the `age` field in `Person`. The constructor in `Person` sets the `age ` field in `Person` to 20 but the `age` field in `Employee` is still 0. This means that the program outputs 0, which is probably not what was intended.


    ```java
    public class FieldMasksSuperField {
        static class Person {
            protected int age;
            public Person(int age)
            {
                this.age = age;
            }
        }

        static class Employee extends Person {
            protected int age;  // This field hides 'Person.age'.
            protected int numberOfYearsEmployed;
            public Employee(int age, int numberOfYearsEmployed)
            {
                super(age);
                this.numberOfYearsEmployed = numberOfYearsEmployed;
            }
        }

        public static void main(String[] args) {
            Employee e = new Employee(20, 2);
            System.out.println(e.age);
        }
    }
    ```
    To fix this, delete the declaration of `age` on line 11.


    ## References
    * Help - Eclipse Platform: [Java Compiler Errors/Warnings Preferences](https://help.eclipse.org/2020-12/advanced/content.jsp?topic=/org.eclipse.jdt.doc.user/reference/preferences/java/compiler/ref-preferences-errors-warnings.htm).
    * The Java Tutorials: [Hiding Fields](https://docs.oracle.com/javase/tutorial/java/IandI/hidevariables.html).
 -
  pack: codeql/java-queries#0
  relativeQueryPath: Violations of Best Practice/Naming Conventions/LocalShadowsField.ql
  relativeBqrsPath: codeql/java-queries/Violations of Best Practice/Naming Conventions/LocalShadowsField.bqrs
  metadata:
    name: Local variable shadows field
    description: |-
      If a local variable shadows a field of the same name, each use of
                    the name is harder to read.
    kind: problem
    problem.severity: recommendation
    precision: low
    id: java/local-shadows-field-unused
    tags: maintainability
  queryHelp: |
    # Local variable shadows field
    This query finds local variables that shadow like-named field declarations. This is confusing since it might easily lead to assignments to the local variable that should have been to the corresponding field.


    ## How to Address the Query Results
    For clarity, it may be better to rename the variable to avoid shadowing.


    ## References
 -
  pack: codeql/java-queries#0
  relativeQueryPath: Violations of Best Practice/Naming Conventions/LocalShadowsFieldConfusing.ql
  relativeBqrsPath: codeql/java-queries/Violations of Best Practice/Naming Conventions/LocalShadowsFieldConfusing.bqrs
  metadata:
    name: Possible confusion of local and field
    description: |-
      A method in which a variable is declared with the same name as a field is difficult
                    to understand.
    kind: problem
    problem.severity: recommendation
    precision: high
    id: java/local-shadows-field
    tags: |-
      maintainability
             readability
  queryHelp: "# Possible confusion of local and field\nIf a method declares a local\
    \ variable with the same name as a field, then it is very easy to mix up the two\
    \ when reading or modifying the program.\n\n\n## Recommendation\nConsider using\
    \ different names for the field and local variable to make the difference between\
    \ them clear.\n\n\n## Example\nThe following example shows a local variable `values`\
    \ that has the same name as a field.\n\n\n```java\npublic class Container\n{\n\
    \tprivate int[] values; // Field called 'values'\n\t\n\tpublic Container (int...\
    \ values) {\n\t\tthis.values = values;\n\t}\n\n\tpublic Container dup() {\n\t\t\
    int length = values.length;\n\t\tint[] values = new int[length];  // Local variable\
    \ called 'values'\n\t\tContainer result = new Container(values);\n\t\treturn result;\n\
    \t}\n}\n\n```\n\n## References\n* Help - Eclipse Platform: [Java Compiler Errors/Warnings\
    \ Preferences](https://help.eclipse.org/2020-12/advanced/content.jsp?topic=/org.eclipse.jdt.doc.user/reference/preferences/java/compiler/ref-preferences-errors-warnings.htm).\n\
    * Java Language Specification: [ 6.4 Shadowing and Obscuring](https://docs.oracle.com/javase/specs/jls/se11/html/jls-6.html#jls-6.4).\n"
 -
  pack: codeql/java-queries#0
  relativeQueryPath: Violations of Best Practice/Naming Conventions/SameNameAsSuper.ql
  relativeBqrsPath: codeql/java-queries/Violations of Best Practice/Naming Conventions/SameNameAsSuper.bqrs
  metadata:
    name: Class has same name as super class
    description: A class that has the same name as its superclass may be confusing.
    kind: problem
    problem.severity: recommendation
    precision: high
    id: java/class-name-matches-super-class
    tags: |-
      maintainability
             readability
             naming
  queryHelp: "# Class has same name as super class\nA class that has the same name\
    \ as its superclass may be confusing.\n\n\n## Recommendation\nClarify the difference\
    \ between the subclass and the superclass by using different names.\n\n\n## Example\n\
    In the following example, it is not clear that the `attendees` field refers to\
    \ the inner class `Attendees` and not the class `com.company.util.Attendees`.\n\
    \n\n```java\nimport com.company.util.Attendees;\n\npublic class Meeting\n{\n\t\
    private Attendees attendees;\n\n\t// ...\n\t// Many lines\n\t// ...\n\n\t// AVOID:\
    \ This class has the same name as its superclass.\n\tprivate static class Attendees\
    \ extends com.company.util.Attendees\n\t{\n\t\t// ...\n\t}\n}\n```\nTo fix this,\
    \ the inner class should be renamed.\n\n\n## References\n* R. C. Martin, *Clean\
    \ Code: A Handbook of Agile Software Craftsmanship*, &sect;17.N4. Prentice Hall,\
    \ 2008.\n"
 -
  pack: codeql/java-queries#0
  relativeQueryPath: Violations of Best Practice/Undesirable Calls/CallsToRunFinalizersOnExit.ql
  relativeBqrsPath: codeql/java-queries/Violations of Best Practice/Undesirable Calls/CallsToRunFinalizersOnExit.bqrs
  metadata:
    name: Dangerous runFinalizersOnExit
    description: |-
      Calling 'System.runFinalizersOnExit' or 'Runtime.runFinalizersOnExit'
                    may cause finalizers to be run on live objects, leading to erratic behavior or
                    deadlock.
    kind: problem
    problem.severity: error
    precision: medium
    id: java/run-finalizers-on-exit
    tags: |-
      reliability
             maintainability
  queryHelp: "# Dangerous runFinalizersOnExit\nAvoid calling `System.runFinalizersOnExit`\
    \ or `Runtime.runFinalizersOnExit`, which are considered to be dangerous methods.\n\
    \nThe Java Development Kit documentation for `System.runFinalizersOnExit` states:\n\
    \n> This method is inherently unsafe. It may result in finalizers being called\
    \ on live objects while other threads are concurrently manipulating those objects,\
    \ resulting in erratic behavior or deadlock.\n\nObject finalizers are normally\
    \ only called when the object is about to be collected by the garbage collector.\
    \ Using `runFinalizersOnExit` sets a Java Virtual Machine-wide flag that executes\
    \ finalizers *on all objects with a `finalize` method* before the runtime exits.\
    \ This would require all objects with finalizers to defend against the possibility\
    \ of `finalize` being called when the object is still in use, which is not practical\
    \ for most applications.\n\n\n## Recommendation\nEnsure that the code does not\
    \ rely on the execution of finalizers. If the code is dependent on the garbage\
    \ collection behavior of the Java Virtual Machine, there is no guarantee that\
    \ finalizers will be executed in a timely manner, or at all. This may become a\
    \ problem if finalizers are used to dispose of limited system resources, such\
    \ as file handles.\n\nInstead of finalizers, use explicit `dispose` methods in\
    \ `finally` blocks, to make sure that an object's resources are released.\n\n\n\
    ## Example\nThe following example shows a program that calls `runFinalizersOnExit`,\
    \ which is not recommended.\n\n\n```java\nvoid main() {\n\t// ...\n\t// BAD: Call\
    \ to 'runFinalizersOnExit' forces execution of all finalizers on termination of\
    \ \n\t// the runtime, which can cause live objects to transition to an invalid\
    \ state.\n\t// Avoid using this method (and finalizers in general).\n\tSystem.runFinalizersOnExit(true);\n\
    \t// ...\n}\n```\nThe following example shows the recommended approach: a program\
    \ that calls a `dispose` method in a `finally` block.\n\n\n```java\n// Instead\
    \ of using finalizers, define explicit termination methods \n// and call them\
    \ in 'finally' blocks.\nclass LocalCache {\n\tprivate Collection<File> cacheFiles\
    \ = ...;\n\t\n\t// Explicit method to close all cacheFiles\n\tpublic void dispose()\
    \ {\n\t\tfor (File cacheFile : cacheFiles) {\n\t\t\tdisposeCacheFile(cacheFile);\n\
    \t\t}\n\t}\n}\n\nvoid main() {\n\tLocalCache cache = new LocalCache();\n\ttry\
    \ {\n\t\t// Use the cache\n\t} finally {\n\t\t// Call the termination method in\
    \ a 'finally' block, to ensure that\n\t\t// the cache's resources are freed. \n\
    \t\tcache.dispose();\n\t}\n}\n```\n\n## References\n* J. Bloch, *Effective Java\
    \ (second edition)*, Item 7. Addison-Wesley, 2008.\n* Java API Specification:\
    \ [System.runFinalizersOnExit()](https://docs.oracle.com/javase/10/docs/api/java/lang/System.html#runFinalizersOnExit-boolean-),\
    \ [Object.finalize()](https://docs.oracle.com/javase/10/docs/api/java/lang/Object.html#finalize--).\n\
    * Java API Specification: [Java Thread Primitive Deprecation](https://docs.oracle.com/javase/10/docs/api/java/lang/doc-files/threadPrimitiveDeprecation.html).\n"
 -
  pack: codeql/java-queries#0
  relativeQueryPath: Violations of Best Practice/Undesirable Calls/CallsToStringToString.ql
  relativeBqrsPath: codeql/java-queries/Violations of Best Practice/Undesirable Calls/CallsToStringToString.bqrs
  metadata:
    name: Useless toString on String
    description: Calling 'toString' on a string is redundant.
    kind: problem
    problem.severity: recommendation
    precision: high
    id: java/useless-tostring-call
    tags: maintainability
  queryHelp: "# Useless toString on String\nThere is no need to call `toString` on\
    \ a `String` because it just returns the object itself. From the Java API Specification\
    \ entry for `String.toString()`:\n\n> `public String toString()`\n\nThis object\
    \ (which is already a string!) is itself returned.\n\n\n## Recommendation\nDo\
    \ not call `toString` on a `String` object.\n\n\n## Example\nThe following example\
    \ shows an unnecessary call to `toString` on the string `name`.\n\n\n```java\n\
    public static void main(String args[]) {\n\tString name = \"John Doe\";\n\t\n\t\
    // BAD: Unnecessary call to 'toString' on 'name'\n\tSystem.out.println(\"Hi, my\
    \ name is \" + name.toString());\n\t\n\t// GOOD: No call to 'toString' on 'name'\n\
    \tSystem.out.println(\"Hi, my name is \" + name);\n}\n```\n\n## References\n*\
    \ Java API Specification: [String.toString()](https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/lang/String.html#toString()).\n"
 -
  pack: codeql/java-queries#0
  relativeQueryPath: Violations of Best Practice/Undesirable Calls/CallsToSystemExit.ql
  relativeBqrsPath: codeql/java-queries/Violations of Best Practice/Undesirable Calls/CallsToSystemExit.bqrs
  metadata:
    name: Forcible JVM termination
    description: |-
      Calling 'System.exit', 'Runtime.halt', or 'Runtime.exit' may make code harder to
                    reuse and prevent important cleanup steps from running.
    kind: problem
    problem.severity: warning
    precision: low
    id: java/jvm-exit
    tags: |-
      reliability
             maintainability
             external/cwe/cwe-382
  queryHelp: "# Forcible JVM termination\nCalling one of the methods `System.exit`,\
    \ `Runtime.halt`, and `Runtime.exit` immediately terminates the Java Virtual Machine\
    \ (JVM), effectively killing all threads without giving any of them a chance to\
    \ perform cleanup actions or recover. As such, it is a dangerous thing to do:\
    \ firstly, it can terminate the entire program inadvertently, and secondly, it\
    \ can prevent important resources from being released or program state from being\
    \ written to disk consistently.\n\nIt is sometimes considered acceptable to call\
    \ `System.exit` from a program's `main` method in order to indicate the overall\
    \ exit status of the program. Such calls are an exception to this rule.\n\n\n\
    ## Recommendation\nIt is usually preferable to use a different mechanism for reporting\
    \ failure conditions. Consider returning a special value (perhaps `null`) that\
    \ users of the current method check for and recover from appropriately. Alternatively,\
    \ throw a suitable exception, which unwinds the stack and allows properly written\
    \ code to clean up after itself, while leaving other threads undisturbed.\n\n\n\
    ## Example\nIn the following example, problem 1 shows that `FileOutput.write`\
    \ tries to write some data to disk and terminates the JVM if this fails. This\
    \ leaves the partially-written file on disk without any cleanup code running.\
    \ It would be better to either return `false` to indicate the failure, or let\
    \ the `IOException` propagate upwards and be handled by a method that knows how\
    \ to recover.\n\nProblem 2 is more subtle. In this example, there is just one\
    \ entry point to the program (the `main` method), which constructs an `Action`\
    \ and performs it. `Action.run` calls `System.exit` to indicate successful completion.\
    \ Consider, however, how this code might be integrated in an application server\
    \ that constructs `Action` instances and calls `run` on them without going through\
    \ `main`. The fact that `run` terminates the JVM instead of returning its exit\
    \ code as an integer makes that use-case impossible.\n\n\n```java\n// Problem\
    \ 1: Miss out cleanup code \nclass FileOutput {\n    boolean write(String[] s)\
    \ {\n        try {\n            output.write(s.getBytes());\n        } catch (IOException\
    \ e) {\n            System.exit(1);\n        }\n        return true;\n    }\n\
    }\n\n// Problem 2: Make code reuse difficult\nclass Action {\n    public void\
    \ run() {\n        // ...\n        // Perform tasks ...\n        // ...\n    \
    \    System.exit(0);\n    }\n    public static void main(String[] args) {\n  \
    \      new Action(args).run();\n    }\n}\n```\n\n## References\n* J. Bloch, *Effective\
    \ Java (second edition)*, p. 232. Addison-Wesley, 2008.\n* Java API Specification:\
    \ [System.exit(int)](https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/lang/System.html#exit(int)),\
    \ [Runtime.halt(int)](https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/lang/Runtime.html#halt(int)),\
    \ [Runtime.exit(int)](https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/lang/Runtime.html#exit(int)).\n\
    * Common Weakness Enumeration: [CWE-382](https://cwe.mitre.org/data/definitions/382.html).\n"
 -
  pack: codeql/java-queries#0
  relativeQueryPath: Violations of Best Practice/Undesirable Calls/DefaultToString.ql
  relativeBqrsPath: codeql/java-queries/Violations of Best Practice/Undesirable Calls/DefaultToString.bqrs
  metadata:
    name: Use of default toString()
    description: |-
      Calling the default implementation of 'toString' returns a value that is unlikely to
                    be what you expect.
    kind: problem
    problem.severity: recommendation
    precision: high
    id: java/call-to-object-tostring
    tags: |-
      reliability
             maintainability
  queryHelp: "# Use of default toString()\nIn most cases, calling the default implementation\
    \ of `toString` in `java.lang.Object` is not what is intended when a string representation\
    \ of an object is required. The output of the default `toString` method consists\
    \ of the class name of the object as well as the object's hashcode, which is usually\
    \ not what was intended.\n\nThis rule includes explicit and implicit calls to\
    \ `toString` that resolve to `java.lang.Object.toString`, particularly calls that\
    \ are used in print or log statements.\n\n\n## Recommendation\nFor objects that\
    \ are printed, define a `toString` method for the object that returns a human-readable\
    \ string.\n\n\n## Example\nThe following example shows that printing an object\
    \ makes an implicit call to `toString`. Because the class `WrongPerson` does not\
    \ have a `toString` method, `Object.toString` is called instead, which returns\
    \ the class name and the `wp` object's hashcode.\n\n\n```java\n// This class does\
    \ not have a 'toString' method, so 'java.lang.Object.toString'\n// is used when\
    \ the class is converted to a string.\nclass WrongPerson {\n\tprivate String name;\n\
    \tprivate Date birthDate; \n\t\n\tpublic WrongPerson(String name, Date birthDate)\
    \ {\n\t\tthis.name =name;\n\t\tthis.birthDate = birthDate;\n\t}\n}\n\npublic static\
    \ void main(String args[]) throws Exception {\n\tDateFormat dateFormatter = new\
    \ SimpleDateFormat(\"yyyy-MM-dd\");\n\tWrongPerson wp = new WrongPerson(\"Robert\
    \ Van Winkle\", dateFormatter.parse(\"1967-10-31\"));\n\n\t// BAD: The following\
    \ statement implicitly calls 'Object.toString', \n\t// which returns something\
    \ similar to:\n\t// WrongPerson@4383f74d\n\tSystem.out.println(wp);\n}\n```\n\
    In contrast, in the following modification of the example, the class `Person`\
    \ does have a `toString` method, which returns a string containing the arguments\
    \ that were passed when the object `p` was created.\n\n\n```java\n// This class\
    \ does have a 'toString' method, which is used when the object is\n// converted\
    \ to a string.\nclass Person {\n\tprivate String name;\n\tprivate Date birthDate;\n\
    \t\n\tpublic String toString() {\n\t\tDateFormat dateFormatter = new SimpleDateFormat(\"\
    yyyy-MM-dd\");\n\t\treturn \"(Name: \" + name + \", Birthdate: \" + dateFormatter.format(birthDate)\
    \ + \")\";\n\t}\n\t\n\tpublic Person(String name, Date birthDate) {\n\t\tthis.name\
    \ =name;\n\t\tthis.birthDate = birthDate;\n\t}\n}\n\npublic static void main(String\
    \ args[]) throws Exception {\n\tDateFormat dateFormatter = new SimpleDateFormat(\"\
    yyyy-MM-dd\");\n\tPerson p = new Person(\"Eric Arthur Blair\", dateFormatter.parse(\"\
    1903-06-25\"));\n\n\t// GOOD: The following statement implicitly calls 'Person.toString',\
    \ \n\t// which correctly returns a human-readable string:\n\t// (Name: Eric Arthur\
    \ Blair, Birthdate: 1903-06-25)\n\tSystem.out.println(p);\n}\n```\n\n## References\n\
    * J. Bloch, *Effective Java (second edition)*, Item 10. Addison-Wesley, 2008.\n\
    * Java API Specification: [Object.toString()](https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/lang/Object.html#toString()).\n"
 -
  pack: codeql/java-queries#0
  relativeQueryPath: Violations of Best Practice/Undesirable Calls/GarbageCollection.ql
  relativeBqrsPath: codeql/java-queries/Violations of Best Practice/Undesirable Calls/GarbageCollection.bqrs
  metadata:
    name: Explicit garbage collection
    description: |-
      Triggering garbage collection explicitly may either have no effect or may trigger
                    unnecessary garbage collection.
    kind: problem
    problem.severity: recommendation
    precision: low
    id: java/garbage-collection
    tags: |-
      reliability
             maintainability
  queryHelp: "# Explicit garbage collection\nYou should avoid making calls to explicit\
    \ garbage collection methods (`Runtime.gc` and `System.gc`). The calls are not\
    \ guaranteed to trigger garbage collection, and they may also trigger unnecessary\
    \ garbage collection passes that lead to decreased performance.\n\n\n## Recommendation\n\
    It is better to let the Java Virtual Machine (JVM) handle garbage collection.\
    \ If it becomes necessary to control how the JVM handles memory, it is better\
    \ to use the JVM's memory and garbage collection options (for example, `-Xmx`,\
    \ `-XX:NewRatio`, `-XX:Use*GC`) than to trigger garbage collection in the application.\n\
    \nThe memory management classes that are used by Real-Time Java are an exception\
    \ to this rule, because they are designed to handle garbage collection differently\
    \ from the JVM default.\n\n\n## Example\nThe following example shows code that\
    \ makes connection requests, and tries to trigger garbage collection after it\
    \ has processed each request.\n\n\n```java\nclass RequestHandler extends Thread\
    \ {\n\tprivate boolean isRunning;\n\tprivate Connection conn = new Connection();\n\
    \t\n\tpublic void run() {\n\t\twhile (isRunning) {\n\t\t\tRequest req = conn.getRequest();\n\
    \t\t\t// Process the request ...\n\t\t\t\n\t\t\tSystem.gc();  // This call may\
    \ cause a garbage collection after each request.\n\t\t\t\t\t\t  // This will likely\
    \ reduce the throughput of the RequestHandler\n\t\t\t\t\t\t  // because the JVM\
    \ spends time on unnecessary garbage collection passes.\n\t\t}\n\t}\n}\n```\n\
    It is better to remove the call to `System.gc` and rely on the JVM to dispose\
    \ of the connection.\n\n\n## References\n* Java API Specification: [System.gc()](https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/lang/System.html#gc()).\n\
    * Java Documentation: [HotSpot Virtual Machine Garbage Collection Tuning Guide](https://docs.oracle.com/en/java/javase/11/gctuning/index.html).\n"
 -
  pack: codeql/java-queries#0
  relativeQueryPath: Violations of Best Practice/Undesirable Calls/NextFromIterator.ql
  relativeBqrsPath: codeql/java-queries/Violations of Best Practice/Undesirable Calls/NextFromIterator.bqrs
  metadata:
    name: Next in hasNext implementation
    description: |-
      Iterator implementations whose 'hasNext' method calls 'next' are most likely
                    incorrect.
    kind: problem
    problem.severity: warning
    precision: medium
    id: java/iterator-hasnext-calls-next
    tags: |-
      reliability
             correctness
  queryHelp: "# Next in hasNext implementation\nIterator implementations with a `hasNext`\
    \ method that calls the `next` method are most likely incorrect. This is because\
    \ `next` changes the iterator's position to the next element and returns that\
    \ element, which is unlikely to be desirable in the implementation of `hasNext`.\n\
    \n\n## Recommendation\nEnsure that any calls to `next` from within `hasNext` are\
    \ legitimate. The `hasNext` method should indicate whether there are further elements\
    \ remaining in the iteration without changing the iterator's state by calling\
    \ `next`.\n\n\n## Example\nIn the following example, which outputs the contents\
    \ of a string, `hasNext` calls `next`, which has the effect of changing the iterator's\
    \ position. Given that `main` also calls `next` when it outputs an item, some\
    \ items are skipped and only half the items are output.\n\n\n```java\npublic class\
    \ NextFromIterator implements Iterator<String> {\n\tprivate int position = -1;\n\
    \tprivate List<String> list = new ArrayList<String>() {{\n\t\tadd(\"alpha\");\
    \ add(\"bravo\"); add(\"charlie\"); add(\"delta\"); add(\"echo\"); add(\"foxtrot\"\
    );\n\t}};\n\t\n\tpublic boolean hasNext() {\n\t\treturn next() != null;  // BAD:\
    \ Call to 'next'\n\t}\n\t\n\tpublic String next() {\n\t\tposition++;\n\t\treturn\
    \ position < list.size() ? list.get(position) : null;\n\t}\n\n\tpublic void remove()\
    \ {\n\t\t// ...\n\t}\n\t\n\tpublic static void main(String[] args) {\n\t\tNextFromIterator\
    \ x = new NextFromIterator();\n\t\twhile(x.hasNext()) {\n\t\t\tSystem.out.println(x.next());\n\
    \t\t}\n\t}\n}\n```\nInstead, the implementation of `hasNext` should use another\
    \ way of indicating whether there are further elements in the string without calling\
    \ `next`. For example, `hasNext` could check the underlying array directly to\
    \ see if there is an element at the next position.\n\n\n## References\n* Java\
    \ API Specification: [Iterator.hasNext()](https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/util/Iterator.html#hasNext()),\
    \ [Iterator.next()](https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/util/Iterator.html#next()).\n"
 -
  pack: codeql/java-queries#0
  relativeQueryPath: Violations of Best Practice/Undesirable Calls/PrintLnArray.ql
  relativeBqrsPath: codeql/java-queries/Violations of Best Practice/Undesirable Calls/PrintLnArray.bqrs
  metadata:
    name: Implicit conversion from array to string
    description: |-
      Directly printing an array, without first converting the array to a string,
                    produces unreadable results.
    kind: problem
    problem.severity: recommendation
    precision: very-high
    id: java/print-array
    tags: maintainability
  queryHelp: "# Implicit conversion from array to string\nPrinting an array is likely\
    \ to produce unintended results. That is, the result does not contain the contents\
    \ of the array. This is because the array is implicitly converted to a `String`\
    \ using `Object.toString`, which just returns the following value:\n\n` getClass().getName()\
    \ + '@' + Integer.toHexString(hashCode()) `\n\n\n## Recommendation\nWhen converting\
    \ an array to a readable string, use `Arrays.toString` for one-dimensional arrays,\
    \ or `Arrays.deepToString` for multi-dimensional arrays. These functions iterate\
    \ over the contents of the array and produce human-readable output.\n\n\n## Example\n\
    In the following example, the contents of the array `words` are printed out only\
    \ if `Arrays.toString` is called on the array first. Similarly, the contents of\
    \ the multi-dimensional array `wordMatrix` are printed out only if `Arrays.deepToString`\
    \ is called on the array first.\n\n\n```java\npublic static void main(String args[])\
    \ {\n\tString[] words = {\"Who\", \"is\", \"John\", \"Galt\"};\n\tString[][] wordMatrix\
    \ = {{\"There\", \"is\"}, {\"no\", \"spoon\"}};\n\t\n\t// BAD: This implicitly\
    \ uses 'Object.toString' to convert the contents\n\t// of 'words[]', and prints\
    \ out something similar to:\n\t// [Ljava.lang.String;@459189e1\n\tSystem.out.println(words);\n\
    \t\n\t// GOOD: 'Arrays.toString' calls 'toString' on\n\t// each of the array's\
    \ elements. The statement prints out:\n\t// [Who, is, John, Galt]\n\tSystem.out.println(Arrays.toString(words));\n\
    \t\n\t// ALMOST RIGHT: This calls 'toString' on each of the multi-dimensional\
    \ \n\t// array's elements. However, because the elements are arrays, the statement\n\
    \t// prints out something similar to:\n\t// [[Ljava.lang.String;@55f33675, [Ljava.lang.String;@527c6768]]\n\
    \tSystem.out.println(Arrays.toString(wordMatrix));\n\t\n\t// GOOD: This properly\
    \ prints out the contents of the multi-dimensional array:\n\t// [[There, is],\
    \ [no, spoon]]\n\tSystem.out.println(Arrays.deepToString(wordMatrix));\n}\n```\n\
    \n## References\n* Java API Specification: [Arrays.toString()](https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/util/Arrays.html#toString(java.lang.Object[])),\
    \ [Arrays.deepToString()](https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/util/Arrays.html#deepToString(java.lang.Object[])),\
    \ [Object.toString()](https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/lang/Object.html#toString()).\n"
 -
  pack: codeql/java-queries#0
  relativeQueryPath: Violations of Best Practice/legacy/AutoBoxing.ql
  relativeBqrsPath: codeql/java-queries/Violations of Best Practice/legacy/AutoBoxing.bqrs
  metadata:
    name: Auto boxing or unboxing
    description: |-
      Implicit boxing or unboxing of primitive types, such as 'int' and 'double',
                    may cause confusion and subtle performance problems.
    kind: problem
    problem.severity: warning
    precision: low
    id: java/implicit-auto-boxing
    tags: efficiency
  queryHelp: "# Auto boxing or unboxing\nFor each primitive type, such as `int` or\
    \ `double`, there is a corresponding *boxed* reference type, such as `Integer`\
    \ or `Double`. These boxed versions differ from their primitive equivalents because\
    \ they can hold an undefined `null` element in addition to numeric (or other)\
    \ values, and there can be more than one instance of a boxed type representing\
    \ the same value.\n\nIn Java 5 and later, automated boxing and unboxing conversions\
    \ have been added to the language. Although these automated conversions reduce\
    \ the verbosity of the code, they can hide potential problems. Such problems include\
    \ performance issues because of unnecessary object creation, and confusion of\
    \ boxed types with their primitive equivalents.\n\n\n## Recommendation\nGenerally,\
    \ you should use primitive types (boolean, byte, char, short, int, long, float,\
    \ double) in preference to boxed types (Boolean, Byte, Character, Short, Integer,\
    \ Long, Float, Double), whenever there is a choice. Exceptions are when a primitive\
    \ value is used in collections and other parameterized types, or when a `null`\
    \ value is explicitly used to represent an undefined value.\n\nWhere they cannot\
    \ be avoided, perform boxing and unboxing conversions explicitly to avoid possible\
    \ confusion of boxed types and their primitive equivalents. In cases where boxing\
    \ conversions cause performance issues, use primitive types instead.\n\n\n## Example\n\
    In the following example, declaring the variable `sum` to have boxed type `Long`\
    \ causes it to be unboxed and reboxed during execution of the statement inside\
    \ the loop.\n\n\n```java\nLong sum = 0L; \nfor (long k = 0; k < Integer.MAX_VALUE;\
    \ k++) {\n\tsum += k;  // AVOID: Inefficient unboxing and reboxing of 'sum'\n\
    }\n```\nTo avoid this inefficiency, declare `sum` to have primitive type `long`\
    \ instead.\n\n\n## References\n* J. Bloch, *Effective Java (second edition)*,\
    \ Item 49. Addison-Wesley, 2008.\n* Help - Eclipse Platform: [Java Compiler Errors/Warnings\
    \ Preferences](https://help.eclipse.org/2020-12/advanced/content.jsp?topic=/org.eclipse.jdt.doc.user/reference/preferences/java/compiler/ref-preferences-errors-warnings.htm).\n\
    * Java Language Specification: [5.1.7 Boxing Conversion](https://docs.oracle.com/javase/specs/jls/se11/html/jls-5.html#jls-5.1.7).\n\
    * Java SE Documentation: [Autoboxing](https://docs.oracle.com/javase/8/docs/technotes/guides/language/autoboxing.html).\n\
    * The Java Tutorials: [Autoboxing and Unboxing](https://docs.oracle.com/javase/tutorial/java/data/autoboxing.html).\n"
 -
  pack: codeql/java-queries#0
  relativeQueryPath: Violations of Best Practice/legacy/FinallyMayNotComplete.ql
  relativeBqrsPath: codeql/java-queries/Violations of Best Practice/legacy/FinallyMayNotComplete.bqrs
  metadata:
    name: Finally block may not complete normally
    description: |-
      A 'finally' block that runs because an exception has been thrown, and that does not
                    complete normally, causes the exception to disappear silently.
    kind: problem
    problem.severity: warning
    precision: low
    id: java/abnormal-finally-completion
    tags: |-
      reliability
             correctness
             exceptions
             external/cwe/cwe-584
  queryHelp: |
    # Finally block may not complete normally
    A `finally` block that does not complete normally suppresses any exceptions that may have been thrown in the corresponding `try` block. This can happen if the `finally` block contains any `return` or `throw` statements, or if it contains any `break` or `continue` statements whose jump target lies outside of the `finally` block.


    ## Recommendation
    To avoid suppressing exceptions that are thrown in a `try` block, design the code so that the corresponding `finally` block always completes normally. Remove any of the following statements that may cause it to terminate abnormally:

    * `return`
    * `throw`
    * `break`
    * `continue`

    ## References
    * J. Bloch and N. Gafter, *Java Puzzlers: Traps, Pitfalls, and Corner Cases*, Puzzle 36. Addison-Wesley, 2005.
    * Java Language Specification: [Execution of try-finally and try-catch-finally](https://docs.oracle.com/javase/specs/jls/se11/html/jls-14.html#jls-14.20.2).
    * Help - Eclipse Platform: [Java Compiler Errors/Warnings Preferences](https://help.eclipse.org/2020-12/advanced/content.jsp?topic=/org.eclipse.jdt.doc.user/reference/preferences/java/compiler/ref-preferences-errors-warnings.htm).
    * Common Weakness Enumeration: [CWE-584](https://cwe.mitre.org/data/definitions/584.html).
 -
  pack: codeql/java-queries#0
  relativeQueryPath: Violations of Best Practice/legacy/InexactVarArg.ql
  relativeBqrsPath: codeql/java-queries/Violations of Best Practice/legacy/InexactVarArg.bqrs
  metadata:
    name: Inexact type match for varargs argument
    description: |-
      Calling a varargs method where it is unclear whether the arguments
                    should be interpreted as a list of arguments or as a single argument, may lead
                    to compiler-dependent behavior.
    kind: problem
    problem.severity: warning
    precision: low
    id: java/inexact-varargs
    tags: reliability
  queryHelp: "# Inexact type match for varargs argument\nA variable arity method,\
    \ commonly known as a varargs method, may be called with different numbers of\
    \ arguments. For example, the method `sum(int...&nbsp;values)` may be called in\
    \ all of the following ways:\n\n* `sum()`\n* `sum(1)`\n* `sum(1,2,3)`\n* `sum(new\
    \ int[] { 1, 2, 3 })`\nWhen a method `foo(T...&nbsp;x)` is called with an argument\
    \ that is neither `T` nor `T[]`, but the argument can be cast as either, the choice\
    \ of which type the argument is cast as is compiler-dependent.\n\n\n## Recommendation\n\
    When a variable arity method, for example `m(T... ts)`, is called with a single\
    \ argument (for example `m(arg)`), the type of the argument should be either `T`\
    \ or `T[]` (insert a cast if necessary).\n\n\n## Example\nIn the following example,\
    \ the calls to `length` do not pass an argument of the same type as the parameter\
    \ of `length`, which is `Object` or an array of `Object`. Therefore, when the\
    \ program is compiled with javac, the output is:\n\n```java\n\n3\n2\n\n```\nWhen\
    \ the program is compiled with a different compiler, for example the default compiler\
    \ for some versions of Eclipse, the output may be:\n\n```java\n\n3\n1\n\n```\n\
    \n```java\nclass InexactVarArg\n{\n\tprivate static void length(Object... objects)\
    \ {\n\t\tSystem.out.println(objects.length);\n\t}\n\n\tpublic static void main(String[]\
    \ args) {\n\t\tString[] words = { \"apple\", \"banana\", \"cherry\" };\n\t\tString[][]\
    \ lists = { words, words };\n\t\tlength(words);\t// avoid: Argument does not clarify\n\
    \t\tlength(lists);\t// which parameter type is used.\n\t}\n}\n\n```\nTo avoid\
    \ this compiler-dependent behavior, `length(words)` should be replaced by either\
    \ of the following:\n\n* `length((Object) words)`\n* `length((Object[]) words)`\n\
    Similarly, `length(lists)` should be replaced by one of the following:\n\n* `length((Object)\
    \ lists)`\n* `length((Object[]) lists)`\n\n## References\n* Help - Eclipse Platform:\
    \ [Java Compiler Errors/Warnings Preferences](https://help.eclipse.org/2020-12/advanced/content.jsp?topic=/org.eclipse.jdt.doc.user/reference/preferences/java/compiler/ref-preferences-errors-warnings.htm).\n\
    * Java Language Specification: [8.4.1 Formal Parameters](https://docs.oracle.com/javase/specs/jls/se11/html/jls-8.html#jls-8.4.1),\
    \ [15.12.4.2 Evaluate Arguments](https://docs.oracle.com/javase/specs/jls/se11/html/jls-15.html#jls-15.12.4.2).\n"
 -
  pack: codeql/java-queries#0
  relativeQueryPath: Violations of Best Practice/legacy/ParameterAssignment.ql
  relativeBqrsPath: codeql/java-queries/Violations of Best Practice/legacy/ParameterAssignment.bqrs
  metadata:
    name: Assignment to parameter
    description: |-
      Changing a parameter's value in a method or constructor may decrease code
                    readability.
    kind: problem
    problem.severity: recommendation
    precision: low
    id: java/assignment-to-parameter
    tags: maintainability
  queryHelp: "# Assignment to parameter\nProgrammers usually assume that the value\
    \ of a parameter is the value that was passed in to the method or constructor.\
    \ Assigning a different value to a parameter in a method or constructor invalidates\
    \ that assumption.\n\n\n## Recommendation\nAvoid assignment to parameters by doing\
    \ one of the following:\n\n* Introduce a local variable and assign to that instead.\n\
    * Use an expression directly rather than assigning it to a parameter.\n\n## Example\n\
    In the following example, the first method shows assignment to the parameter `miles`.\
    \ The second method shows how to avoid this by using the expression `miles * KM_PER_MILE`.\
    \ The third method shows how to avoid the assignment by declaring a local variable\
    \ `kilometres` and assigning to that.\n\n\n```java\nfinal private static double\
    \ KM_PER_MILE = 1.609344;\n\n// AVOID: Example that assigns to a parameter\npublic\
    \ double milesToKM(double miles) {\n\tmiles *= KM_PER_MILE;\n\treturn miles;\n\
    }\n\n// GOOD: Example of using an expression instead\npublic double milesToKM(double\
    \ miles) {\n\treturn miles * KM_PER_MILE;\n}\n\n// GOOD: Example of using a local\
    \ variable\npublic double milesToKM(double miles) {\n\tdouble kilometres = miles\
    \ * KM_PER_MILE;\n\treturn kilometres;\n}\n\n```\n\n## References\n* Help - Eclipse\
    \ Platform: [Java Compiler Errors/Warnings Preferences](https://help.eclipse.org/2020-12/advanced/content.jsp?topic=/org.eclipse.jdt.doc.user/reference/preferences/java/compiler/ref-preferences-errors-warnings.htm).\n\
    * Java Basics: [Methods 4 - Local variables](https://web.archive.org/web/20200223080939/http://leepoint.net/JavaBasics/methods/methods-22-local-variables.html).\n"
 -
  pack: codeql/java-queries#0
  relativeQueryPath: Violations of Best Practice/legacy/UnnecessaryCast.ql
  relativeBqrsPath: codeql/java-queries/Violations of Best Practice/legacy/UnnecessaryCast.bqrs
  metadata:
    name: Unnecessary cast
    description: Casting an object to its own type is unnecessary.
    kind: problem
    problem.severity: recommendation
    precision: low
    id: java/redundant-cast
    tags: |-
      maintainability
             external/cwe/cwe-561
  queryHelp: |
    # Unnecessary cast
    A cast is unnecessary if the type of the operand is already the same as the type that is being cast to.


    ## Recommendation
    Avoid including unnecessary casts.


    ## Example
    In the following example, casting `i` to an `Integer` is not necessary. It is already an `Integer`.


    ```java
    public class UnnecessaryCast {
        public static void main(String[] args) {
            Integer i = 23;
            Integer j = (Integer)i;  // AVOID: Redundant cast
        }
    }
    ```
    To fix the code, delete `(Integer)` on the right-hand side of the assignment on line 4.


    ## References
    * Help - Eclipse Platform: [Java Compiler Errors/Warnings Preferences](https://help.eclipse.org/2020-12/advanced/content.jsp?topic=/org.eclipse.jdt.doc.user/reference/preferences/java/compiler/ref-preferences-errors-warnings.htm).
    * Common Weakness Enumeration: [CWE-561](https://cwe.mitre.org/data/definitions/561.html).
 -
  pack: codeql/java-queries#0
  relativeQueryPath: Violations of Best Practice/legacy/UnnecessaryImport.ql
  relativeBqrsPath: codeql/java-queries/Violations of Best Practice/legacy/UnnecessaryImport.bqrs
  metadata:
    name: Unnecessary import
    description: |-
      A redundant 'import' statement introduces unnecessary and undesirable
                    dependencies.
    kind: problem
    problem.severity: recommendation
    precision: low
    id: java/unused-import
    tags: |-
      maintainability
             external/cwe/cwe-561
  queryHelp: |
    # Unnecessary import
    An `import` statement that is not necessary (because no part of the file that it is in uses any imported type) should be avoided. Although importing too many types does not affect performance, redundant `import` statements introduce unnecessary and undesirable dependencies in the code. If an imported type is renamed or deleted, the source code cannot be compiled because the `import` statement cannot be resolved.

    Unnecessary `import` statements are often an indication of incomplete refactoring.


    ## Recommendation
    Avoid including an `import` statement that is not needed. Many modern IDEs have automated support for doing this, typically under the name 'Organize imports'. This sorts the `import` statements and removes any that are not used, and it is good practice to run such a command before every commit.


    ## References
    * Help - Eclipse Platform: [Java Compiler Errors/Warnings Preferences](https://help.eclipse.org/2020-12/advanced/content.jsp?topic=/org.eclipse.jdt.doc.user/reference/preferences/java/compiler/ref-preferences-errors-warnings.htm).
    * Common Weakness Enumeration: [CWE-561](https://cwe.mitre.org/data/definitions/561.html).
 -
  pack: codeql/java-queries#0
  relativeQueryPath: definitions.ql
  relativeBqrsPath: codeql/java-queries/definitions.bqrs
  metadata:
    name: Jump-to-definition links
    description: |-
      Generates use-definition pairs that provide the data
                    for jump-to-definition in the code viewer.
    kind: definitions
    id: java/jump-to-definition
 -
  pack: codeql/java-queries#0
  relativeQueryPath: experimental/Security/CWE/CWE-016/InsecureSpringActuatorConfig.ql
  relativeBqrsPath: codeql/java-queries/experimental/Security/CWE/CWE-016/InsecureSpringActuatorConfig.bqrs
  metadata:
    name: Insecure Spring Boot Actuator Configuration
    description: |-
      Exposed Spring Boot Actuator through configuration files without declarative or procedural
                    security enforcement leads to information leak or even remote code execution.
    kind: problem
    problem.severity: error
    precision: high
    id: java/insecure-spring-actuator-config
    tags: |-
      security
             experimental
             external/cwe/cwe-016
  queryHelp: "# Insecure Spring Boot Actuator Configuration\nSpring Boot is a popular\
    \ framework that facilitates the development of stand-alone applications and micro\
    \ services. Spring Boot Actuator helps to expose production-ready support features\
    \ against Spring Boot applications.\n\nEndpoints of Spring Boot Actuator allow\
    \ to monitor and interact with a Spring Boot application. Exposing unprotected\
    \ actuator endpoints through configuration files can lead to information disclosure\
    \ or even remote code execution vulnerability.\n\nRather than programmatically\
    \ permitting endpoint requests or enforcing access control, frequently developers\
    \ simply leave management endpoints publicly accessible in the application configuration\
    \ file `application.properties` without enforcing access control through Spring\
    \ Security.\n\n\n## Recommendation\nDeclare the Spring Boot Starter Security module\
    \ in XML configuration or programmatically enforce security checks on management\
    \ endpoints using Spring Security. Otherwise accessing management endpoints on\
    \ a different HTTP port other than the port that the web application is listening\
    \ on also helps to improve the security.\n\n\n## Example\nThe following examples\
    \ show both 'BAD' and 'GOOD' configurations. In the 'BAD' configuration, no security\
    \ module is declared and sensitive management endpoints are exposed. In the 'GOOD'\
    \ configuration, security is enforced and only endpoints requiring exposure are\
    \ exposed.\n\n\n```xml\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<project xmlns=\"\
    http://maven.apache.org/POM/4.0.0\"\n         xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\
    \n         xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\"\
    >\n    <modelVersion>4.0.0</modelVersion>\n\n    <groupId>spring-boot-actuator-app</groupId>\n\
    \    <artifactId>spring-boot-actuator-app</artifactId>\n    <version>1.0-SNAPSHOT</version>\n\
    \n    <properties>\n        <project.build.sourceEncoding>UTF-8</project.build.sourceEncoding>\n\
    \        <maven.compiler.source>1.8</maven.compiler.source>\n        <maven.compiler.target>1.8</maven.compiler.target>\n\
    \    </properties>\n\n    <parent>\n        <groupId>org.springframework.boot</groupId>\n\
    \        <artifactId>spring-boot-starter-parent</artifactId>\n        <version>2.3.8.RELEASE</version>\n\
    \        <relativePath/>\n    </parent>\n\n    <dependencies>\n        <dependency>\n\
    \            <groupId>org.springframework.boot</groupId>\n            <artifactId>spring-boot-starter-web</artifactId>\n\
    \        </dependency>\n        <dependency>\n            <groupId>org.springframework.boot</groupId>\n\
    \            <artifactId>spring-boot-starter-actuator</artifactId>\n        </dependency>\n\
    \        <dependency>\n            <groupId>org.springframework.boot</groupId>\n\
    \            <artifactId>spring-boot-devtools</artifactId>\n        </dependency>\n\
    \n        <!-- GOOD: Enable Spring Security -->\n        <dependency>\n      \
    \      <groupId>org.springframework.boot</groupId>\n            <artifactId>spring-boot-starter-security</artifactId>\n\
    \        </dependency>\n\n        <dependency>\n            <groupId>org.springframework.boot</groupId>\n\
    \            <artifactId>spring-boot-test</artifactId>\n        </dependency>\n\
    \    </dependencies>\n\n</project>\n```\n\n```xml\n<?xml version=\"1.0\" encoding=\"\
    UTF-8\"?>\n<project xmlns=\"http://maven.apache.org/POM/4.0.0\"\n         xmlns:xsi=\"\
    http://www.w3.org/2001/XMLSchema-instance\"\n         xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0\
    \ http://maven.apache.org/xsd/maven-4.0.0.xsd\">\n    <modelVersion>4.0.0</modelVersion>\n\
    \n    <groupId>spring-boot-actuator-app</groupId>\n    <artifactId>spring-boot-actuator-app</artifactId>\n\
    \    <version>1.0-SNAPSHOT</version>\n\n    <properties>\n        <project.build.sourceEncoding>UTF-8</project.build.sourceEncoding>\n\
    \        <maven.compiler.source>1.8</maven.compiler.source>\n        <maven.compiler.target>1.8</maven.compiler.target>\n\
    \    </properties>\n\n    <parent>\n        <groupId>org.springframework.boot</groupId>\n\
    \        <artifactId>spring-boot-starter-parent</artifactId>\n        <version>2.3.8.RELEASE</version>\n\
    \        <relativePath/>\n    </parent>\n\n    <dependencies>\n        <dependency>\n\
    \            <groupId>org.springframework.boot</groupId>\n            <artifactId>spring-boot-starter-web</artifactId>\n\
    \        </dependency>\n        <dependency>\n            <groupId>org.springframework.boot</groupId>\n\
    \            <artifactId>spring-boot-starter-actuator</artifactId>\n        </dependency>\n\
    \        <dependency>\n            <groupId>org.springframework.boot</groupId>\n\
    \            <artifactId>spring-boot-devtools</artifactId>\n        </dependency>\n\
    \n        <!-- BAD: No Spring Security enabled -->\n        <!-- dependency>\n\
    \            <groupId>org.springframework.boot</groupId>\n            <artifactId>spring-boot-starter-security</artifactId>\n\
    \        </dependency -->\n\n        <dependency>\n            <groupId>org.springframework.boot</groupId>\n\
    \            <artifactId>spring-boot-test</artifactId>\n        </dependency>\n\
    \    </dependencies>\n\n</project>\n```\n\n```none\n#management.endpoints.web.base-path=/admin\n\
    \n\n#### BAD: All management endpoints are accessible #### \n# vulnerable configuration\
    \ (spring boot 1.0 - 1.4): exposes actuators by default\n\n# vulnerable configuration\
    \ (spring boot 1.5+): requires value false to expose sensitive actuators\nmanagement.security.enabled=false\n\
    \n# vulnerable configuration (spring boot 2+): exposes health and info only by\
    \ default, here overridden to expose everything\nmanagement.endpoints.web.exposure.include=*\n\
    \n\n#### GOOD: All management endpoints have access control #### \n# safe configuration\
    \ (spring boot 1.0 - 1.4): exposes actuators by default\nmanagement.security.enabled=true\n\
    \n# safe configuration (spring boot 1.5+): requires value false to expose sensitive\
    \ actuators\nmanagement.security.enabled=true\n\n# safe configuration (spring\
    \ boot 2+): exposes health and info only by default, here overridden to expose\
    \ one additional endpoint which we assume is intentional and safe.\nmanagement.endpoints.web.exposure.include=beans,info,health\n\
    \n```\n\n## References\n* Spring Boot documentation: [Spring Boot Actuator: Production-ready\
    \ Features](https://docs.spring.io/spring-boot/docs/current/reference/html/production-ready-features.html)\n\
    * VERACODE Blog: [Exploiting Spring Boot Actuators](https://www.veracode.com/blog/research/exploiting-spring-boot-actuators)\n\
    * HackerOne Report: [Spring Actuator endpoints publicly available, leading to\
    \ account takeover](https://hackerone.com/reports/862589)\n* Common Weakness Enumeration:\
    \ [CWE-16](https://cwe.mitre.org/data/definitions/16.html).\n"
 -
  pack: codeql/java-queries#0
  relativeQueryPath: experimental/Security/CWE/CWE-016/SpringBootActuators.ql
  relativeBqrsPath: codeql/java-queries/experimental/Security/CWE/CWE-016/SpringBootActuators.bqrs
  metadata:
    name: Exposed Spring Boot actuators
    description: |-
      Exposing Spring Boot actuators may lead to internal application's information leak
                    or even to remote code execution.
    kind: problem
    problem.severity: error
    precision: high
    id: java/spring-boot-exposed-actuators
    tags: |-
      security
             experimental
             external/cwe/cwe-16
  queryHelp: |
    # Exposed Spring Boot actuators
    Spring Boot includes a number of additional features called actuators that let you monitor and interact with your web application. Exposing unprotected actuator endpoints via JXM or HTTP can, however, lead to information disclosure or even to remote code execution vulnerability.


    ## Recommendation
    Since actuator endpoints may contain sensitive information, careful consideration should be given about when to expose them. You should take care to secure exposed HTTP endpoints in the same way that you would any other sensitive URL. If Spring Security is present, endpoints are secured by default using Spring Securitys content-negotiation strategy. If you wish to configure custom security for HTTP endpoints, for example, only allow users with a certain role to access them, Spring Boot provides some convenient `RequestMatcher` objects that can be used in combination with Spring Security.


    ## Example
    In the first example, the custom security configuration allows unauthenticated access to all actuator endpoints. This may lead to sensitive information disclosure and should be avoided.

    In the second example, only users with `ENDPOINT_ADMIN` role are allowed to access the actuator endpoints.


    ```java
    @Configuration(proxyBeanMethods = false)
    public class SpringBootActuators extends WebSecurityConfigurerAdapter {

      @Override
      protected void configure(HttpSecurity http) throws Exception {
        // BAD: Unauthenticated access to Spring Boot actuator endpoints is allowed
        http.requestMatcher(EndpointRequest.toAnyEndpoint()).authorizeRequests((requests) ->
            requests.anyRequest().permitAll());
      }
    }

    @Configuration(proxyBeanMethods = false)
    public class ActuatorSecurity extends WebSecurityConfigurerAdapter {

      @Override
      protected void configure(HttpSecurity http) throws Exception {
        // GOOD: only users with ENDPOINT_ADMIN role are allowed to access the actuator endpoints
        http.requestMatcher(EndpointRequest.toAnyEndpoint()).authorizeRequests((requests) ->
            requests.anyRequest().hasRole("ENDPOINT_ADMIN"));
        http.httpBasic();
      }
    }
    ```

    ## References
    * Spring Boot documentation: [Actuators](https://docs.spring.io/spring-boot/docs/current/reference/html/production-ready-features.html).
    * [Exploiting Spring Boot Actuators](https://www.veracode.com/blog/research/exploiting-spring-boot-actuators)
    * Common Weakness Enumeration: [CWE-16](https://cwe.mitre.org/data/definitions/16.html).
 -
  pack: codeql/java-queries#0
  relativeQueryPath: experimental/Security/CWE/CWE-020/Log4jJndiInjection.ql
  relativeBqrsPath: codeql/java-queries/experimental/Security/CWE/CWE-020/Log4jJndiInjection.bqrs
  metadata:
    name: Potential Log4J LDAP JNDI injection (CVE-2021-44228)
    description: |-
      Building Log4j log entries from user-controlled data may allow
                    attackers to inject malicious code through JNDI lookups when
                    using Log4J versions vulnerable to CVE-2021-44228.
    kind: path-problem
    problem.severity: error
    precision: high
    id: java/log4j-injection
    tags: |-
      security
             experimental
             external/cwe/cwe-020
             external/cwe/cwe-074
             external/cwe/cwe-400
             external/cwe/cwe-502
  queryHelp: |
    # Potential Log4J LDAP JNDI injection (CVE-2021-44228)
    This query flags up situations in which untrusted user data is included in Log4j messages. If an application uses a Log4j version prior to 2.15.0, using untrusted user data in log messages will make an application vulnerable to remote code execution through Log4j's LDAP JNDI parser (CVE-2021-44228).

    As per Apache's Log4j security guide: Apache Log4j2 &lt;=2.14.1 JNDI features used in configuration, log messages, and parameters do not protect against attacker controlled LDAP and other JNDI related endpoints. An attacker who can control log messages or log message parameters can execute arbitrary code loaded from LDAP servers when message lookup substitution is enabled. From Log4j 2.15.0, this behavior has been disabled by default. Note that this query will not try to determine which version of Log4j is used.


    ## Recommendation
    This issue was remediated in Log4j v2.15.0. The Apache Logging Services team provides the following mitigation advice:

    In previous releases (&gt;=2.10) this behavior can be mitigated by setting system property `log4j2.formatMsgNoLookups` to `true` or by removing the `JndiLookup` class from the classpath (example: `zip -q -d log4j-core-*.jar org/apache/logging/log4j/core/lookup/JndiLookup.class`).

    You can manually check for use of affected versions of Log4j by searching your project repository for Log4j use, which is often in a pom.xml file.

    Where possible, upgrade to Log4j version 2.15.0. If you are using Log4j v1 there is a migration guide available.

    Please note that Log4j v1 is End Of Life (EOL) and will not receive patches for this issue. Log4j v1 is also vulnerable to other RCE vectors and we recommend you migrate to Log4j 2.15.0 where possible.

    If upgrading is not possible, then ensure the -Dlog4j2.formatMsgNoLookups=true system property is set on both client- and server-side components.


    ## Example
    In this example, a username, provided by the user, is logged using `logger.warn` (from `org.apache.logging.log4j.Logger`). If a malicious user provides `${jndi:ldap://127.0.0.1:1389/a}` as a username parameter, Log4j will make a JNDI lookup on the specified LDAP server and potentially load arbitrary code.


    ```java
    package com.example.restservice;

    import org.apache.commons.logging.log4j.Logger;
    import org.springframework.web.bind.annotation.GetMapping;
    import org.springframework.web.bind.annotation.RequestParam;
    import org.springframework.web.bind.annotation.RestController;

    @RestController
    public class Log4jJndiInjection {

        private final Logger logger = LogManager.getLogger();

        @GetMapping("/bad")
        public String bad(@RequestParam(value = "username", defaultValue = "name") String username) {
            logger.warn("User:'{}'", username);
            return username;
        }
    }

    ```

    ## References
    * GitHub Advisory Database: [Remote code injection in Log4j](https://github.com/advisories/GHSA-jfh8-c2jp-5v3q).
    * Common Weakness Enumeration: [CWE-20](https://cwe.mitre.org/data/definitions/20.html).
    * Common Weakness Enumeration: [CWE-74](https://cwe.mitre.org/data/definitions/74.html).
    * Common Weakness Enumeration: [CWE-400](https://cwe.mitre.org/data/definitions/400.html).
    * Common Weakness Enumeration: [CWE-502](https://cwe.mitre.org/data/definitions/502.html).
 -
  pack: codeql/java-queries#0
  relativeQueryPath: experimental/Security/CWE/CWE-036/OpenStream.ql
  relativeBqrsPath: codeql/java-queries/experimental/Security/CWE/CWE-036/OpenStream.bqrs
  metadata:
    name: openStream called on URLs created from remote source
    description: |-
      Calling openStream on URLs created from remote source
                    can lead to local file disclosure.
    kind: path-problem
    problem.severity: warning
    precision: medium
    id: java/openstream-called-on-tainted-url
    tags: |-
      security
             experimental
             external/cwe/cwe-036
  queryHelp: |
    # openStream called on URLs created from remote source
    Calling `openStream` on URLs created from remote source can lead to local file disclosure.

    If `openStream` is called on a `java.net.URL`, that was created from a remote source, an attacker can try to pass absolute URLs starting with `file://` or `jar://` to access local resources in addition to remote ones.


    ## Recommendation
    When you construct a URL using `java.net.URL` from a remote source, don't call `openStream` on it. Instead, use an HTTP Client to fetch the URL and access its content. You should also validate the URL to check that it uses the correct protocol and host combination.


    ## Example
    The following example shows an URL that is constructed from a request parameter. Afterwards `openStream` is called on the URL, potentially leading to a local file access.


    ```java
    public class TestServlet extends HttpServlet {
        protected void doGet(HttpServletRequest request, HttpServletResponse response)
        throws ServletException, IOException {
            // BAD: a URL from a remote source is opened with URL#openStream()
            URL url = new URL(request.getParameter("url"));
            InputStream inputStream = new URL(url).openStream();
        }
    }

    ```

    ## References
    * Java API Specification: [ Class URL](https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/net/URL.html).
    * Common Weakness Enumeration: [CWE-36](https://cwe.mitre.org/data/definitions/36.html).
 -
  pack: codeql/java-queries#0
  relativeQueryPath: experimental/Security/CWE/CWE-073/FilePathInjection.ql
  relativeBqrsPath: codeql/java-queries/experimental/Security/CWE/CWE-073/FilePathInjection.bqrs
  metadata:
    name: File Path Injection
    description: |-
      Loading files based on unvalidated user-input may cause file information disclosure
                    and uploading files with unvalidated file types to an arbitrary directory may lead to
                    Remote Command Execution (RCE).
    kind: path-problem
    problem.severity: error
    precision: high
    id: java/file-path-injection
    tags: |-
      security
             experimental
             external/cwe/cwe-073
  queryHelp: |
    # File Path Injection
    External Control of File Name or Path, also called File Path Injection, is a vulnerability by which a file path is created using data from outside the application (such as the HTTP request). It allows an attacker to traverse through the filesystem and access arbitrary files.


    ## Recommendation
    Unsanitized user-provided data must not be used to construct file paths. In order to prevent File Path Injection, it is recommended to avoid concatenating user input directly into the file path. Instead, user input should be checked against allowed or disallowed paths (for example, the path must be within `/user_content/` or must not be within `/internal`), ensuring that neither path traversal using `../` nor URL encoding is used to evade these checks.


    ## Example
    The following examples show the bad case and the good case respectively. The `BAD` methods show an HTTP request parameter being used directly to construct a file path without validating the input, which may cause file leakage. In the `GOOD` method, the file path is validated.


    ```java
    // BAD: no file download validation
    HttpServletRequest request = getRequest();
    String path = request.getParameter("path");
    String filePath = "/pages/" + path;
    HttpServletResponse resp = getResponse();
    File file = new File(filePath);
    resp.getOutputStream().write(file.readContent());

    // BAD: no file upload validation
    String savePath = getPara("dir");
    File file = getFile("fileParam").getFile();
    FileInputStream fis = new FileInputStream(file);
    String filePath = "/files/" + savePath;
    FileOutputStream fos = new FileOutputStream(filePath);

    // GOOD: check for a trusted prefix, ensuring path traversal is not used to erase that prefix:
    // (alternatively use `Path.normalize` instead of checking for `..`)
    if (!filePath.contains("..") && filePath.hasPrefix("/pages")) { ... }
    // Also GOOD: check for a forbidden prefix, ensuring URL-encoding is not used to evade the check:
    // (alternatively use `URLDecoder.decode` before `hasPrefix`)
    if (filePath.hasPrefix("/files") && !filePath.contains("%")) { ... }
    ```

    ## References
    * OWASP: [Path Traversal](https://owasp.org/www-community/attacks/Path_Traversal).
    * Veracode: [External Control of File Name or Path Flaw](https://www.veracode.com/security/dotnet/cwe-73).
    * Common Weakness Enumeration: [CWE-73](https://cwe.mitre.org/data/definitions/73.html).
 -
  pack: codeql/java-queries#0
  relativeQueryPath: experimental/Security/CWE/CWE-078/CommandInjectionRuntimeExec.ql
  relativeBqrsPath: codeql/java-queries/experimental/Security/CWE/CWE-078/CommandInjectionRuntimeExec.bqrs
  metadata:
    name: Command Injection into Runtime.exec() with dangerous command
    description: "High sensitvity and precision version of java/command-line-injection,\
      \ designed to find more cases of command injection in rare cases that the default\
      \ query does not find"
    kind: path-problem
    problem.severity: error
    security-severity: 9.8
    precision: high
    id: java/command-line-injection-extra
    tags: |-
      security
             experimental
             external/cwe/cwe-078
  queryHelp: |
    # Command Injection into Runtime.exec() with dangerous command
    Code that passes remote user input to an arugment of a call of `Runtime.exec` that executes a scripting executable will allow the user to execute malicious code.


    ## Recommendation
    If possible, use hard-coded string literals to specify the command or script to run, or library to load. Instead of passing the user input directly to the process or library function, examine the user input and then choose among hard-coded string literals.

    If the applicable libraries or commands cannot be determined at compile time, then add code to verify that the user input string is safe before using it.


    ## Example
    The following example shows code that takes a shell script that can be changed maliciously by a user, and passes it straight to the array going into `Runtime.exec` without examining it first.


    ```java
    class Test {
        public static void main(String[] args) {
            String script = System.getenv("SCRIPTNAME");
            if (script != null) {
                // BAD: The script to be executed by /bin/sh is controlled by the user.
                Runtime.getRuntime().exec(new String[]{"/bin/sh", script});
            }
        }
    }
    ```

    ## References
    * OWASP: [Command Injection](https://www.owasp.org/index.php/Command_Injection).
    * SEI CERT Oracle Coding Standard for Java: [IDS07-J. Sanitize untrusted data passed to the Runtime.exec() method](https://wiki.sei.cmu.edu/confluence/display/java/IDS07-J.+Sanitize+untrusted+data+passed+to+the+Runtime.exec()+method).
    * Common Weakness Enumeration: [CWE-78](https://cwe.mitre.org/data/definitions/78.html).
 -
  pack: codeql/java-queries#0
  relativeQueryPath: experimental/Security/CWE/CWE-078/CommandInjectionRuntimeExecLocal.ql
  relativeBqrsPath: codeql/java-queries/experimental/Security/CWE/CWE-078/CommandInjectionRuntimeExecLocal.bqrs
  metadata:
    name: Command Injection into Runtime.exec() with dangerous command
    description: "High sensitvity and precision version of java/command-line-injection,\
      \ designed to find more cases of command injection in rare cases that the default\
      \ query does not find"
    kind: path-problem
    problem.severity: error
    security-severity: 6.1
    precision: high
    id: java/command-line-injection-extra-local
    tags: |-
      security
             experimental
             local
             external/cwe/cwe-078
  queryHelp: |
    # Command Injection into Runtime.exec() with dangerous command
    Code that passes local user input to an arugment of a call of `Runtime.exec` that executes a scripting executable will allow the user to execute malicious code.


    ## Recommendation
    If possible, use hard-coded string literals to specify the command or script to run, or library to load. Instead of passing the user input directly to the process or library function, examine the user input and then choose among hard-coded string literals.

    If the applicable libraries or commands cannot be determined at compile time, then add code to verify that the user input string is safe before using it.


    ## Example
    The following example shows code that takes a shell script that can be changed maliciously by a user, and passes it straight to the array going into `Runtime.exec` without examining it first.


    ```java
    class Test {
        public static void main(String[] args) {
            String script = System.getenv("SCRIPTNAME");
            if (script != null) {
                // BAD: The script to be executed by /bin/sh is controlled by the user.
                Runtime.getRuntime().exec(new String[]{"/bin/sh", script});
            }
        }
    }
    ```

    ## References
    * OWASP: [Command Injection](https://www.owasp.org/index.php/Command_Injection).
    * SEI CERT Oracle Coding Standard for Java: [IDS07-J. Sanitize untrusted data passed to the Runtime.exec() method](https://wiki.sei.cmu.edu/confluence/display/java/IDS07-J.+Sanitize+untrusted+data+passed+to+the+Runtime.exec()+method).
    * Common Weakness Enumeration: [CWE-78](https://cwe.mitre.org/data/definitions/78.html).
 -
  pack: codeql/java-queries#0
  relativeQueryPath: experimental/Security/CWE/CWE-078/ExecTainted.ql
  relativeBqrsPath: codeql/java-queries/experimental/Security/CWE/CWE-078/ExecTainted.bqrs
  metadata:
    name: Uncontrolled command line (experimental sinks)
    description: |-
      Using externally controlled strings in a command line is vulnerable to malicious
                    changes in the strings (includes experimental sinks).
    kind: path-problem
    problem.severity: error
    precision: high
    id: java/command-line-injection-experimental
    tags: |-
      security
             experimental
             external/cwe/cwe-078
             external/cwe/cwe-088
  queryHelp: |
    # Uncontrolled command line (experimental sinks)
    Code that passes user input directly to `Runtime.exec`, or some other library routine that executes a command, allows the user to execute malicious code.


    ## Recommendation
    If possible, use hard-coded string literals to specify the command to run or library to load. Instead of passing the user input directly to the process or library function, examine the user input and then choose among hard-coded string literals.

    If the applicable libraries or commands cannot be determined at compile time, then add code to verify that the user input string is safe before using it.


    ## Example
    The following example shows code that takes a shell script that can be changed maliciously by a user, and passes it straight to `Runtime.exec` without examining it first.


    ```java
    class Test {
        public static void main(String[] args) {
            String script = System.getenv("SCRIPTNAME");
            if (script != null) {
                // BAD: The script to be executed is controlled by the user.
                Runtime.getRuntime().exec(script);
            }
        }
    }
    ```

    ## References
    * OWASP: [Command Injection](https://www.owasp.org/index.php/Command_Injection).
    * SEI CERT Oracle Coding Standard for Java: [IDS07-J. Sanitize untrusted data passed to the Runtime.exec() method](https://wiki.sei.cmu.edu/confluence/display/java/IDS07-J.+Sanitize+untrusted+data+passed+to+the+Runtime.exec()+method).
    * Common Weakness Enumeration: [CWE-78](https://cwe.mitre.org/data/definitions/78.html).
    * Common Weakness Enumeration: [CWE-88](https://cwe.mitre.org/data/definitions/88.html).
 -
  pack: codeql/java-queries#0
  relativeQueryPath: experimental/Security/CWE/CWE-089/MyBatisAnnotationSqlInjection.ql
  relativeBqrsPath: codeql/java-queries/experimental/Security/CWE/CWE-089/MyBatisAnnotationSqlInjection.bqrs
  metadata:
    name: SQL injection in MyBatis annotation
    description: |-
      Constructing a dynamic SQL statement with input that comes from an
                    untrusted source could allow an attacker to modify the statement's
                    meaning or to execute arbitrary SQL commands.
    kind: path-problem
    problem.severity: error
    precision: high
    id: java/mybatis-annotation-sql-injection
    tags: |-
      security
             experimental
             external/cwe/cwe-089
  queryHelp: "# SQL injection in MyBatis annotation\nMyBatis uses methods with the\
    \ annotations `@Select`, `@Insert`, etc. to construct dynamic SQL statements.\
    \ If the syntax `${param}` is used in those statements, and `param` is a parameter\
    \ of the annotated method, attackers can exploit this to tamper with the SQL statements\
    \ or execute arbitrary SQL commands.\n\n\n## Recommendation\nWhen writing MyBatis\
    \ mapping statements, use the syntax `#{xxx}` whenever possible. If the syntax\
    \ `${xxx}` must be used, any parameters included in it should be sanitized to\
    \ prevent SQL injection attacks.\n\n\n## Example\nThe following sample shows a\
    \ bad and a good example of MyBatis annotations usage. The `bad1` method uses\
    \ `$(name)` in the `@Select` annotation to dynamically build a SQL statement,\
    \ which causes a SQL injection vulnerability. The `good1` method uses `#{name}`\
    \ in the `@Select` annotation to dynamically include the parameter in a SQL statement,\
    \ which causes the MyBatis framework to sanitize the input provided, preventing\
    \ the vulnerability.\n\n\n```java\nimport org.apache.ibatis.annotations.Select;\n\
    \npublic interface MyBatisAnnotationSqlInjection {\n\n    @Select(\"select * from\
    \ test where name = ${name}\")\n\tpublic Test bad1(String name);\n\n    @Select(\"\
    select * from test where name = #{name}\")\n\tpublic Test good1(String name);\n\
    }\n```\n\n## References\n* Fortify: [SQL Injection: MyBatis Mapper](https://vulncat.fortify.com/en/detail?id=desc.config.java.sql_injection_mybatis_mapper).\n\
    * Common Weakness Enumeration: [CWE-89](https://cwe.mitre.org/data/definitions/89.html).\n"
 -
  pack: codeql/java-queries#0
  relativeQueryPath: experimental/Security/CWE/CWE-089/MyBatisMapperXmlSqlInjection.ql
  relativeBqrsPath: codeql/java-queries/experimental/Security/CWE/CWE-089/MyBatisMapperXmlSqlInjection.bqrs
  metadata:
    name: SQL injection in MyBatis Mapper XML
    description: |-
      Constructing a dynamic SQL statement with input that comes from an
                    untrusted source could allow an attacker to modify the statement's
                    meaning or to execute arbitrary SQL commands.
    kind: path-problem
    problem.severity: error
    precision: high
    id: java/mybatis-xml-sql-injection
    tags: |-
      security
             experimental
             external/cwe/cwe-089
  queryHelp: |
    # SQL injection in MyBatis Mapper XML
    MyBatis allows operating the database by creating XML files to construct dynamic SQL statements. If the syntax `${param}` is used in those statements, and `param` is under the user's control, attackers can exploit this to tamper with the SQL statements or execute arbitrary SQL commands.


    ## Recommendation
    When writing MyBatis mapping statements, try to use the syntax `#{xxx}`. If the syntax `${xxx}` must be used, any parameters included in it should be sanitized to prevent SQL injection attacks.


    ## Example
    The following sample shows several bad and good examples of MyBatis XML files usage. In `bad1`, `bad2`, `bad3`, `bad4`, and `bad5` the syntax `${xxx}` is used to build dynamic SQL statements, which causes a SQL injection vulnerability. In `good1`, the program uses the `${xxx}` syntax, but there are subtle restrictions on the data, while in `good2` the syntax `#{xxx}` is used. In both cases the SQL injection vulnerability is prevented.


    ```xml
    <?xml version="1.0" encoding="UTF-8" ?>
    <!DOCTYPE mapper PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN"
      "http://mybatis.org/dtd/mybatis-3-mapper.dtd" >
    <mapper namespace="SqlInjectionMapper">

      <resultMap id="BaseResultMap" type="Test">
        <id column="id" jdbcType="INTEGER" property="id"/>
        <result column="name" jdbcType="VARCHAR" property="name"/>
        <result column="pass" jdbcType="VARCHAR" property="pass"/>
      </resultMap>

      <sql id="Update_By_Example_Where_Clause">
        <where>
          <if test="name != null">
            -- bad
            and name = ${name}
          </if>
          <if test="id != null">
            and id = #{id}
          </if>
        </where>
      </sql>

      <select id="bad1" parameterType="java.lang.String" resultMap="BaseResultMap">
        -- bad
        select id,name from test where name like '%${name}%'
      </select>

      <select id="bad2" parameterType="java.lang.String" resultMap="BaseResultMap">
        -- bad
        select id,name from test order by ${name} desc
      </select>

      <select id="bad3" parameterType="java.lang.String" resultMap="BaseResultMap">
        -- bad
        select id,name from test where name in ${name}
      </select>

      <update id="bad4" parameterType="Test">
        update test
        <set>
          <if test="pass != null">
            pass = #{pass},
          </if>
        </set>
        <if test="_parameter != null">
          -- bad
          <include refid="Update_By_Example_Where_Clause" />
        </if>
      </update>

      <insert id="bad5" parameterType="Test">
        insert into test (name, pass)
        <trim prefix="values (" suffix=")" suffixOverrides=",">
          <if test="name != null">
            -- bad
            name = ${name},
          </if>
          <if test="pass != null">
            -- bad
            pass = ${pass},
          </if>
        </trim>
      </insert>

      <select id="good1" parameterType="java.lang.Integer" resultMap="BaseResultMap">
        -- good
        select id,name from test where id = ${id}
      </select>

      <select id="good2" parameterType="java.lang.String" resultMap="BaseResultMap">
        -- good
        select id,name from test where name = #{name}
      </select>
    </mapper>

    ```

    ## References
    * Fortify: [SQL Injection: MyBatis Mapper](https://vulncat.fortify.com/en/detail?id=desc.config.java.sql_injection_mybatis_mapper).
    * Common Weakness Enumeration: [CWE-89](https://cwe.mitre.org/data/definitions/89.html).
 -
  pack: codeql/java-queries#0
  relativeQueryPath: experimental/Security/CWE/CWE-094/BeanShellInjection.ql
  relativeBqrsPath: codeql/java-queries/experimental/Security/CWE/CWE-094/BeanShellInjection.bqrs
  metadata:
    name: BeanShell injection
    description: |-
      Evaluation of a user-controlled BeanShell expression
                    may lead to arbitrary code execution.
    kind: path-problem
    problem.severity: error
    precision: high
    id: java/beanshell-injection
    tags: |-
      security
             experimental
             external/cwe/cwe-094
  queryHelp: "# BeanShell injection\nBeanShell is a small, free, embeddable Java source\
    \ interpreter with object scripting language features, written in Java. BeanShell\
    \ dynamically executes standard Java syntax and extends it with common scripting\
    \ conveniences such as loose types, commands, and method closures like those in\
    \ Perl and JavaScript. If a BeanShell expression is built using attacker-controlled\
    \ data, and then evaluated, then it may allow the attacker to run arbitrary code.\n\
    \n\n## Recommendation\nIt is generally recommended to avoid using untrusted input\
    \ in a BeanShell expression. If it is not possible, BeanShell expressions should\
    \ be run in a sandbox that allows accessing only explicitly allowed classes.\n\
    \n\n## Example\nThe following example uses untrusted data to build and run a BeanShell\
    \ expression.\n\n\n```java\nimport bsh.Interpreter;\nimport javax.servlet.http.HttpServletRequest;\n\
    import org.springframework.scripting.bsh.BshScriptEvaluator;\nimport org.springframework.scripting.support.StaticScriptSource;\n\
    import org.springframework.stereotype.Controller;\nimport org.springframework.web.bind.annotation.GetMapping;\n\
    \n@Controller\npublic class BeanShellInjection {\n\n\t@GetMapping(value = \"bad1\"\
    )\n\tpublic void bad1(HttpServletRequest request) {\n\t\tString code = request.getParameter(\"\
    code\");\n\t\tBshScriptEvaluator evaluator = new BshScriptEvaluator();\n\t\tevaluator.evaluate(new\
    \ StaticScriptSource(code)); //bad\n\t}\n\n\t@GetMapping(value = \"bad2\")\n\t\
    public void bad2(HttpServletRequest request) throws Exception {\n\t\tString code\
    \ = request.getParameter(\"code\");\n\t\tInterpreter interpreter = new Interpreter();\n\
    \t\tinterpreter.eval(code);  //bad\n\t}\n\n\t@GetMapping(value = \"bad3\")\n\t\
    public void bad3(HttpServletRequest request) {\n\t\tString code = request.getParameter(\"\
    code\");\n\t\tStaticScriptSource staticScriptSource = new StaticScriptSource(\"\
    test\");\n\t\tstaticScriptSource.setScript(code);\n\t\tBshScriptEvaluator evaluator\
    \ = new BshScriptEvaluator();\n\t\tevaluator.evaluate(staticScriptSource);  //bad\n\
    \t}\n}\n\n```\n\n## References\n* CVE-2016-2510:[BeanShell Injection](https://nvd.nist.gov/vuln/detail/CVE-2016-2510).\n\
    * Common Weakness Enumeration: [CWE-94](https://cwe.mitre.org/data/definitions/94.html).\n"
 -
  pack: codeql/java-queries#0
  relativeQueryPath: experimental/Security/CWE/CWE-094/InsecureDexLoading.ql
  relativeBqrsPath: codeql/java-queries/experimental/Security/CWE/CWE-094/InsecureDexLoading.bqrs
  metadata:
    name: Insecure loading of an Android Dex File
    description: |-
      Loading a DEX library located in a world-writable location such as
       an SD card can lead to arbitrary code execution vulnerabilities.
    kind: path-problem
    problem.severity: error
    precision: high
    id: java/android-insecure-dex-loading
    tags: |-
      security
             experimental
             external/cwe/cwe-094
  queryHelp: "# Insecure loading of an Android Dex File\nIt is dangerous to load Dex\
    \ libraries from shared world-writable storage spaces. A malicious actor can replace\
    \ a dex file with a maliciously crafted file which when loaded by the app can\
    \ lead to code execution.\n\n\n## Recommendation\nLoading a file from private\
    \ storage instead of a world-writable one can prevent this issue, because the\
    \ attacker cannot access files stored there.\n\n\n## Example\nThe following example\
    \ loads a Dex file from a shared world-writable location. in this case, since\
    \ the \\`/sdcard\\` directory is on external storage, anyone can read/write to\
    \ the location. bypassing all Android security policies. Hence, this is insecure.\n\
    \n\n```java\n\nimport android.app.Application;\nimport android.content.Context;\n\
    import android.content.pm.PackageInfo;\nimport android.os.Bundle;\n\nimport dalvik.system.DexClassLoader;\n\
    import dalvik.system.DexFile;\n\npublic class InsecureDexLoading extends Application\
    \ {\n\t@Override\n\tpublic void onCreate() {\n\t\tsuper.onCreate();\n\t\tupdateChecker();\n\
    \t}\n\n\tprivate void updateChecker() {\n\t\ttry {\n\t\t\tFile file = new File(\"\
    /sdcard/updater.apk\");\n\t\t\tif (file.exists() && file.isFile() && file.length()\
    \ <= 1000) {\n\t\t\t\tDexClassLoader cl = new DexClassLoader(file.getAbsolutePath(),\
    \ getCacheDir().getAbsolutePath(), null,\n\t\t\t\t\t\tgetClassLoader());\n\t\t\
    \t\tint version = (int) cl.loadClass(\"my.package.class\").getDeclaredMethod(\"\
    myMethod\").invoke(null);\n\t\t\t\tif (Build.VERSION.SDK_INT < version) {\n\t\t\
    \t\t\tToast.makeText(this, \"Loaded Dex!\", Toast.LENGTH_LONG).show();\n\t\t\t\
    \t}\n\t\t\t}\n\t\t} catch (Exception e) {\n\t\t\t// ignore\n\t\t}\n\t}\n}\n\n\
    ```\nThe next example loads a Dex file stored inside the app's private storage.\
    \ This is not exploitable as nobody else except the app can access the data stored\
    \ there.\n\n\n```java\npublic class SecureDexLoading extends Application {\n\t\
    @Override\n\tpublic void onCreate() {\n\t\tsuper.onCreate();\n\t\tupdateChecker();\n\
    \t}\n\n\tprivate void updateChecker() {\n\t\ttry {\n\t\t\tFile file = new File(getCacheDir()\
    \ + \"/updater.apk\");\n\t\t\tif (file.exists() && file.isFile() && file.length()\
    \ <= 1000) {\n\t\t\t\tDexClassLoader cl = new DexClassLoader(file.getAbsolutePath(),\
    \ getCacheDir().getAbsolutePath(), null,\n\t\t\t\t\t\tgetClassLoader());\n\t\t\
    \t\tint version = (int) cl.loadClass(\"my.package.class\").getDeclaredMethod(\"\
    myMethod\").invoke(null);\n\t\t\t\tif (Build.VERSION.SDK_INT < version) {\n\t\t\
    \t\t\tToast.makeText(this, \"Securely loaded Dex!\", Toast.LENGTH_LONG).show();\n\
    \t\t\t\t}\n\t\t\t}\n\t\t} catch (Exception e) {\n\t\t\t// ignore\n\t\t}\n\t}\n\
    }\n```\n\n## References\n* Android Documentation: [Data and file storage overview](https://developer.android.com/training/data-storage/).\n\
    * Android Documentation: [DexClassLoader](https://developer.android.com/reference/dalvik/system/DexClassLoader).\n\
    * Common Weakness Enumeration: [CWE-94](https://cwe.mitre.org/data/definitions/94.html).\n"
 -
  pack: codeql/java-queries#0
  relativeQueryPath: experimental/Security/CWE/CWE-094/JShellInjection.ql
  relativeBqrsPath: codeql/java-queries/experimental/Security/CWE/CWE-094/JShellInjection.bqrs
  metadata:
    name: JShell injection
    description: |-
      Evaluation of a user-controlled JShell expression
                    may lead to arbitrary code execution.
    kind: path-problem
    problem.severity: error
    precision: high
    id: java/jshell-injection
    tags: |-
      security
             experimental
             external/cwe/cwe-094
  queryHelp: "# JShell injection\nThe Java Shell tool (JShell) is an interactive tool\
    \ for learning the Java programming language and prototyping Java code. JShell\
    \ is a Read-Evaluate-Print Loop (REPL), which evaluates declarations, statements,\
    \ and expressions as they are entered and immediately shows the results. If an\
    \ expression is built using attacker-controlled data and then evaluated, it may\
    \ allow the attacker to run arbitrary code.\n\n\n## Recommendation\nIt is generally\
    \ recommended to avoid using untrusted input in a JShell expression. If it is\
    \ not possible, JShell expressions should be run in a sandbox that allows accessing\
    \ only explicitly allowed classes.\n\n\n## Example\nThe following example calls\
    \ `JShell.eval(...)` or `SourceCodeAnalysis.wrappers(...)` to execute untrusted\
    \ data.\n\n\n```java\nimport javax.servlet.http.HttpServletRequest;\nimport jdk.jshell.JShell;\n\
    import jdk.jshell.SourceCodeAnalysis;\nimport org.springframework.stereotype.Controller;\n\
    import org.springframework.web.bind.annotation.GetMapping;\n\n@Controller\npublic\
    \ class JShellInjection {\n\n\t@GetMapping(value = \"bad1\")\n\tpublic void bad1(HttpServletRequest\
    \ request) {\n\t\tString input = request.getParameter(\"code\");\n\t\tJShell jShell\
    \ = JShell.builder().build();\n        // BAD: allow execution of arbitrary Java\
    \ code\n\t\tjShell.eval(input);\n\t}\n\n\t@GetMapping(value = \"bad2\")\n\tpublic\
    \ void bad2(HttpServletRequest request) {\n\t\tString input = request.getParameter(\"\
    code\");\n\t\tJShell jShell = JShell.builder().build();\n\t\tSourceCodeAnalysis\
    \ sourceCodeAnalysis = jShell.sourceCodeAnalysis();\n        // BAD: allow execution\
    \ of arbitrary Java code\n\t\tsourceCodeAnalysis.wrappers(input);\n\t}\n\n\t@GetMapping(value\
    \ = \"bad3\")\n\tpublic void bad3(HttpServletRequest request) {\n\t\tString input\
    \ = request.getParameter(\"code\");\n\t\tJShell jShell = JShell.builder().build();\n\
    \t\tSourceCodeAnalysis.CompletionInfo info;\n\t\tSourceCodeAnalysis sca = jShell.sourceCodeAnalysis();\n\
    \t\tfor (info = sca.analyzeCompletion(input);\n\t\t\t\tinfo.completeness().isComplete();\n\
    \t\t\t\tinfo = sca.analyzeCompletion(info.remaining())) {\n\t\t\t// BAD: allow\
    \ execution of arbitrary Java code\n\t\t\tjShell.eval(info.source());\n\t\t}\n\
    \t}\n}\n```\n\n## References\n* Java Shell Users Guide: [Introduction to JShell](https://docs.oracle.com/en/java/javase/11/jshell/introduction-jshell.html)\n\
    * Common Weakness Enumeration: [CWE-94](https://cwe.mitre.org/data/definitions/94.html).\n"
 -
  pack: codeql/java-queries#0
  relativeQueryPath: experimental/Security/CWE/CWE-094/JakartaExpressionInjection.ql
  relativeBqrsPath: codeql/java-queries/experimental/Security/CWE/CWE-094/JakartaExpressionInjection.bqrs
  metadata:
    name: Jakarta Expression Language injection
    description: |-
      Evaluation of a user-controlled expression
                    may lead to arbitrary code execution.
    kind: path-problem
    problem.severity: error
    precision: high
    id: java/javaee-expression-injection
    tags: |-
      security
             experimental
             external/cwe/cwe-094
  queryHelp: |
    # Jakarta Expression Language injection
    Jakarta Expression Language (EL) is an expression language for Java applications. There is a single language specification and multiple implementations such as Glassfish, Juel, Apache Commons EL, etc. The language allows invocation of methods available in the JVM. If an expression is built using attacker-controlled data, and then evaluated, it may allow the attacker to run arbitrary code.


    ## Recommendation
    It is generally recommended to avoid using untrusted data in an EL expression. Before using untrusted data to build an EL expression, the data should be validated to ensure it is not evaluated as expression language. If the EL implementation offers configuring a sandbox for EL expressions, they should be run in a restrictive sandbox that allows accessing only explicitly allowed classes. If the EL implementation does not support sandboxing, consider using other expression language implementations with sandboxing capabilities such as Apache Commons JEXL or the Spring Expression Language.


    ## Example
    The following example shows how untrusted data is used to build and run an expression using the JUEL interpreter:


    ```java
    String expression = "${" + getRemoteUserInput() + "}";
    ExpressionFactory factory = new de.odysseus.el.ExpressionFactoryImpl();
    ValueExpression e = factory.createValueExpression(context, expression, Object.class);
    SimpleContext context = getContext();
    Object result = e.getValue(context);
    ```
    JUEL does not support running expressions in a sandbox. To prevent running arbitrary code, incoming data has to be checked before including it in an expression. The next example uses a Regex pattern to check whether a user tries to run an allowed expression or not:


    ```java
    String input = getRemoteUserInput();
    String pattern = "(inside|outside)\\.(temperature|humidity)";
    if (!input.matches(pattern)) {
        throw new IllegalArgumentException("Unexpected expression");
    }
    String expression = "${" + input + "}";
    ExpressionFactory factory = new de.odysseus.el.ExpressionFactoryImpl();
    ValueExpression e = factory.createValueExpression(context, expression, Object.class);
    SimpleContext context = getContext();
    Object result = e.getValue(context);

    ```

    ## References
    * Eclipse Foundation: [Jakarta Expression Language](https://projects.eclipse.org/projects/ee4j.el).
    * Jakarta EE documentation: [Jakarta Expression Language API](https://javadoc.io/doc/jakarta.el/jakarta.el-api/latest/index.html)
    * OWASP: [Expression Language Injection](https://owasp.org/www-community/vulnerabilities/Expression_Language_Injection).
    * JUEL: [Home page](http://juel.sourceforge.net)
    * Common Weakness Enumeration: [CWE-94](https://cwe.mitre.org/data/definitions/94.html).
 -
  pack: codeql/java-queries#0
  relativeQueryPath: experimental/Security/CWE/CWE-094/JythonInjection.ql
  relativeBqrsPath: codeql/java-queries/experimental/Security/CWE/CWE-094/JythonInjection.bqrs
  metadata:
    name: Injection in Jython
    description: |-
      Evaluation of a user-controlled malicious expression in Java Python
                    interpreter may lead to remote code execution.
    kind: path-problem
    problem.severity: error
    precision: high
    id: java/jython-injection
    tags: |-
      security
             experimental
             external/cwe/cwe-094
             external/cwe/cwe-095
  queryHelp: |
    # Injection in Jython
    Python has been the most widely used programming language in recent years, and Jython (formerly known as JPython) is a popular Java implementation of Python. It allows embedded Python scripting inside Java applications and provides an interactive interpreter that can be used to interact with Java packages or with running Java applications. If an expression is built using attacker-controlled data and then evaluated, it may allow the attacker to run arbitrary code.


    ## Recommendation
    In general, including user input in Jython expression should be avoided. If user input must be included in an expression, it should be then evaluated in a safe context that doesn't allow arbitrary code invocation.


    ## Example
    The following code could execute arbitrary code in Jython Interpreter


    ```java
    import org.python.util.PythonInterpreter;

    public class JythonInjection extends HttpServlet {
        protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {
            response.setContentType("text/plain");
            String code = request.getParameter("code");
            PythonInterpreter interpreter = null;
            ByteArrayOutputStream out = new ByteArrayOutputStream();

            try {
                interpreter = new PythonInterpreter();
                interpreter.setOut(out);
                interpreter.setErr(out);

                // BAD: allow execution of arbitrary Python code
                interpreter.exec(code);
                out.flush();

                response.getWriter().print(out.toString());
            } catch(PyException ex) {
                response.getWriter().println(ex.getMessage());
            } finally {
                if (interpreter != null) {
                    interpreter.close();
                }
                out.close();
            }
        }

        protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {
            response.setContentType("text/plain");
            String code = request.getParameter("code");
            PythonInterpreter interpreter = null;

            try {
                interpreter = new PythonInterpreter();
                // BAD: allow execution of arbitrary Python code
                PyObject py = interpreter.eval(code);

                response.getWriter().print(py.toString());
            } catch(PyException ex) {
                response.getWriter().println(ex.getMessage());
            } finally {
                if (interpreter != null) {
                    interpreter.close();
                }
            }
        }
    }

    ```

    ## References
    * Jython Organization: [Jython and Java Integration](https://jython.readthedocs.io/en/latest/JythonAndJavaIntegration/)
    * PortSwigger: [Python code injection](https://portswigger.net/kb/issues/00100f10_python-code-injection)
    * Common Weakness Enumeration: [CWE-94](https://cwe.mitre.org/data/definitions/94.html).
    * Common Weakness Enumeration: [CWE-95](https://cwe.mitre.org/data/definitions/95.html).
 -
  pack: codeql/java-queries#0
  relativeQueryPath: experimental/Security/CWE/CWE-094/ScriptInjection.ql
  relativeBqrsPath: codeql/java-queries/experimental/Security/CWE/CWE-094/ScriptInjection.bqrs
  metadata:
    name: Injection in Java Script Engine
    description: |-
      Evaluation of user-controlled data using the Java Script Engine may
                    lead to remote code execution.
    kind: path-problem
    problem.severity: error
    precision: high
    id: java/unsafe-eval
    tags: |-
      security
             experimental
             external/cwe/cwe-094
  queryHelp: |
    # Injection in Java Script Engine
    The Java Scripting API has been available since the release of Java 6. It allows applications to interact with scripts written in languages such as JavaScript. It serves as an embedded scripting engine inside Java applications which allows Java-to-JavaScript interoperability and provides a seamless integration between the two languages. If an expression is built using attacker-controlled data, and then evaluated in a powerful context, it may allow the attacker to run arbitrary code.


    ## Recommendation
    In general, including user input in a Java Script Engine expression should be avoided. If user input must be included in the expression, it should be then evaluated in a safe context that doesn't allow arbitrary code invocation. Use "Cloudbees Rhino Sandbox" or sandboxing with SecurityManager, which will be deprecated in a future release, or use [GraalVM](https://www.graalvm.org/) instead.


    ## Example
    The following code could execute user-supplied JavaScript code in `ScriptEngine`


    ```java
    // Bad: ScriptEngine allows arbitrary code injection
    ScriptEngineManager scriptEngineManager = new ScriptEngineManager();
    ScriptEngine scriptEngine = scriptEngineManager.getEngineByExtension("js");
    Object result = scriptEngine.eval(code);
    ```

    ```java
    // Bad: Execute externally controlled input in Nashorn Script Engine
    NashornScriptEngineFactory factory = new NashornScriptEngineFactory();
    NashornScriptEngine engine = (NashornScriptEngine) factory.getScriptEngine(new String[] { "-scripting"});
    Object result = engine.eval(input);

    ```
    The following example shows two ways of using Rhino expression. In the 'BAD' case, an unsafe context is initialized with `initStandardObjects` that allows arbitrary Java code to be executed. In the 'GOOD' case, a safe context is initialized with `initSafeStandardObjects` or `setClassShutter`.


    ```java
    import org.mozilla.javascript.ClassShutter;
    import org.mozilla.javascript.Context;
    import org.mozilla.javascript.Scriptable;

    public class RhinoInjection extends HttpServlet {

      protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {
        response.setContentType("text/plain");
        String code = request.getParameter("code");
        Context ctx = Context.enter();
        try {
          {
            // BAD: allow arbitrary Java and JavaScript code to be executed
            Scriptable scope = ctx.initStandardObjects();
          }

          {
            // GOOD: enable the safe mode
            Scriptable scope = ctx.initSafeStandardObjects();
          }

          {
            // GOOD: enforce a constraint on allowed classes
            Scriptable scope = ctx.initStandardObjects();
            ctx.setClassShutter(new ClassShutter() {
                public boolean visibleToScripts(String className) {
                  return className.startsWith("com.example.");
                }
            });
          }

          Object result = ctx.evaluateString(scope, code, "<code>", 1, null);
          response.getWriter().print(Context.toString(result));
        } catch(RhinoException ex) {
          response.getWriter().println(ex.getMessage());
        } finally {
          Context.exit();
        }
      }
    }

    ```

    ## References
    * CERT coding standard: [ScriptEngine code injection](https://wiki.sei.cmu.edu/confluence/display/java/IDS52-J.+Prevent+code+injection)
    * GraalVM: [Secure by Default](https://www.graalvm.org/reference-manual/js/NashornMigrationGuide/#secure-by-default)
    * Mozilla Rhino: [Rhino: JavaScript in Java](https://github.com/mozilla/rhino)
    * Rhino Sandbox: [A sandbox to execute JavaScript code with Rhino in Java](https://github.com/javadelight/delight-rhino-sandbox)
    * GuardRails: [Code Injection](https://docs.guardrails.io/docs/en/vulnerabilities/java/insecure_use_of_dangerous_function#code-injection)
    * Common Weakness Enumeration: [CWE-94](https://cwe.mitre.org/data/definitions/94.html).
 -
  pack: codeql/java-queries#0
  relativeQueryPath: experimental/Security/CWE/CWE-094/SpringImplicitViewManipulation.ql
  relativeBqrsPath: codeql/java-queries/experimental/Security/CWE/CWE-094/SpringImplicitViewManipulation.bqrs
  metadata:
    name: Spring Implicit View Manipulation
    description: Untrusted input in a Spring View Controller can lead to RCE.
    kind: problem
    problem.severity: error
    precision: high
    id: java/spring-view-manipulation-implicit
    tags: |-
      security
             experimental
             external/cwe/cwe-094
  queryHelp: |
    # Spring Implicit View Manipulation
    The Spring Expression Language (SpEL) is a powerful expression language provided by Spring Framework. The language offers many features including invocation of methods available in the JVM.

    An unrestricted view name manipulation vulnerability in Spring Framework could lead to attacker-controlled arbitrary SpEL expressions being evaluated using attacker-controlled data, which may in turn allow an attacker to run arbitrary code.

    Note: two related variants of this problem are detected by different queries, \`java/spring-view-manipulation\` and \`java/spring-view-manipulation-implicit\`. The first detects taint flow problems where the return types is always `String`. While the latter, \`java/spring-view-manipulation-implicit\` detects cases where the request mapping method has a non-string return type such as `void`.


    ## Recommendation
    In general, using user input to determine Spring view name should be avoided. If user input must be included in the expression, the controller can be annotated by a `@ResponseBody` annotation. In this case, Spring Framework does not interpret it as a view name, but just returns this string in HTTP Response. The same applies to using a `@RestController` annotation on a class, as internally it inherits `@ResponseBody`.


    ## Example
    In the following example, the `Fragment` method uses an externally controlled variable `section` to generate the view name. Hence, it is vulnerable to Spring View Manipulation attacks.


    ```java
    @Controller
    public class SptingViewManipulationController {

        Logger log = LoggerFactory.getLogger(HelloController.class);

        @GetMapping("/safe/fragment")
        public String Fragment(@RequestParam String section) {
            // bad as template path is attacker controlled
            return "welcome :: " + section;
        }

        @GetMapping("/doc/{document}")
        public void getDocument(@PathVariable String document) {
            // returns void, so view name is taken from URI
            log.info("Retrieving " + document);
        }
    }

    ```
    This can be easily prevented by using the `ResponseBody` annotation which marks the response is already processed preventing exploitation of Spring View Manipulation vulnerabilities. Alternatively, this can also be fixed by adding a `HttpServletResponse` parameter to the method definition as shown in the example below.


    ```java
    @Controller
    public class SptingViewManipulationController {

        Logger log = LoggerFactory.getLogger(HelloController.class);

        @GetMapping("/safe/fragment")
        @ResponseBody
        public String Fragment(@RequestParam String section) {
            // good, as `@ResponseBody` annotation tells Spring
            // to process the return values as body, instead of view name
            return "welcome :: " + section;
        }

        @GetMapping("/safe/doc/{document}")
        public void getDocument(@PathVariable String document, HttpServletResponse response) {
            // good as `HttpServletResponse param tells Spring that the response is already
            // processed.
            log.info("Retrieving " + document); // FP
        }
    }

    ```

    ## References
    * Veracode Research : [Spring View Manipulation ](https://github.com/veracode-research/spring-view-manipulation/)
    * Spring Framework Reference Documentation: [Spring Expression Language (SpEL)](https://docs.spring.io/spring/docs/4.2.x/spring-framework-reference/html/expressions.html)
    * OWASP: [Expression Language Injection](https://owasp.org/www-community/vulnerabilities/Expression_Language_Injection)
    * Common Weakness Enumeration: [CWE-94](https://cwe.mitre.org/data/definitions/94.html).
 -
  pack: codeql/java-queries#0
  relativeQueryPath: experimental/Security/CWE/CWE-094/SpringViewManipulation.ql
  relativeBqrsPath: codeql/java-queries/experimental/Security/CWE/CWE-094/SpringViewManipulation.bqrs
  metadata:
    name: Spring View Manipulation
    description: Untrusted input in a Spring View can lead to RCE.
    kind: path-problem
    problem.severity: error
    precision: high
    id: java/spring-view-manipulation
    tags: |-
      security
             experimental
             external/cwe/cwe-094
  queryHelp: |
    # Spring View Manipulation
    The Spring Expression Language (SpEL) is a powerful expression language provided by Spring Framework. The language offers many features including invocation of methods available in the JVM.

    An unrestricted view name manipulation vulnerability in Spring Framework could lead to attacker-controlled arbitrary SpEL expressions being evaluated using attacker-controlled data, which may in turn allow an attacker to run arbitrary code.

    Note: two related variants of this problem are detected by different queries, \`java/spring-view-manipulation\` and \`java/spring-view-manipulation-implicit\`. The first detects taint flow problems where the return types is always `String`. While the latter, \`java/spring-view-manipulation-implicit\` detects cases where the request mapping method has a non-string return type such as `void`.


    ## Recommendation
    In general, using user input to determine Spring view name should be avoided. If user input must be included in the expression, the controller can be annotated by a `@ResponseBody` annotation. In this case, Spring Framework does not interpret it as a view name, but just returns this string in HTTP Response. The same applies to using a `@RestController` annotation on a class, as internally it inherits `@ResponseBody`.


    ## Example
    In the following example, the `Fragment` method uses an externally controlled variable `section` to generate the view name. Hence, it is vulnerable to Spring View Manipulation attacks.


    ```java
    @Controller
    public class SptingViewManipulationController {

        Logger log = LoggerFactory.getLogger(HelloController.class);

        @GetMapping("/safe/fragment")
        public String Fragment(@RequestParam String section) {
            // bad as template path is attacker controlled
            return "welcome :: " + section;
        }

        @GetMapping("/doc/{document}")
        public void getDocument(@PathVariable String document) {
            // returns void, so view name is taken from URI
            log.info("Retrieving " + document);
        }
    }

    ```
    This can be easily prevented by using the `ResponseBody` annotation which marks the response is already processed preventing exploitation of Spring View Manipulation vulnerabilities. Alternatively, this can also be fixed by adding a `HttpServletResponse` parameter to the method definition as shown in the example below.


    ```java
    @Controller
    public class SptingViewManipulationController {

        Logger log = LoggerFactory.getLogger(HelloController.class);

        @GetMapping("/safe/fragment")
        @ResponseBody
        public String Fragment(@RequestParam String section) {
            // good, as `@ResponseBody` annotation tells Spring
            // to process the return values as body, instead of view name
            return "welcome :: " + section;
        }

        @GetMapping("/safe/doc/{document}")
        public void getDocument(@PathVariable String document, HttpServletResponse response) {
            // good as `HttpServletResponse param tells Spring that the response is already
            // processed.
            log.info("Retrieving " + document); // FP
        }
    }

    ```

    ## References
    * Veracode Research : [Spring View Manipulation ](https://github.com/veracode-research/spring-view-manipulation/)
    * Spring Framework Reference Documentation: [Spring Expression Language (SpEL)](https://docs.spring.io/spring/docs/4.2.x/spring-framework-reference/html/expressions.html)
    * OWASP: [Expression Language Injection](https://owasp.org/www-community/vulnerabilities/Expression_Language_Injection)
    * Common Weakness Enumeration: [CWE-94](https://cwe.mitre.org/data/definitions/94.html).
 -
  pack: codeql/java-queries#0
  relativeQueryPath: experimental/Security/CWE/CWE-1004/InsecureTomcatConfig.ql
  relativeBqrsPath: codeql/java-queries/experimental/Security/CWE/CWE-1004/InsecureTomcatConfig.bqrs
  metadata:
    name: Tomcat config disables 'HttpOnly' flag (XSS risk)
    description: Disabling 'HttpOnly' leaves session cookies vulnerable to an XSS
      attack.
    kind: problem
    problem.severity: warning
    precision: medium
    id: java/tomcat-disabled-httponly
    tags: |-
      security
             experimental
             external/cwe/cwe-1004
  queryHelp: "# Tomcat config disables 'HttpOnly' flag (XSS risk)\nWhen you add an\
    \ application to a Tomcat server, it will generate a new `JSESSIONID` when you\
    \ call `request.getSession()` or if you invoke a JSP from a servlet. If cookies\
    \ are generated without the `HttpOnly` flag, an attacker can use a cross-site\
    \ scripting (XSS) attack to get another user's session ID.\n\n\n## Recommendation\n\
    Tomcat version 7+ automatically sets an `HttpOnly` flag on all session cookies\
    \ to prevent client side scripts from accessing the session ID. In most situations,\
    \ you should not override this behavior.\n\n\n## Example\nThe following example\
    \ shows a Tomcat configuration with `useHttpOnly` disabled. Usually you should\
    \ not set this.\n\n\n```xml\n<web-app xmlns=\"http://java.sun.com/xml/ns/javaee\"\
    \ \n    xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"\
    http://java.sun.com/xml/ns/javaee\n          http://java.sun.com/xml/ns/javaee/web-app_2_5.xsd\"\
    \ version=\"2.5\">\n    <display-name>Sample Tomcat Web Application</display-name>\n\
    \    <context-param>\n        <param-name>useHttpOnly</param-name>\n        <param-value>false</param-value>\n\
    \    </context-param>\n</web-app>\n```\n\n## References\n* CWE: [Sensitive Cookie\
    \ Without 'HttpOnly' Flag](https://cwe.mitre.org/data/definitions/1004.html).\n\
    * OWASP: [ HttpOnly ](https://www.owasp.org/index.php/HttpOnly).\n* Common Weakness\
    \ Enumeration: [CWE-1004](https://cwe.mitre.org/data/definitions/1004.html).\n"
 -
  pack: codeql/java-queries#0
  relativeQueryPath: experimental/Security/CWE/CWE-1004/SensitiveCookieNotHttpOnly.ql
  relativeBqrsPath: codeql/java-queries/experimental/Security/CWE/CWE-1004/SensitiveCookieNotHttpOnly.bqrs
  metadata:
    name: Sensitive cookies without the HttpOnly response header set
    description: |-
      Sensitive cookies without the 'HttpOnly' flag set leaves session cookies vulnerable to
                    an XSS attack.
    kind: path-problem
    problem.severity: warning
    precision: medium
    id: java/sensitive-cookie-not-httponly
    tags: |-
      security
             experimental
             external/cwe/cwe-1004
  queryHelp: "# Sensitive cookies without the HttpOnly response header set\nCross-Site\
    \ Scripting (XSS) is categorized as one of the OWASP Top 10 Security Vulnerabilities.\
    \ The `HttpOnly` flag directs compatible browsers to prevent client-side script\
    \ from accessing cookies. Including the `HttpOnly` flag in the Set-Cookie HTTP\
    \ response header for a sensitive cookie helps mitigate the risk associated with\
    \ XSS where an attacker's script code attempts to read the contents of a cookie\
    \ and exfiltrate information obtained.\n\n\n## Recommendation\nUse the `HttpOnly`\
    \ flag when generating a cookie containing sensitive information to help mitigate\
    \ the risk of client side script accessing the protected cookie.\n\n\n## Example\n\
    The following example shows two ways of generating sensitive cookies. In the 'BAD'\
    \ cases, the `HttpOnly` flag is not set. In the 'GOOD' cases, the `HttpOnly` flag\
    \ is set.\n\n\n```java\nclass SensitiveCookieNotHttpOnly {\n    // GOOD - Create\
    \ a sensitive cookie with the `HttpOnly` flag set.\n    public void addCookie(String\
    \ jwt_token, HttpServletRequest request, HttpServletResponse response) {\n   \
    \     Cookie jwtCookie =new Cookie(\"jwt_token\", jwt_token);\n        jwtCookie.setPath(\"\
    /\");\n        jwtCookie.setMaxAge(3600*24*7);\n        jwtCookie.setHttpOnly(true);\n\
    \        response.addCookie(jwtCookie);\n    }\n\n    // BAD - Create a sensitive\
    \ cookie without the `HttpOnly` flag set.\n    public void addCookie2(String jwt_token,\
    \ String userId, HttpServletRequest request, HttpServletResponse response) {\n\
    \        Cookie jwtCookie =new Cookie(\"jwt_token\", jwt_token);\n        jwtCookie.setPath(\"\
    /\");\n        jwtCookie.setMaxAge(3600*24*7);\n        response.addCookie(jwtCookie);\n\
    \    }\n\n    // GOOD - Set a sensitive cookie header with the `HttpOnly` flag\
    \ set.\n    public void addCookie3(String authId, HttpServletRequest request,\
    \ HttpServletResponse response) {\n        response.addHeader(\"Set-Cookie\",\
    \ \"token=\" +authId + \";HttpOnly;Secure\");\n    }\n\n    // BAD - Set a sensitive\
    \ cookie header without the `HttpOnly` flag set.\n    public void addCookie4(String\
    \ authId, HttpServletRequest request, HttpServletResponse response) {\n      \
    \  response.addHeader(\"Set-Cookie\", \"token=\" +authId + \";Secure\");\n   \
    \ }\n    \n    // GOOD - Set a sensitive cookie header using the class `javax.ws.rs.core.Cookie`\
    \ with the `HttpOnly` flag set through string concatenation.\n    public void\
    \ addCookie5(String accessKey, HttpServletRequest request, HttpServletResponse\
    \ response) {\n        response.setHeader(\"Set-Cookie\", new NewCookie(\"session-access-key\"\
    , accessKey, \"/\", null, null, 0, true) + \";HttpOnly\");\n    }\n\n    // BAD\
    \ - Set a sensitive cookie header using the class `javax.ws.rs.core.Cookie` without\
    \ the `HttpOnly` flag set.\n    public void addCookie6(String accessKey, HttpServletRequest\
    \ request, HttpServletResponse response) {\n        response.setHeader(\"Set-Cookie\"\
    , new NewCookie(\"session-access-key\", accessKey, \"/\", null, null, 0, true).toString());\n\
    \    }\n\n    // GOOD - Set a sensitive cookie header using the class `javax.ws.rs.core.Cookie`\
    \ with the `HttpOnly` flag set through the constructor.\n    public void addCookie7(String\
    \ accessKey, HttpServletRequest request, HttpServletResponse response) {\n   \
    \     NewCookie accessKeyCookie = new NewCookie(\"session-access-key\", accessKey,\
    \ \"/\", null, null, 0, true, true);\n        response.setHeader(\"Set-Cookie\"\
    , accessKeyCookie.toString());\n    }\n}\n\n```\n\n## References\n* PortSwigger:\
    \ [Cookie without HttpOnly flag set](https://portswigger.net/kb/issues/00500600_cookie-without-httponly-flag-set)\n\
    * OWASP: [HttpOnly](https://owasp.org/www-community/HttpOnly)\n* Common Weakness\
    \ Enumeration: [CWE-1004](https://cwe.mitre.org/data/definitions/1004.html).\n"
 -
  pack: codeql/java-queries#0
  relativeQueryPath: experimental/Security/CWE/CWE-200/InsecureWebResourceResponse.ql
  relativeBqrsPath: codeql/java-queries/experimental/Security/CWE/CWE-200/InsecureWebResourceResponse.bqrs
  metadata:
    name: Insecure Android WebView Resource Response
    description: |-
      An insecure implementation of Android `WebResourceResponse` may lead to leakage of arbitrary
                     sensitive content.
    kind: path-problem
    id: java/insecure-webview-resource-response
    problem.severity: error
    tags: |-
      security
             experimental
             external/cwe/cwe-200
  queryHelp: |
    # Insecure Android WebView Resource Response
    Android provides a `WebResourceResponse` class, which allows an Android application to behave as a web server by handling requests of popular protocols such as `http(s)`, `file`, as well as `javascript` and returning a response (including status code, content type, content encoding, headers and the response body). Improper implementation with insufficient input validation can lead to leakage of sensitive configuration files or user data because requests could refer to paths intended to be application-private.


    ## Recommendation
    Unsanitized user-provided URLs must not be used to serve a response directly. When handling a request, always validate that the requested file path is not in the receiver's protected directory. Alternatively the Android class `WebViewAssetLoader` can be used, which safely processes data from resources, assets or a predefined directory.


    ## Example
    The following examples show a bad scenario and two good scenarios respectively. In the bad scenario, a response is served without path validation. In the good scenario, a response is either served with path validation or through the safe `WebViewAssetLoader` implementation.


    ```java
    // BAD: no URI validation
    Uri uri = Uri.parse(url);
    FileInputStream inputStream = new FileInputStream(uri.getPath());
    String mimeType = getMimeTypeFromPath(uri.getPath());
    return new WebResourceResponse(mimeType, "UTF-8", inputStream);


    // GOOD: check for a trusted prefix, ensuring path traversal is not used to erase that prefix:
    // (alternatively use `WebViewAssetsLoader`)
    if (uri.getPath().startsWith("/local_cache/") && !uri.getPath().contains("..")) {
        File cacheFile = new File(getCacheDir(), uri.getLastPathSegment());
        FileInputStream inputStream = new FileInputStream(cacheFile);
        String mimeType = getMimeTypeFromPath(uri.getPath());
        return new WebResourceResponse(mimeType, "UTF-8", inputStream);
    }

    return assetLoader.shouldInterceptRequest(request.getUrl());

    ```

    ## References
    * Oversecured: [Android: Exploring vulnerabilities in WebResourceResponse](https://blog.oversecured.com/Android-Exploring-vulnerabilities-in-WebResourceResponse/).
    * CVE: [CVE-2014-3502: Cordova apps can potentially leak data to other apps via URL loading](https://cordova.apache.org/announcements/2014/08/04/android-351.html).
    * Common Weakness Enumeration: [CWE-200](https://cwe.mitre.org/data/definitions/200.html).
 -
  pack: codeql/java-queries#0
  relativeQueryPath: experimental/Security/CWE/CWE-200/SensitiveAndroidFileLeak.ql
  relativeBqrsPath: codeql/java-queries/experimental/Security/CWE/CWE-200/SensitiveAndroidFileLeak.bqrs
  metadata:
    name: Leaking sensitive Android file
    description: |-
      Using a path specified in an Android Intent without validation could leak arbitrary
                    Android configuration file and sensitive user data.
    kind: path-problem
    id: java/sensitive-android-file-leak
    problem.severity: warning
    tags: |-
      security
             experimental
             external/cwe/cwe-200
  queryHelp: "# Leaking sensitive Android file\nThe Android API allows to start an\
    \ activity in another mobile application and receive a result back. When starting\
    \ an activity to retrieve a file from another application, missing input validation\
    \ can lead to leaking of sensitive configuration file or user data because the\
    \ intent could refer to paths which are accessible to the receiver application,\
    \ but are intended to be application-private.\n\n\n## Recommendation\nWhen loading\
    \ file data from an activity of another application, validate that the file path\
    \ is not the receiver's protected directory, which is a subdirectory of the Android\
    \ application directory `/data/data/`.\n\n\n## Example\nThe following examples\
    \ show a bad situation and a good situation respectively. In the bad situation,\
    \ a file is loaded without path validation. In the good situation, a file is loaded\
    \ with path validation.\n\n\n```java\npublic class LoadFileFromAppActivity extends\
    \ Activity {\n    public static final int REQUEST_CODE__SELECT_CONTENT_FROM_APPS\
    \ = 99;\n\n    @Override\n    protected void onActivityResult(int requestCode,\
    \ int resultCode, Intent data) {\n        if (requestCode == LoadFileFromAppActivity.REQUEST_CODE__SELECT_CONTENT_FROM_APPS\
    \ &&\n                resultCode == RESULT_OK) {\n            \n            {\n\
    \                // BAD: Load file without validation\n                loadOfContentFromApps(data,\
    \ resultCode);\n            }\n\n            {\n                // GOOD: load\
    \ file with validation\n                if (!data.getData().getPath().startsWith(\"\
    /data/data\")) {\n                    loadOfContentFromApps(data, resultCode);\n\
    \                }    \n            }\n        }\n    }\n\n    private void loadOfContentFromApps(Intent\
    \ contentIntent, int resultCode) {\n        Uri streamsToUpload = contentIntent.getData();\n\
    \        try {\n            RandomAccessFile file = new RandomAccessFile(streamsToUpload.getPath(),\
    \ \"r\");\n        } catch (Exception ex) {\n            ex.printStackTrace();\n\
    \        }\n    }\n}\n\n```\n\n## References\n* Google: [Android: Interacting\
    \ with Other Apps](https://developer.android.com/training/basics/intents).\n*\
    \ CVE: [CVE-2021-32695: File Sharing Flow Initiated by a Victim Leaks Sensitive\
    \ Data to a Malicious App](https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2021-32695).\n\
    * Common Weakness Enumeration: [CWE-200](https://cwe.mitre.org/data/definitions/200.html).\n"
 -
  pack: codeql/java-queries#0
  relativeQueryPath: experimental/Security/CWE/CWE-208/PossibleTimingAttackAgainstSignature.ql
  relativeBqrsPath: codeql/java-queries/experimental/Security/CWE/CWE-208/PossibleTimingAttackAgainstSignature.bqrs
  metadata:
    name: Possible timing attack against signature validation
    description: |-
      When checking a signature over a message, a constant-time algorithm should be used.
                    Otherwise, there is a risk of a timing attack that allows an attacker
                    to forge a valid signature for an arbitrary message. For a successful attack,
                    the attacker has to be able to send to the validation procedure both the message and the signature.
    kind: path-problem
    problem.severity: warning
    precision: medium
    id: java/possible-timing-attack-against-signature
    tags: |-
      security
             experimental
             external/cwe/cwe-208
  queryHelp: |
    # Possible timing attack against signature validation
    A constant-time algorithm should be used for checking a MAC or a digital signature. In other words, the comparison time should not depend on the content of the input. Otherwise, an attacker may be able to forge a valid signature for an arbitrary message by running a timing attack if they can send to the validation procedure both the message and the signature. A successful attack can result in authentication bypass.


    ## Recommendation
    Use `MessageDigest.isEqual()` method to check MACs and signatures. If this method is used, then the calculation time depends only on the length of input byte arrays, and does not depend on the contents of the arrays.


    ## Example
    The following example uses `Arrays.equals()` method for validating a MAC over a message. This method implements a non-constant-time algorithm. Both the message and the signature come from an untrusted HTTP request:


    ```java
    public boolean validate(HttpRequest request, SecretKey key) throws Exception {
        byte[] message = getMessageFrom(request);
        byte[] signature = getSignatureFrom(request);

        Mac mac = Mac.getInstance("HmacSHA256");
        mac.init(new SecretKeySpec(key.getEncoded(), "HmacSHA256"));
        byte[] actual = mac.doFinal(message);
        return Arrays.equals(signature, actual);
    }
    ```
    The next example uses a safe constant-time algorithm for validating a MAC:


    ```java
    public boolean validate(HttpRequest request, SecretKey key) throws Exception {
        byte[] message = getMessageFrom(request);
        byte[] signature = getSignatureFrom(request);

        Mac mac = Mac.getInstance("HmacSHA256");
        mac.init(new SecretKeySpec(key.getEncoded(), "HmacSHA256"));
        byte[] actual = mac.doFinal(message);
        return MessageDigest.isEqual(signature, actual);
    }
    ```

    ## References
    * Wikipedia: [Timing attack](https://en.wikipedia.org/wiki/Timing_attack).
    * Coursera: [Timing attacks on MAC verification](https://www.coursera.org/lecture/crypto/timing-attacks-on-mac-verification-FHGW1)
    * NCC Group: [Time Trial: Racing Towards Practical Remote Timing Attacks](https://www.nccgroup.trust/globalassets/our-research/us/whitepapers/TimeTrial.pdf)
    * Java API Specification: [MessageDigest.isEqual() method](https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/security/MessageDigest.html#isEqual(byte[],byte[]))
    * Common Weakness Enumeration: [CWE-208](https://cwe.mitre.org/data/definitions/208.html).
 -
  pack: codeql/java-queries#0
  relativeQueryPath: experimental/Security/CWE/CWE-208/TimingAttackAgainstHeader.ql
  relativeBqrsPath: codeql/java-queries/experimental/Security/CWE/CWE-208/TimingAttackAgainstHeader.bqrs
  metadata:
    name: Timing attack against header value
    description: |-
      Use of a non-constant-time verification routine to check the value of an HTTP header,
                    possibly allowing a timing attack to infer the header's expected value.
    kind: path-problem
    problem.severity: error
    precision: high
    id: java/timing-attack-against-headers-value
    tags: |-
      security
             experimental
             external/cwe/cwe-208
  queryHelp: "# Timing attack against header value\nA constant-time algorithm should\
    \ be used for checking the value of sensitive headers. In other words, the comparison\
    \ time should not depend on the content of the input. Otherwise timing information\
    \ could be used to infer the header's expected, secret value.\n\n\n## Recommendation\n\
    Use `MessageDigest.isEqual()` method to check the value of headers. If this method\
    \ is used, then the calculation time depends only on the length of input byte\
    \ arrays, and does not depend on the contents of the arrays.\n\n\n## Example\n\
    The following example uses `String.equals()` method for validating a csrf token.\
    \ This method implements a non-constant-time algorithm. The example also demonstrates\
    \ validation using a safe constant-time algorithm.\n\n\n```java\nimport javax.servlet.http.HttpServletRequest;\n\
    import java.nio.charset.StandardCharsets;\nimport java.security.MessageDigest;\n\
    import java.lang.String;\n\n\npublic class Test {\n    private boolean UnsafeComparison(HttpServletRequest\
    \ request) {\n        String Key = \"secret\";\n        return Key.equals(request.getHeader(\"\
    X-Auth-Token\"));        \n    }\n\n    private boolean safeComparison(HttpServletRequest\
    \ request) {\n          String token = request.getHeader(\"X-Auth-Token\");\n\
    \          String Key = \"secret\"; \n          return MessageDigest.isEqual(Key.getBytes(StandardCharsets.UTF_8),\
    \ token.getBytes(StandardCharsets.UTF_8));\n    }\n    \n}\n\n\n```\n"
 -
  pack: codeql/java-queries#0
  relativeQueryPath: experimental/Security/CWE/CWE-208/TimingAttackAgainstSignature.ql
  relativeBqrsPath: codeql/java-queries/experimental/Security/CWE/CWE-208/TimingAttackAgainstSignature.bqrs
  metadata:
    name: Timing attack against signature validation
    description: |-
      When checking a signature over a message, a constant-time algorithm should be used.
                    Otherwise, an attacker may be able to forge a valid signature for an arbitrary message
                    by running a timing attack if they can send to the validation procedure
                    both the message and the signature.
                    A successful attack can result in authentication bypass.
    kind: path-problem
    problem.severity: error
    precision: high
    id: java/timing-attack-against-signature
    tags: |-
      security
             experimental
             external/cwe/cwe-208
  queryHelp: |
    # Timing attack against signature validation
    A constant-time algorithm should be used for checking a MAC or a digital signature. In other words, the comparison time should not depend on the content of the input. Otherwise, an attacker may be able to forge a valid signature for an arbitrary message by running a timing attack if they can send to the validation procedure both the message and the signature. A successful attack can result in authentication bypass.


    ## Recommendation
    Use `MessageDigest.isEqual()` method to check MACs and signatures. If this method is used, then the calculation time depends only on the length of input byte arrays, and does not depend on the contents of the arrays.


    ## Example
    The following example uses `Arrays.equals()` method for validating a MAC over a message. This method implements a non-constant-time algorithm. Both the message and the signature come from an untrusted HTTP request:


    ```java
    public boolean validate(HttpRequest request, SecretKey key) throws Exception {
        byte[] message = getMessageFrom(request);
        byte[] signature = getSignatureFrom(request);

        Mac mac = Mac.getInstance("HmacSHA256");
        mac.init(new SecretKeySpec(key.getEncoded(), "HmacSHA256"));
        byte[] actual = mac.doFinal(message);
        return Arrays.equals(signature, actual);
    }
    ```
    The next example uses a safe constant-time algorithm for validating a MAC:


    ```java
    public boolean validate(HttpRequest request, SecretKey key) throws Exception {
        byte[] message = getMessageFrom(request);
        byte[] signature = getSignatureFrom(request);

        Mac mac = Mac.getInstance("HmacSHA256");
        mac.init(new SecretKeySpec(key.getEncoded(), "HmacSHA256"));
        byte[] actual = mac.doFinal(message);
        return MessageDigest.isEqual(signature, actual);
    }
    ```

    ## References
    * Wikipedia: [Timing attack](https://en.wikipedia.org/wiki/Timing_attack).
    * Coursera: [Timing attacks on MAC verification](https://www.coursera.org/lecture/crypto/timing-attacks-on-mac-verification-FHGW1)
    * NCC Group: [Time Trial: Racing Towards Practical Remote Timing Attacks](https://www.nccgroup.trust/globalassets/our-research/us/whitepapers/TimeTrial.pdf)
    * Java API Specification: [MessageDigest.isEqual() method](https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/security/MessageDigest.html#isEqual(byte[],byte[]))
    * Common Weakness Enumeration: [CWE-208](https://cwe.mitre.org/data/definitions/208.html).
 -
  pack: codeql/java-queries#0
  relativeQueryPath: experimental/Security/CWE/CWE-295/JxBrowserWithoutCertValidation.ql
  relativeBqrsPath: codeql/java-queries/experimental/Security/CWE/CWE-295/JxBrowserWithoutCertValidation.bqrs
  metadata:
    name: JxBrowser with disabled certificate validation
    description: |-
      Insecure configuration of JxBrowser disables certificate
                    validation making the app vulnerable to man-in-the-middle
                    attacks.
    kind: problem
    problem.severity: warning
    precision: medium
    id: java/jxbrowser/disabled-certificate-validation
    tags: |-
      security
             experimental
             external/cwe/cwe-295
  queryHelp: "# JxBrowser with disabled certificate validation\nJxBrowser is a Java\
    \ library that allows to embed the Chromium browser inside Java applications.\
    \ Versions smaller than 6.24 by default ignore any HTTPS certificate errors thereby\
    \ allowing man-in-the-middle attacks.\n\n\n## Recommendation\nDo either of these:\n\
    \n* Update to version 6.24 or 7.x.x as these correctly reject certificate errors\
    \ by default.\n* Add a custom implementation of the `LoadHandler` interface whose\
    \ `onCertificateError` method always returns **true** indicating that loading\
    \ should be cancelled. Then use the `setLoadHandler` method with your custom `LoadHandler`\
    \ on every `Browser` you use.\n\n## Example\nThe following two examples show two\
    \ ways of using a `Browser`. In the 'BAD' case, all certificate errors are ignored.\
    \ In the 'GOOD' case, certificate errors are rejected.\n\n\n```java\npublic static\
    \ void main(String[] args) {\n\t{\n\t\tBrowser browser = new Browser();\n\t\t\
    browser.loadURL(\"https://example.com\");\n\t\t// no further calls\n\t\t// BAD:\
    \ The browser ignores any certificate error by default!\n\t}\n\n\t{\n\t\tBrowser\
    \ browser = new Browser();\n\t\tbrowser.setLoadHandler(new LoadHandler() {\n\t\
    \t\tpublic boolean onLoad(LoadParams params) {\n\t\t\t\treturn true;\n\t\t\t}\n\
    \n\t\t\tpublic boolean onCertificateError(CertificateErrorParams params){\n\t\t\
    \t\treturn true; // GOOD: This means that loading will be cancelled on certificate\
    \ errors\n\t\t\t}\n\t\t}); // GOOD: A secure `LoadHandler` is used.\n\t\tbrowser.loadURL(\"\
    https://example.com\");\n\n\t}\n}\n```\n\n## References\n* Teamdev: [ Changelog\
    \ of JxBrowser 6.24](https://jxbrowser-support.teamdev.com/release-notes/2019/v6-24.html).\n\
    * Common Weakness Enumeration: [CWE-295](https://cwe.mitre.org/data/definitions/295.html).\n"
 -
  pack: codeql/java-queries#0
  relativeQueryPath: experimental/Security/CWE/CWE-297/IgnoredHostnameVerification.ql
  relativeBqrsPath: codeql/java-queries/experimental/Security/CWE/CWE-297/IgnoredHostnameVerification.bqrs
  metadata:
    name: Ignored result of hostname verification
    description: |-
      The method HostnameVerifier.verify() returns a result of hostname verification.
                    A caller has to check the result and drop the connection if the verification failed.
    kind: problem
    problem.severity: error
    precision: high
    id: java/ignored-hostname-verification
    tags: |-
      security
             experimental
             external/cwe/cwe-297
  queryHelp: |
    # Ignored result of hostname verification
    The method `HostnameVerifier.verify()` checks that the hostname from the server's certificate matches the server hostname after an HTTPS connection is established. The method returns `true` if the hostname is acceptable and `false` otherwise. The contract of the method does not require it to throw an exception if the verification failed. Therefore, a caller has to check the result and drop the connection if the hostname verification failed. Otherwise, an attacker may be able to implement a man-in-the-middle attack and impersonate the server.


    ## Recommendation
    Always check the result of `HostnameVerifier.verify()` and drop the connection if the method returns false.


    ## Example
    In the following example, the method `HostnameVerifier.verify()` is called but its result is ignored. As a result, no hostname verification actually happens.


    ```java
    public SSLSocket connect(String host, int port, HostnameVerifier verifier) {
        SSLSocket socket = (SSLSocket) SSLSocketFactory.getDefault().createSocket(host, port);
        socket.startHandshake();
        verifier.verify(host, socket.getSession());
        return socket;
    }
    ```
    In the next example, the result of the `HostnameVerifier.verify()` method is checked and an exception is thrown if the verification failed.


    ```java
    public SSLSocket connect(String host, int port, HostnameVerifier verifier) {
        SSLSocket socket = (SSLSocket) SSLSocketFactory.getDefault().createSocket(host, port);
        socket.startHandshake();
        boolean successful = verifier.verify(host, socket.getSession());
        if (!successful) {
            socket.close();
            throw new SSLException("Oops! Hostname verification failed!");
        }
        return socket;
    }
    ```

    ## References
    * Java API Specification: [HostnameVerifier.verify() method](https://docs.oracle.com/en/java/javase/11/docs/api/java.base/javax/net/ssl/HostnameVerifier.html#verify(java.lang.String,javax.net.ssl.SSLSession)).
    * Common Weakness Enumeration: [CWE-297](https://cwe.mitre.org/data/definitions/297.html).
 -
  pack: codeql/java-queries#0
  relativeQueryPath: experimental/Security/CWE/CWE-297/InsecureLdapEndpoint.ql
  relativeBqrsPath: codeql/java-queries/experimental/Security/CWE/CWE-297/InsecureLdapEndpoint.bqrs
  metadata:
    name: Insecure LDAPS Endpoint Configuration
    description: |-
      Java application configured to disable LDAPS endpoint
                    identification does not validate the SSL certificate to
                    properly ensure that it is actually associated with that host.
    kind: problem
    problem.severity: warning
    precision: medium
    id: java/insecure-ldaps-endpoint
    tags: |-
      security
             experimental
             external/cwe/cwe-297
  queryHelp: |
    # Insecure LDAPS Endpoint Configuration
    Java versions 8u181 or greater have enabled LDAPS endpoint identification by default. Nowadays infrastructure services like LDAP are commonly deployed behind load balancers therefore the LDAP server name can be different from the FQDN of the LDAPS endpoint. If a service certificate does not properly contain a matching DNS name as part of the certificate, Java will reject it by default.

    Instead of addressing the issue properly by having a compliant certificate deployed, frequently developers simply disable the LDAPS endpoint check.

    Failing to validate the certificate makes the SSL session susceptible to a man-in-the-middle attack. This query checks whether the LDAPS endpoint check is disabled in system properties.


    ## Recommendation
    Replace any non-conforming LDAP server certificates to include a DNS name in the subjectAltName field of the certificate that matches the FQDN of the service.


    ## Example
    The following two examples show two ways of configuring LDAPS endpoint. In the 'BAD' case, endpoint check is disabled. In the 'GOOD' case, endpoint check is left enabled through the default Java configuration.


    ```java
    public class InsecureLdapEndpoint {
        public Hashtable<String, String> createConnectionEnv() {
            Hashtable<String, String> env = new Hashtable<String, String>();
            env.put(Context.INITIAL_CONTEXT_FACTORY, "com.sun.jndi.ldap.LdapCtxFactory");
            env.put(Context.PROVIDER_URL, "ldaps://ad.your-server.com:636");

            env.put(Context.SECURITY_AUTHENTICATION, "simple");
            env.put(Context.SECURITY_PRINCIPAL, "username");
            env.put(Context.SECURITY_CREDENTIALS, "secpassword");

            // BAD - Test configuration with disabled SSL endpoint check.
            {
                System.setProperty("com.sun.jndi.ldap.object.disableEndpointIdentification", "true");
            }

            return env;
        }
    }

    ```

    ```java
    public class InsecureLdapEndpoint2 {
        public Hashtable<String, String> createConnectionEnv() {
            Hashtable<String, String> env = new Hashtable<String, String>();
            env.put(Context.INITIAL_CONTEXT_FACTORY, "com.sun.jndi.ldap.LdapCtxFactory");
            env.put(Context.PROVIDER_URL, "ldaps://ad.your-server.com:636");

            env.put(Context.SECURITY_AUTHENTICATION, "simple");
            env.put(Context.SECURITY_PRINCIPAL, "username");
            env.put(Context.SECURITY_CREDENTIALS, "secpassword");

            // GOOD - No configuration to disable SSL endpoint check since it is enabled by default.
            {
            }

            return env;
        }
    }

    ```

    ## References
    * Oracle Java 8 Update 181 (8u181): [Endpoint identification enabled on LDAPS connections](https://www.java.com/en/download/help/release_changes.html)
    * IBM: [Fix this LDAP SSL error](https://www.ibm.com/support/pages/how-do-i-fix-ldap-ssl-error-%E2%80%9Cjavasecuritycertcertificateexception-no-subject-alternative-names-present%E2%80%9D-websphere-application-server)
    * Common Weakness Enumeration: [CWE-297](https://cwe.mitre.org/data/definitions/297.html).
 -
  pack: codeql/java-queries#0
  relativeQueryPath: experimental/Security/CWE/CWE-299/DisabledRevocationChecking.ql
  relativeBqrsPath: codeql/java-queries/experimental/Security/CWE/CWE-299/DisabledRevocationChecking.bqrs
  metadata:
    name: Disabled certificate revocation checking
    description: |-
      Using revoked certificates is dangerous.
                    Therefore, revocation status of certificates in a chain should be checked.
    kind: path-problem
    problem.severity: error
    precision: high
    id: java/disabled-certificate-revocation-checking
    tags: |-
      security
             experimental
             external/cwe/cwe-299
  queryHelp: |
    # Disabled certificate revocation checking
    Validating a certificate chain includes multiple steps. One of them is checking whether or not certificates in the chain have been revoked. A certificate may be revoked due to multiple reasons. One of the reasons why the certificate authority (CA) may revoke a certificate is that its private key has been compromised. For example, the private key might have been stolen by an adversary. In this case, the adversary may be able to impersonate the owner of the private key. Therefore, trusting a revoked certificate may be dangerous.

    The Java Certification Path API provides a revocation checking mechanism that supports both CRL and OCSP. Revocation checking happens while building and validating certificate chains. If at least one of the certificates is revoked, then an exception is thrown. This mechanism is enabled by default. However, it may be disabled by passing `false` to the `PKIXParameters.setRevocationEnabled()` method. If an application doesn't set a custom `PKIXRevocationChecker` via `PKIXParameters.addCertPathChecker()` or `PKIXParameters.setCertPathCheckers()` methods, then revocation checking is not going to happen.


    ## Recommendation
    An application should not disable the default revocation checking mechanism unless it provides a custom revocation checker.


    ## Example
    The following example turns off revocation checking for validating a certificate chain. That should be avoided.


    ```java
    public void validateUnsafe(KeyStore cacerts, CertPath chain) throws Exception {
        CertPathValidator validator = CertPathValidator.getInstance("PKIX");
        PKIXParameters params = new PKIXParameters(cacerts);
        params.setRevocationEnabled(false);
        validator.validate(chain, params);
    }
    ```
    The next example uses the default revocation checking mechanism.


    ```java
    public void validate(KeyStore cacerts, CertPath chain) throws Exception {
        CertPathValidator validator = CertPathValidator.getInstance("PKIX");
        PKIXParameters params = new PKIXParameters(cacerts);
        validator.validate(chain, params);
    }
    ```
    The third example turns off the default revocation mechanism. However, it registers another revocation checker that uses OCSP to obtain revocation status of certificates.


    ```java
    public void validate(KeyStore cacerts, CertPath certPath) throws Exception {
        CertPathValidator validator = CertPathValidator.getInstance("PKIX");
        PKIXParameters params = new PKIXParameters(cacerts);
        params.setRevocationEnabled(false);
        PKIXRevocationChecker checker = (PKIXRevocationChecker) validator.getRevocationChecker();
        checker.setOcspResponder(OCSP_RESPONDER_URL);
        checker.setOcspResponderCert(OCSP_RESPONDER_CERT);
        params.addCertPathChecker(checker);
        validator.validate(certPath, params);
    }
    ```

    ## References
    * Wikipedia: [Public key certificate](https://en.wikipedia.org/wiki/Public_key_certificate)
    * Java SE Documentation: [Java PKI Programmer's Guide](https://docs.oracle.com/javase/8/docs/technotes/guides/security/certpath/CertPathProgGuide.html)
    * Java API Specification: [CertPathValidator](https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/security/cert/CertPathValidator.html)
    * Common Weakness Enumeration: [CWE-299](https://cwe.mitre.org/data/definitions/299.html).
 -
  pack: codeql/java-queries#0
  relativeQueryPath: experimental/Security/CWE/CWE-327/Azure/UnsafeUsageOfClientSideEncryptionVersion.ql
  relativeBqrsPath: codeql/java-queries/experimental/Security/CWE/CWE-327/Azure/UnsafeUsageOfClientSideEncryptionVersion.bqrs
  metadata:
    name: Unsafe usage of v1 version of Azure Storage client-side encryption (CVE-2022-30187).
    description: "Unsafe usage of v1 version of Azure Storage client-side encryption,\
      \ please refer to http://aka.ms/azstorageclientencryptionblog"
    kind: problem
    tags: |-
      security
             cryptography
             external/cwe/cwe-327
    id: java/azure-storage/unsafe-client-side-encryption-in-use
    problem.severity: error
    precision: high
  queryHelp: |
    # Unsafe usage of v1 version of Azure Storage client-side encryption (CVE-2022-30187).
    Azure Storage .NET, Java, and Python SDKs support encryption on the client with a customer-managed key that is maintained in Azure Key Vault or another key store.

    The Azure Storage SDK version 12.18.0 or later supports version `V2` for client-side encryption. All previous versions of Azure Storage SDK only support client-side encryption `V1` which is unsafe.


    ## Recommendation
    Consider switching to `V2` client-side encryption.


    ## Example

    ```java

    // BAD: Using an outdated SDK that does not support client side encryption version V2_0
    new EncryptedBlobClientBuilder()
            .blobClient(blobClient)
            .key(resolver.buildAsyncKeyEncryptionKey(keyid).block(), keyWrapAlgorithm)
            .buildEncryptedBlobClient()
            .uploadWithResponse(new BlobParallelUploadOptions(data)
                            .setMetadata(metadata)
                            .setHeaders(headers)
                            .setTags(tags)
                            .setTier(tier)
                            .setRequestConditions(requestConditions)
                            .setComputeMd5(computeMd5)
                            .setParallelTransferOptions(parallelTransferOptions),
                    timeout, context);

    // BAD: Using the deprecatedd client side encryption version V1_0
    new EncryptedBlobClientBuilder(EncryptionVersion.V1)
            .blobClient(blobClient)
            .key(resolver.buildAsyncKeyEncryptionKey(keyid).block(), keyWrapAlgorithm)
            .buildEncryptedBlobClient()
            .uploadWithResponse(new BlobParallelUploadOptions(data)
                            .setMetadata(metadata)
                            .setHeaders(headers)
                            .setTags(tags)
                            .setTier(tier)
                            .setRequestConditions(requestConditions)
                            .setComputeMd5(computeMd5)
                            .setParallelTransferOptions(parallelTransferOptions),
                    timeout, context);


    // GOOD: Using client side encryption version V2_0
    new EncryptedBlobClientBuilder(EncryptionVersion.V2)
            .blobClient(blobClient)
            .key(resolver.buildAsyncKeyEncryptionKey(keyid).block(), keyWrapAlgorithm)
            .buildEncryptedBlobClient()
            .uploadWithResponse(new BlobParallelUploadOptions(data)
                            .setMetadata(metadata)
                            .setHeaders(headers)
                            .setTags(tags)
                            .setTier(tier)
                            .setRequestConditions(requestConditions)
                            .setComputeMd5(computeMd5)
                            .setParallelTransferOptions(parallelTransferOptions),
                    timeout, context);

    ```

    ## References
    * [Azure Storage Client Encryption Blog.](http://aka.ms/azstorageclientencryptionblog)
    * [CVE-2022-30187](https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2022-30187)
    * Common Weakness Enumeration: [CWE-327](https://cwe.mitre.org/data/definitions/327.html).
 -
  pack: codeql/java-queries#0
  relativeQueryPath: experimental/Security/CWE/CWE-327/UnsafeTlsVersion.ql
  relativeBqrsPath: codeql/java-queries/experimental/Security/CWE/CWE-327/UnsafeTlsVersion.bqrs
  metadata:
    name: Unsafe TLS version
    description: |-
      SSL and older TLS versions are known to be vulnerable.
                    TLS 1.3 or at least TLS 1.2 should be used.
    kind: path-problem
    problem.severity: error
    precision: high
    id: java/unsafe-tls-version
    tags: |-
      security
             experimental
             external/cwe/cwe-327
  queryHelp: "# Unsafe TLS version\nTransport Layer Security (TLS) provides a number\
    \ of security features such as confidentiality, integrity, replay prevention and\
    \ authentication. There are several versions of TLS protocols. The latest is TLS\
    \ 1.3. Unfortunately, older versions were found to be vulnerable to a number of\
    \ attacks.\n\n\n## Recommendation\nAn application should use TLS 1.3. Currently,\
    \ TLS 1.2 is also considered acceptable.\n\n\n## Example\nThe following example\
    \ shows how a socket with an unsafe TLS version may be created:\n\n\n```java\n\
    public SSLSocket connect(String host, int port)\n        throws NoSuchAlgorithmException,\
    \ IOException {\n    \n    SSLContext context = SSLContext.getInstance(\"SSLv3\"\
    );\n    return (SSLSocket) context.getSocketFactory().createSocket(host, port);\n\
    }\n```\nThe next example creates a socket with the latest TLS version:\n\n\n```java\n\
    public SSLSocket connect(String host, int port)\n        throws NoSuchAlgorithmException,\
    \ IOException {\n    \n    SSLContext context = SSLContext.getInstance(\"TLSv1.3\"\
    );\n    return (SSLSocket) context.getSocketFactory().createSocket(host, port);\n\
    }\n```\n\n## References\n* Wikipedia: [Transport Layer Security](https://en.wikipedia.org/wiki/Transport_Layer_Security)\n\
    * OWASP: [Transport Layer Protection Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/Transport_Layer_Protection_Cheat_Sheet.html)\n\
    * Java SE Documentation: [Java Secure Socket Extension (JSSE) Reference Guide](https://docs.oracle.com/javase/8/docs/technotes/guides/security/jsse/JSSERefGuide.html)\n\
    * Java API Specification: [SSLContext](https://docs.oracle.com/en/java/javase/11/docs/api/java.base/javax/net/ssl/SSLContext.html)\n\
    * Java API Specification: [SSLParameters](https://docs.oracle.com/en/java/javase/11/docs/api/java.base/javax/net/ssl/SSLParameters.html)\n\
    * Java API Specification: [SSLSocket](https://docs.oracle.com/en/java/javase/11/docs/api/java.base/javax/net/ssl/SSLSocket.html)\n\
    * Common Weakness Enumeration: [CWE-327](https://cwe.mitre.org/data/definitions/327.html).\n"
 -
  pack: codeql/java-queries#0
  relativeQueryPath: experimental/Security/CWE/CWE-346/UnvalidatedCors.ql
  relativeBqrsPath: codeql/java-queries/experimental/Security/CWE/CWE-346/UnvalidatedCors.bqrs
  metadata:
    name: CORS is derived from untrusted input
    description: "CORS header is derived from untrusted input, allowing a remote user\
      \ to control which origins are trusted."
    kind: path-problem
    problem.severity: error
    precision: high
    id: java/unvalidated-cors-origin-set
    tags: |-
      security
             experimental
             external/cwe/cwe-346
  queryHelp: |
    # CORS is derived from untrusted input
    A server can send the `Access-Control-Allow-Credentials` CORS header to control when a browser may send user credentials in Cross-Origin HTTP requests.

    When the `Access-Control-Allow-Credentials` header is `true`, the `Access-Control-Allow-Origin` header must have a value different from `*` in order for browsers to accept the header. Therefore, to allow multiple origins for cross-origin requests with credentials, the server must dynamically compute the value of the `Access-Control-Allow-Origin` header. Computing this header value from information in the request to the server can therefore potentially allow an attacker to control the origins that the browser sends credentials to.


    ## Recommendation
    When the `Access-Control-Allow-Credentials` header value is `true`, a dynamic computation of the `Access-Control-Allow-Origin` header must involve sanitization if it relies on user-controlled input.

    Since the `null` origin is easy to obtain for an attacker, it is never safe to use `null` as the value of the `Access-Control-Allow-Origin` header when the `Access-Control-Allow-Credentials` header value is `true`.A null origin can be set by an attacker using a sandboxed iframe. A more detailed explanation is available in the portswigger blogpost referenced below.


    ## Example
    In the example below, the server allows the browser to send user credentials in a cross-origin request. The request header `origins` controls the allowed origins for such a Cross-Origin request.


    ```java
    import java.io.IOException;

    import javax.servlet.Filter;
    import javax.servlet.FilterChain;
    import javax.servlet.FilterConfig;
    import javax.servlet.ServletException;
    import javax.servlet.ServletRequest;
    import javax.servlet.ServletResponse;
    import javax.servlet.http.HttpServletRequest;
    import javax.servlet.http.HttpServletResponse;

    import org.apache.commons.lang3.StringUtils;

    public class CorsFilter implements Filter {
        public void init(FilterConfig filterConfig) throws ServletException {}

        public void doFilter(ServletRequest req, ServletResponse res,
                FilterChain chain) throws IOException, ServletException {
            HttpServletRequest request = (HttpServletRequest) req;
            HttpServletResponse response = (HttpServletResponse) res;
            String url = request.getHeader("Origin");

            if (!StringUtils.isEmpty(url)) {
                String val = response.getHeader("Access-Control-Allow-Origin");

                if (StringUtils.isEmpty(val)) {
                    response.addHeader("Access-Control-Allow-Origin", url); // BAD -> User controlled CORS header being set here.
                    response.addHeader("Access-Control-Allow-Credentials", "true");
                }
            }

            if (!StringUtils.isEmpty(url)) {
                List<String> checkorigins = Arrays.asList("www.example.com", "www.sub.example.com");

                if (checkorigins.contains(url)) { // GOOD -> Origin is validated here.
                    response.addHeader("Access-Control-Allow-Origin", url);
                    response.addHeader("Access-Control-Allow-Credentials", "true");
                }
            }

            chain.doFilter(req, res);
        }

        public void destroy() {}
    }

    ```

    ## References
    * Mozilla Developer Network: [CORS, Access-Control-Allow-Origin](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Access-Control-Allow-Origin).
    * Mozilla Developer Network: [CORS, Access-Control-Allow-Credentials](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Access-Control-Allow-Credentials).
    * PortSwigger: [Exploiting CORS Misconfigurations for Bitcoins and Bounties](http://blog.portswigger.net/2016/10/exploiting-cors-misconfigurations-for.html)
    * W3C: [CORS for developers, Advice for Resource Owners](https://w3c.github.io/webappsec-cors-for-developers/#resources)
    * Common Weakness Enumeration: [CWE-346](https://cwe.mitre.org/data/definitions/346.html).
 -
  pack: codeql/java-queries#0
  relativeQueryPath: experimental/Security/CWE/CWE-347/Auth0NoVerifier.ql
  relativeBqrsPath: codeql/java-queries/experimental/Security/CWE/CWE-347/Auth0NoVerifier.bqrs
  metadata:
    name: Missing JWT signature check
    description: Failing to check the Json Web Token (JWT) signature may allow an
      attacker to forge their own tokens.
    kind: path-problem
    problem.severity: error
    security-severity: 7.8
    precision: high
    id: java/missing-jwt-signature-check-auth0
    tags: |-
      security
             external/cwe/cwe-347
  queryHelp: |
    # Missing JWT signature check
    A JSON Web Token (JWT) is used for authenticating and managing users in an application. It must be verified in order to ensure the JWT is genuine.


    ## Recommendation
    Don't use information from a JWT without verifying that JWT.


    ## Example
    The following example illustrates secure and insecure use of the Auth0 \`java-jwt\` library.


    ```java
    package com.example.JwtTest;

    import java.io.*;
    import java.security.NoSuchAlgorithmException;
    import java.util.Objects;
    import java.util.Optional;
    import javax.crypto.KeyGenerator;
    import javax.servlet.http.*;
    import javax.servlet.annotation.*;
    import com.auth0.jwt.JWT;
    import com.auth0.jwt.JWTVerifier;
    import com.auth0.jwt.algorithms.Algorithm;
    import com.auth0.jwt.exceptions.JWTCreationException;
    import com.auth0.jwt.exceptions.JWTVerificationException;
    import com.auth0.jwt.interfaces.DecodedJWT;

    @WebServlet(name = "JwtTest1", value = "/Auth")
    public class auth0 extends HttpServlet {

      public void doPost(HttpServletRequest request, HttpServletResponse response) throws IOException {
        response.setContentType("text/html");
        PrintWriter out = response.getWriter();

        // OK: first decode without signature verification
        // and then verify with signature verification
        String JwtToken1 = request.getParameter("JWT1");
        String userName =  decodeToken(JwtToken1);
        verifyToken(JwtToken1, "A Securely generated Key");
        if (Objects.equals(userName, "Admin")) {
          out.println("<html><body>");
          out.println("<h1>" + "heyyy Admin" + "</h1>");
          out.println("</body></html>");
        }

        out.println("<html><body>");
        out.println("<h1>" + "heyyy Nobody" + "</h1>");
        out.println("</body></html>");
      }

      public void doGet(HttpServletRequest request, HttpServletResponse response) throws IOException {
        response.setContentType("text/html");
        PrintWriter out = response.getWriter();

        // NOT OK:  only decode, no verification
        String JwtToken2 = request.getParameter("JWT2");
        String userName = decodeToken(JwtToken2);
        if (Objects.equals(userName, "Admin")) {
          out.println("<html><body>");
          out.println("<h1>" + "heyyy Admin" + "</h1>");
          out.println("</body></html>");
        }

        // OK:  no clue of the use of unsafe decoded JWT return value
        JwtToken2 = request.getParameter("JWT2");
        JWT.decode(JwtToken2);


        out.println("<html><body>");
        out.println("<h1>" + "heyyy Nobody" + "</h1>");
        out.println("</body></html>");
      }

      public static boolean verifyToken(final String token, final String key) {
        try {
          JWTVerifier verifier = JWT.require(Algorithm.HMAC256(key)).build();
          verifier.verify(token);
          return true;
        } catch (JWTVerificationException e) {
          System.out.printf("jwt decode fail, token: %s", e);
        }
        return false;
      }


      public static String decodeToken(final String token) {
        DecodedJWT jwt = JWT.decode(token);
        return Optional.of(jwt).map(item -> item.getClaim("userName").asString()).orElse("");
      }

    }

    ```

    ## References
    * [The incorrect use of JWT in ShenyuAdminBootstrap allows an attacker to bypass authentication.](https://nvd.nist.gov/vuln/detail/CVE-2021-37580)
    * Common Weakness Enumeration: [CWE-347](https://cwe.mitre.org/data/definitions/347.html).
 -
  pack: codeql/java-queries#0
  relativeQueryPath: experimental/Security/CWE/CWE-348/ClientSuppliedIpUsedInSecurityCheck.ql
  relativeBqrsPath: codeql/java-queries/experimental/Security/CWE/CWE-348/ClientSuppliedIpUsedInSecurityCheck.bqrs
  metadata:
    name: IP address spoofing
    description: |-
      A remote endpoint identifier is read from an HTTP header. Attackers can modify the value
                    of the identifier to forge the client ip.
    kind: path-problem
    problem.severity: error
    precision: high
    id: java/ip-address-spoofing
    tags: |-
      security
             experimental
             external/cwe/cwe-348
  queryHelp: |
    # IP address spoofing
    An original client IP address is retrieved from an http header (`X-Forwarded-For` or `X-Real-IP` or `Proxy-Client-IP` etc.), which is used to ensure security. Attackers can forge the value of these identifiers to bypass a ban-list, for example.


    ## Recommendation
    Do not trust the values of HTTP headers allegedly identifying the originating IP. If you are aware your application will run behind some reverse proxies then the last entry of a `X-Forwarded-For` header value may be more trustworthy than the rest of it because some reverse proxies append the IP address they observed to the end of any remote-supplied header.


    ## Example
    The following examples show the bad case and the good case respectively. In `bad1` method and `bad2` method, the client ip the `X-Forwarded-For` is split into comma-separated values, but the less-trustworthy first one is used. Both of these examples could be deceived by providing a forged HTTP header. The method `good1` similarly splits an `X-Forwarded-For` value, but uses the last, more-trustworthy entry.


    ```java
    import javax.servlet.http.HttpServletRequest;
    import org.apache.commons.lang3.StringUtils;
    import org.springframework.beans.factory.annotation.Autowired;
    import org.springframework.stereotype.Controller;
    import org.springframework.web.bind.annotation.GetMapping;
    import org.springframework.web.bind.annotation.ResponseBody;

    @Controller
    public class ClientSuppliedIpUsedInSecurityCheck {

        @Autowired
        private HttpServletRequest request;

        @GetMapping(value = "bad1")
        public void bad1(HttpServletRequest request) {
            String ip = getClientIP();
            if (!StringUtils.startsWith(ip, "192.168.")) {
                new Exception("ip illegal");
            }
        }

        @GetMapping(value = "bad2")
        public void bad2(HttpServletRequest request) {
            String ip = getClientIP();
            if (!"127.0.0.1".equals(ip)) {
                new Exception("ip illegal");
            }
        }

        @GetMapping(value = "good1")
        @ResponseBody
        public String good1(HttpServletRequest request) {
            String ip = request.getHeader("X-FORWARDED-FOR");
            // Good: if this application runs behind a reverse proxy it may append the real remote IP to the end of any client-supplied X-Forwarded-For header.
            ip = ip.split(",")[ip.split(",").length - 1];
            if (!StringUtils.startsWith(ip, "192.168.")) {
                new Exception("ip illegal");
            }
            return ip;
        }

        protected String getClientIP() {
            String xfHeader = request.getHeader("X-Forwarded-For");
            if (xfHeader == null) {
                return request.getRemoteAddr();
            }
            return xfHeader.split(",")[0];
        }
    }

    ```

    ## References
    * Dennis Schneider: [ Prevent IP address spoofing with X-Forwarded-For header when using AWS ELB and Clojure Ring](https://www.dennis-schneider.com/blog/prevent-ip-address-spoofing-with-x-forwarded-for-header-and-aws-elb-in-clojure-ring/)
    * Security Rule Zero: [A Warning about X-Forwarded-For](https://www.f5.com/company/blog/security-rule-zero-a-warning-about-x-forwarded-for)
    * Common Weakness Enumeration: [CWE-348](https://cwe.mitre.org/data/definitions/348.html).
 -
  pack: codeql/java-queries#0
  relativeQueryPath: experimental/Security/CWE/CWE-352/JsonpInjection.ql
  relativeBqrsPath: codeql/java-queries/experimental/Security/CWE/CWE-352/JsonpInjection.bqrs
  metadata:
    name: JSONP Injection
    description: |-
      User-controlled callback function names that are not verified are vulnerable
                    to jsonp injection attacks.
    kind: path-problem
    problem.severity: error
    precision: high
    id: java/jsonp-injection
    tags: |-
      security
             experimental
             external/cwe/cwe-352
  queryHelp: |
    # JSONP Injection
    The software uses external input as the function name to wrap JSON data and returns it to the client as a request response. When there is a cross-domain problem, this could lead to information leakage.


    ## Recommendation
    Adding `Referer`/`Origin` or random `token` verification processing can effectively prevent the leakage of sensitive information.


    ## Example
    The following examples show the bad case and the good case respectively. Bad cases, such as `bad1` to `bad7`, will cause information leakage when there are cross-domain problems. In a good case, for example, in the `good1` method and the `good2` method, When these two methods process the request, there must be a request body in the request, which does not meet the conditions of Jsonp injection.


    ```java
    import com.alibaba.fastjson.JSONObject;
    import com.fasterxml.jackson.databind.ObjectMapper;
    import com.google.gson.Gson;
    import java.io.BufferedReader;
    import java.io.IOException;
    import java.io.InputStreamReader;
    import java.io.PrintWriter;
    import java.util.HashMap;
    import javax.servlet.http.HttpServletRequest;
    import javax.servlet.http.HttpServletResponse;
    import org.springframework.stereotype.Controller;
    import org.springframework.web.bind.annotation.GetMapping;
    import org.springframework.web.bind.annotation.RequestMapping;
    import org.springframework.web.bind.annotation.RequestMethod;
    import org.springframework.web.bind.annotation.RequestParam;
    import org.springframework.web.bind.annotation.ResponseBody;
    import org.springframework.web.multipart.MultipartFile;

    @Controller
    public class JsonpInjection {

        private static HashMap hashMap = new HashMap();

        static {
            hashMap.put("username","admin");
            hashMap.put("password","123456");
        }

        @GetMapping(value = "jsonp1")
        @ResponseBody
        public String bad1(HttpServletRequest request) {
            String resultStr = null;
            String jsonpCallback = request.getParameter("jsonpCallback");
            Gson gson = new Gson();
            String result = gson.toJson(hashMap);
            resultStr = jsonpCallback + "(" + result + ")";
            return resultStr;
        }

        @GetMapping(value = "jsonp2")
        @ResponseBody
        public String bad2(HttpServletRequest request) {
            String resultStr = null;
            String jsonpCallback = request.getParameter("jsonpCallback");
            resultStr = jsonpCallback + "(" + JSONObject.toJSONString(hashMap) + ")";
            return resultStr;
        }

        @GetMapping(value = "jsonp3")
        @ResponseBody
        public String bad3(HttpServletRequest request) {
            String resultStr = null;
            String jsonpCallback = request.getParameter("jsonpCallback");
            String jsonStr = getJsonStr(hashMap);
            resultStr = jsonpCallback + "(" + jsonStr + ")";
            return resultStr;
        }

        @GetMapping(value = "jsonp4")
        @ResponseBody
        public String bad4(HttpServletRequest request) {
            String resultStr = null;
            String jsonpCallback = request.getParameter("jsonpCallback");
            String restr = JSONObject.toJSONString(hashMap);
            resultStr = jsonpCallback + "(" + restr + ");";
            return resultStr;
        }

        @GetMapping(value = "jsonp5")
        @ResponseBody
        public void bad5(HttpServletRequest request,
                HttpServletResponse response) throws Exception {
            String jsonpCallback = request.getParameter("jsonpCallback");
            PrintWriter pw = null;
            Gson gson = new Gson();
            String result = gson.toJson(hashMap);
            String resultStr = null;
            pw = response.getWriter();
            resultStr = jsonpCallback + "(" + result + ")";
            pw.println(resultStr);
        }

        @GetMapping(value = "jsonp6")
        @ResponseBody
        public void bad6(HttpServletRequest request,
                HttpServletResponse response) throws Exception {
            String jsonpCallback = request.getParameter("jsonpCallback");
            PrintWriter pw = null;
            ObjectMapper mapper = new ObjectMapper();
            String result = mapper.writeValueAsString(hashMap);
            String resultStr = null;
            pw = response.getWriter();
            resultStr = jsonpCallback + "(" + result + ")";
            pw.println(resultStr);
        }

        @RequestMapping(value = "jsonp7", method = RequestMethod.GET)
        @ResponseBody
        public String bad7(HttpServletRequest request) {
            String resultStr = null;
            String jsonpCallback = request.getParameter("jsonpCallback");
            Gson gson = new Gson();
            String result = gson.toJson(hashMap);
            resultStr = jsonpCallback + "(" + result + ")";
            return resultStr;
        }

        @RequestMapping(value = "jsonp11")
        @ResponseBody
        public String good1(HttpServletRequest request) {
            JSONObject parameterObj = readToJSONObect(request);
            String resultStr = null;
            String jsonpCallback = request.getParameter("jsonpCallback");
            String restr = JSONObject.toJSONString(hashMap);
            resultStr = jsonpCallback + "(" + restr + ");";
            return resultStr;
        }

        @RequestMapping(value = "jsonp12")
        @ResponseBody
        public String good2(@RequestParam("file") MultipartFile file,HttpServletRequest request) {
            if(null == file){
                return "upload file error";
            }
            String fileName = file.getOriginalFilename();
            System.out.println("file operations");
            String resultStr = null;
            String jsonpCallback = request.getParameter("jsonpCallback");
            String restr = JSONObject.toJSONString(hashMap);
            resultStr = jsonpCallback + "(" + restr + ");";
            return resultStr;
        }

        public static JSONObject readToJSONObect(HttpServletRequest request){
            String jsonText = readPostContent(request);
            JSONObject jsonObj = JSONObject.parseObject(jsonText, JSONObject.class);
            return jsonObj;
        }

        public static String readPostContent(HttpServletRequest request){
            BufferedReader in= null;
            String content = null;
            String line = null;
            try {
                in = new BufferedReader(new InputStreamReader(request.getInputStream(),"UTF-8"));
                StringBuilder buf = new StringBuilder();
                while ((line = in.readLine()) != null) {
                    buf.append(line);
                }
                content = buf.toString();
            } catch (IOException e) {
                e.printStackTrace();
            }
            String uri = request.getRequestURI();
            return content;
        }

        public static String getJsonStr(Object result) {
            return JSONObject.toJSONString(result);
        }
    }
    ```

    ## References
    * OWASPLondon20161124_JSON_Hijacking_Gareth_Heyes: [JSON hijacking](https://owasp.org/www-chapter-london/assets/slides/OWASPLondon20161124_JSON_Hijacking_Gareth_Heyes.pdf).
    * Practical JSONP Injection: [ Completely controllable from the URL (GET variable) ](https://securitycafe.ro/2017/01/18/practical-jsonp-injection).
    * Common Weakness Enumeration: [CWE-352](https://cwe.mitre.org/data/definitions/352.html).
 -
  pack: codeql/java-queries#0
  relativeQueryPath: experimental/Security/CWE/CWE-400/LocalThreadResourceAbuse.ql
  relativeBqrsPath: codeql/java-queries/experimental/Security/CWE/CWE-400/LocalThreadResourceAbuse.bqrs
  metadata:
    name: Uncontrolled thread resource consumption from local input source
    description: |-
      Using user input directly to control a thread's sleep time could lead to
                    performance problems or even resource exhaustion.
    kind: path-problem
    id: java/local-thread-resource-abuse
    problem.severity: recommendation
    tags: |-
      security
             external/cwe/cwe-400
  queryHelp: "# Uncontrolled thread resource consumption from local input source\n\
    The `Thread.sleep` method is used to pause the execution of current thread for\
    \ specified time. When the sleep time is user-controlled, especially in the web\
    \ application context, it can be abused to cause all of a server's threads to\
    \ sleep, leading to denial of service.\n\n\n## Recommendation\nTo guard against\
    \ this attack, consider specifying an upper range of allowed sleep time or adopting\
    \ the producer/consumer design pattern with `Object.wait` method to avoid performance\
    \ problems or even resource exhaustion. For more information, refer to the concurrency\
    \ tutorial of Oracle listed below or `java/ql/src/Likely Bugs/Concurrency` queries\
    \ of CodeQL.\n\n\n## Example\nThe following example shows a bad situation and\
    \ a good situation respectively. In the bad situation, a thread sleep time comes\
    \ directly from user input. In the good situation, an upper range check on the\
    \ maximum sleep time allowed is enforced.\n\n\n```java\nclass SleepTest {\n\t\
    public void test(int userSuppliedWaitTime) throws Exception {\n\t\t// BAD: no\
    \ boundary check on wait time\n\t\tThread.sleep(userSuppliedWaitTime);\n\n\t\t\
    // GOOD: enforce an upper limit on wait time\n\t\tif (userSuppliedWaitTime > 0\
    \ && userSuppliedWaitTime < 5000) {\n\t\t\tThread.sleep(userSuppliedWaitTime);\n\
    \t\t}\n\t}\n}\n\n```\n\n## References\n* Snyk: [Denial of Service (DoS) in com.googlecode.gwtupload:gwtupload](https://snyk.io/vuln/SNYK-JAVA-COMGOOGLECODEGWTUPLOAD-569506).\n\
    * gwtupload: [\\[Fix DOS issue\\] Updating the AbstractUploadListener.java file](https://github.com/manolo/gwtupload/issues/33).\n\
    * The blog of a gypsy engineer: [ CVE-2019-17555: DoS via Retry-After header in\
    \ Apache Olingo](https://blog.gypsyengineer.com/en/security/cve-2019-17555-dos-via-retry-after-header-in-apache-olingo.html).\n\
    * Oracle: [The Java Concurrency Tutorials](https://docs.oracle.com/javase/tutorial/essential/concurrency/guardmeth.html)\n\
    * Common Weakness Enumeration: [CWE-400](https://cwe.mitre.org/data/definitions/400.html).\n"
 -
  pack: codeql/java-queries#0
  relativeQueryPath: experimental/Security/CWE/CWE-400/ThreadResourceAbuse.ql
  relativeBqrsPath: codeql/java-queries/experimental/Security/CWE/CWE-400/ThreadResourceAbuse.bqrs
  metadata:
    name: Uncontrolled thread resource consumption
    description: |-
      Using user input directly to control a thread's sleep time could lead to
                    performance problems or even resource exhaustion.
    kind: path-problem
    id: java/thread-resource-abuse
    problem.severity: warning
    tags: |-
      security
             experimental
             external/cwe/cwe-400
  queryHelp: "# Uncontrolled thread resource consumption\nThe `Thread.sleep` method\
    \ is used to pause the execution of current thread for specified time. When the\
    \ sleep time is user-controlled, especially in the web application context, it\
    \ can be abused to cause all of a server's threads to sleep, leading to denial\
    \ of service.\n\n\n## Recommendation\nTo guard against this attack, consider specifying\
    \ an upper range of allowed sleep time or adopting the producer/consumer design\
    \ pattern with `Object.wait` method to avoid performance problems or even resource\
    \ exhaustion. For more information, refer to the concurrency tutorial of Oracle\
    \ listed below or `java/ql/src/Likely Bugs/Concurrency` queries of CodeQL.\n\n\
    \n## Example\nThe following example shows a bad situation and a good situation\
    \ respectively. In the bad situation, a thread sleep time comes directly from\
    \ user input. In the good situation, an upper range check on the maximum sleep\
    \ time allowed is enforced.\n\n\n```java\nclass SleepTest {\n\tpublic void test(int\
    \ userSuppliedWaitTime) throws Exception {\n\t\t// BAD: no boundary check on wait\
    \ time\n\t\tThread.sleep(userSuppliedWaitTime);\n\n\t\t// GOOD: enforce an upper\
    \ limit on wait time\n\t\tif (userSuppliedWaitTime > 0 && userSuppliedWaitTime\
    \ < 5000) {\n\t\t\tThread.sleep(userSuppliedWaitTime);\n\t\t}\n\t}\n}\n\n```\n\
    \n## References\n* Snyk: [Denial of Service (DoS) in com.googlecode.gwtupload:gwtupload](https://snyk.io/vuln/SNYK-JAVA-COMGOOGLECODEGWTUPLOAD-569506).\n\
    * gwtupload: [\\[Fix DOS issue\\] Updating the AbstractUploadListener.java file](https://github.com/manolo/gwtupload/issues/33).\n\
    * The blog of a gypsy engineer: [ CVE-2019-17555: DoS via Retry-After header in\
    \ Apache Olingo](https://blog.gypsyengineer.com/en/security/cve-2019-17555-dos-via-retry-after-header-in-apache-olingo.html).\n\
    * Oracle: [The Java Concurrency Tutorials](https://docs.oracle.com/javase/tutorial/essential/concurrency/guardmeth.html)\n\
    * Common Weakness Enumeration: [CWE-400](https://cwe.mitre.org/data/definitions/400.html).\n"
 -
  pack: codeql/java-queries#0
  relativeQueryPath: experimental/Security/CWE/CWE-470/LoadClassNoSignatureCheck.ql
  relativeBqrsPath: codeql/java-queries/experimental/Security/CWE/CWE-470/LoadClassNoSignatureCheck.bqrs
  metadata:
    name: Load 3rd party classes or code ('unsafe reflection') without signature check
    description: |-
      Loading classes or code from third-party packages without checking the
                    package signature could make the application
                    susceptible to package namespace squatting attacks,
                    potentially leading to arbitrary code execution.
    problem.severity: error
    precision: high
    kind: path-problem
    id: java/android/unsafe-reflection
    tags: |-
      security
             experimental
             external/cwe/cwe-470
  queryHelp: |
    # Load 3rd party classes or code ('unsafe reflection') without signature check
    If an application loads classes or code from another app based solely on its package name without first checking its package signature, this could allow a malicious app with the same package name to be loaded through "package namespace squatting". If the victim user install such malicious app in the same device as the vulnerable app, the vulnerable app would load classes or code from the malicious app, potentially leading to arbitrary code execution.


    ## Recommendation
    Verify the package signature in addition to the package name before loading any classes or code from another application.


    ## Example
    The `BadClassLoader` class illustrates class loading with the `android.content.pm.PackageInfo.packageName.startsWith()` method without any check on the package signature.


    ```java
    package poc.sample.classloader;

    import android.app.Application;
    import android.content.pm.PackageInfo;
    import android.content.Context;
    import android.util.Log;

    public class BadClassLoader extends Application {
        @Override
        public void onCreate() {
            super.onCreate();
            for (PackageInfo p : getPackageManager().getInstalledPackages(0)) {
                try {
                    if (p.packageName.startsWith("some.package.")) {
                        Context appContext = createPackageContext(p.packageName,
                                CONTEXT_INCLUDE_CODE | CONTEXT_IGNORE_SECURITY);
                        ClassLoader classLoader = appContext.getClassLoader();
                        Object result = classLoader.loadClass("some.package.SomeClass")
                                .getMethod("someMethod")
                                .invoke(null);
                    }
                } catch (Exception e) {
                    Log.e("Class loading failed", e.toString());
                }
            }
        }
    }

    ```
    The `GoodClassLoader` class illustrates class loading with correct package signature check using the `android.content.pm.PackageManager.checkSignatures()` method.


    ```java
    package poc.sample.classloader;

    import android.app.Application;
    import android.content.pm.PackageInfo;
    import android.content.Context;
    import android.content.pm.PackageManager;
    import android.util.Log;

    public class GoodClassLoader extends Application {
        @Override
        public void onCreate() {
            super.onCreate();
            PackageManager pm = getPackageManager();
            for (PackageInfo p : pm.getInstalledPackages(0)) {
                try {
                    if (p.packageName.startsWith("some.package.") &&
                            (pm.checkSignatures(p.packageName, getApplicationContext().getPackageName()) == PackageManager.SIGNATURE_MATCH)
                    ) {
                        Context appContext = createPackageContext(p.packageName,
                                CONTEXT_INCLUDE_CODE | CONTEXT_IGNORE_SECURITY);
                        ClassLoader classLoader = appContext.getClassLoader();
                        Object result = classLoader.loadClass("some.package.SomeClass")
                                .getMethod("someMethod")
                                .invoke(null);
                    }
                } catch (Exception e) {
                    Log.e("Class loading failed", e.toString());
                }
            }
        }
    }

    ```

    ## References
    * [ Oversecured (Android: arbitrary code execution via third-party package contexts) ](https://blog.oversecured.com/Android-arbitrary-code-execution-via-third-party-package-contexts/)
    * Common Weakness Enumeration: [CWE-470](https://cwe.mitre.org/data/definitions/470.html).
 -
  pack: codeql/java-queries#0
  relativeQueryPath: experimental/Security/CWE/CWE-470/UnsafeReflection.ql
  relativeBqrsPath: codeql/java-queries/experimental/Security/CWE/CWE-470/UnsafeReflection.bqrs
  metadata:
    name: Use of externally-controlled input to select classes or code ('unsafe reflection')
    description: |-
      Use external input with reflection function to select the class or code to
                    be used, which brings serious security risks.
    kind: path-problem
    problem.severity: error
    precision: high
    id: java/unsafe-reflection
    tags: |-
      security
             experimental
             external/cwe/cwe-470
  queryHelp: "# Use of externally-controlled input to select classes or code ('unsafe\
    \ reflection')\nAllowing users to freely choose the name of a class to instantiate\
    \ could provide means to attack a vulnerable application.\n\n\n## Recommendation\n\
    Create a list of classes that are allowed to load reflectively and strictly verify\
    \ the input to ensure that users can only instantiate classes or execute methods\
    \ that ought to be allowed.\n\n\n## Example\nThe `bad` method shown below illustrate\
    \ class loading with `Class.forName` without any check on the particular class\
    \ being instantiated. The `good` methods illustrate some different ways to restrict\
    \ which classes can be instantiated.\n\n\n```java\nimport java.lang.reflect.Method;\n\
    import java.util.HashMap;\nimport java.util.HashSet;\nimport java.util.List;\n\
    import java.util.Map;\nimport javax.servlet.http.HttpServletRequest;\nimport org.springframework.stereotype.Controller;\n\
    import org.springframework.util.StringUtils;\nimport org.springframework.web.bind.annotation.GetMapping;\n\
    import org.springframework.web.bind.annotation.PathVariable;\nimport org.springframework.web.bind.annotation.RequestBody;\n\
    import org.springframework.web.bind.annotation.RequestMapping;\nimport org.springframework.web.bind.annotation.RequestMethod;\n\
    import org.springframework.web.multipart.MultipartFile;\n\n@Controller\npublic\
    \ class UnsafeReflection {\n\n    @RequestMapping(value = {\"/service/{beanIdOrClassName}/{methodName}\"\
    }, method = {RequestMethod.POST}, consumes = {\"application/json\"}, produces\
    \ = {\"application/json\"})\n    public Object bad1(@PathVariable(\"beanIdOrClassName\"\
    ) String beanIdOrClassName, @PathVariable(\"methodName\") String methodName, @RequestBody\
    \ Map<String, Object> body) throws Exception {\n        List<Object> rawData =\
    \ null;\n        try {\n            rawData = (List<Object>)body.get(\"methodInput\"\
    );\n        } catch (Exception e) {\n            return e;\n        }\n      \
    \  return invokeService(beanIdOrClassName, methodName, null, rawData);\n    }\n\
    \n    @GetMapping(value = \"uf1\")\n    public void good1(HttpServletRequest request)\
    \ throws Exception {\n        HashSet<String> hashSet = new HashSet<>();\n   \
    \     hashSet.add(\"com.example.test1\");\n        hashSet.add(\"com.example.test2\"\
    );\n        String className = request.getParameter(\"className\");\n        String\
    \ parameterValue = request.getParameter(\"parameterValue\");\n        if (!hashSet.contains(className)){\
    \ \n            throw new Exception(\"Class not valid: \"  + className);\n   \
    \     }\n        try {\n            Class clazz = Class.forName(className);\n\
    \            Object object = clazz.getDeclaredConstructors()[0].newInstance(parameterValue);\
    \ //good\n        } catch (Exception e) {\n            e.printStackTrace();\n\
    \        }\n    }\n\n    @GetMapping(value = \"uf2\")\n    public void good2(HttpServletRequest\
    \ request) throws Exception {\n        String className = request.getParameter(\"\
    className\");\n        String parameterValue = request.getParameter(\"parameterValue\"\
    );\n        if (!\"com.example.test1\".equals(className)){\n            throw\
    \ new Exception(\"Class not valid: \"  + className);\n        }\n        try {\n\
    \            Class clazz = Class.forName(className);\n            Object object\
    \ = clazz.getDeclaredConstructors()[0].newInstance(parameterValue); //good\n \
    \       } catch (Exception e) {\n            e.printStackTrace();\n        }\n\
    \    }\n\n    private Object invokeService(String beanIdOrClassName, String methodName,\
    \ MultipartFile[] files, List<Object> data) throws Exception {\n        BeanFactory\
    \ beanFactory = new BeanFactory();\n\t\ttry {\n\t\t\tObject bean = null;\n\t\t\
    \tClass<?> beanClass = Class.forName(beanIdOrClassName);\n\t\t\tbean = beanFactory.getBean(beanClass);\n\
    \t\t\tbyte b;\n\t\t\tint i;\n\t\t\tMethod[] arrayOfMethod;\n\t\t\tfor (i = (arrayOfMethod\
    \ = bean.getClass().getMethods()).length, b = 0; b < i; ) {\n\t\t\t\tMethod method\
    \ = arrayOfMethod[b];\n\t\t\t\tif (!method.getName().equals(methodName)) {\n\t\
    \t\t\t\tb++;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tObject result = method.invoke(bean,\
    \ data);\n\t\t\t\tMap<String, Object> map = new HashMap<>();\n\t\t\t\treturn map;\n\
    \t\t\t}\n\t\t} catch (Exception e) {\n\t\t\treturn e;\n\t\t}\n\t\treturn null;\n\
    \    }\n}\n\nclass BeanFactory {\n\n\tprivate static HashMap<String, Object> classNameMap\
    \ = new HashMap<>();\n\n\tprivate static HashMap<Class<?>, Object> classMap =\
    \ new HashMap<>();\n\n\tstatic {\n\t\tclassNameMap.put(\"xxxx\", Runtime.getRuntime());\n\
    \t\tclassMap.put(Runtime.class, Runtime.getRuntime());\n\t}\n\n\tpublic Object\
    \ getBean(Class<?> clzz) {\n\t\treturn classMap.get(clzz);\n\t}\n}\n\n```\n\n\
    ## References\n* Unsafe use of Reflection | OWASP: [Unsafe use of Reflection](https://owasp.org/www-community/vulnerabilities/Unsafe_use_of_Reflection).\n\
    * Java owasp: Classes should not be loaded dynamically: [Classes should not be\
    \ loaded dynamically](https://rules.sonarsource.com/java/tag/owasp/RSPEC-2658).\n\
    * Common Weakness Enumeration: [CWE-470](https://cwe.mitre.org/data/definitions/470.html).\n"
 -
  pack: codeql/java-queries#0
  relativeQueryPath: experimental/Security/CWE/CWE-489/EJBMain.ql
  relativeBqrsPath: codeql/java-queries/experimental/Security/CWE/CWE-489/EJBMain.bqrs
  metadata:
    name: Main Method in Enterprise Java Bean
    description: Java EE applications with a main method.
    kind: problem
    problem.severity: warning
    precision: medium
    id: java/main-method-in-enterprise-bean
    tags: |-
      security
             experimental
             external/cwe/cwe-489
  queryHelp: |
    # Main Method in Enterprise Java Bean
    Debug code can create unintended entry points in a deployed Java EE web application therefore should never make into production. There is no reason to have a main method in a Java EE web application. Having a main method in the Java EE application increases the attack surface that an attacker can exploit to attack the application logic.


    ## Recommendation
    Remove the main method from enterprise beans.


    ## Example
    The following example shows two ways of implementing enterprise beans. In the 'BAD' case, a main method is implemented. In the 'GOOD' case, no main method is implemented.


    ```java
    public class EJBMain implements SessionBean {
        /**
         * Create the session bean (empty implementation)
         */
        public void ejbCreate() throws javax.ejb.CreateException {
            System.out.println("EJBMain:ejbCreate()");
        }

        public void ejbActivate() throws javax.ejb.EJBException, java.rmi.RemoteException {
        }

        public void ejbPassivate() throws javax.ejb.EJBException, java.rmi.RemoteException {
        }

        public void ejbRemove() throws javax.ejb.EJBException, java.rmi.RemoteException {
        }

        public void setSessionContext(SessionContext parm1) throws javax.ejb.EJBException, java.rmi.RemoteException {
        }

        public String doService() {
            return null;
        }

        // BAD - Implement a main method in session bean.
        public static void main(String[] args) throws Exception {
            EJBMain b = new EJBMain();
            b.doService();
        }

        // GOOD - Not to have a main method in session bean.
    }

    ```

    ## References
    * SonarSource: [Web applications should not have a "main" method](https://rules.sonarsource.com/java/tag/owasp/RSPEC-2653)
    * Carnegie Mellon University: [ENV06-J. Production code must not contain debugging entry points](https://wiki.sei.cmu.edu/confluence/display/java/ENV06-J.+Production+code+must+not+contain+debugging+entry+points)
    * Common Weakness Enumeration: [CWE-489](https://cwe.mitre.org/data/definitions/489.html).
 -
  pack: codeql/java-queries#0
  relativeQueryPath: experimental/Security/CWE/CWE-489/WebComponentMain.ql
  relativeBqrsPath: codeql/java-queries/experimental/Security/CWE/CWE-489/WebComponentMain.bqrs
  metadata:
    name: Main Method in Java EE Web Components
    description: Java EE web applications with a main method.
    kind: problem
    problem.severity: warning
    precision: medium
    id: java/main-method-in-web-components
    tags: |-
      security
             experimental
             external/cwe/cwe-489
  queryHelp: "# Main Method in Java EE Web Components\nDebug code can create unintended\
    \ entry points in a deployed Java EE web application therefore should never make\
    \ into production. There is no reason to have a main method in a Java EE web application.\
    \ Having a main method in the Java EE application increases the attack surface\
    \ that an attacker can exploit to attack the application logic.\n\n\n## Recommendation\n\
    Remove the main method from web components including servlets, filters, and listeners.\n\
    \n\n## Example\nThe following example shows two ways of implementing web components.\
    \ In the 'BAD' case, a main method is implemented. In the 'GOOD' case, no main\
    \ method is implemented.\n\n\n```java\npublic class WebComponentMain implements\
    \ Servlet {\n\t// BAD - Implement a main method in servlet.\n\tpublic static void\
    \ main(String[] args) throws Exception {\n\t\t// Connect to my server\n\t\tURL\
    \ url = new URL(\"https://www.example.com\");\n\t\turl.openConnection();\n\t}\n\
    \n\t// GOOD - Not to have a main method in servlet.\n}\n\n```\n\n## References\n\
    * Fortify: [J2EE Bad Practices: Leftover Debug Code](https://vulncat.fortify.com/en/detail?id=desc.structural.java.j2ee_badpractices_leftover_debug_code)\n\
    * SonarSource: [Web applications should not have a \"main\" method](https://rules.sonarsource.com/java/tag/owasp/RSPEC-2653)\n\
    * Carnegie Mellon University: [ENV06-J. Production code must not contain debugging\
    \ entry points](https://wiki.sei.cmu.edu/confluence/display/java/ENV06-J.+Production+code+must+not+contain+debugging+entry+points)\n\
    * Common Weakness Enumeration: [CWE-489](https://cwe.mitre.org/data/definitions/489.html).\n"
 -
  pack: codeql/java-queries#0
  relativeQueryPath: experimental/Security/CWE/CWE-489/devMode.ql
  relativeBqrsPath: codeql/java-queries/experimental/Security/CWE/CWE-489/devMode.bqrs
  metadata:
    name: Apache Struts development mode enabled
    description: |-
      Enabling struts development mode in production environment
        can lead to remote code execution.
    kind: problem
    problem.severity: error
    precision: high
    id: java/struts-development-mode
    tags: |-
      security
             experimental
             external/cwe/cwe-489
  queryHelp: "# Apache Struts development mode enabled\nTurning Apache Struts' development\
    \ mode configuration on while deploying applications to production environments\
    \ can lead to remote code execution.\n\n\n## Recommendation\nAn application should\
    \ disable the development mode at the time of deployment.\n\n\n## Example\nThe\
    \ following example shows a \\`struts.xml\\` file with \\`struts.devmode\\` enabled.\n\
    \n\n```xml\n<?xml version=\"1.0\" encoding=\"UTF-8\" ?>\n<!DOCTYPE struts PUBLIC\n\
    \t\"-//Apache Software Foundation//DTD Struts Configuration 2.3//EN\"\n\t\"http://struts.apache.org/dtds/struts-2.3.dtd\"\
    >\n\n<struts>\n    <constant name=\"struts.enable.DynamicMethodInvocation\" value=\"\
    true\" />\n    <constant name=\"struts.devMode\" value=\"true\" />\n    <constant\
    \ name=\"struts.i18n.encoding\" value=\"utf-8\" />\n    <include file=\"login.xml\"\
    \ />\n</struts>\n\n```\nThis can be easily corrected by setting the value of the\
    \ \\`struts.devmode\\` parameter to false.\n\n\n```xml\n<?xml version=\"1.0\"\
    \ encoding=\"UTF-8\" ?>\n<!DOCTYPE struts PUBLIC\n\t\"-//Apache Software Foundation//DTD\
    \ Struts Configuration 2.3//EN\"\n\t\"http://struts.apache.org/dtds/struts-2.3.dtd\"\
    >\n\n<struts>\n    <constant name=\"struts.enable.DynamicMethodInvocation\" value=\"\
    true\" />\n    <constant name=\"struts.devMode\" value=\"false\" />\n    <constant\
    \ name=\"struts.i18n.encoding\" value=\"utf-8\"></constant>\n    <include file=\"\
    login.xml\" />\n</struts>\n```\n\n## References\n* Apache Struts: [Struts development\
    \ mode configuration](https://struts.apache.org/core-developers/development-mode.html)\n\
    * Common Weakness Enumeration: [CWE-489](https://cwe.mitre.org/data/definitions/489.html).\n"
 -
  pack: codeql/java-queries#0
  relativeQueryPath: experimental/Security/CWE/CWE-502/UnsafeDeserializationRmi.ql
  relativeBqrsPath: codeql/java-queries/experimental/Security/CWE/CWE-502/UnsafeDeserializationRmi.bqrs
  metadata:
    name: Unsafe deserialization in a remotely callable method.
    description: |-
      If a registered remote object has a method that accepts a complex object,
                    an attacker can take advantage of the unsafe deserialization mechanism
                    which is used to pass parameters in RMI.
                    In the worst case, it results in remote code execution.
    kind: path-problem
    problem.severity: error
    precision: high
    id: java/unsafe-deserialization-rmi
    tags: |-
      security
             experimental
             external/cwe/cwe-502
  queryHelp: |
    # Unsafe deserialization in a remotely callable method.
    Java RMI uses the default Java serialization mechanism (in other words, `ObjectInputStream`) to pass parameters in remote method invocations. This mechanism is known to be unsafe when deserializing untrusted data. If a registered remote object has a method that accepts a complex object, an attacker can take advantage of the unsafe deserialization mechanism. In the worst case, it results in remote code execution.


    ## Recommendation
    Use only strings and primitive types for parameters of remotely invokable methods.

    Set a filter for incoming serialized data by wrapping remote objects using either `UnicastRemoteObject.exportObject(Remote, int, ObjectInputFilter)` or `UnicastRemoteObject.exportObject(Remote, int, RMIClientSocketFactory, RMIServerSocketFactory, ObjectInputFilter)` methods. Those methods accept an `ObjectInputFilter` that decides which classes are allowed for deserialization. The filter should allow deserializing only safe classes.

    It is also possible to set a process-wide deserialization filter. The filter can be set by with `ObjectInputFilter.Config.setSerialFilter(ObjectInputFilter)` method, or by setting system or security property `jdk.serialFilter`. Make sure that you use the latest Java versions that include JEP 290. Please note that the query is not sensitive to this mitigation.

    If switching to the latest Java versions is not possible, consider using other implementations of remote procedure calls. For example, HTTP API with JSON. Make sure that the underlying deserialization mechanism is properly configured so that deserialization attacks are not possible.


    ## Example
    The following code registers a remote object with a vulnerable method that accepts a complex object:


    ```java
    public class Server {
        public void bindRemoteObject(Registry registry) throws Exception {
            registry.bind("unsafe", new RemoteObjectImpl());
        }
    }

    interface RemoteObject extends Remote {
        void action(Object obj) throws RemoteException;
    }

    class RemoteObjectImpl implements RemoteObject {
        // ...
    }
    ```
    The next example registers a safe remote object whose methods use only primitive types and strings:


    ```java
    public class Server {
        public void bindRemoteObject(Registry registry) throws Exception {
            registry.bind("safe", new RemoteObjectImpl());
        }
    }

    interface RemoteObject extends Remote {
        void calculate(int a, double b) throws RemoteException;
        void save(String s) throws RemoteException;
    }

    class RemoteObjectImpl implements RemoteObject {
        // ...
    }
    ```
    The next example shows how to set a deserialization filter for a remote object:


    ```java
    public void bindRemoteObject(Registry registry, int port) throws Exception {
        ObjectInputFilter filter = info -> {
            if (info.serialClass().getCanonicalName().startsWith("com.safe.package.")) {
                return ObjectInputFilter.Status.ALLOWED;
            }
            return ObjectInputFilter.Status.REJECTED;
        };
        registry.bind("safer", UnicastRemoteObject.exportObject(new RemoteObjectImpl(), port, filter));
    }

    ```

    ## References
    * Oracle: [Remote Method Invocation (RMI)](https://www.oracle.com/java/technologies/javase/remote-method-invocation-home.html).
    * ITNEXT: [Java RMI for pentesters part two - reconnaissance &amp; attack against non-JMX registries](https://itnext.io/java-rmi-for-pentesters-part-two-reconnaissance-attack-against-non-jmx-registries-187a6561314d).
    * MOGWAI LABS: [Attacking Java RMI services after JEP 290](https://mogwailabs.de/en/blog/2019/03/attacking-java-rmi-services-after-jep-290)
    * OWASP: [Deserialization of untrusted data](https://www.owasp.org/index.php/Deserialization_of_untrusted_data).
    * OpenJDK: [JEP 290: Filter Incoming Serialization Data](https://openjdk.java.net/jeps/290)
    * Common Weakness Enumeration: [CWE-502](https://cwe.mitre.org/data/definitions/502.html).
 -
  pack: codeql/java-queries#0
  relativeQueryPath: experimental/Security/CWE/CWE-502/UnsafeSpringExporterInConfigurationClass.ql
  relativeBqrsPath: codeql/java-queries/experimental/Security/CWE/CWE-502/UnsafeSpringExporterInConfigurationClass.bqrs
  metadata:
    name: Unsafe deserialization with Spring's remote service exporters.
    description: |-
      A Spring bean, which is based on RemoteInvocationSerializingExporter,
                    initializes an endpoint that uses ObjectInputStream to deserialize
                    incoming data. In the worst case, that may lead to remote code execution.
    kind: problem
    problem.severity: error
    precision: high
    id: java/unsafe-deserialization-spring-exporter-in-configuration-class
    tags: |-
      security
             experimental
             external/cwe/cwe-502
  queryHelp: |
    # Unsafe deserialization with Spring's remote service exporters.
    The Spring Framework provides several classes for creating remote service exporters. Under the hood, the exporters use various deserialization mechanisms such as `ObjectInputStream` or Hessian. Deserializing untrusted data is easily exploitable and in many cases allows an attacker to execute arbitrary code. If a remote attacker can reach endpoints created by the exporters, it results in remote code execution in the worst case.

    Examples of unsafe exporters include: `HttpInvokerServiceExporter`, `SimpleHttpInvokerServiceExporter`, `RmiServiceExporter`, `HessianServiceExporter`.

    CVE-2016-1000027 has been assigned to this issue in the Spring Framework. It is regarded as a design limitation, and can be mitigated but not fixed outright.


    ## Recommendation
    Avoid using unsafe service exporters. Instead, use other message formats for API endpoints (for example, JSON), but make sure that the underlying deserialization mechanism is properly configured so that deserialization attacks are not possible. If the vulnerable exporters can not be replaced, consider using global deserialization filters introduced in JEP 290.


    ## Example
    The following example shows how a vulnerable HTTP endpoint can be defined using `HttpInvokerServiceExporter` and Spring annotations:


    ```java
    @Configuration
    public class Server {

        @Bean(name = "/account")
        HttpInvokerServiceExporter accountService() {
            HttpInvokerServiceExporter exporter = new HttpInvokerServiceExporter();
            exporter.setService(new AccountServiceImpl());
            exporter.setServiceInterface(AccountService.class);
            return exporter;
        }

    }

    class AccountServiceImpl implements AccountService {

        @Override
        public String echo(String data) {
            return data;
        }
    }

    interface AccountService {
        String echo(String data);
    }
    ```

    ## References
    * OWASP: [Deserialization of untrusted data](https://www.owasp.org/index.php/Deserialization_of_untrusted_data).
    * Spring Framework API documentation: [RemoteInvocationSerializingExporter class](https://docs.spring.io/spring-framework/docs/current/javadoc-api/org/springframework/remoting/rmi/RemoteInvocationSerializingExporter.html)
    * Spring Framework API documentation: [HttpInvokerServiceExporter class](https://docs.spring.io/spring-framework/docs/current/javadoc-api/org/springframework/remoting/httpinvoker/HttpInvokerServiceExporter.html)
    * National Vulnerability Database: [CVE-2016-1000027](https://nvd.nist.gov/vuln/detail/CVE-2016-1000027)
    * Tenable Research Advisory: [\[R2\] Pivotal Spring Framework HttpInvokerServiceExporter readRemoteInvocation Method Untrusted Java Deserialization](https://www.tenable.com/security/research/tra-2016-20)
    * Spring Framework bug tracker: [Sonatype vulnerability CVE-2016-1000027 in Spring-web project](https://github.com/spring-projects/spring-framework/issues/24434)
    * OpenJDK: [JEP 290: Filter Incoming Serialization Data](https://openjdk.java.net/jeps/290)
    * Common Weakness Enumeration: [CWE-502](https://cwe.mitre.org/data/definitions/502.html).
 -
  pack: codeql/java-queries#0
  relativeQueryPath: experimental/Security/CWE/CWE-502/UnsafeSpringExporterInXMLConfiguration.ql
  relativeBqrsPath: codeql/java-queries/experimental/Security/CWE/CWE-502/UnsafeSpringExporterInXMLConfiguration.bqrs
  metadata:
    name: Unsafe deserialization with Spring's remote service exporters.
    description: |-
      A Spring bean, which is based on RemoteInvocationSerializingExporter,
                    initializes an endpoint that uses ObjectInputStream to deserialize
                    incoming data. In the worst case, that may lead to remote code execution.
    kind: problem
    problem.severity: error
    precision: high
    id: java/unsafe-deserialization-spring-exporter-in-xml-configuration
    tags: |-
      security
             experimental
             external/cwe/cwe-502
  queryHelp: |
    # Unsafe deserialization with Spring's remote service exporters.
    The Spring Framework provides several classes for creating remote service exporters. Under the hood, the exporters use various deserialization mechanisms such as `ObjectInputStream` or Hessian. Deserializing untrusted data is easily exploitable and in many cases allows an attacker to execute arbitrary code. If a remote attacker can reach endpoints created by the exporters, it results in remote code execution in the worst case.

    Examples of unsafe exporters include: `HttpInvokerServiceExporter`, `SimpleHttpInvokerServiceExporter`, `RmiServiceExporter`, `HessianServiceExporter`.

    CVE-2016-1000027 has been assigned to this issue in the Spring Framework. It is regarded as a design limitation, and can be mitigated but not fixed outright.


    ## Recommendation
    Avoid using unsafe service exporters. Instead, use other message formats for API endpoints (for example, JSON), but make sure that the underlying deserialization mechanism is properly configured so that deserialization attacks are not possible. If the vulnerable exporters can not be replaced, consider using global deserialization filters introduced in JEP 290.


    ## Example
    The following examples shows how a vulnerable HTTP endpoint can be defined in a Spring XML config:


    ```xml
    <bean name="/account" class="org.springframework.remoting.httpinvoker.HttpInvokerServiceExporter">
        <property name="service" ref="accountService"/>
        <property name="serviceInterface" value="AccountService"/>
    </bean>
    ```

    ## References
    * OWASP: [Deserialization of untrusted data](https://www.owasp.org/index.php/Deserialization_of_untrusted_data).
    * Spring Framework API documentation: [RemoteInvocationSerializingExporter class](https://docs.spring.io/spring-framework/docs/current/javadoc-api/org/springframework/remoting/rmi/RemoteInvocationSerializingExporter.html)
    * Spring Framework API documentation: [HttpInvokerServiceExporter class](https://docs.spring.io/spring-framework/docs/current/javadoc-api/org/springframework/remoting/httpinvoker/HttpInvokerServiceExporter.html)
    * National Vulnerability Database: [CVE-2016-1000027](https://nvd.nist.gov/vuln/detail/CVE-2016-1000027)
    * Tenable Research Advisory: [\[R2\] Pivotal Spring Framework HttpInvokerServiceExporter readRemoteInvocation Method Untrusted Java Deserialization](https://www.tenable.com/security/research/tra-2016-20)
    * Spring Framework bug tracker: [Sonatype vulnerability CVE-2016-1000027 in Spring-web project](https://github.com/spring-projects/spring-framework/issues/24434)
    * OpenJDK: [JEP 290: Filter Incoming Serialization Data](https://openjdk.java.net/jeps/290)
    * Common Weakness Enumeration: [CWE-502](https://cwe.mitre.org/data/definitions/502.html).
 -
  pack: codeql/java-queries#0
  relativeQueryPath: experimental/Security/CWE/CWE-522-DecompressionBombs/DecompressionBomb.ql
  relativeBqrsPath: codeql/java-queries/experimental/Security/CWE/CWE-522-DecompressionBombs/DecompressionBomb.bqrs
  metadata:
    name: Uncontrolled file decompression
    description: Decompressing user-controlled files without checking the compression
      ratio may allow attackers to perform denial-of-service attacks.
    kind: path-problem
    problem.severity: error
    security-severity: 7.8
    precision: high
    id: java/uncontrolled-file-decompression
    tags: |-
      security
             experimental
             external/cwe/cwe-409
  queryHelp: |
    # Uncontrolled file decompression
    Extracting Compressed files with any compression algorithm like gzip can cause a denial of service attack.

    Attackers can create a huge file by just repeating a single byte and compress it to a small file.


    ## Recommendation
    When decompressing a user-provided compressed file, verify the decompression ratio or decompress the files within a loop byte by byte to be able to manage the decompressed size in each cycle of the loop.


    ## Example
    In the following example, the decompressed file size is not checked before decompression, exposing the application to a denial of service.


    ```java
    package org.example;

    import java.nio.file.StandardCopyOption;
    import java.util.Enumeration;
    import java.io.IOException;
    import java.util.zip.*;
    import java.util.zip.ZipEntry;
    import java.io.File;
    import java.nio.file.Files;


    class BadExample {
        public static void ZipInputStreamUnSafe(String filename) throws IOException {
            File f = new File(filename);
            try (ZipFile zipFile = new ZipFile(f)) {
                Enumeration<? extends ZipEntry> entries = zipFile.entries();

                while (entries.hasMoreElements()) {
                    ZipEntry ze = entries.nextElement();
                    File out = new File("./tmp/tmp.txt");
                    Files.copy(zipFile.getInputStream(ze), out.toPath(), StandardCopyOption.REPLACE_EXISTING);
                }
            }
        }
    }
    ```
    A better approach is shown in the following example, where a ZIP file is read within a loop and a size threshold is checked every cycle.


    ```java
    import java.util.zip.*;
    import java.io.FileInputStream;
    import java.io.FileOutputStream;
    import java.util.zip.ZipEntry;

    public class GoodExample {
        public static void ZipInputStreamSafe(String filename) throws IOException {
            int UncompressedSizeThreshold = 10 * 1024 * 1024; // 10MB
            int BUFFERSIZE = 256;
            FileInputStream fis = new FileInputStream(filename);
            try (ZipInputStream zis = new ZipInputStream(new BufferedInputStream(fis))) {
                ZipEntry entry;
                while ((entry = zis.getNextEntry()) != null) {
                    int count;
                    byte[] data = new byte[BUFFERSIZE];
                    FileOutputStream fos = new FileOutputStream(entry.getName());
                    BufferedOutputStream dest = new BufferedOutputStream(fos, BUFFERSIZE);
                    int totalRead = 0;
                    while ((count = zis.read(data, 0, BUFFERSIZE)) != -1) {
                        totalRead = totalRead + count;
                        if (totalRead > UncompressedSizeThreshold) {
                            System.out.println("This Compressed file can be a bomb!");
                            break;
                        }
                        dest.write(data, 0, count);
                    }
                    dest.flush();
                    dest.close();
                    zis.closeEntry();
                }
            }
        }
    }
    ```

    ## References
    * [CVE-2022-4565](https://github.com/advisories/GHSA-47vx-fqr5-j2gw)
    * David Fifield: [A better zip bomb](https://www.bamsoftware.com/hacks/zipbomb/).
    * Common Weakness Enumeration: [CWE-409](https://cwe.mitre.org/data/definitions/409.html).
 -
  pack: codeql/java-queries#0
  relativeQueryPath: experimental/Security/CWE/CWE-548/InsecureDirectoryConfig.ql
  relativeBqrsPath: codeql/java-queries/experimental/Security/CWE/CWE-548/InsecureDirectoryConfig.bqrs
  metadata:
    name: Directories and files exposure
    description: |-
      A directory listing provides an attacker with the complete
                    index of all the resources located inside of the complete web
                    directory, which could yield files containing sensitive
                    information like source code and credentials to the attacker.
    kind: problem
    problem.severity: warning
    precision: medium
    id: java/server-directory-listing
    tags: |-
      security
             experimental
             external/cwe/cwe-548
  queryHelp: |
    # Directories and files exposure
    Enabling directory listing in J2EE application servers introduces the vulnerability of filename and path disclosure, which could allow an attacker to read arbitrary files in the server web directory. This includes application source code and data, as well as credentials for back-end systems.

    The query detects insecure configuration by validating its web configuration.


    ## Recommendation
    Always disabling directory listing in the production environment.


    ## Example
    The following two examples show two ways of directory listing configuration. In the 'BAD' case, it is enabled. In the 'GOOD' case, it is disabled.


    ```xml
    <?xml version="1.0" encoding="UTF-8" ?>
    <web-app xmlns="http://xmlns.jcp.org/xml/ns/javaee" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://xmlns.jcp.org/xml/ns/javaee
                          http://xmlns.jcp.org/xml/ns/javaee/web-app_4_0.xsd" version="4.0">

        <!-- The default servlet for all web applications, that serves static     -->
        <!-- resources.  It processes all requests that are not mapped to other   -->
        <!-- servlets with servlet mappings (defined either here or in your own   -->
        <!-- web.xml file).                                                       -->
        <servlet>
            <servlet-name>default</servlet-name>
            <servlet-class>org.apache.catalina.servlets.DefaultServlet</servlet-class>
            <init-param>
                <param-name>listings</param-name>
                <!-- GOOD: Don't allow directory listing -->
                <param-value>false</param-value>
            </init-param>
            <load-on-startup>1</load-on-startup>
        </servlet>

        <servlet>
            <servlet-name>default</servlet-name>
            <servlet-class>org.apache.catalina.servlets.DefaultServlet</servlet-class>
            <init-param>
                <param-name>listings</param-name>
                <!-- BAD: Allow directory listing -->
                <param-value>true</param-value>
            </init-param>
            <load-on-startup>1</load-on-startup>
        </servlet>
    </web-app>
    ```

    ## References
    * [CWE-548: Exposure of Information Through Directory Listing](https://cwe.mitre.org/data/definitions/548.html) [Directory listing](https://portswigger.net/kb/issues/00600100_directory-listing) [Directory traversal](https://portswigger.net/web-security/file-path-traversal)
    * Common Weakness Enumeration: [CWE-548](https://cwe.mitre.org/data/definitions/548.html).
 -
  pack: codeql/java-queries#0
  relativeQueryPath: experimental/Security/CWE/CWE-555/CredentialsInPropertiesFile.ql
  relativeBqrsPath: codeql/java-queries/experimental/Security/CWE/CWE-555/CredentialsInPropertiesFile.bqrs
  metadata:
    name: Cleartext Credentials in Properties File
    description: Finds cleartext credentials in Java properties files.
    kind: problem
    problem.severity: warning
    precision: high
    id: java/credentials-in-properties
    tags: |-
      security
             experimental
             external/cwe/cwe-555
             external/cwe/cwe-256
             external/cwe/cwe-260
  queryHelp: "# Cleartext Credentials in Properties File\nCredentials management issues\
    \ occur when credentials are stored in plaintext in an application's properties\
    \ file. Common credentials include but are not limited to LDAP, mail, database,\
    \ proxy account, and so on. Storing plaintext credentials in a properties file\
    \ allows anyone who can read the file access to the protected resource. Good credentials\
    \ management guidelines require that credentials never be stored in plaintext.\n\
    \n\n## Recommendation\nCredentials stored in properties files should be encrypted\
    \ and recycled regularly. In a Java EE deployment scenario, utilities provided\
    \ by application servers like keystores and password vaults can be used to encrypt\
    \ and manage credentials.\n\n\n## Example\nIn the first example, the credentials\
    \ for the LDAP and datasource properties are stored in cleartext in the properties\
    \ file.\n\nIn the second example, the credentials for the LDAP and datasource\
    \ properties are stored in an encrypted format.\n\n\n```none\n#*****************************\
    \ LDAP Credentials *****************************************#\n \nldap.ldapHost\
    \ = ldap.example.com\nldap.ldapPort = 636\nldap.loginDN = cn=Directory Manager\n\
    \n#### BAD: LDAP credentials are stored in cleartext #### \nldap.password = mysecpass\n\
    \n#### GOOD: LDAP credentials are stored in the encrypted format #### \nldap.password\
    \ = eFRZ3Cqo5zDJWMYLiaEupw==\n\nldap.domain1 = example\nldap.domain2 = com\nldap.url=\
    \ ldaps://ldap.example.com:636/dc=example,dc=com\n\n#***************************\
    \ MS SQL Database Connection **********************************# \ndatasource1.driverClassName\
    \ = com.microsoft.sqlserver.jdbc.SQLServerDriver\ndatasource1.url = jdbc:sqlserver://ms.example.com\\\
    \\exampledb:1433;\ndatasource1.username = sa\n\n#### BAD: Datasource credentials\
    \ are stored in cleartext #### \ndatasource1.password = Passw0rd@123\n\n#### GOOD:\
    \ Datasource credentials are stored in the encrypted format #### \ndatasource1.password\
    \ = VvOgflYS1EUzJdVNDoBcnA==\n\n```\n\n## References\n* OWASP: [Password Plaintext\
    \ Storage](https://owasp.org/www-community/vulnerabilities/Password_Plaintext_Storage)\n\
    * Medium (Rajeev Shukla): [Encrypting database password in the application.properties\
    \ file](https://medium.com/@mail2rajeevshukla/hiding-encrypting-database-password-in-the-application-properties-34d59fe104eb)\n\
    * Common Weakness Enumeration: [CWE-555](https://cwe.mitre.org/data/definitions/555.html).\n\
    * Common Weakness Enumeration: [CWE-256](https://cwe.mitre.org/data/definitions/256.html).\n\
    * Common Weakness Enumeration: [CWE-260](https://cwe.mitre.org/data/definitions/260.html).\n"
 -
  pack: codeql/java-queries#0
  relativeQueryPath: experimental/Security/CWE/CWE-555/PasswordInConfigurationFile.ql
  relativeBqrsPath: codeql/java-queries/experimental/Security/CWE/CWE-555/PasswordInConfigurationFile.bqrs
  metadata:
    name: Password in configuration file
    description: Finds passwords in configuration files.
    kind: problem
    problem.severity: warning
    precision: medium
    id: java/password-in-configuration
    tags: |-
      security
             experimental
             external/cwe/cwe-555
             external/cwe/cwe-256
             external/cwe/cwe-260
  queryHelp: |
    # Password in configuration file
    Storing a plaintext password in a configuration file allows anyone who can read the file to access the password-protected resources.


    ## Recommendation
    Passwords stored in configuration files should be encrypted. Utilities provided by application servers like keystore and password vault can be used to encrypt and manage passwords.


    ## Example
    In the first example, the password of a datasource configuration is stored in cleartext in the context.xml file of a Java EE application.

    In the second example, the password of a datasource configuration is encrypted and managed by a password vault.


    ```xml
    <?xml version="1.0" encoding="UTF-8"?>
    <Context>
        <!-- BAD: Password of datasource is not encrypted -->
        <Resource name="jdbc/exampleDS" auth="Container" type="javax.sql.DataSource"
                   maxTotal="100" maxIdle="30" maxWaitMillis="10000"
                   username="root" password="1234"
                   driverClassName="com.mysql.jdbc.Driver"
                   url="jdbc:mysql://www.example.com:3306/proj"/>

        <!-- GOOD: Password is encrypted and stored in a password vault -->
        <Resource name="jdbc/exampleDS" auth="Container" type="javax.sql.DataSource"
                   maxTotal="100" maxIdle="30" maxWaitMillis="10000"
                   username="root" password="${VAULT::exampleDS::password::N2NhZDYzOTMtNWE0OS00ZGQ0LWE4MmEtMWNlMDMyNDdmNmI2TElORV9CUkVBS3ZhdWx0}"
                   driverClassName="com.mysql.jdbc.Driver"
                   url="jdbc:mysql://www.example.com:3306/proj"/>

    </Context>
    ```

    ## References
    * CWE: [CWE-555: J2EE Misconfiguration: Plaintext Password in Configuration File](https://cwe.mitre.org/data/definitions/555.html)
    * RedHat Security Guide: [Store and Retrieve Encrypted Sensitive Strings in the Java Keystore](https://access.redhat.com/documentation/en-us/jboss_enterprise_application_platform/6.1/html/security_guide/Store_and_Retrieve_Encrypted_Sensitive_Strings_in_the_Java_Keystore)
    * SonarSource: [Hard-coded credentials are security-sensitive](https://rules.sonarsource.com/java/RSPEC-2068)
    * Common Weakness Enumeration: [CWE-555](https://cwe.mitre.org/data/definitions/555.html).
    * Common Weakness Enumeration: [CWE-256](https://cwe.mitre.org/data/definitions/256.html).
    * Common Weakness Enumeration: [CWE-260](https://cwe.mitre.org/data/definitions/260.html).
 -
  pack: codeql/java-queries#0
  relativeQueryPath: experimental/Security/CWE/CWE-598/SensitiveGetQuery.ql
  relativeBqrsPath: codeql/java-queries/experimental/Security/CWE/CWE-598/SensitiveGetQuery.bqrs
  metadata:
    name: Sensitive GET Query
    description: Use of GET request method with sensitive query strings.
    kind: path-problem
    problem.severity: warning
    precision: medium
    id: java/sensitive-query-with-get
    tags: |-
      security
             experimental
             external/cwe/cwe-598
  queryHelp: "# Sensitive GET Query\nSensitive information such as user passwords\
    \ should not be transmitted within the query string of the requested URL. Sensitive\
    \ information within URLs may be logged in various locations, including the user's\
    \ browser, the web server, and any forward or reverse proxy servers between the\
    \ two endpoints. URLs may also be displayed on-screen, bookmarked or emailed around\
    \ by users. They may be disclosed to third parties via the Referer header when\
    \ any off-site links are followed. Placing passwords into the URL therefore increases\
    \ the risk that they will be captured by an attacker.\n\n\n## Recommendation\n\
    Use HTTP POST to send sensitive information as part of the request body; for example,\
    \ as form data.\n\n\n## Example\nThe following example shows two ways of sending\
    \ sensitive information. In the 'BAD' case, a password is transmitted using the\
    \ GET method. In the 'GOOD' case, the password is transmitted using the POST method.\n\
    \n\n```java\npublic class SensitiveGetQuery extends HttpServlet {\n\t// BAD -\
    \ Tests sending sensitive information in a GET request.\n\tpublic void doGet(HttpServletRequest\
    \ request, HttpServletResponse response) throws IOException, ServletException\
    \ {\n\t\tString password = request.getParameter(\"password\");\n\t\tSystem.out.println(\"\
    password = \" + password);\n\t}\n\t\n\t// GOOD - Tests sending sensitive information\
    \ in a POST request.\n\tpublic void doPost(HttpServletRequest request, HttpServletResponse\
    \ response) throws IOException, ServletException {\n\t\tString password = request.getParameter(\"\
    password\");\n\t\tSystem.out.println(\"password = \" + password);\n\t}\n}\n\n\
    ```\n\n## References\n* CWE: [CWE-598: Use of GET Request Method with Sensitive\
    \ Query Strings](https://cwe.mitre.org/data/definitions/598.html)\n* PortSwigger\
    \ (Burp): [Password Submitted using GET Method](https://portswigger.net/kb/issues/00400300_password-submitted-using-get-method)\n\
    * OWASP: [Information Exposure through Query Strings in URL](https://owasp.org/www-community/vulnerabilities/Information_exposure_through_query_strings_in_url)\n\
    * Common Weakness Enumeration: [CWE-598](https://cwe.mitre.org/data/definitions/598.html).\n"
 -
  pack: codeql/java-queries#0
  relativeQueryPath: experimental/Security/CWE/CWE-600/UncaughtServletException.ql
  relativeBqrsPath: codeql/java-queries/experimental/Security/CWE/CWE-600/UncaughtServletException.bqrs
  metadata:
    name: Uncaught Servlet Exception
    description: |-
      Uncaught exceptions in a servlet could leave a system in an
                    unexpected state, possibly resulting in denial-of-service
                    attacks or the exposure of sensitive information disclosed in
                    stack traces.
    kind: path-problem
    problem.severity: warning
    precision: medium
    id: java/uncaught-servlet-exception
    tags: |-
      security
             experimental
             external/cwe/cwe-600
  queryHelp: |
    # Uncaught Servlet Exception
    Even though the request-handling methods of `Servlet` are declared `throws IOException, ServletException`, it's a bad idea to let such exceptions be thrown. Failure to catch exceptions in a servlet could lead to exposure of sensitive information because when a servlet throws an exception, the servlet container typically sends debugging information back to the user. That information could be valuable to an attacker.


    ## Recommendation
    Catch IOExceptions and/or RuntimeExceptions and display custom error messages without stack traces and sensitive information, or configure an `error-page` in web.xml to display a generic user-friendly message for any uncaught exception.


    ## Example
    In the first and second examples, subclasses of IOException and RuntimeException are not caught, which disclose stack traces. Because user-controlled data is passed to methods that throw, there is an opportunity for an attacker to provoke a stack dump.

    In the third example, the code catches the exception. In the fourth example, the code is not of concern since the variable cannot be controlled by attackers thus no unexpected exceptions can be thrown.


    ```java
    import java.io.InputStream;
    import java.io.IOException;
    import java.net.InetAddress;
    import java.net.UnknownHostException;

    class UncaughtServletException extends HttpServlet {
        // BAD: Uncaught exceptions
        {
            public void doGet(HttpServletRequest request, HttpServletResponse response) throws IOException, ServletException {
                String ip = request.getParameter("srcIP");
                InetAddress addr = InetAddress.getByName(ip); //BAD: getByName(String) throws UnknownHostException.

                String username = request.getRemoteUser();
                Integer.parseInt(username); //BAD: Integer.parse(String) throws RuntimeException.
            }
        }

        // GOOD
        {
            public void doGet(HttpServletRequest request, HttpServletResponse response) throws IOException, ServletException {
                try {
                    String ip = request.getParameter("srcIP");
                    InetAddress addr = InetAddress.getByName(ip);
                } catch (UnknownHostException uhex) {  //GOOD: Catch the subclass exception UnknownHostException of IOException.
                    uhex.printStackTrace();
                }
            }
        }

        // GOOD
        {
            public void doGet(HttpServletRequest request, HttpServletResponse response) throws IOException, ServletException {
                String ip = "10.100.10.81";
                InetAddress addr = InetAddress.getByName(ip); // OK: Hard-coded variable value or system property is not controlled by attacker.
            }
        }

    }
    ```

    ## References
    * CWE: [CWE-600: Uncaught Exception in Servlet](https://cwe.mitre.org/data/definitions/600.html)
    * SonarSource: [Exceptions should not be thrown from servlet methods](https://rules.sonarsource.com/java/tag/owasp/RSPEC-1989)
    * OWASP: [Error Handling Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/Error_Handling_Cheat_Sheet.html)
    * Common Weakness Enumeration: [CWE-600](https://cwe.mitre.org/data/definitions/600.html).
 -
  pack: codeql/java-queries#0
  relativeQueryPath: experimental/Security/CWE/CWE-601/SpringUrlRedirect.ql
  relativeBqrsPath: codeql/java-queries/experimental/Security/CWE/CWE-601/SpringUrlRedirect.bqrs
  metadata:
    name: Spring url redirection from remote source
    description: |-
      Spring url redirection based on unvalidated user-input
                    may cause redirection to malicious web sites.
    kind: path-problem
    problem.severity: error
    precision: high
    id: java/spring-unvalidated-url-redirection
    tags: |-
      security
             experimental
             external/cwe/cwe-601
  queryHelp: |
    # Spring url redirection from remote source
    Directly incorporating user input into a URL redirect request without validating the input can facilitate phishing attacks. In these attacks, unsuspecting users can be redirected to a malicious site that looks very similar to the real site they intend to visit, but which is controlled by the attacker.


    ## Recommendation
    To guard against untrusted URL redirection, it is advisable to avoid putting user input directly into a redirect URL. Instead, maintain a list of authorized redirects on the server; then choose from that list based on the user input provided.


    ## Example
    The following examples show the bad case and the good case respectively. The `bad` methods show an HTTP request parameter being used directly in a URL redirect without validating the input, which facilitates phishing attacks. In the `good1` method, it is shown how to solve this problem by verifying whether the user input is a known fixed string beginning.


    ```java
    import javax.servlet.http.HttpServletResponse;
    import org.springframework.stereotype.Controller;
    import org.springframework.web.bind.annotation.GetMapping;
    import org.springframework.web.servlet.ModelAndView;
    import org.springframework.web.servlet.view.RedirectView;

    @Controller
    public class SpringUrlRedirect {

        private final static String VALID_REDIRECT = "http://127.0.0.1";

        @GetMapping("url1")
        public RedirectView bad1(String redirectUrl, HttpServletResponse response) throws Exception {
            RedirectView rv = new RedirectView();
            rv.setUrl(redirectUrl);
            return rv;
        }

        @GetMapping("url2")
        public String bad2(String redirectUrl) {
            String url = "redirect:" + redirectUrl;
            return url;
        }

        @GetMapping("url3")
        public RedirectView bad3(String redirectUrl) {
            RedirectView rv = new RedirectView(redirectUrl);
            return rv;
        }

        @GetMapping("url4")
        public ModelAndView bad4(String redirectUrl) {
            return new ModelAndView("redirect:" + redirectUrl);
        }

        @GetMapping("url5")
        public ResponseEntity<Void> bad5(String redirectUrl) {
            return ResponseEntity.status(HttpStatus.FOUND)
                    .location(URI.create(redirectUrl))
                    .build();
        }

        @GetMapping("url6")
        public ResponseEntity<Void> bad6(String redirectUrl) {
            HttpHeaders httpHeaders = new HttpHeaders();
            httpHeaders.setLocation(URI.create(redirectUrl));

            return new ResponseEntity<>(httpHeaders, HttpStatus.SEE_OTHER);
        }

        @GetMapping("url7")
        public ResponseEntity<Void> bad7(String redirectUrl) {
            HttpHeaders httpHeaders = new HttpHeaders();
            httpHeaders.add("Location", redirectUrl);

            return ResponseEntity.status(HttpStatus.SEE_OTHER).headers(httpHeaders).build();
        }

        @GetMapping("url8")
        public RedirectView good1(String redirectUrl) {
            RedirectView rv = new RedirectView();
            if (redirectUrl.startsWith(VALID_REDIRECT)){
                rv.setUrl(redirectUrl);
            }else {
                rv.setUrl(VALID_REDIRECT);
            }
            return rv;
        }
    }

    ```

    ## References
    * A Guide To Spring Redirects: [Spring Redirects](https://www.baeldung.com/spring-redirect-and-forward).
    * Url redirection - attack and defense: [Url Redirection](https://www.virtuesecurity.com/kb/url-redirection-attack-and-defense/).
    * How to redirect to an external URL from Spring Boot REST Controller (Post/Redirect/Get pattern)?: [ResponseEntity Redirection](https://fullstackdeveloper.guru/2021/03/12/how-to-redirect-to-an-external-url-from-spring-boot-rest-controller/).
    * Common Weakness Enumeration: [CWE-601](https://cwe.mitre.org/data/definitions/601.html).
 -
  pack: codeql/java-queries#0
  relativeQueryPath: experimental/Security/CWE/CWE-625/PermissiveDotRegex.ql
  relativeBqrsPath: codeql/java-queries/experimental/Security/CWE/CWE-625/PermissiveDotRegex.bqrs
  metadata:
    name: URL matched by permissive `.` in a regular expression
    description: |-
      URLs validated with a permissive `.` in regular expressions may be vulnerable
                    to an authorization bypass.
    kind: path-problem
    problem.severity: warning
    precision: high
    id: java/permissive-dot-regex
    tags: |-
      security
             experimental
             external/cwe/cwe-625
             external/cwe/cwe-863
  queryHelp: |
    # URL matched by permissive `.` in a regular expression
    By default, a "dot" (`.`) in a regular expression matches all characters except the newline characters `\n` and `\r`. Regular expressions containing a dot can be bypassed with the characters `\r`(`%0a`) and `\n`(`%0d`) when the default Java regular expression matching implementations are used. This becomes a security issue if these regular expressions are used to decide whether to grant access to protected application resources.


    ## Recommendation
    To guard against unauthorized access, it is advisable to properly specify regex patterns for validating user input. The Java Pattern Matcher API `Pattern.compile(PATTERN, Pattern.DOTALL)` with the `DOTALL` flag set can be adopted to address this vulnerability.


    ## Example
    The following snippets show a vulnerable example and a secure example respectively. The `bad` methods show a regex pattern allowing a bypass by using line break characters. In the `good` methods, it is shown how to solve this problem by either specifying the regex pattern correctly or using a Java API that properly matches new line characters.


    ```java
    String PROTECTED_PATTERN = "/protected/.*";
    String CONSTRAINT_PATTERN = "/protected/xyz\\.xml";

    // BAD: A string with line return e.g. `/protected/%0dxyz` can bypass the path check
    Pattern p = Pattern.compile(PROTECTED_PATTERN);
    Matcher m = p.matcher(path);

    // GOOD: A string with line return e.g. `/protected/%0dxyz` cannot bypass the path check
    Pattern p = Pattern.compile(PROTECTED_PATTERN, Pattern.DOTALL);
    Matcher m = p.matcher(path);

    // GOOD: Only a specific path can pass the validation
    Pattern p = Pattern.compile(CONSTRAINT_PATTERN);
    Matcher m = p.matcher(path);

    if (m.matches()) {
        // Protected page - check access token and redirect to login page
    } else {
        // Not protected page - render content
    }

    // BAD: A string with line return e.g. `/protected/%0axyz` can bypass the path check
    boolean matches = path.matches(PROTECTED_PATTERN);

    // BAD: A string with line return e.g. `/protected/%0axyz` can bypass the path check
    boolean matches = Pattern.matches(PROTECTED_PATTERN, path);

    if (matches) {
        // Protected page - check access token and redirect to login page
    } else {
        // Not protected page - render content
    }

    ```

    ## References
    * Apache Shiro: [Address the RegexRequestMatcher issue in 1.9.1](https://github.com/apache/shiro/commit/6bcb92e06fa588b9c7790dd01bc02135d58d3f5b).
    * CVE-2022-32532: [Applications using RegExPatternMatcher with "." in the regular expression are possibly vulnerable to an authorization bypass](https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2022-32532).
    * Common Weakness Enumeration: [CWE-625](https://cwe.mitre.org/data/definitions/625.html).
    * Common Weakness Enumeration: [CWE-863](https://cwe.mitre.org/data/definitions/863.html).
 -
  pack: codeql/java-queries#0
  relativeQueryPath: experimental/Security/CWE/CWE-652/XQueryInjection.ql
  relativeBqrsPath: codeql/java-queries/experimental/Security/CWE/CWE-652/XQueryInjection.bqrs
  metadata:
    name: XQuery query built from user-controlled sources
    description: |-
      Building an XQuery query from user-controlled sources is vulnerable to insertion of
                    malicious XQuery code by the user.
    kind: path-problem
    problem.severity: error
    precision: high
    id: java/xquery-injection
    tags: |-
      security
             experimental
             external/cwe/cwe-652
  queryHelp: |
    # XQuery query built from user-controlled sources
    The software uses external input to dynamically construct an XQuery expression which is then used to retrieve data from an XML database. However, the input is not neutralized, or is incorrectly neutralized, which allows an attacker to control the structure of the query.


    ## Recommendation
    Use parameterized queries. This will help ensure the program retains control of the query structure.


    ## Example
    The following example compares building a query by string concatenation (bad) vs. using `bindString` to parameterize the query (good).


    ```java
    import javax.servlet.http.HttpServletRequest;
    import javax.xml.namespace.QName;
    import javax.xml.xquery.XQConnection;
    import javax.xml.xquery.XQDataSource;
    import javax.xml.xquery.XQException;
    import javax.xml.xquery.XQItemType;
    import javax.xml.xquery.XQPreparedExpression;
    import javax.xml.xquery.XQResultSequence;
    import net.sf.saxon.xqj.SaxonXQDataSource;

    public void bad(HttpServletRequest request) throws XQException {
        String name = request.getParameter("name");
        XQDataSource ds = new SaxonXQDataSource();
        XQConnection conn = ds.getConnection();
        String query = "for $user in doc(\"users.xml\")/Users/User[name='" + name + "'] return $user/password";
        XQPreparedExpression xqpe = conn.prepareExpression(query);
        XQResultSequence result = xqpe.executeQuery();
        while (result.next()){
            System.out.println(result.getItemAsString(null));
        }
    }

    public void bad1(HttpServletRequest request) throws XQException {
        String name = request.getParameter("name");
        XQDataSource xqds = new SaxonXQDataSource();
        String query = "for $user in doc(\"users.xml\")/Users/User[name='" + name + "'] return $user/password";
        XQConnection conn = xqds.getConnection();
        XQExpression expr = conn.createExpression();
        XQResultSequence result = expr.executeQuery(query);
        while (result.next()){
            System.out.println(result.getItemAsString(null));
        }
    }

    public void bad2(HttpServletRequest request) throws XQException {
        String name = request.getParameter("name");
        XQDataSource xqds = new SaxonXQDataSource();
        XQConnection conn = xqds.getConnection();
        XQExpression expr = conn.createExpression();
        //bad code
        expr.executeCommand(name);
    }

    public void good(HttpServletRequest request) throws XQException {
        String name = request.getParameter("name");
        XQDataSource ds = new SaxonXQDataSource();
        XQConnection conn = ds.getConnection();
        String query = "declare variable $name as xs:string external;"
                + " for $user in doc(\"users.xml\")/Users/User[name=$name] return $user/password";
        XQPreparedExpression xqpe = conn.prepareExpression(query);
        xqpe.bindString(new QName("name"), name, conn.createAtomicType(XQItemType.XQBASETYPE_STRING));
        XQResultSequence result = xqpe.executeQuery();
        while (result.next()){
            System.out.println(result.getItemAsString(null));
        }
    }

    public void good1(HttpServletRequest request) throws XQException {
        String name = request.getParameter("name");
        String query = "declare variable $name as xs:string external;"
                + " for $user in doc(\"users.xml\")/Users/User[name=$name] return $user/password";
        XQDataSource xqds = new SaxonXQDataSource();
        XQConnection conn = xqds.getConnection();
        XQExpression expr = conn.createExpression();
        expr.bindString(new QName("name"), name, conn.createAtomicType(XQItemType.XQBASETYPE_STRING));
        XQResultSequence result = expr.executeQuery(query);
        while (result.next()){
            System.out.println(result.getItemAsString(null));
        }
    }
    ```

    ## References
    * Balisage: [XQuery Injection](https://www.balisage.net/Proceedings/vol7/html/Vlist02/BalisageVol7-Vlist02.html).
    * Common Weakness Enumeration: [CWE-652](https://cwe.mitre.org/data/definitions/652.html).
 -
  pack: codeql/java-queries#0
  relativeQueryPath: experimental/Security/CWE/CWE-665/InsecureRmiJmxEnvironmentConfiguration.ql
  relativeBqrsPath: codeql/java-queries/experimental/Security/CWE/CWE-665/InsecureRmiJmxEnvironmentConfiguration.bqrs
  metadata:
    name: InsecureRmiJmxAuthenticationEnvironment
    description: "This query detects if a JMX/RMI server is created with a potentially\
      \ dangerous environment, which could lead to code execution through insecure\
      \ deserialization."
    kind: problem
    problem.severity: error
    tags: |-
      security
             experimental
             external/cwe/cwe-665
    precision: high
    id: java/insecure-rmi-jmx-server-initialization
  queryHelp: "# InsecureRmiJmxAuthenticationEnvironment\nFor special use cases some\
    \ applications may implement a custom service which handles JMX-RMI connections.\n\
    \nWhen creating such a custom service, a developer should pass a certain environment\
    \ configuration to the JMX-RMI server initialization, as otherwise the JMX-RMI\
    \ service is susceptible to an unsafe deserialization vulnerability.\n\nThis is\
    \ because the JMX-RMI service allows attackers to supply arbitrary objects to\
    \ the service authentication method, resulting in the attempted deserialization\
    \ of an attacker-controlled object. In the worst case scenario this could allow\
    \ an attacker to achieve remote code execution within the context of the application\
    \ server.\n\nBy setting the appropriate environment, the deserialization can be\
    \ controlled via a deserialization filter.\n\n\n## Recommendation\nDuring the\
    \ creation of a custom JMX-RMI service an environment should be supplied that\
    \ sets a deserialization filter. Ideally this filter should be as restrictive\
    \ as possible, for example to only allow the deserialization of `java.lang.String`.\n\
    \nThe filter can be configured by setting the key `jmx.remote.rmi.server.credentials.filter.pattern`\
    \ (given by the constant `RMIConnectorServer.CREDENTIALS_FILTER_PATTERN`). The\
    \ filter should (ideally) only allow java.lang.String and disallow all other classes\
    \ for deserialization: (`\"java.lang.String;!*\"`).\n\nThe key-value pair can\
    \ be set as following:\n\n\n```java\nString stringsOnlyFilter = \"java.lang.String;!*\"\
    ; // Deny everything but java.lang.String\n\nMap<String, Object> env = new HashMap<String,\
    \ Object>;\nenv.put(RMIConnectorServer.CREDENTIALS_FILTER_PATTERN, stringsOnlyFilter);\n\
    ```\nFor applications using Java 6u113 to 9:\n\n\n```java\n// This is deprecated\
    \ in Java 10+ !\nMap<String, Object>; env = new HashMap<String, Object>;\nenv.put\
    \ ( \n  \"jmx.remote.rmi.server.credential.types\",\n    new String[]{\n     String[].class.getName(),\n\
    \     String.class.getName()\n   }\n );\n```\nPlease note that the JMX-RMI service\
    \ is vulnerable in the default configuration. For this reason an initialization\
    \ with a `null` environment is also vulnerable.\n\n\n## Example\nThe following\
    \ examples show how an JMX-RMI service can be initialized securely.\n\nThe first\
    \ example shows how an JMX server is initialized securely with the `JMXConnectorServerFactory.newJMXConnectorServer()`\
    \ call.\n\n\n```java\nimport java.io.IOException;\nimport java.lang.management.ManagementFactory;\n\
    import java.rmi.registry.LocateRegistry;\nimport java.util.HashMap;\nimport java.util.Map;\n\
    \nimport javax.management.MBeanServer;\nimport javax.management.remote.JMXConnectorServerFactory;\n\
    import javax.management.remote.JMXServiceURL;\n\npublic class CorrectJmxInitialisation\
    \ {\n\n    public void initAndStartJmxServer() throws IOException{\n        int\
    \ jmxPort = 1919;\n        LocateRegistry.createRegistry(jmxPort);\n\n       \
    \ /* Restrict the login function to String Objects only (see CVE-2016-3427) */\n\
    \        Map<String, Object> env = new HashMap<String, Object>();\n        //\
    \ For Java 10+\n        String stringsOnlyFilter = \"java.lang.String;!*\"; //\
    \ Deny everything but java.lang.String\n        env.put(RMIConnectorServer.CREDENTIALS_FILTER_PATTERN,\
    \ stringsOnlyFilter);\n                \n        /* Java 9 or below:\n       \
    \ env.put(\"jmx.remote.rmi.server.credential.types\",\n                new String[]\
    \ { String[].class.getName(), String.class.getName() });\n        */\n       \
    \ \n        MBeanServer beanServer = ManagementFactory.getPlatformMBeanServer();\n\
    \n        JMXServiceURL jmxUrl = new JMXServiceURL(\"service:jmx:rmi:///jndi/rmi://localhost:\"\
    \ + jmxPort + \"/jmxrmi\");\n\n        // Create JMXConnectorServer in a secure\
    \ manner\n        javax.management.remote.JMXConnectorServer connectorServer =\
    \ JMXConnectorServerFactory\n                .newJMXConnectorServer(jmxUrl, env,\
    \ beanServer);\n\n        connectorServer.start();\n    }\n}\n\n```\nThe second\
    \ example shows how a JMX Server is initialized securely if the `RMIConnectorServer`\
    \ class is used.\n\n\n```java\npublic class CorrectRmiInitialisation {\n    public\
    \ void initAndStartRmiServer(int port, String hostname, boolean local) {\n   \
    \     MBeanServerForwarder authzProxy = null;\n\n        env.put(\"jmx.remote.x.daemon\"\
    , \"true\");\n        \n        /* Restrict the login function to String Objects\
    \ only (see CVE-2016-3427) */\n        Map<String, Object> env = new HashMap<String,\
    \ Object>();\n        // For Java 10+\n        String stringsOnlyFilter = \"java.lang.String;!*\"\
    ; // Deny everything but java.lang.String\n        env.put(RMIConnectorServer.CREDENTIALS_FILTER_PATTERN,\
    \ stringsOnlyFilter);\n                \n        /* Java 9 or below\n        env.put(\"\
    jmx.remote.rmi.server.credential.types\",\n                new String[] { String[].class.getName(),\
    \ String.class.getName() });\n        */\n        \n        int rmiPort = Integer.getInteger(\"\
    com.sun.management.jmxremote.rmi.port\", 0);\n        RMIJRMPServerImpl server\
    \ = new RMIJRMPServerImpl(rmiPort,\n                (RMIClientSocketFactory) env.get(RMIConnectorServer.RMI_CLIENT_SOCKET_FACTORY_ATTRIBUTE),\n\
    \                (RMIServerSocketFactory) env.get(RMIConnectorServer.RMI_SERVER_SOCKET_FACTORY_ATTRIBUTE),\
    \ env);\n\n        JMXServiceURL serviceURL = new JMXServiceURL(\"rmi\", hostname,\
    \ rmiPort);\n\n        // Create RMI Server\n        RMIConnectorServer jmxServer\
    \ = new RMIConnectorServer(serviceURL, env, server,\n                ManagementFactory.getPlatformMBeanServer());\n\
    \n        jmxServer.start();\n\n    }\n}\n\n```\n\n## References\n* Deserialization\
    \ of arbitrary objects could lead to remote code execution as described following:\
    \ [OWASP Deserialization of untrusted data](https://owasp.org/www-community/vulnerabilities/Deserialization_of_untrusted_data).\n\
    * Issue discovered in Tomcat (CVE-2016-8735): [OWASP ESAPI](https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2016-8735).\n\
    * [Oracle release notes](https://www.oracle.com/java/technologies/javase/8u91-relnotes.html#bugfixes-8u91):\
    \ New attribute for JMX RMI JRMP servers.\n* Java 10 API specification for [RMIConnectorServer.CREDENTIALS_FILTER_PATTERN](https://docs.oracle.com/javase/10/docs/api/javax/management/remote/rmi/RMIConnectorServer.html#CREDENTIALS_FILTER_PATTERN)\n\
    * The Java API specification for [RMIConnectorServer.CREDENTIAL_TYPES](https://docs.oracle.com/javase/10/docs/api/javax/management/remote/rmi/RMIConnectorServer.html#CREDENTIAL_TYPES).\
    \ Please note that this field is deprecated since Java 10.\n* Common Weakness\
    \ Enumeration: [CWE-665](https://cwe.mitre.org/data/definitions/665.html).\n"
 -
  pack: codeql/java-queries#0
  relativeQueryPath: experimental/Security/CWE/CWE-755/NFEAndroidDoS.ql
  relativeBqrsPath: codeql/java-queries/experimental/Security/CWE/CWE-755/NFEAndroidDoS.bqrs
  metadata:
    name: Local Android DoS Caused By NumberFormatException
    description: |-
      NumberFormatException thrown but not caught by an Android
                    application that allows external inputs can crash the
                    application, constituting a local Denial of Service (DoS)
                    attack.
    kind: path-problem
    problem.severity: warning
    precision: medium
    id: java/android/nfe-local-android-dos
    tags: |-
      security
             experimental
             external/cwe/cwe-755
  queryHelp: "# Local Android DoS Caused By NumberFormatException\nNumberFormatException\
    \ (NFE) thrown but not caught by an Android application will crash the application.\
    \ If the application allows external inputs, an attacker can send an invalid number\
    \ as intent extra to trigger NFE, which introduces local Denial of Service (Dos)\
    \ attack.\n\nThis is a common problem in Android development since Android components\
    \ don't have `throw Exception(...)` in their class and method definitions.\n\n\
    \n## Recommendation\nUse the Android methods intended to get number extras e.g.\
    \ `Intent.getFloatExtra(String name, float defaultValue)` since they have the\
    \ built-in try/catch processing, or explicitly do try/catch in the application.\n\
    \n\n## Example\nThe following example shows both 'BAD' and 'GOOD' configurations.\
    \ In the 'BAD' configuration, number value is retrieved as string extra then parsed\
    \ to double. In the 'GOOD' configuration, number value is retrieved as integer\
    \ extra.\n\n\n```java\npublic class NFEAndroidDoS extends Activity {\n\tpublic\
    \ void onCreate(Bundle savedInstanceState) {\n\t\tsuper.onCreate(savedInstanceState);\n\
    \t\tsetContentView(R.layout.activity_view);\n\n\t\t// BAD: Uncaught NumberFormatException\
    \ due to remote user inputs\n\t\t{\n\t\t\tString minPriceStr = getIntent().getStringExtra(\"\
    priceMin\");\n\t\t\tdouble minPrice = Double.parseDouble(minPriceStr);\t\n\t\t\
    }\n\n\t\t// GOOD: Use the proper Android method to get number extra  \n\t\t{\n\
    \t\t\tint width = getIntent().getIntExtra(\"width\", 0);\n\t\t\tint height = getIntent().getIntExtra(\"\
    height\", 0);\n\t\t}\n\t}\n}\n```\n\n## References\n* CWE: [CWE-755: Improper\
    \ Handling of Exceptional Conditions](https://cwe.mitre.org/data/definitions/749.html)\n\
    * Android Developers: [Android Crashes](https://developer.android.com/topic/performance/vitals/crash)\n\
    * Google Analytics: [Crash and Exception Measurement Using the Google Analytics\
    \ SDK](https://developers.google.com/analytics/devguides/collection/android/v4/exceptions)\n\
    * Common Weakness Enumeration: [CWE-755](https://cwe.mitre.org/data/definitions/755.html).\n"
 -
  pack: codeql/java-queries#0
  relativeQueryPath: experimental/Security/CWE/CWE-759/HashWithoutSalt.ql
  relativeBqrsPath: codeql/java-queries/experimental/Security/CWE/CWE-759/HashWithoutSalt.bqrs
  metadata:
    name: Use of a hash function without a salt
    description: Hashed passwords without a salt are vulnerable to dictionary attacks.
    kind: path-problem
    problem.severity: warning
    precision: low
    id: java/hash-without-salt
    tags: |-
      security
             experimental
             external/cwe/cwe-759
  queryHelp: "# Use of a hash function without a salt\nIn cryptography, a salt is\
    \ some random data used as an additional input to a one-way function that hashes\
    \ a password or pass-phrase. It makes dictionary attacks more difficult.\n\nWithout\
    \ a salt, it is much easier for attackers to pre-compute the hash value using\
    \ dictionary attack techniques such as rainbow tables to crack passwords.\n\n\n\
    ## Recommendation\nUse a long random salt of at least 32 bytes then use the combination\
    \ of password and salt to hash a password or password phrase.\n\n\n## Example\n\
    The following example shows two ways of hashing. In the 'BAD' case, no salt is\
    \ provided. In the 'GOOD' case, a salt is provided.\n\n\n```java\npublic class\
    \ HashWithoutSalt {\n\t// BAD - Hash without a salt.\n\tpublic void getSHA256Hash(String\
    \ password) throws NoSuchAlgorithmException {\n\t\tMessageDigest md = MessageDigest.getInstance(\"\
    SHA-256\");\n\t\tbyte[] messageDigest = md.digest(password.getBytes());\n\t}\n\
    \n\t// GOOD - Hash with a salt.\n\tpublic void getSHA256Hash(String password,\
    \ byte[] salt) throws NoSuchAlgorithmException {\n\t\tMessageDigest md = MessageDigest.getInstance(\"\
    SHA-256\");\n\t\tmd.update(salt);\n\t\tbyte[] messageDigest = md.digest(password.getBytes());\n\
    \t}\n}\n```\n\n## References\n* DZone: [A Look at Java Cryptography](https://dzone.com/articles/a-look-at-java-cryptography)\n\
    * CWE: [CWE-759: Use of a One-Way Hash without a Salt](https://cwe.mitre.org/data/definitions/759.html)\n\
    * Common Weakness Enumeration: [CWE-759](https://cwe.mitre.org/data/definitions/759.html).\n"
 -
  pack: codeql/java-queries#0
  relativeQueryPath: experimental/Security/CWE/CWE-939/IncorrectURLVerification.ql
  relativeBqrsPath: codeql/java-queries/experimental/Security/CWE/CWE-939/IncorrectURLVerification.bqrs
  metadata:
    name: Incorrect URL verification
    description: |-
      Apps that rely on URL parsing to verify that a given URL is
                    pointing to a trusted server are susceptible to wrong ways of
                    URL parsing and verification.
    kind: problem
    problem.severity: warning
    precision: medium
    id: java/incorrect-url-verification
    tags: |-
      security
             experimental
             external/cwe/cwe-939
  queryHelp: |
    # Incorrect URL verification
    Apps that rely on URL Parsing to verify that a given URL is pointing to a trust server may be susceptible to many different ways to get URL parsing and verification wrong, which allows an attacker to register a fake site to break the access control.


    ## Recommendation
    Verify the whole host and domain (FQDN) or check endsWith dot+domain.


    ## Example
    The following example shows two ways of verifying host domain. In the 'BAD' case, verification is implemented as partial domain match. In the 'GOOD' case, full domain is verified.


    ```java
    public boolean shouldOverrideUrlLoading(WebView view, String url) {
        {
            Uri uri = Uri.parse(url);
            // BAD: partial domain match, which allows an attacker to register a domain like myexample.com to circumvent the verification
            if (uri.getHost() != null && uri.getHost().endsWith("example.com")) {
                return false;
            }
        }

        {
            Uri uri = Uri.parse(url);
            // GOOD: full domain match
            if (uri.getHost() != null && uri.getHost().endsWith(".example.com")) {
                return false;
            }
        }
    }

    ```

    ## References
    * [Common Android app vulnerabilities from Sebastian Porst of Google](https://drive.google.com/file/d/0BwMN49Gzo3x6T1N5WGQ4TTNlMHBOb1ZRQTVEWnVBZjFUaE5N/view)
    * [Common Android app vulnerabilities from bugcrowd](https://www.bugcrowd.com/resources/webinars/overview-of-common-android-app-vulnerabilities/)
    * Common Weakness Enumeration: [CWE-939](https://cwe.mitre.org/data/definitions/939.html).
 -
  pack: codeql/java-queries#0
  relativeQueryPath: external/DuplicateAnonymous.ql
  relativeBqrsPath: codeql/java-queries/external/DuplicateAnonymous.bqrs
  metadata:
    deprecated: ""
    name: Duplicate anonymous class
    description: Duplicated anonymous classes indicate that refactoring is necessary.
    kind: problem
    problem.severity: recommendation
    precision: high
    id: java/duplicate-anonymous-class
    tags: |-
      testability
             maintainability
             useless-code
             duplicate-code
             statistical
             non-attributable
  queryHelp: |
    # Duplicate anonymous class
    Anonymous classes are a common way of creating implementations of an interface or abstract class whose functionality is really only needed once. Duplicating the definition of an anonymous class in several places is usually a sign that refactoring is necessary.

    Code duplication in general is highly undesirable for a range of reasons. The artificially inflated amount of code is more difficult to understand, and sequences of similar but subtly different lines can mask the real purpose or intention behind them. Also, there is always a risk that only one of several copies of the code is updated to address a defect or add a feature.


    ## Recommendation
    Introduce a concrete class that contains the definition just once, and replace the anonymous classes with instances of this concrete class.


    ## Example
    In the following example, the definition of the class `addActionListener` is duplicated for each button that needs to use it. A better solution is shown that defines just one class, `MultiplexingListener`, which is used by each button.


    ```java
    // BAD: Duplicate anonymous classes:
    button1.addActionListener(new ActionListener() {
        public void actionPerfored(ActionEvent e)
        {
            for (ActionListener listener: listeners)
                listeners.actionPerformed(e);
        }
    });

    button2.addActionListener(new ActionListener() {
        public void actionPerfored(ActionEvent e)
        {
            for (ActionListener listener: listeners)
                listeners.actionPerformed(e);
        }
    });

    // ... and so on.

    // GOOD: Better solution:
    class MultiplexingListener implements ActionListener {
        public void actionPerformed(ActionEvent e) {
            for (ActionListener listener : listeners)
                listener.actionPerformed(e);
        }
    }

    button1.addActionListener(new MultiplexingListener());
    button2.addActionListener(new MultiplexingListener());
    // ... and so on.

    ```

    ## References
    * E. Juergens, F. Deissenboeck, B. Hummel, S. Wagner. *Do code clones matter?* Proceedings of the 31st International Conference on Software Engineering, 485-495, 2009.
 -
  pack: codeql/java-queries#0
  relativeQueryPath: external/DuplicateBlock.ql
  relativeBqrsPath: codeql/java-queries/external/DuplicateBlock.bqrs
  metadata:
    deprecated: ""
    name: Duplicate code
    description: "This block of code is duplicated elsewhere. If possible, the shared\
      \ code should be refactored so there is only one occurrence left. It may not\
      \ always be possible to address these issues; other duplicate code checks (such\
      \ as duplicate function, duplicate class) give subsets of the results with higher\
      \ confidence."
    kind: problem
    problem.severity: recommendation
    precision: low
    id: java/duplicate-block
 -
  pack: codeql/java-queries#0
  relativeQueryPath: external/DuplicateMethod.ql
  relativeBqrsPath: codeql/java-queries/external/DuplicateMethod.bqrs
  metadata:
    deprecated: ""
    name: Duplicate method
    description: |-
      Duplicated methods make code more difficult to understand and introduce a risk of
                    changes being made to only one copy.
    kind: problem
    problem.severity: recommendation
    precision: high
    id: java/duplicate-method
    tags: |-
      testability
             maintainability
             useless-code
             duplicate-code
             statistical
             non-attributable
  queryHelp: "# Duplicate method\nA method should never be duplicated exactly in several\
    \ places in the code. The severity of this problem is higher for longer methods\
    \ than for extremely short methods of one or two statements, but there are usually\
    \ better ways of achieving the same effect.\n\nCode duplication in general is\
    \ highly undesirable for a range of reasons. The artificially inflated amount\
    \ of code is more difficult to understand, and sequences of similar but subtly\
    \ different lines can mask the real purpose or intention behind them. Also, there\
    \ is always a risk that only one of several copies of the code is updated to address\
    \ a defect or add a feature.\n\n\n## Recommendation\nAt its simplest, the duplication\
    \ can be addressed by simply removing all but one of the duplicate method definitions,\
    \ and changing calls to the removed methods so that they call the remaining function\
    \ instead.\n\nThis may not be possible because of visibility or accessibility.\
    \ A common example is where two classes implement the same functionality but neither\
    \ is a subtype of the other, so it is not possible to inherit a single method\
    \ definition. In such cases, introducing a common superclass to share the duplicated\
    \ code is a possible option. Alternatively, if the methods do not need access\
    \ to private object state, they can be moved to a shared utility class that just\
    \ provides the functionality itself.\n\n\n## Example\nIn the following example,\
    \ `RowWidget` and `ColumnWidget` contain duplicate methods. The `collectChildren`\
    \ method should probably be moved into the superclass, `Widget`, and shared between\
    \ `RowWidget` and `ColumnWidget`.\n\n\n```java\nclass RowWidget extends Widget\
    \ {\n\t// ...\n\tpublic void collectChildren(Set<Widget> result) {\n\t\tfor (Widget\
    \ child : this.children) {\n\t\t\tif (child.isVisible()) {\n\t\t\t\tresult.add(children);\n\
    \t\t\t\tchild.collectChildren(result);\n\t\t\t}\n\t\t}\n\t}\n}\n\nclass ColumnWidget\
    \ extends Widget {\n\t// ...\n\tpublic void collectChildren(Set<Widget> result)\
    \ {\n\t\tfor (Widget child : this.children) {\n\t\t\tif (child.isVisible()) {\n\
    \t\t\t\tresult.add(children);\n\t\t\t\tchild.collectChildren(result);\n\t\t\t\
    }\n\t\t}\n\t}\n}\n```\nAlternatively, if not all kinds of `Widget` actually need\
    \ `collectChildren` (for example, not all of them have children), it might be\
    \ necessary to introduce a new, possibly abstract, class under `Widget`. For example,\
    \ the new class might be called `ContainerWidget` and include a single definition\
    \ of `collectChildren`. Both `RowWidget` and `ColumnWidget` could extend the class\
    \ and inherit `collectChildren`.\n\nModern IDEs may provide refactoring support\
    \ for this sort of issue, usually with the names \"Pull up\" or \"Extract supertype\"\
    .\n\n\n## References\n* E. Juergens, F. Deissenboeck, B. Hummel, S. Wagner. *Do\
    \ code clones matter?* Proceedings of the 31st International Conference on Software\
    \ Engineering, 485-495, 2009.\n"
 -
  pack: codeql/java-queries#0
  relativeQueryPath: external/MostlyDuplicateClass.ql
  relativeBqrsPath: codeql/java-queries/external/MostlyDuplicateClass.bqrs
  metadata:
    deprecated: ""
    name: Mostly duplicate class
    description: |-
      Classes in which most of the methods are duplicated in another class make code more
                    difficult to understand and introduce a risk of changes being made to only one copy.
    kind: problem
    problem.severity: recommendation
    precision: high
    id: java/duplicate-class
    tags: |-
      testability
             maintainability
             useless-code
             duplicate-code
             statistical
             non-attributable
  queryHelp: |
    # Mostly duplicate class
    When most of the methods in one class are duplicated in one or more other classes, the classes themselves are regarded as *mostly duplicate*.

    Code duplication in general is highly undesirable for a range of reasons. The artificially inflated amount of code is more difficult to understand, and sequences of similar but subtly different lines can mask the real purpose or intention behind them. Also, there is always a risk that only one of several copies of the code is updated to address a defect or add a feature.


    ## Recommendation
    Although completely duplicated classes are rare, they are usually a sign of a simple oversight (or deliberate copy/paste) by a developer. Usually the required solution is to remove all but one of them.

    It is more common to see duplication of many methods between two classes, leaving just a few that are actually different. Decide whether the differences are intended or the result of an inconsistent update to one of the copies:

    * If the two classes serve different purposes but many of their methods are duplicated, this indicates that there is a missing level of abstraction. Introducing a common super-class to define the common methods is likely to prevent many problems in the long term. Modern IDEs may provide refactoring support for this sort of issue, usually with the names "Pull up" or "Extract supertype".
    * If the two classes serve the same purpose and are different only as a result of inconsistent updates then treat the classes as completely duplicate. Determine the most up-to-date and correct version of the code and eliminate all near duplicates.

    ## References
    * E. Juergens, F. Deissenboeck, B. Hummel, S. Wagner. *Do code clones matter?* Proceedings of the 31st International Conference on Software Engineering, 485-495, 2009.
 -
  pack: codeql/java-queries#0
  relativeQueryPath: external/MostlyDuplicateFile.ql
  relativeBqrsPath: codeql/java-queries/external/MostlyDuplicateFile.bqrs
  metadata:
    deprecated: ""
    name: Mostly duplicate file
    description: |-
      Files in which most of the lines are duplicated in another file make code more
                    difficult to understand and introduce a risk of changes being made to only one copy.
    kind: problem
    problem.severity: recommendation
    precision: high
    id: java/duplicate-file
    tags: |-
      testability
             maintainability
             useless-code
             duplicate-code
             statistical
             non-attributable
  queryHelp: |
    # Mostly duplicate file
    When most of the lines in one file are duplicated in one or more other files, the files themselves are regarded as *mostly duplicate*.

    Code duplication in general is highly undesirable for a range of reasons. The artificially inflated amount of code is more difficult to understand, and sequences of similar but subtly different lines can mask the real purpose or intention behind them. Also, there is always a risk that only one of several copies of the code is updated to address a defect or add a feature.


    ## Recommendation
    Although completely duplicated files are rare, they are usually a sign of a simple oversight (or deliberate copy/paste) by a developer. Usually the required solution is to remove all but one of them. A common exception is generated code that simply occurs in several places in the source tree.

    It is more common to see duplication of many lines between two files, leaving just a few that are actually different. Decide whether the differences are intended or the result of an inconsistent update to one of the copies:

    * If the two files serve different purposes but many of their lines are duplicated, this indicates that there is a missing level of abstraction. Look for ways to share the functionality, either by extracting a utility class for parts of it or by encapsulating the common parts into a new super class of any classes involved.
    * If the two files serve the same purpose and are different only as a result of inconsistent updates then treat the files as completely duplicate. Determine the most up-to-date and correct version of the code and eliminate all near duplicates.

    ## References
    * E. Juergens, F. Deissenboeck, B. Hummel, S. Wagner. *Do code clones matter?* Proceedings of the 31st International Conference on Software Engineering, 485-495, 2009.
 -
  pack: codeql/java-queries#0
  relativeQueryPath: external/MostlyDuplicateMethod.ql
  relativeBqrsPath: codeql/java-queries/external/MostlyDuplicateMethod.bqrs
  metadata:
    deprecated: ""
    name: Mostly duplicate method
    description: |-
      Methods in which most of the lines are duplicated in another method make code more
                    difficult to understand and introduce a risk of changes being made to only one copy.
    kind: problem
    problem.severity: recommendation
    precision: high
    id: java/similar-method
    tags: |-
      testability
             maintainability
             useless-code
             duplicate-code
             statistical
             non-attributable
  queryHelp: |
    # Mostly duplicate method
    When most of the lines in one method are duplicated in one or more other methods, the methods themselves are regarded as *mostly duplicate* or *similar*.

    Code duplication in general is highly undesirable for a range of reasons. The artificially inflated amount of code is more difficult to understand, and sequences of similar but subtly different lines can mask the real purpose or intention behind them. Also, there is always a risk that only one of several copies of the code is updated to address a defect or add a feature.


    ## Recommendation
    Although completely duplicated methods are rare, they are usually a sign of a simple oversight (or deliberate copy/paste) by a developer. Usually the required solution is to remove all but one of them.

    It is more common to see duplication of many lines between two methods, leaving just a few that are actually different. Decide whether the differences are intended or the result of an inconsistent update to one of the copies.

    * If the two methods serve different purposes but many of their lines are duplicated, this indicates that there is a missing level of abstraction. Look for ways of encapsulating the commonality and sharing it while retaining the differences in functionality. Perhaps the method can be moved to a single place and given an additional parameter, allowing it to cover all use cases. Alternatively, there may be a common pre-processing or post-processing step that can be extracted to its own (shared) method, leaving only the specific parts in the existing methods. Modern IDEs may provide refactoring support for this sort of issue, usually with the names "Extract method", "Change method signature", "Pull up" or "Extract supertype".
    * If the two methods serve the same purpose and are different only as a result of inconsistent updates then treat the methods as completely duplicate. Determine the most up-to-date and correct version of the code and eliminate all near duplicates. Callers of the removed methods should be updated to call the remaining method instead.

    ## References
    * E. Juergens, F. Deissenboeck, B. Hummel, S. Wagner. *Do code clones matter?* Proceedings of the 31st International Conference on Software Engineering, 485-495, 2009.
 -
  pack: codeql/java-queries#0
  relativeQueryPath: external/MostlySimilarFile.ql
  relativeBqrsPath: codeql/java-queries/external/MostlySimilarFile.bqrs
  metadata:
    deprecated: ""
    name: Mostly similar file
    description: |-
      Files in which most of the lines are similar to those in another file make code more
                    difficult to understand and introduce a risk of changes being made to only one copy.
    kind: problem
    problem.severity: recommendation
    precision: high
    id: java/similar-file
    tags: |-
      testability
             maintainability
             useless-code
             duplicate-code
             statistical
             non-attributable
  queryHelp: |
    # Mostly similar file
    When most of the lines in one file have corresponding "similar" lines in one or more other files, the files themselves are regarded as *mostly similar*. Two lines are defined as similar if they are either identical or contain only very minor differences.

    Code duplication in general is highly undesirable for a range of reasons. The artificially inflated amount of code is more difficult to understand, and sequences of similar but subtly different lines can mask the real purpose or intention behind them. Also, there is always a risk that only one of several copies of the code is updated to address a defect or add a feature.


    ## Recommendation
    Consider whether the differences are deliberate or a result of an inconsistent update to one of the clones. If the latter, then treating the files as completely duplicate and eliminating all but one (while preserving any corrections or new features that may have been introduced) is the best course. If two files serve genuinely different purposes but almost all of their lines are the same, that can be a sign that there is a missing level of abstraction. Can some of the shared code be extracted into methods (perhaps with additional parameters, to cover the differences in behavior)? Should it be moved into a utility class or file that is accessible to all current implementations, or should a new level of abstraction be introduced?


    ## References
    * E. Juergens, F. Deissenboeck, B. Hummel, S. Wagner. *Do code clones matter?* Proceedings of the 31st International Conference on Software Engineering, 485-495, 2009.
 -
  pack: codeql/java-queries#0
  relativeQueryPath: filters/ClassifyFiles.ql
  relativeBqrsPath: codeql/java-queries/filters/ClassifyFiles.bqrs
  metadata:
    name: Classify files
    description: |-
      This query produces a list of all files in a snapshot
                    that are classified as generated code or test code.
    kind: file-classifier
    id: java/file-classifier
 -
  pack: codeql/java-queries#0
  relativeQueryPath: meta/frameworks/Coverage.ql
  relativeBqrsPath: codeql/java-queries/meta/frameworks/Coverage.bqrs
  metadata:
    name: Framework coverage
    description: |-
      The number of API endpoints covered by MaD models sorted by
                    package and source-, sink-, and summary-kind.
    kind: table
    id: java/meta/framework-coverage
 -
  pack: codeql/java-queries#0
  relativeQueryPath: meta/ssa/AmbiguousToString.ql
  relativeBqrsPath: codeql/java-queries/meta/ssa/AmbiguousToString.bqrs
  metadata:
    name: An SSA variable without a unique 'toString()'
    description: |-
      An ambiguous 'toString()' indicates overlap in the defining
                    sub-classes of 'SsaVariable'.
    kind: problem
    problem.severity: error
    id: java/consistency/non-unique-ssa-tostring
    tags: consistency
 -
  pack: codeql/java-queries#0
  relativeQueryPath: meta/ssa/TooFewPhiInputs.ql
  relativeBqrsPath: codeql/java-queries/meta/ssa/TooFewPhiInputs.bqrs
  metadata:
    name: A phi node without two or more inputs
    description: A phi node should have at least two inputs.
    kind: problem
    problem.severity: error
    id: java/consistency/too-few-phi-inputs
    tags: consistency
 -
  pack: codeql/java-queries#0
  relativeQueryPath: meta/ssa/UncertainDefWithoutPrior.ql
  relativeBqrsPath: codeql/java-queries/meta/ssa/UncertainDefWithoutPrior.bqrs
  metadata:
    name: An uncertain SSA update without a prior definition
    description: |-
      An uncertain SSA update may retain its previous value
                    and should therefore have a prior definition.
    kind: problem
    problem.severity: error
    id: java/consistency/uncertain-ssa-update-without-prior-def
    tags: consistency
 -
  pack: codeql/java-queries#0
  relativeQueryPath: meta/ssa/UseWithoutUniqueSsaVariable.ql
  relativeBqrsPath: codeql/java-queries/meta/ssa/UseWithoutUniqueSsaVariable.bqrs
  metadata:
    name: A variable use without a unique SSA variable
    description: |-
      Every variable use that is sufficiently trackable
                    should have a unique associated SSA variable.
    kind: problem
    problem.severity: error
    id: java/consistency/use-without-unique-ssa-variable
    tags: consistency
 -
  pack: codeql/java-queries#0
  relativeQueryPath: utils/modelconverter/ExtractNeutrals.ql
  relativeBqrsPath: codeql/java-queries/utils/modelconverter/ExtractNeutrals.bqrs
  metadata:
    name: Extract MaD neutral model rows.
    description: This extracts the Models as data neutral model rows.
    id: java/utils/modelconverter/generate-data-extensions-neutral
 -
  pack: codeql/java-queries#0
  relativeQueryPath: utils/modelconverter/ExtractSinks.ql
  relativeBqrsPath: codeql/java-queries/utils/modelconverter/ExtractSinks.bqrs
  metadata:
    name: Extract MaD sink model rows.
    description: This extracts the Models as data sink model rows.
    id: java/utils/modelconverter/generate-data-extensions-sink
 -
  pack: codeql/java-queries#0
  relativeQueryPath: utils/modelconverter/ExtractSources.ql
  relativeBqrsPath: codeql/java-queries/utils/modelconverter/ExtractSources.bqrs
  metadata:
    name: Extract MaD source model rows.
    description: This extracts the Models as data source model rows.
    id: java/utils/modelconverter/generate-data-extensions-source
 -
  pack: codeql/java-queries#0
  relativeQueryPath: utils/modelconverter/ExtractSummaries.ql
  relativeBqrsPath: codeql/java-queries/utils/modelconverter/ExtractSummaries.bqrs
  metadata:
    name: Extract MaD summary model rows.
    description: This extracts the Models as data summary model rows.
    id: java/utils/modelconverter/generate-data-extensions-summary
 -
  pack: codeql/java-queries#0
  relativeQueryPath: utils/modeleditor/ApplicationModeEndpoints.ql
  relativeBqrsPath: codeql/java-queries/utils/modeleditor/ApplicationModeEndpoints.bqrs
  metadata:
    name: Fetch endpoints for use in the model editor (application mode)
    description: A list of 3rd party endpoints (methods) used in the codebase. Excludes
      test and generated code.
    kind: table
    id: java/utils/modeleditor/application-mode-endpoints
    tags: modeleditor endpoints application-mode
 -
  pack: codeql/java-queries#0
  relativeQueryPath: utils/modeleditor/FrameworkModeEndpoints.ql
  relativeBqrsPath: codeql/java-queries/utils/modeleditor/FrameworkModeEndpoints.bqrs
  metadata:
    name: Fetch endpoints for use in the model editor (framework mode)
    description: A list of endpoints accessible (methods) for consumers of the library.
      Excludes test and generated code.
    kind: table
    id: java/utils/modeleditor/framework-mode-endpoints
    tags: modeleditor endpoints framework-mode
 -
  pack: codeql/java-queries#0
  relativeQueryPath: utils/modelgenerator/CaptureContentSummaryModels.ql
  relativeBqrsPath: codeql/java-queries/utils/modelgenerator/CaptureContentSummaryModels.bqrs
  metadata:
    name: Capture content based summary models.
    description: Finds applicable content based summary models to be used by other
      queries.
    kind: diagnostic
    id: java/utils/modelgenerator/contentbased-summary-models
    tags: modelgenerator
 -
  pack: codeql/java-queries#0
  relativeQueryPath: utils/modelgenerator/CaptureMixedNeutralModels.ql
  relativeBqrsPath: codeql/java-queries/utils/modelgenerator/CaptureMixedNeutralModels.bqrs
  metadata:
    name: Capture mixed neutral models.
    description: Finds neutral models to be used by other queries.
    kind: diagnostic
    id: java/utils/modelgenerator/mixed-neutral-models
    tags: modelgenerator
 -
  pack: codeql/java-queries#0
  relativeQueryPath: utils/modelgenerator/CaptureMixedSummaryModels.ql
  relativeBqrsPath: codeql/java-queries/utils/modelgenerator/CaptureMixedSummaryModels.bqrs
  metadata:
    name: Capture mixed summary models.
    description: Finds applicable summary models to be used by other queries.
    kind: diagnostic
    id: java/utils/modelgenerator/mixed-summary-models
    tags: modelgenerator
 -
  pack: codeql/java-queries#0
  relativeQueryPath: utils/modelgenerator/CaptureNeutralModels.ql
  relativeBqrsPath: codeql/java-queries/utils/modelgenerator/CaptureNeutralModels.bqrs
  metadata:
    name: Capture neutral models.
    description: Finds neutral models to be used by other queries.
    kind: diagnostic
    id: java/utils/modelgenerator/neutral-models
    tags: modelgenerator
 -
  pack: codeql/java-queries#0
  relativeQueryPath: utils/modelgenerator/CaptureSinkModels.ql
  relativeBqrsPath: codeql/java-queries/utils/modelgenerator/CaptureSinkModels.bqrs
  metadata:
    name: Capture sink models.
    description: Finds public methods that act as sinks as they flow into a known
      sink.
    kind: diagnostic
    id: java/utils/modelgenerator/sink-models
    tags: modelgenerator
 -
  pack: codeql/java-queries#0
  relativeQueryPath: utils/modelgenerator/CaptureSourceModels.ql
  relativeBqrsPath: codeql/java-queries/utils/modelgenerator/CaptureSourceModels.bqrs
  metadata:
    name: Capture source models.
    description: Finds APIs that act as sources as they expose already known sources.
    kind: diagnostic
    id: java/utils/modelgenerator/source-models
    tags: modelgenerator
 -
  pack: codeql/java-queries#0
  relativeQueryPath: utils/modelgenerator/CaptureSummaryModels.ql
  relativeBqrsPath: codeql/java-queries/utils/modelgenerator/CaptureSummaryModels.bqrs
  metadata:
    name: Capture summary models.
    description: Finds applicable summary models to be used by other queries.
    kind: diagnostic
    id: java/utils/modelgenerator/summary-models
    tags: modelgenerator
 -
  pack: codeql/java-queries#0
  relativeQueryPath: utils/modelgenerator/CaptureTypeBasedSummaryModels.ql
  relativeBqrsPath: codeql/java-queries/utils/modelgenerator/CaptureTypeBasedSummaryModels.bqrs
  metadata:
    name: Capture typed based summary models.
    description: Finds applicable summary models to be used by other queries.
    kind: diagnostic
    id: java/utils/modelgenerator/summary-models-typed-based
    tags: modelgenerator
 -
  pack: codeql/java-queries#0
  relativeQueryPath: utils/modelgenerator/debug/CaptureSummaryModelsPartialPath.ql
  relativeBqrsPath: codeql/java-queries/utils/modelgenerator/debug/CaptureSummaryModelsPartialPath.bqrs
  metadata:
    name: Capture Summary Models Partial Path
    description: Capture Summary Models Partial Path
    kind: path-problem
    precision: low
    id: java/utils/modelgenerator/summary-models-partial-path
    severity: info
    tags: modelgenerator
 -
  pack: codeql/java-queries#0
  relativeQueryPath: utils/modelgenerator/debug/CaptureSummaryModelsPath.ql
  relativeBqrsPath: codeql/java-queries/utils/modelgenerator/debug/CaptureSummaryModelsPath.bqrs
  metadata:
    name: Capture Summary Models Path
    description: Capture Summary Models Path
    kind: path-problem
    precision: low
    id: java/utils/modelgenerator/summary-models-path
    severity: warning
    tags: modelgenerator
 -
  pack: codeql/java-queries#0
  relativeQueryPath: utils/stub-generator/MinimalStubsFromSource.ql
  relativeBqrsPath: codeql/java-queries/utils/stub-generator/MinimalStubsFromSource.bqrs
  metadata: {}
extensionPacks: []
packs:
  codeql/util#3:
    name: codeql/util
    version: 1.0.11
    isLibrary: true
    isExtensionPack: false
    localPath: file:///Users/hamzamajidqureshi/codeql/qlpacks/codeql/java-queries/1.1.8/.codeql/libraries/codeql/util/1.0.11/
    localPackDefinitionFile: file:///Users/hamzamajidqureshi/codeql/qlpacks/codeql/java-queries/1.1.8/.codeql/libraries/codeql/util/1.0.11/qlpack.yml
    headSha: 39a67b6e2e6490a9bd010db50e148f647765e9f7
    runDataExtensions: []
  codeql/java-all#1:
    name: codeql/java-all
    version: 4.2.0
    isLibrary: true
    isExtensionPack: false
    localPath: file:///Users/hamzamajidqureshi/codeql/qlpacks/codeql/java-queries/1.1.8/.codeql/libraries/codeql/java-all/4.2.0/
    localPackDefinitionFile: file:///Users/hamzamajidqureshi/codeql/qlpacks/codeql/java-queries/1.1.8/.codeql/libraries/codeql/java-all/4.2.0/qlpack.yml
    headSha: 39a67b6e2e6490a9bd010db50e148f647765e9f7
    runDataExtensions: []
  codeql/threat-models#2:
    name: codeql/threat-models
    version: 1.0.11
    isLibrary: true
    isExtensionPack: false
    localPath: file:///Users/hamzamajidqureshi/codeql/qlpacks/codeql/java-queries/1.1.8/.codeql/libraries/codeql/threat-models/1.0.11/
    localPackDefinitionFile: file:///Users/hamzamajidqureshi/codeql/qlpacks/codeql/java-queries/1.1.8/.codeql/libraries/codeql/threat-models/1.0.11/qlpack.yml
    headSha: 39a67b6e2e6490a9bd010db50e148f647765e9f7
    runDataExtensions: []
  codeql/java-queries#0:
    name: codeql/java-queries
    version: 1.1.8
    isLibrary: false
    isExtensionPack: false
    localPath: file:///Users/hamzamajidqureshi/codeql/qlpacks/codeql/java-queries/1.1.8/
    localPackDefinitionFile: file:///Users/hamzamajidqureshi/codeql/qlpacks/codeql/java-queries/1.1.8/qlpack.yml
    headSha: 39a67b6e2e6490a9bd010db50e148f647765e9f7
    runDataExtensions:
     -
      pack: codeql/java-all#1
      relativePath: ext/android.app.model.yml
      index: 0
      firstRowId: 0
      rowCount: 77
      locations:
        lineNumbers: A=6+1*76
        columnNumbers: A=9*77
     -
      pack: codeql/java-all#1
      relativePath: ext/android.app.model.yml
      index: 1
      firstRowId: 77
      rowCount: 103
      locations:
        lineNumbers: A=88+1*102
        columnNumbers: A=9*103
     -
      pack: codeql/java-all#1
      relativePath: ext/android.content.model.yml
      index: 0
      firstRowId: 180
      rowCount: 31
      locations:
        lineNumbers: A=7+1*30
        columnNumbers: A=9*31
     -
      pack: codeql/java-all#1
      relativePath: ext/android.content.model.yml
      index: 1
      firstRowId: 211
      rowCount: 24
      locations:
        lineNumbers: A=42+1*23
        columnNumbers: A=9*24
     -
      pack: codeql/java-all#1
      relativePath: ext/android.content.model.yml
      index: 2
      firstRowId: 235
      rowCount: 154
      locations:
        lineNumbers: A=70+1*13+2+1*51+2+1*87
        columnNumbers: A=9*154
     -
      pack: codeql/java-all#1
      relativePath: ext/android.database.model.yml
      index: 0
      firstRowId: 389
      rowCount: 7
      locations:
        lineNumbers: A=6+1*6
        columnNumbers: A=9*7
     -
      pack: codeql/java-all#1
      relativePath: ext/android.database.model.yml
      index: 1
      firstRowId: 396
      rowCount: 11
      locations:
        lineNumbers: A=17+1*10
        columnNumbers: A=9*11
     -
      pack: codeql/java-all#1
      relativePath: ext/android.database.sqlite.model.yml
      index: 0
      firstRowId: 407
      rowCount: 52
      locations:
        lineNumbers: A=6+1*51
        columnNumbers: A=9*52
     -
      pack: codeql/java-all#1
      relativePath: ext/android.database.sqlite.model.yml
      index: 1
      firstRowId: 459
      rowCount: 30
      locations:
        lineNumbers: A=62+1*29
        columnNumbers: A=9*30
     -
      pack: codeql/java-all#1
      relativePath: ext/android.net.model.yml
      index: 0
      firstRowId: 489
      rowCount: 60
      locations:
        lineNumbers: A=6+1*59
        columnNumbers: A=9*60
     -
      pack: codeql/java-all#1
      relativePath: ext/android.os.model.yml
      index: 0
      firstRowId: 549
      rowCount: 2
      locations:
        lineNumbers: A=6+1
        columnNumbers: A=9*2
     -
      pack: codeql/java-all#1
      relativePath: ext/android.os.model.yml
      index: 1
      firstRowId: 551
      rowCount: 122
      locations:
        lineNumbers: A=12+1*25+2+1*95
        columnNumbers: A=9*122
     -
      pack: codeql/java-all#1
      relativePath: ext/android.os.model.yml
      index: 2
      firstRowId: 673
      rowCount: 1
      locations:
        lineNumbers: A=139
        columnNumbers: A=9
     -
      pack: codeql/java-all#1
      relativePath: ext/android.support.v4.app.model.yml
      index: 0
      firstRowId: 674
      rowCount: 11
      locations:
        lineNumbers: A=6+1*10
        columnNumbers: A=9*11
     -
      pack: codeql/java-all#1
      relativePath: ext/android.util.model.yml
      index: 0
      firstRowId: 685
      rowCount: 16
      locations:
        lineNumbers: A=6+1*15
        columnNumbers: A=9*16
     -
      pack: codeql/java-all#1
      relativePath: ext/android.util.model.yml
      index: 1
      firstRowId: 701
      rowCount: 6
      locations:
        lineNumbers: A=26+1*5
        columnNumbers: A=9*6
     -
      pack: codeql/java-all#1
      relativePath: ext/android.webkit.model.yml
      index: 0
      firstRowId: 707
      rowCount: 2
      locations:
        lineNumbers: A=6+1
        columnNumbers: A=9*2
     -
      pack: codeql/java-all#1
      relativePath: ext/android.webkit.model.yml
      index: 1
      firstRowId: 709
      rowCount: 3
      locations:
        lineNumbers: A=13+1*2
        columnNumbers: A=9*3
     -
      pack: codeql/java-all#1
      relativePath: ext/android.widget.model.yml
      index: 0
      firstRowId: 712
      rowCount: 1
      locations:
        lineNumbers: A=6
        columnNumbers: A=9
     -
      pack: codeql/java-all#1
      relativePath: ext/android.widget.model.yml
      index: 1
      firstRowId: 713
      rowCount: 1
      locations:
        lineNumbers: A=11
        columnNumbers: A=9
     -
      pack: codeql/java-all#1
      relativePath: ext/androidx.core.app.model.yml
      index: 0
      firstRowId: 714
      rowCount: 47
      locations:
        lineNumbers: A=6+1*46
        columnNumbers: A=9*47
     -
      pack: codeql/java-all#1
      relativePath: ext/androidx.core.app.model.yml
      index: 1
      firstRowId: 761
      rowCount: 95
      locations:
        lineNumbers: A=58+1*94
        columnNumbers: A=9*95
     -
      pack: codeql/java-all#1
      relativePath: ext/androidx.fragment.app.model.yml
      index: 0
      firstRowId: 856
      rowCount: 11
      locations:
        lineNumbers: A=6+1*10
        columnNumbers: A=9*11
     -
      pack: codeql/java-all#1
      relativePath: ext/androidx.slice.builders.model.yml
      index: 0
      firstRowId: 867
      rowCount: 88
      locations:
        lineNumbers: A=6+1*87
        columnNumbers: A=9*88
     -
      pack: codeql/java-all#1
      relativePath: ext/androidx.slice.model.yml
      index: 0
      firstRowId: 955
      rowCount: 5
      locations:
        lineNumbers: A=6+1*4
        columnNumbers: A=9*5
     -
      pack: codeql/java-all#1
      relativePath: ext/androidx.slice.model.yml
      index: 1
      firstRowId: 960
      rowCount: 2
      locations:
        lineNumbers: A=15+1
        columnNumbers: A=9*2
     -
      pack: codeql/java-all#1
      relativePath: ext/ch.ethz.ssh2.model.yml
      index: 0
      firstRowId: 962
      rowCount: 2
      locations:
        lineNumbers: A=6+1
        columnNumbers: A=9*2
     -
      pack: codeql/java-all#1
      relativePath: ext/cn.hutool.core.codec.model.yml
      index: 0
      firstRowId: 964
      rowCount: 1
      locations:
        lineNumbers: A=6
        columnNumbers: A=9
     -
      pack: codeql/java-all#1
      relativePath: ext/com.alibaba.druid.sql.model.yml
      index: 0
      firstRowId: 965
      rowCount: 1
      locations:
        lineNumbers: A=6
        columnNumbers: A=9
     -
      pack: codeql/java-all#1
      relativePath: ext/com.alibaba.druid.sql.repository.model.yml
      index: 0
      firstRowId: 966
      rowCount: 1
      locations:
        lineNumbers: A=6
        columnNumbers: A=9
     -
      pack: codeql/java-all#1
      relativePath: ext/com.alibaba.fastjson2.model.yml
      index: 0
      firstRowId: 967
      rowCount: 1
      locations:
        lineNumbers: A=6
        columnNumbers: A=9
     -
      pack: codeql/java-all#1
      relativePath: ext/com.amazonaws.auth.model.yml
      index: 0
      firstRowId: 968
      rowCount: 2
      locations:
        lineNumbers: A=6+1
        columnNumbers: A=9*2
     -
      pack: codeql/java-all#1
      relativePath: ext/com.auth0.jwt.algorithms.model.yml
      index: 0
      firstRowId: 970
      rowCount: 6
      locations:
        lineNumbers: A=6+1*5
        columnNumbers: A=9*6
     -
      pack: codeql/java-all#1
      relativePath: ext/com.azure.identity.model.yml
      index: 0
      firstRowId: 976
      rowCount: 3
      locations:
        lineNumbers: A=6+1*2
        columnNumbers: A=9*3
     -
      pack: codeql/java-all#1
      relativePath: ext/com.esotericsoftware.kryo.io.model.yml
      index: 0
      firstRowId: 979
      rowCount: 1
      locations:
        lineNumbers: A=6
        columnNumbers: A=9
     -
      pack: codeql/java-all#1
      relativePath: ext/com.esotericsoftware.kryo5.io.model.yml
      index: 0
      firstRowId: 980
      rowCount: 1
      locations:
        lineNumbers: A=6
        columnNumbers: A=9
     -
      pack: codeql/java-all#1
      relativePath: ext/com.fasterxml.jackson.core.model.yml
      index: 0
      firstRowId: 981
      rowCount: 1
      locations:
        lineNumbers: A=6
        columnNumbers: A=9
     -
      pack: codeql/java-all#1
      relativePath: ext/com.fasterxml.jackson.databind.model.yml
      index: 0
      firstRowId: 982
      rowCount: 8
      locations:
        lineNumbers: A=6+1*7
        columnNumbers: A=9*8
     -
      pack: codeql/java-all#1
      relativePath: ext/com.fasterxml.jackson.databind.model.yml
      index: 1
      firstRowId: 990
      rowCount: 2
      locations:
        lineNumbers: A=18+1
        columnNumbers: A=9*2
     -
      pack: codeql/java-all#1
      relativePath: ext/com.google.common.base.model.yml
      index: 0
      firstRowId: 992
      rowCount: 4
      locations:
        lineNumbers: A=6+1*3
        columnNumbers: A=9*4
     -
      pack: codeql/java-all#1
      relativePath: ext/com.google.common.base.model.yml
      index: 1
      firstRowId: 996
      rowCount: 87
      locations:
        lineNumbers: A=14+1*86
        columnNumbers: A=9*87
     -
      pack: codeql/java-all#1
      relativePath: ext/com.google.common.cache.model.yml
      index: 0
      firstRowId: 1083
      rowCount: 17
      locations:
        lineNumbers: A=6+1+2*2+1*13
        columnNumbers: A=9*17
     -
      pack: codeql/java-all#1
      relativePath: ext/com.google.common.collect.model.yml
      index: 0
      firstRowId: 1100
      rowCount: 553
      locations:
        lineNumbers: A=8+1*552
        columnNumbers: A=9*553
     -
      pack: codeql/java-all#1
      relativePath: ext/com.google.common.flogger.model.yml
      index: 0
      firstRowId: 1653
      rowCount: 29
      locations:
        lineNumbers: A=6+1*28
        columnNumbers: A=9*29
     -
      pack: codeql/java-all#1
      relativePath: ext/com.google.common.io.model.yml
      index: 0
      firstRowId: 1682
      rowCount: 10
      locations:
        lineNumbers: A=6+1*9
        columnNumbers: A=9*10
     -
      pack: codeql/java-all#1
      relativePath: ext/com.google.common.io.model.yml
      index: 1
      firstRowId: 1692
      rowCount: 73
      locations:
        lineNumbers: A=20+1*72
        columnNumbers: A=9*73
     -
      pack: codeql/java-all#1
      relativePath: ext/com.google.gson.model.yml
      index: 0
      firstRowId: 1765
      rowCount: 52
      locations:
        lineNumbers: A=6+1*51
        columnNumbers: A=9*52
     -
      pack: codeql/java-all#1
      relativePath: ext/com.hubspot.jinjava.model.yml
      index: 0
      firstRowId: 1817
      rowCount: 2
      locations:
        lineNumbers: A=6+1
        columnNumbers: A=9*2
     -
      pack: codeql/java-all#1
      relativePath: ext/com.jcraft.jsch.model.yml
      index: 0
      firstRowId: 1819
      rowCount: 5
      locations:
        lineNumbers: A=6+1*4
        columnNumbers: A=9*5
     -
      pack: codeql/java-all#1
      relativePath: ext/com.jcraft.jsch.model.yml
      index: 1
      firstRowId: 1824
      rowCount: 1
      locations:
        lineNumbers: A=15
        columnNumbers: A=9
     -
      pack: codeql/java-all#1
      relativePath: ext/com.microsoft.sqlserver.jdbc.model.yml
      index: 0
      firstRowId: 1825
      rowCount: 4
      locations:
        lineNumbers: A=6+1*3
        columnNumbers: A=9*4
     -
      pack: codeql/java-all#1
      relativePath: ext/com.mitchellbosecke.pebble.model.yml
      index: 0
      firstRowId: 1829
      rowCount: 2
      locations:
        lineNumbers: A=6+1
        columnNumbers: A=9*2
     -
      pack: codeql/java-all#1
      relativePath: ext/com.mongodb.model.yml
      index: 0
      firstRowId: 1831
      rowCount: 10
      locations:
        lineNumbers: A=6+1*9
        columnNumbers: A=9*10
     -
      pack: codeql/java-all#1
      relativePath: ext/com.opensymphony.xwork2.ognl.model.yml
      index: 0
      firstRowId: 1841
      rowCount: 3
      locations:
        lineNumbers: A=6+1*2
        columnNumbers: A=9*3
     -
      pack: codeql/java-all#1
      relativePath: ext/com.rabbitmq.client.impl.model.yml
      index: 0
      firstRowId: 1844
      rowCount: 3
      locations:
        lineNumbers: A=6+1*2
        columnNumbers: A=9*3
     -
      pack: codeql/java-all#1
      relativePath: ext/com.rabbitmq.client.impl.model.yml
      index: 1
      firstRowId: 1847
      rowCount: 3
      locations:
        lineNumbers: A=13+1*2
        columnNumbers: A=9*3
     -
      pack: codeql/java-all#1
      relativePath: ext/com.rabbitmq.client.model.yml
      index: 0
      firstRowId: 1850
      rowCount: 18
      locations:
        lineNumbers: A=6+1*17
        columnNumbers: A=9*18
     -
      pack: codeql/java-all#1
      relativePath: ext/com.rabbitmq.client.model.yml
      index: 1
      firstRowId: 1868
      rowCount: 4
      locations:
        lineNumbers: A=28+1*3
        columnNumbers: A=9*4
     -
      pack: codeql/java-all#1
      relativePath: ext/com.sshtools.j2ssh.authentication.model.yml
      index: 0
      firstRowId: 1872
      rowCount: 3
      locations:
        lineNumbers: A=6+1*2
        columnNumbers: A=9*3
     -
      pack: codeql/java-all#1
      relativePath: ext/com.sun.crypto.provider.model.yml
      index: 0
      firstRowId: 1875
      rowCount: 19
      locations:
        lineNumbers: A=6+1*18
        columnNumbers: A=9*19
     -
      pack: codeql/java-all#1
      relativePath: ext/com.sun.jndi.ldap.model.yml
      index: 0
      firstRowId: 1894
      rowCount: 4
      locations:
        lineNumbers: A=6+1*3
        columnNumbers: A=9*4
     -
      pack: codeql/java-all#1
      relativePath: ext/com.sun.net.httpserver.model.yml
      index: 0
      firstRowId: 1898
      rowCount: 3
      locations:
        lineNumbers: A=6+1*2
        columnNumbers: A=9*3
     -
      pack: codeql/java-all#1
      relativePath: ext/com.sun.net.ssl.model.yml
      index: 0
      firstRowId: 1901
      rowCount: 3
      locations:
        lineNumbers: A=6+1*2
        columnNumbers: A=9*3
     -
      pack: codeql/java-all#1
      relativePath: ext/com.sun.rowset.model.yml
      index: 0
      firstRowId: 1904
      rowCount: 3
      locations:
        lineNumbers: A=6+1*2
        columnNumbers: A=9*3
     -
      pack: codeql/java-all#1
      relativePath: ext/com.sun.security.auth.module.model.yml
      index: 0
      firstRowId: 1907
      rowCount: 2
      locations:
        lineNumbers: A=6+1
        columnNumbers: A=9*2
     -
      pack: codeql/java-all#1
      relativePath: ext/com.sun.security.ntlm.model.yml
      index: 0
      firstRowId: 1909
      rowCount: 5
      locations:
        lineNumbers: A=6+1*4
        columnNumbers: A=9*5
     -
      pack: codeql/java-all#1
      relativePath: ext/com.sun.security.sasl.digest.model.yml
      index: 0
      firstRowId: 1914
      rowCount: 3
      locations:
        lineNumbers: A=6+1*2
        columnNumbers: A=9*3
     -
      pack: codeql/java-all#1
      relativePath: ext/com.thoughtworks.xstream.model.yml
      index: 0
      firstRowId: 1917
      rowCount: 1
      locations:
        lineNumbers: A=6
        columnNumbers: A=9
     -
      pack: codeql/java-all#1
      relativePath: ext/com.trilead.ssh2.model.yml
      index: 0
      firstRowId: 1918
      rowCount: 13
      locations:
        lineNumbers: A=6+1*12
        columnNumbers: A=9*13
     -
      pack: codeql/java-all#1
      relativePath: ext/com.unboundid.ldap.sdk.model.yml
      index: 0
      firstRowId: 1931
      rowCount: 17
      locations:
        lineNumbers: A=6+1*16
        columnNumbers: A=9*17
     -
      pack: codeql/java-all#1
      relativePath: ext/com.zaxxer.hikari.model.yml
      index: 0
      firstRowId: 1948
      rowCount: 2
      locations:
        lineNumbers: A=6+1
        columnNumbers: A=9*2
     -
      pack: codeql/java-all#1
      relativePath: ext/experimental/android.webkit.model.yml
      index: 0
      firstRowId: 1950
      rowCount: 1
      locations:
        lineNumbers: A=6
        columnNumbers: A=9
     -
      pack: codeql/java-all#1
      relativePath: ext/experimental/com.google.common.io.model.yml
      index: 0
      firstRowId: 1951
      rowCount: 6
      locations:
        lineNumbers: A=6+1*5
        columnNumbers: A=9*6
     -
      pack: codeql/java-all#1
      relativePath: ext/experimental/com.jcraft.jsch.model.yml
      index: 0
      firstRowId: 1957
      rowCount: 1
      locations:
        lineNumbers: A=6
        columnNumbers: A=9
     -
      pack: codeql/java-all#1
      relativePath: ext/experimental/com.jfinal.core.model.yml
      index: 0
      firstRowId: 1958
      rowCount: 23
      locations:
        lineNumbers: A=6+1*22
        columnNumbers: A=9*23
     -
      pack: codeql/java-all#1
      relativePath: ext/experimental/java.io.model.yml
      index: 0
      firstRowId: 1981
      rowCount: 1
      locations:
        lineNumbers: A=6
        columnNumbers: A=9
     -
      pack: codeql/java-all#1
      relativePath: ext/experimental/java.lang.model.yml
      index: 0
      firstRowId: 1982
      rowCount: 1
      locations:
        lineNumbers: A=6
        columnNumbers: A=9
     -
      pack: codeql/java-all#1
      relativePath: ext/experimental/java.lang.model.yml
      index: 1
      firstRowId: 1983
      rowCount: 2
      locations:
        lineNumbers: A=11+1
        columnNumbers: A=9*2
     -
      pack: codeql/java-all#1
      relativePath: ext/experimental/java.nio.model.yml
      index: 0
      firstRowId: 1985
      rowCount: 3
      locations:
        lineNumbers: A=6+1*2
        columnNumbers: A=9*3
     -
      pack: codeql/java-all#1
      relativePath: ext/experimental/java.util.concurrent.model.yml
      index: 0
      firstRowId: 1988
      rowCount: 1
      locations:
        lineNumbers: A=6
        columnNumbers: A=9
     -
      pack: codeql/java-all#1
      relativePath: ext/experimental/java.util.zip.model.yml
      index: 0
      firstRowId: 1989
      rowCount: 1
      locations:
        lineNumbers: A=6
        columnNumbers: A=9
     -
      pack: codeql/java-all#1
      relativePath: ext/experimental/javax.servlet.http.model.yml
      index: 0
      firstRowId: 1990
      rowCount: 5
      locations:
        lineNumbers: A=6+1*4
        columnNumbers: A=9*5
     -
      pack: codeql/java-all#1
      relativePath: ext/experimental/org.apache.logging.log4j.message.model.yml
      index: 0
      firstRowId: 1995
      rowCount: 4
      locations:
        lineNumbers: A=6+1*3
        columnNumbers: A=9*4
     -
      pack: codeql/java-all#1
      relativePath: ext/experimental/org.apache.logging.log4j.model.yml
      index: 0
      firstRowId: 1999
      rowCount: 357
      locations:
        lineNumbers: A=6+1*356
        columnNumbers: A=9*357
     -
      pack: codeql/java-all#1
      relativePath: ext/experimental/org.apache.shiro.authc.model.yml
      index: 0
      firstRowId: 2356
      rowCount: 1
      locations:
        lineNumbers: A=6
        columnNumbers: A=9
     -
      pack: codeql/java-all#1
      relativePath: ext/experimental/s3-transfer-manager.model.yml
      index: 0
      firstRowId: 2357
      rowCount: 8
      locations:
        lineNumbers: A=6+1*7
        columnNumbers: A=9*8
     -
      pack: codeql/java-all#1
      relativePath: ext/experimental/spring-core.model.yml
      index: 0
      firstRowId: 2365
      rowCount: 21
      locations:
        lineNumbers: A=6+1*20
        columnNumbers: A=9*21
     -
      pack: codeql/java-all#1
      relativePath: ext/experimental/zip4j.model.yml
      index: 0
      firstRowId: 2386
      rowCount: 2
      locations:
        lineNumbers: A=6+1
        columnNumbers: A=9*2
     -
      pack: codeql/java-all#1
      relativePath: ext/flexjson.model.yml
      index: 0
      firstRowId: 2388
      rowCount: 1
      locations:
        lineNumbers: A=6
        columnNumbers: A=9
     -
      pack: codeql/java-all#1
      relativePath: ext/freemarker.cache.model.yml
      index: 0
      firstRowId: 2389
      rowCount: 1
      locations:
        lineNumbers: A=6
        columnNumbers: A=9
     -
      pack: codeql/java-all#1
      relativePath: ext/freemarker.template.model.yml
      index: 0
      firstRowId: 2390
      rowCount: 7
      locations:
        lineNumbers: A=6+1*6
        columnNumbers: A=9*7
     -
      pack: codeql/java-all#1
      relativePath: ext/generated/java.applet.model.yml
      index: 0
      firstRowId: 2397
      rowCount: 11
      locations:
        lineNumbers: A=7+1*10
        columnNumbers: A=9*11
     -
      pack: codeql/java-all#1
      relativePath: ext/generated/java.applet.model.yml
      index: 1
      firstRowId: 2408
      rowCount: 19
      locations:
        lineNumbers: A=22+1*18
        columnNumbers: A=9*19
     -
      pack: codeql/java-all#1
      relativePath: ext/generated/java.beans.beancontext.model.yml
      index: 0
      firstRowId: 2427
      rowCount: 37
      locations:
        lineNumbers: A=7+1*36
        columnNumbers: A=9*37
     -
      pack: codeql/java-all#1
      relativePath: ext/generated/java.beans.beancontext.model.yml
      index: 1
      firstRowId: 2464
      rowCount: 42
      locations:
        lineNumbers: A=48+1*41
        columnNumbers: A=9*42
     -
      pack: codeql/java-all#1
      relativePath: ext/generated/java.beans.model.yml
      index: 0
      firstRowId: 2506
      rowCount: 139
      locations:
        lineNumbers: A=7+1*138
        columnNumbers: A=9*139
     -
      pack: codeql/java-all#1
      relativePath: ext/generated/java.beans.model.yml
      index: 1
      firstRowId: 2645
      rowCount: 90
      locations:
        lineNumbers: A=150+1*89
        columnNumbers: A=9*90
     -
      pack: codeql/java-all#1
      relativePath: ext/generated/java.io.model.yml
      index: 0
      firstRowId: 2735
      rowCount: 173
      locations:
        lineNumbers: A=7+1*172
        columnNumbers: A=9*173
     -
      pack: codeql/java-all#1
      relativePath: ext/generated/java.io.model.yml
      index: 1
      firstRowId: 2908
      rowCount: 278
      locations:
        lineNumbers: A=184+1*277
        columnNumbers: A=9*278
     -
      pack: codeql/java-all#1
      relativePath: ext/generated/java.lang.annotation.model.yml
      index: 0
      firstRowId: 3186
      rowCount: 10
      locations:
        lineNumbers: A=7+1*9
        columnNumbers: A=9*10
     -
      pack: codeql/java-all#1
      relativePath: ext/generated/java.lang.annotation.model.yml
      index: 1
      firstRowId: 3196
      rowCount: 1
      locations:
        lineNumbers: A=21
        columnNumbers: A=9
     -
      pack: codeql/java-all#1
      relativePath: ext/generated/java.lang.constant.model.yml
      index: 0
      firstRowId: 3197
      rowCount: 97
      locations:
        lineNumbers: A=7+1*96
        columnNumbers: A=9*97
     -
      pack: codeql/java-all#1
      relativePath: ext/generated/java.lang.constant.model.yml
      index: 1
      firstRowId: 3294
      rowCount: 6
      locations:
        lineNumbers: A=108+1*5
        columnNumbers: A=9*6
     -
      pack: codeql/java-all#1
      relativePath: ext/generated/java.lang.instrument.model.yml
      index: 0
      firstRowId: 3300
      rowCount: 5
      locations:
        lineNumbers: A=7+1*4
        columnNumbers: A=9*5
     -
      pack: codeql/java-all#1
      relativePath: ext/generated/java.lang.instrument.model.yml
      index: 1
      firstRowId: 3305
      rowCount: 3
      locations:
        lineNumbers: A=16+1*2
        columnNumbers: A=9*3
     -
      pack: codeql/java-all#1
      relativePath: ext/generated/java.lang.invoke.model.yml
      index: 0
      firstRowId: 3308
      rowCount: 143
      locations:
        lineNumbers: A=7+1*142
        columnNumbers: A=9*143
     -
      pack: codeql/java-all#1
      relativePath: ext/generated/java.lang.invoke.model.yml
      index: 1
      firstRowId: 3451
      rowCount: 128
      locations:
        lineNumbers: A=154+1*127
        columnNumbers: A=9*128
     -
      pack: codeql/java-all#1
      relativePath: ext/generated/java.lang.management.model.yml
      index: 0
      firstRowId: 3579
      rowCount: 29
      locations:
        lineNumbers: A=7+1*28
        columnNumbers: A=9*29
     -
      pack: codeql/java-all#1
      relativePath: ext/generated/java.lang.management.model.yml
      index: 1
      firstRowId: 3608
      rowCount: 38
      locations:
        lineNumbers: A=40+1*37
        columnNumbers: A=9*38
     -
      pack: codeql/java-all#1
      relativePath: ext/generated/java.lang.model.yml
      index: 0
      firstRowId: 3646
      rowCount: 240
      locations:
        lineNumbers: A=7+1*239
        columnNumbers: A=9*240
     -
      pack: codeql/java-all#1
      relativePath: ext/generated/java.lang.model.yml
      index: 1
      firstRowId: 3886
      rowCount: 707
      locations:
        lineNumbers: A=251+1*706
        columnNumbers: A=9*707
     -
      pack: codeql/java-all#1
      relativePath: ext/generated/java.lang.module.model.yml
      index: 0
      firstRowId: 4593
      rowCount: 84
      locations:
        lineNumbers: A=7+1*83
        columnNumbers: A=9*84
     -
      pack: codeql/java-all#1
      relativePath: ext/generated/java.lang.module.model.yml
      index: 1
      firstRowId: 4677
      rowCount: 10
      locations:
        lineNumbers: A=95+1*9
        columnNumbers: A=9*10
     -
      pack: codeql/java-all#1
      relativePath: ext/generated/java.lang.ref.model.yml
      index: 0
      firstRowId: 4687
      rowCount: 15
      locations:
        lineNumbers: A=7+1*14
        columnNumbers: A=9*15
     -
      pack: codeql/java-all#1
      relativePath: ext/generated/java.lang.ref.model.yml
      index: 1
      firstRowId: 4702
      rowCount: 8
      locations:
        lineNumbers: A=26+1*7
        columnNumbers: A=9*8
     -
      pack: codeql/java-all#1
      relativePath: ext/generated/java.lang.reflect.model.yml
      index: 0
      firstRowId: 4710
      rowCount: 58
      locations:
        lineNumbers: A=7+1*57
        columnNumbers: A=9*58
     -
      pack: codeql/java-all#1
      relativePath: ext/generated/java.lang.reflect.model.yml
      index: 1
      firstRowId: 4768
      rowCount: 106
      locations:
        lineNumbers: A=69+1*105
        columnNumbers: A=9*106
     -
      pack: codeql/java-all#1
      relativePath: ext/generated/java.lang.runtime.model.yml
      index: 0
      firstRowId: 4874
      rowCount: 3
      locations:
        lineNumbers: A=7+1*2
        columnNumbers: A=9*3
     -
      pack: codeql/java-all#1
      relativePath: ext/generated/java.math.model.yml
      index: 0
      firstRowId: 4877
      rowCount: 9
      locations:
        lineNumbers: A=7+1*8
        columnNumbers: A=9*9
     -
      pack: codeql/java-all#1
      relativePath: ext/generated/java.math.model.yml
      index: 1
      firstRowId: 4886
      rowCount: 91
      locations:
        lineNumbers: A=20+1*90
        columnNumbers: A=9*91
     -
      pack: codeql/java-all#1
      relativePath: ext/generated/java.net.http.model.yml
      index: 0
      firstRowId: 4977
      rowCount: 93
      locations:
        lineNumbers: A=7+1*92
        columnNumbers: A=9*93
     -
      pack: codeql/java-all#1
      relativePath: ext/generated/java.net.http.model.yml
      index: 1
      firstRowId: 5070
      rowCount: 38
      locations:
        lineNumbers: A=104+1*37
        columnNumbers: A=9*38
     -
      pack: codeql/java-all#1
      relativePath: ext/generated/java.net.model.yml
      index: 0
      firstRowId: 5108
      rowCount: 215
      locations:
        lineNumbers: A=7+1*214
        columnNumbers: A=9*215
     -
      pack: codeql/java-all#1
      relativePath: ext/generated/java.net.model.yml
      index: 1
      firstRowId: 5323
      rowCount: 259
      locations:
        lineNumbers: A=226+1*258
        columnNumbers: A=9*259
     -
      pack: codeql/java-all#1
      relativePath: ext/generated/java.nio.channels.model.yml
      index: 0
      firstRowId: 5582
      rowCount: 128
      locations:
        lineNumbers: A=7+1*127
        columnNumbers: A=9*128
     -
      pack: codeql/java-all#1
      relativePath: ext/generated/java.nio.channels.model.yml
      index: 1
      firstRowId: 5710
      rowCount: 79
      locations:
        lineNumbers: A=139+1*78
        columnNumbers: A=9*79
     -
      pack: codeql/java-all#1
      relativePath: ext/generated/java.nio.channels.spi.model.yml
      index: 0
      firstRowId: 5789
      rowCount: 16
      locations:
        lineNumbers: A=7+1*15
        columnNumbers: A=9*16
     -
      pack: codeql/java-all#1
      relativePath: ext/generated/java.nio.channels.spi.model.yml
      index: 1
      firstRowId: 5805
      rowCount: 9
      locations:
        lineNumbers: A=27+1*8
        columnNumbers: A=9*9
     -
      pack: codeql/java-all#1
      relativePath: ext/generated/java.nio.charset.model.yml
      index: 0
      firstRowId: 5814
      rowCount: 35
      locations:
        lineNumbers: A=7+1*34
        columnNumbers: A=9*35
     -
      pack: codeql/java-all#1
      relativePath: ext/generated/java.nio.charset.model.yml
      index: 1
      firstRowId: 5849
      rowCount: 42
      locations:
        lineNumbers: A=46+1*41
        columnNumbers: A=9*42
     -
      pack: codeql/java-all#1
      relativePath: ext/generated/java.nio.charset.spi.model.yml
      index: 0
      firstRowId: 5891
      rowCount: 2
      locations:
        lineNumbers: A=7+1
        columnNumbers: A=9*2
     -
      pack: codeql/java-all#1
      relativePath: ext/generated/java.nio.file.attribute.model.yml
      index: 0
      firstRowId: 5893
      rowCount: 23
      locations:
        lineNumbers: A=7+1*22
        columnNumbers: A=9*23
     -
      pack: codeql/java-all#1
      relativePath: ext/generated/java.nio.file.attribute.model.yml
      index: 1
      firstRowId: 5916
      rowCount: 9
      locations:
        lineNumbers: A=34+1*8
        columnNumbers: A=9*9
     -
      pack: codeql/java-all#1
      relativePath: ext/generated/java.nio.file.model.yml
      index: 0
      firstRowId: 5925
      rowCount: 85
      locations:
        lineNumbers: A=7+1*84
        columnNumbers: A=9*85
     -
      pack: codeql/java-all#1
      relativePath: ext/generated/java.nio.file.model.yml
      index: 1
      firstRowId: 6010
      rowCount: 36
      locations:
        lineNumbers: A=96+1*35
        columnNumbers: A=9*36
     -
      pack: codeql/java-all#1
      relativePath: ext/generated/java.nio.file.spi.model.yml
      index: 0
      firstRowId: 6046
      rowCount: 23
      locations:
        lineNumbers: A=7+1*22
        columnNumbers: A=9*23
     -
      pack: codeql/java-all#1
      relativePath: ext/generated/java.nio.file.spi.model.yml
      index: 1
      firstRowId: 6069
      rowCount: 14
      locations:
        lineNumbers: A=34+1*13
        columnNumbers: A=9*14
     -
      pack: codeql/java-all#1
      relativePath: ext/generated/java.nio.model.yml
      index: 0
      firstRowId: 6083
      rowCount: 137
      locations:
        lineNumbers: A=7+1*136
        columnNumbers: A=9*137
     -
      pack: codeql/java-all#1
      relativePath: ext/generated/java.nio.model.yml
      index: 1
      firstRowId: 6220
      rowCount: 89
      locations:
        lineNumbers: A=148+1*88
        columnNumbers: A=9*89
     -
      pack: codeql/java-all#1
      relativePath: ext/generated/java.rmi.dgc.model.yml
      index: 0
      firstRowId: 6309
      rowCount: 4
      locations:
        lineNumbers: A=7+1*3
        columnNumbers: A=9*4
     -
      pack: codeql/java-all#1
      relativePath: ext/generated/java.rmi.dgc.model.yml
      index: 1
      firstRowId: 6313
      rowCount: 2
      locations:
        lineNumbers: A=15+1
        columnNumbers: A=9*2
     -
      pack: codeql/java-all#1
      relativePath: ext/generated/java.rmi.model.yml
      index: 0
      firstRowId: 6315
      rowCount: 29
      locations:
        lineNumbers: A=7+1*28
        columnNumbers: A=9*29
     -
      pack: codeql/java-all#1
      relativePath: ext/generated/java.rmi.model.yml
      index: 1
      firstRowId: 6344
      rowCount: 5
      locations:
        lineNumbers: A=40+1*4
        columnNumbers: A=9*5
     -
      pack: codeql/java-all#1
      relativePath: ext/generated/java.rmi.registry.model.yml
      index: 0
      firstRowId: 6349
      rowCount: 6
      locations:
        lineNumbers: A=7+1*5
        columnNumbers: A=9*6
     -
      pack: codeql/java-all#1
      relativePath: ext/generated/java.rmi.registry.model.yml
      index: 1
      firstRowId: 6355
      rowCount: 7
      locations:
        lineNumbers: A=17+1*6
        columnNumbers: A=9*7
     -
      pack: codeql/java-all#1
      relativePath: ext/generated/java.rmi.server.model.yml
      index: 0
      firstRowId: 6362
      rowCount: 29
      locations:
        lineNumbers: A=7+1*28
        columnNumbers: A=9*29
     -
      pack: codeql/java-all#1
      relativePath: ext/generated/java.rmi.server.model.yml
      index: 1
      firstRowId: 6391
      rowCount: 33
      locations:
        lineNumbers: A=40+1*32
        columnNumbers: A=9*33
     -
      pack: codeql/java-all#1
      relativePath: ext/generated/java.security.cert.model.yml
      index: 0
      firstRowId: 6424
      rowCount: 186
      locations:
        lineNumbers: A=7+1*185
        columnNumbers: A=9*186
     -
      pack: codeql/java-all#1
      relativePath: ext/generated/java.security.cert.model.yml
      index: 1
      firstRowId: 6610
      rowCount: 87
      locations:
        lineNumbers: A=197+1*86
        columnNumbers: A=9*87
     -
      pack: codeql/java-all#1
      relativePath: ext/generated/java.security.interfaces.model.yml
      index: 0
      firstRowId: 6697
      rowCount: 11
      locations:
        lineNumbers: A=7+1*10
        columnNumbers: A=9*11
     -
      pack: codeql/java-all#1
      relativePath: ext/generated/java.security.model.yml
      index: 0
      firstRowId: 6708
      rowCount: 309
      locations:
        lineNumbers: A=7+1*308
        columnNumbers: A=9*309
     -
      pack: codeql/java-all#1
      relativePath: ext/generated/java.security.model.yml
      index: 1
      firstRowId: 7017
      rowCount: 138
      locations:
        lineNumbers: A=320+1*137
        columnNumbers: A=9*138
     -
      pack: codeql/java-all#1
      relativePath: ext/generated/java.security.spec.model.yml
      index: 0
      firstRowId: 7155
      rowCount: 66
      locations:
        lineNumbers: A=7+1*65
        columnNumbers: A=9*66
     -
      pack: codeql/java-all#1
      relativePath: ext/generated/java.security.spec.model.yml
      index: 1
      firstRowId: 7221
      rowCount: 75
      locations:
        lineNumbers: A=77+1*74
        columnNumbers: A=9*75
     -
      pack: codeql/java-all#1
      relativePath: ext/generated/java.sql.model.yml
      index: 0
      firstRowId: 7296
      rowCount: 290
      locations:
        lineNumbers: A=7+1*289
        columnNumbers: A=9*290
     -
      pack: codeql/java-all#1
      relativePath: ext/generated/java.sql.model.yml
      index: 1
      firstRowId: 7586
      rowCount: 104
      locations:
        lineNumbers: A=301+1*103
        columnNumbers: A=9*104
     -
      pack: codeql/java-all#1
      relativePath: ext/generated/java.text.model.yml
      index: 0
      firstRowId: 7690
      rowCount: 144
      locations:
        lineNumbers: A=7+1*143
        columnNumbers: A=9*144
     -
      pack: codeql/java-all#1
      relativePath: ext/generated/java.text.model.yml
      index: 1
      firstRowId: 7834
      rowCount: 205
      locations:
        lineNumbers: A=155+1*204
        columnNumbers: A=9*205
     -
      pack: codeql/java-all#1
      relativePath: ext/generated/java.text.spi.model.yml
      index: 0
      firstRowId: 8039
      rowCount: 10
      locations:
        lineNumbers: A=7+1*9
        columnNumbers: A=9*10
     -
      pack: codeql/java-all#1
      relativePath: ext/generated/java.text.spi.model.yml
      index: 1
      firstRowId: 8049
      rowCount: 5
      locations:
        lineNumbers: A=21+1*4
        columnNumbers: A=9*5
     -
      pack: codeql/java-all#1
      relativePath: ext/generated/java.time.chrono.model.yml
      index: 0
      firstRowId: 8054
      rowCount: 3
      locations:
        lineNumbers: A=7+1*2
        columnNumbers: A=9*3
     -
      pack: codeql/java-all#1
      relativePath: ext/generated/java.time.chrono.model.yml
      index: 1
      firstRowId: 8057
      rowCount: 105
      locations:
        lineNumbers: A=14+1*104
        columnNumbers: A=9*105
     -
      pack: codeql/java-all#1
      relativePath: ext/generated/java.time.format.model.yml
      index: 0
      firstRowId: 8162
      rowCount: 73
      locations:
        lineNumbers: A=7+1*72
        columnNumbers: A=9*73
     -
      pack: codeql/java-all#1
      relativePath: ext/generated/java.time.format.model.yml
      index: 1
      firstRowId: 8235
      rowCount: 21
      locations:
        lineNumbers: A=84+1*20
        columnNumbers: A=9*21
     -
      pack: codeql/java-all#1
      relativePath: ext/generated/java.time.model.yml
      index: 0
      firstRowId: 8256
      rowCount: 49
      locations:
        lineNumbers: A=7+1*48
        columnNumbers: A=9*49
     -
      pack: codeql/java-all#1
      relativePath: ext/generated/java.time.model.yml
      index: 1
      firstRowId: 8305
      rowCount: 292
      locations:
        lineNumbers: A=60+1*291
        columnNumbers: A=9*292
     -
      pack: codeql/java-all#1
      relativePath: ext/generated/java.time.temporal.model.yml
      index: 0
      firstRowId: 8597
      rowCount: 3
      locations:
        lineNumbers: A=7+1*2
        columnNumbers: A=9*3
     -
      pack: codeql/java-all#1
      relativePath: ext/generated/java.time.temporal.model.yml
      index: 1
      firstRowId: 8600
      rowCount: 52
      locations:
        lineNumbers: A=14+1*51
        columnNumbers: A=9*52
     -
      pack: codeql/java-all#1
      relativePath: ext/generated/java.time.zone.model.yml
      index: 0
      firstRowId: 8652
      rowCount: 3
      locations:
        lineNumbers: A=7+1*2
        columnNumbers: A=9*3
     -
      pack: codeql/java-all#1
      relativePath: ext/generated/java.time.zone.model.yml
      index: 1
      firstRowId: 8655
      rowCount: 20
      locations:
        lineNumbers: A=14+1*19
        columnNumbers: A=9*20
     -
      pack: codeql/java-all#1
      relativePath: ext/generated/java.util.concurrent.atomic.model.yml
      index: 0
      firstRowId: 8675
      rowCount: 12
      locations:
        lineNumbers: A=7+1*11
        columnNumbers: A=9*12
     -
      pack: codeql/java-all#1
      relativePath: ext/generated/java.util.concurrent.atomic.model.yml
      index: 1
      firstRowId: 8687
      rowCount: 255
      locations:
        lineNumbers: A=23+1*254
        columnNumbers: A=9*255
     -
      pack: codeql/java-all#1
      relativePath: ext/generated/java.util.concurrent.locks.model.yml
      index: 0
      firstRowId: 8942
      rowCount: 15
      locations:
        lineNumbers: A=7+1*14
        columnNumbers: A=9*15
     -
      pack: codeql/java-all#1
      relativePath: ext/generated/java.util.concurrent.locks.model.yml
      index: 1
      firstRowId: 8957
      rowCount: 116
      locations:
        lineNumbers: A=26+1*115
        columnNumbers: A=9*116
     -
      pack: codeql/java-all#1
      relativePath: ext/generated/java.util.concurrent.model.yml
      index: 0
      firstRowId: 9073
      rowCount: 229
      locations:
        lineNumbers: A=7+1*228
        columnNumbers: A=9*229
     -
      pack: codeql/java-all#1
      relativePath: ext/generated/java.util.concurrent.model.yml
      index: 1
      firstRowId: 9302
      rowCount: 313
      locations:
        lineNumbers: A=240+1*312
        columnNumbers: A=9*313
     -
      pack: codeql/java-all#1
      relativePath: ext/generated/java.util.function.model.yml
      index: 0
      firstRowId: 9615
      rowCount: 37
      locations:
        lineNumbers: A=7+1*36
        columnNumbers: A=9*37
     -
      pack: codeql/java-all#1
      relativePath: ext/generated/java.util.jar.model.yml
      index: 0
      firstRowId: 9652
      rowCount: 38
      locations:
        lineNumbers: A=7+1*37
        columnNumbers: A=9*38
     -
      pack: codeql/java-all#1
      relativePath: ext/generated/java.util.jar.model.yml
      index: 1
      firstRowId: 9690
      rowCount: 10
      locations:
        lineNumbers: A=49+1*9
        columnNumbers: A=9*10
     -
      pack: codeql/java-all#1
      relativePath: ext/generated/java.util.logging.model.yml
      index: 0
      firstRowId: 9700
      rowCount: 63
      locations:
        lineNumbers: A=7+1*62
        columnNumbers: A=9*63
     -
      pack: codeql/java-all#1
      relativePath: ext/generated/java.util.logging.model.yml
      index: 1
      firstRowId: 9763
      rowCount: 81
      locations:
        lineNumbers: A=74+1*80
        columnNumbers: A=9*81
     -
      pack: codeql/java-all#1
      relativePath: ext/generated/java.util.model.yml
      index: 0
      firstRowId: 9844
      rowCount: 194
      locations:
        lineNumbers: A=7+1*193
        columnNumbers: A=9*194
     -
      pack: codeql/java-all#1
      relativePath: ext/generated/java.util.model.yml
      index: 1
      firstRowId: 10038
      rowCount: 680
      locations:
        lineNumbers: A=205+1*679
        columnNumbers: A=9*680
     -
      pack: codeql/java-all#1
      relativePath: ext/generated/java.util.prefs.model.yml
      index: 0
      firstRowId: 10718
      rowCount: 26
      locations:
        lineNumbers: A=7+1*25
        columnNumbers: A=9*26
     -
      pack: codeql/java-all#1
      relativePath: ext/generated/java.util.prefs.model.yml
      index: 1
      firstRowId: 10744
      rowCount: 31
      locations:
        lineNumbers: A=37+1*30
        columnNumbers: A=9*31
     -
      pack: codeql/java-all#1
      relativePath: ext/generated/java.util.random.model.yml
      index: 0
      firstRowId: 10775
      rowCount: 24
      locations:
        lineNumbers: A=7+1*23
        columnNumbers: A=9*24
     -
      pack: codeql/java-all#1
      relativePath: ext/generated/java.util.random.model.yml
      index: 1
      firstRowId: 10799
      rowCount: 54
      locations:
        lineNumbers: A=35+1*53
        columnNumbers: A=9*54
     -
      pack: codeql/java-all#1
      relativePath: ext/generated/java.util.regex.model.yml
      index: 0
      firstRowId: 10853
      rowCount: 21
      locations:
        lineNumbers: A=7+1*20
        columnNumbers: A=9*21
     -
      pack: codeql/java-all#1
      relativePath: ext/generated/java.util.regex.model.yml
      index: 1
      firstRowId: 10874
      rowCount: 23
      locations:
        lineNumbers: A=32+1*22
        columnNumbers: A=9*23
     -
      pack: codeql/java-all#1
      relativePath: ext/generated/java.util.spi.model.yml
      index: 0
      firstRowId: 10897
      rowCount: 7
      locations:
        lineNumbers: A=7+1*6
        columnNumbers: A=9*7
     -
      pack: codeql/java-all#1
      relativePath: ext/generated/java.util.spi.model.yml
      index: 1
      firstRowId: 10904
      rowCount: 12
      locations:
        lineNumbers: A=18+1*11
        columnNumbers: A=9*12
     -
      pack: codeql/java-all#1
      relativePath: ext/generated/java.util.stream.model.yml
      index: 0
      firstRowId: 10916
      rowCount: 102
      locations:
        lineNumbers: A=7+1*101
        columnNumbers: A=9*102
     -
      pack: codeql/java-all#1
      relativePath: ext/generated/java.util.stream.model.yml
      index: 1
      firstRowId: 11018
      rowCount: 80
      locations:
        lineNumbers: A=113+1*79
        columnNumbers: A=9*80
     -
      pack: codeql/java-all#1
      relativePath: ext/generated/java.util.zip.model.yml
      index: 0
      firstRowId: 11098
      rowCount: 60
      locations:
        lineNumbers: A=7+1*59
        columnNumbers: A=9*60
     -
      pack: codeql/java-all#1
      relativePath: ext/generated/java.util.zip.model.yml
      index: 1
      firstRowId: 11158
      rowCount: 92
      locations:
        lineNumbers: A=71+1*91
        columnNumbers: A=9*92
     -
      pack: codeql/java-all#1
      relativePath: ext/generated/javax.accessibility.model.yml
      index: 0
      firstRowId: 11250
      rowCount: 63
      locations:
        lineNumbers: A=7+1*62
        columnNumbers: A=9*63
     -
      pack: codeql/java-all#1
      relativePath: ext/generated/javax.accessibility.model.yml
      index: 1
      firstRowId: 11313
      rowCount: 25
      locations:
        lineNumbers: A=74+1*24
        columnNumbers: A=9*25
     -
      pack: codeql/java-all#1
      relativePath: ext/generated/javax.annotation.processing.model.yml
      index: 0
      firstRowId: 11338
      rowCount: 28
      locations:
        lineNumbers: A=7+1*27
        columnNumbers: A=9*28
     -
      pack: codeql/java-all#1
      relativePath: ext/generated/javax.annotation.processing.model.yml
      index: 1
      firstRowId: 11366
      rowCount: 6
      locations:
        lineNumbers: A=39+1*5
        columnNumbers: A=9*6
     -
      pack: codeql/java-all#1
      relativePath: ext/generated/javax.crypto.interfaces.model.yml
      index: 0
      firstRowId: 11372
      rowCount: 3
      locations:
        lineNumbers: A=7+1*2
        columnNumbers: A=9*3
     -
      pack: codeql/java-all#1
      relativePath: ext/generated/javax.crypto.model.yml
      index: 0
      firstRowId: 11375
      rowCount: 72
      locations:
        lineNumbers: A=7+1*71
        columnNumbers: A=9*72
     -
      pack: codeql/java-all#1
      relativePath: ext/generated/javax.crypto.model.yml
      index: 1
      firstRowId: 11447
      rowCount: 26
      locations:
        lineNumbers: A=83+1*25
        columnNumbers: A=9*26
     -
      pack: codeql/java-all#1
      relativePath: ext/generated/javax.crypto.spec.model.yml
      index: 0
      firstRowId: 11473
      rowCount: 35
      locations:
        lineNumbers: A=7+1*34
        columnNumbers: A=9*35
     -
      pack: codeql/java-all#1
      relativePath: ext/generated/javax.crypto.spec.model.yml
      index: 1
      firstRowId: 11508
      rowCount: 30
      locations:
        lineNumbers: A=46+1*29
        columnNumbers: A=9*30
     -
      pack: codeql/java-all#1
      relativePath: ext/generated/javax.imageio.metadata.model.yml
      index: 0
      firstRowId: 11538
      rowCount: 65
      locations:
        lineNumbers: A=7+1*64
        columnNumbers: A=9*65
     -
      pack: codeql/java-all#1
      relativePath: ext/generated/javax.imageio.metadata.model.yml
      index: 1
      firstRowId: 11603
      rowCount: 58
      locations:
        lineNumbers: A=76+1*57
        columnNumbers: A=9*58
     -
      pack: codeql/java-all#1
      relativePath: ext/generated/javax.imageio.model.yml
      index: 0
      firstRowId: 11661
      rowCount: 117
      locations:
        lineNumbers: A=7+1*116
        columnNumbers: A=9*117
     -
      pack: codeql/java-all#1
      relativePath: ext/generated/javax.imageio.model.yml
      index: 1
      firstRowId: 11778
      rowCount: 138
      locations:
        lineNumbers: A=128+1*137
        columnNumbers: A=9*138
     -
      pack: codeql/java-all#1
      relativePath: ext/generated/javax.imageio.plugins.bmp.model.yml
      index: 0
      firstRowId: 11916
      rowCount: 1
      locations:
        lineNumbers: A=7
        columnNumbers: A=9
     -
      pack: codeql/java-all#1
      relativePath: ext/generated/javax.imageio.plugins.bmp.model.yml
      index: 1
      firstRowId: 11917
      rowCount: 2
      locations:
        lineNumbers: A=12+1
        columnNumbers: A=9*2
     -
      pack: codeql/java-all#1
      relativePath: ext/generated/javax.imageio.plugins.jpeg.model.yml
      index: 0
      firstRowId: 11919
      rowCount: 13
      locations:
        lineNumbers: A=7+1*12
        columnNumbers: A=9*13
     -
      pack: codeql/java-all#1
      relativePath: ext/generated/javax.imageio.plugins.jpeg.model.yml
      index: 1
      firstRowId: 11932
      rowCount: 15
      locations:
        lineNumbers: A=24+1*14
        columnNumbers: A=9*15
     -
      pack: codeql/java-all#1
      relativePath: ext/generated/javax.imageio.plugins.tiff.model.yml
      index: 0
      firstRowId: 11947
      rowCount: 43
      locations:
        lineNumbers: A=7+1*42
        columnNumbers: A=9*43
     -
      pack: codeql/java-all#1
      relativePath: ext/generated/javax.imageio.plugins.tiff.model.yml
      index: 1
      firstRowId: 11990
      rowCount: 45
      locations:
        lineNumbers: A=54+1*44
        columnNumbers: A=9*45
     -
      pack: codeql/java-all#1
      relativePath: ext/generated/javax.imageio.spi.model.yml
      index: 0
      firstRowId: 12035
      rowCount: 48
      locations:
        lineNumbers: A=7+1*47
        columnNumbers: A=9*48
     -
      pack: codeql/java-all#1
      relativePath: ext/generated/javax.imageio.spi.model.yml
      index: 1
      firstRowId: 12083
      rowCount: 37
      locations:
        lineNumbers: A=59+1*36
        columnNumbers: A=9*37
     -
      pack: codeql/java-all#1
      relativePath: ext/generated/javax.imageio.stream.model.yml
      index: 0
      firstRowId: 12120
      rowCount: 16
      locations:
        lineNumbers: A=7+1*15
        columnNumbers: A=9*16
     -
      pack: codeql/java-all#1
      relativePath: ext/generated/javax.imageio.stream.model.yml
      index: 1
      firstRowId: 12136
      rowCount: 82
      locations:
        lineNumbers: A=27+1*81
        columnNumbers: A=9*82
     -
      pack: codeql/java-all#1
      relativePath: ext/generated/javax.lang.model.element.model.yml
      index: 0
      firstRowId: 12218
      rowCount: 51
      locations:
        lineNumbers: A=7+1*50
        columnNumbers: A=9*51
     -
      pack: codeql/java-all#1
      relativePath: ext/generated/javax.lang.model.element.model.yml
      index: 1
      firstRowId: 12269
      rowCount: 9
      locations:
        lineNumbers: A=62+1*8
        columnNumbers: A=9*9
     -
      pack: codeql/java-all#1
      relativePath: ext/generated/javax.lang.model.model.yml
      index: 0
      firstRowId: 12278
      rowCount: 1
      locations:
        lineNumbers: A=7
        columnNumbers: A=9
     -
      pack: codeql/java-all#1
      relativePath: ext/generated/javax.lang.model.model.yml
      index: 1
      firstRowId: 12279
      rowCount: 7
      locations:
        lineNumbers: A=12+1*6
        columnNumbers: A=9*7
     -
      pack: codeql/java-all#1
      relativePath: ext/generated/javax.lang.model.type.model.yml
      index: 0
      firstRowId: 12286
      rowCount: 24
      locations:
        lineNumbers: A=7+1*23
        columnNumbers: A=9*24
     -
      pack: codeql/java-all#1
      relativePath: ext/generated/javax.lang.model.type.model.yml
      index: 1
      firstRowId: 12310
      rowCount: 1
      locations:
        lineNumbers: A=35
        columnNumbers: A=9
     -
      pack: codeql/java-all#1
      relativePath: ext/generated/javax.lang.model.util.model.yml
      index: 0
      firstRowId: 12311
      rowCount: 201
      locations:
        lineNumbers: A=7+1*200
        columnNumbers: A=9*201
     -
      pack: codeql/java-all#1
      relativePath: ext/generated/javax.lang.model.util.model.yml
      index: 1
      firstRowId: 12512
      rowCount: 21
      locations:
        lineNumbers: A=212+1*20
        columnNumbers: A=9*21
     -
      pack: codeql/java-all#1
      relativePath: ext/generated/javax.management.loading.model.yml
      index: 0
      firstRowId: 12533
      rowCount: 35
      locations:
        lineNumbers: A=7+1*34
        columnNumbers: A=9*35
     -
      pack: codeql/java-all#1
      relativePath: ext/generated/javax.management.loading.model.yml
      index: 1
      firstRowId: 12568
      rowCount: 10
      locations:
        lineNumbers: A=46+1*9
        columnNumbers: A=9*10
     -
      pack: codeql/java-all#1
      relativePath: ext/generated/javax.management.model.yml
      index: 0
      firstRowId: 12578
      rowCount: 285
      locations:
        lineNumbers: A=7+1*284
        columnNumbers: A=9*285
     -
      pack: codeql/java-all#1
      relativePath: ext/generated/javax.management.model.yml
      index: 1
      firstRowId: 12863
      rowCount: 85
      locations:
        lineNumbers: A=296+1*84
        columnNumbers: A=9*85
     -
      pack: codeql/java-all#1
      relativePath: ext/generated/javax.management.modelmbean.model.yml
      index: 0
      firstRowId: 12948
      rowCount: 84
      locations:
        lineNumbers: A=7+1*83
        columnNumbers: A=9*84
     -
      pack: codeql/java-all#1
      relativePath: ext/generated/javax.management.modelmbean.model.yml
      index: 1
      firstRowId: 13032
      rowCount: 19
      locations:
        lineNumbers: A=95+1*18
        columnNumbers: A=9*19
     -
      pack: codeql/java-all#1
      relativePath: ext/generated/javax.management.monitor.model.yml
      index: 0
      firstRowId: 13051
      rowCount: 13
      locations:
        lineNumbers: A=7+1*12
        columnNumbers: A=9*13
     -
      pack: codeql/java-all#1
      relativePath: ext/generated/javax.management.monitor.model.yml
      index: 1
      firstRowId: 13064
      rowCount: 54
      locations:
        lineNumbers: A=24+1*53
        columnNumbers: A=9*54
     -
      pack: codeql/java-all#1
      relativePath: ext/generated/javax.management.openmbean.model.yml
      index: 0
      firstRowId: 13118
      rowCount: 104
      locations:
        lineNumbers: A=7+1*103
        columnNumbers: A=9*104
     -
      pack: codeql/java-all#1
      relativePath: ext/generated/javax.management.openmbean.model.yml
      index: 1
      firstRowId: 13222
      rowCount: 26
      locations:
        lineNumbers: A=115+1*25
        columnNumbers: A=9*26
     -
      pack: codeql/java-all#1
      relativePath: ext/generated/javax.management.relation.model.yml
      index: 0
      firstRowId: 13248
      rowCount: 125
      locations:
        lineNumbers: A=7+1*124
        columnNumbers: A=9*125
     -
      pack: codeql/java-all#1
      relativePath: ext/generated/javax.management.relation.model.yml
      index: 1
      firstRowId: 13373
      rowCount: 41
      locations:
        lineNumbers: A=136+1*40
        columnNumbers: A=9*41
     -
      pack: codeql/java-all#1
      relativePath: ext/generated/javax.management.remote.model.yml
      index: 0
      firstRowId: 13414
      rowCount: 55
      locations:
        lineNumbers: A=7+1*54
        columnNumbers: A=9*55
     -
      pack: codeql/java-all#1
      relativePath: ext/generated/javax.management.remote.model.yml
      index: 1
      firstRowId: 13469
      rowCount: 7
      locations:
        lineNumbers: A=66+1*6
        columnNumbers: A=9*7
     -
      pack: codeql/java-all#1
      relativePath: ext/generated/javax.management.remote.rmi.model.yml
      index: 0
      firstRowId: 13476
      rowCount: 57
      locations:
        lineNumbers: A=7+1*56
        columnNumbers: A=9*57
     -
      pack: codeql/java-all#1
      relativePath: ext/generated/javax.management.remote.rmi.model.yml
      index: 1
      firstRowId: 13533
      rowCount: 43
      locations:
        lineNumbers: A=68+1*42
        columnNumbers: A=9*43
     -
      pack: codeql/java-all#1
      relativePath: ext/generated/javax.management.timer.model.yml
      index: 0
      firstRowId: 13576
      rowCount: 4
      locations:
        lineNumbers: A=7+1*3
        columnNumbers: A=9*4
     -
      pack: codeql/java-all#1
      relativePath: ext/generated/javax.management.timer.model.yml
      index: 1
      firstRowId: 13580
      rowCount: 24
      locations:
        lineNumbers: A=15+1*23
        columnNumbers: A=9*24
     -
      pack: codeql/java-all#1
      relativePath: ext/generated/javax.naming.directory.model.yml
      index: 0
      firstRowId: 13604
      rowCount: 87
      locations:
        lineNumbers: A=7+1*86
        columnNumbers: A=9*87
     -
      pack: codeql/java-all#1
      relativePath: ext/generated/javax.naming.directory.model.yml
      index: 1
      firstRowId: 13691
      rowCount: 26
      locations:
        lineNumbers: A=98+1*25
        columnNumbers: A=9*26
     -
      pack: codeql/java-all#1
      relativePath: ext/generated/javax.naming.event.model.yml
      index: 0
      firstRowId: 13717
      rowCount: 12
      locations:
        lineNumbers: A=7+1*11
        columnNumbers: A=9*12
     -
      pack: codeql/java-all#1
      relativePath: ext/generated/javax.naming.event.model.yml
      index: 1
      firstRowId: 13729
      rowCount: 3
      locations:
        lineNumbers: A=23+1*2
        columnNumbers: A=9*3
     -
      pack: codeql/java-all#1
      relativePath: ext/generated/javax.naming.ldap.model.yml
      index: 0
      firstRowId: 13732
      rowCount: 63
      locations:
        lineNumbers: A=7+1*62
        columnNumbers: A=9*63
     -
      pack: codeql/java-all#1
      relativePath: ext/generated/javax.naming.ldap.model.yml
      index: 1
      firstRowId: 13795
      rowCount: 30
      locations:
        lineNumbers: A=74+1*29
        columnNumbers: A=9*30
     -
      pack: codeql/java-all#1
      relativePath: ext/generated/javax.naming.ldap.spi.model.yml
      index: 0
      firstRowId: 13825
      rowCount: 4
      locations:
        lineNumbers: A=7+1*3
        columnNumbers: A=9*4
     -
      pack: codeql/java-all#1
      relativePath: ext/generated/javax.naming.ldap.spi.model.yml
      index: 1
      firstRowId: 13829
      rowCount: 1
      locations:
        lineNumbers: A=15
        columnNumbers: A=9
     -
      pack: codeql/java-all#1
      relativePath: ext/generated/javax.naming.model.yml
      index: 0
      firstRowId: 13830
      rowCount: 140
      locations:
        lineNumbers: A=7+1*139
        columnNumbers: A=9*140
     -
      pack: codeql/java-all#1
      relativePath: ext/generated/javax.naming.model.yml
      index: 1
      firstRowId: 13970
      rowCount: 25
      locations:
        lineNumbers: A=151+1*24
        columnNumbers: A=9*25
     -
      pack: codeql/java-all#1
      relativePath: ext/generated/javax.naming.spi.model.yml
      index: 0
      firstRowId: 13995
      rowCount: 26
      locations:
        lineNumbers: A=7+1*25
        columnNumbers: A=9*26
     -
      pack: codeql/java-all#1
      relativePath: ext/generated/javax.naming.spi.model.yml
      index: 1
      firstRowId: 14021
      rowCount: 4
      locations:
        lineNumbers: A=37+1*3
        columnNumbers: A=9*4
     -
      pack: codeql/java-all#1
      relativePath: ext/generated/javax.net.model.yml
      index: 0
      firstRowId: 14025
      rowCount: 16
      locations:
        lineNumbers: A=7+1*15
        columnNumbers: A=9*16
     -
      pack: codeql/java-all#1
      relativePath: ext/generated/javax.net.model.yml
      index: 1
      firstRowId: 14041
      rowCount: 2
      locations:
        lineNumbers: A=27+1
        columnNumbers: A=9*2
     -
      pack: codeql/java-all#1
      relativePath: ext/generated/javax.net.ssl.model.yml
      index: 0
      firstRowId: 14043
      rowCount: 120
      locations:
        lineNumbers: A=7+1*119
        columnNumbers: A=9*120
     -
      pack: codeql/java-all#1
      relativePath: ext/generated/javax.net.ssl.model.yml
      index: 1
      firstRowId: 14163
      rowCount: 124
      locations:
        lineNumbers: A=131+1*123
        columnNumbers: A=9*124
     -
      pack: codeql/java-all#1
      relativePath: ext/generated/javax.print.attribute.model.yml
      index: 0
      firstRowId: 14287
      rowCount: 38
      locations:
        lineNumbers: A=7+1*37
        columnNumbers: A=9*38
     -
      pack: codeql/java-all#1
      relativePath: ext/generated/javax.print.attribute.model.yml
      index: 1
      firstRowId: 14325
      rowCount: 24
      locations:
        lineNumbers: A=49+1*23
        columnNumbers: A=9*24
     -
      pack: codeql/java-all#1
      relativePath: ext/generated/javax.print.attribute.standard.model.yml
      index: 0
      firstRowId: 14349
      rowCount: 41
      locations:
        lineNumbers: A=7+1*40
        columnNumbers: A=9*41
     -
      pack: codeql/java-all#1
      relativePath: ext/generated/javax.print.attribute.standard.model.yml
      index: 1
      firstRowId: 14390
      rowCount: 179
      locations:
        lineNumbers: A=52+1*178
        columnNumbers: A=9*179
     -
      pack: codeql/java-all#1
      relativePath: ext/generated/javax.print.event.model.yml
      index: 0
      firstRowId: 14569
      rowCount: 9
      locations:
        lineNumbers: A=7+1*8
        columnNumbers: A=9*9
     -
      pack: codeql/java-all#1
      relativePath: ext/generated/javax.print.event.model.yml
      index: 1
      firstRowId: 14578
      rowCount: 7
      locations:
        lineNumbers: A=20+1*6
        columnNumbers: A=9*7
     -
      pack: codeql/java-all#1
      relativePath: ext/generated/javax.print.model.yml
      index: 0
      firstRowId: 14585
      rowCount: 45
      locations:
        lineNumbers: A=7+1*44
        columnNumbers: A=9*45
     -
      pack: codeql/java-all#1
      relativePath: ext/generated/javax.print.model.yml
      index: 1
      firstRowId: 14630
      rowCount: 20
      locations:
        lineNumbers: A=56+1*19
        columnNumbers: A=9*20
     -
      pack: codeql/java-all#1
      relativePath: ext/generated/javax.rmi.ssl.model.yml
      index: 0
      firstRowId: 14650
      rowCount: 6
      locations:
        lineNumbers: A=7+1*5
        columnNumbers: A=9*6
     -
      pack: codeql/java-all#1
      relativePath: ext/generated/javax.rmi.ssl.model.yml
      index: 1
      firstRowId: 14656
      rowCount: 1
      locations:
        lineNumbers: A=17
        columnNumbers: A=9
     -
      pack: codeql/java-all#1
      relativePath: ext/generated/javax.script.model.yml
      index: 0
      firstRowId: 14657
      rowCount: 50
      locations:
        lineNumbers: A=7+1*49
        columnNumbers: A=9*50
     -
      pack: codeql/java-all#1
      relativePath: ext/generated/javax.script.model.yml
      index: 1
      firstRowId: 14707
      rowCount: 15
      locations:
        lineNumbers: A=61+1*14
        columnNumbers: A=9*15
     -
      pack: codeql/java-all#1
      relativePath: ext/generated/javax.security.auth.callback.model.yml
      index: 0
      firstRowId: 14722
      rowCount: 35
      locations:
        lineNumbers: A=7+1*34
        columnNumbers: A=9*35
     -
      pack: codeql/java-all#1
      relativePath: ext/generated/javax.security.auth.callback.model.yml
      index: 1
      firstRowId: 14757
      rowCount: 14
      locations:
        lineNumbers: A=46+1*13
        columnNumbers: A=9*14
     -
      pack: codeql/java-all#1
      relativePath: ext/generated/javax.security.auth.kerberos.model.yml
      index: 0
      firstRowId: 14771
      rowCount: 42
      locations:
        lineNumbers: A=7+1*41
        columnNumbers: A=9*42
     -
      pack: codeql/java-all#1
      relativePath: ext/generated/javax.security.auth.kerberos.model.yml
      index: 1
      firstRowId: 14813
      rowCount: 33
      locations:
        lineNumbers: A=53+1*32
        columnNumbers: A=9*33
     -
      pack: codeql/java-all#1
      relativePath: ext/generated/javax.security.auth.login.model.yml
      index: 0
      firstRowId: 14846
      rowCount: 31
      locations:
        lineNumbers: A=7+1*30
        columnNumbers: A=9*31
     -
      pack: codeql/java-all#1
      relativePath: ext/generated/javax.security.auth.login.model.yml
      index: 1
      firstRowId: 14877
      rowCount: 6
      locations:
        lineNumbers: A=42+1*5
        columnNumbers: A=9*6
     -
      pack: codeql/java-all#1
      relativePath: ext/generated/javax.security.auth.model.yml
      index: 0
      firstRowId: 14883
      rowCount: 17
      locations:
        lineNumbers: A=7+1*16
        columnNumbers: A=9*17
     -
      pack: codeql/java-all#1
      relativePath: ext/generated/javax.security.auth.model.yml
      index: 1
      firstRowId: 14900
      rowCount: 11
      locations:
        lineNumbers: A=28+1*10
        columnNumbers: A=9*11
     -
      pack: codeql/java-all#1
      relativePath: ext/generated/javax.security.auth.spi.model.yml
      index: 0
      firstRowId: 14911
      rowCount: 4
      locations:
        lineNumbers: A=7+1*3
        columnNumbers: A=9*4
     -
      pack: codeql/java-all#1
      relativePath: ext/generated/javax.security.auth.x500.model.yml
      index: 0
      firstRowId: 14915
      rowCount: 18
      locations:
        lineNumbers: A=7+1*17
        columnNumbers: A=9*18
     -
      pack: codeql/java-all#1
      relativePath: ext/generated/javax.security.auth.x500.model.yml
      index: 1
      firstRowId: 14933
      rowCount: 6
      locations:
        lineNumbers: A=29+1*5
        columnNumbers: A=9*6
     -
      pack: codeql/java-all#1
      relativePath: ext/generated/javax.security.cert.model.yml
      index: 0
      firstRowId: 14939
      rowCount: 5
      locations:
        lineNumbers: A=7+1*4
        columnNumbers: A=9*5
     -
      pack: codeql/java-all#1
      relativePath: ext/generated/javax.security.cert.model.yml
      index: 1
      firstRowId: 14944
      rowCount: 17
      locations:
        lineNumbers: A=16+1*16
        columnNumbers: A=9*17
     -
      pack: codeql/java-all#1
      relativePath: ext/generated/javax.security.sasl.model.yml
      index: 0
      firstRowId: 14961
      rowCount: 49
      locations:
        lineNumbers: A=7+1*48
        columnNumbers: A=9*49
     -
      pack: codeql/java-all#1
      relativePath: ext/generated/javax.security.sasl.model.yml
      index: 1
      firstRowId: 15010
      rowCount: 4
      locations:
        lineNumbers: A=60+1*3
        columnNumbers: A=9*4
     -
      pack: codeql/java-all#1
      relativePath: ext/generated/javax.smartcardio.model.yml
      index: 0
      firstRowId: 15014
      rowCount: 34
      locations:
        lineNumbers: A=7+1*33
        columnNumbers: A=9*34
     -
      pack: codeql/java-all#1
      relativePath: ext/generated/javax.smartcardio.model.yml
      index: 1
      firstRowId: 15048
      rowCount: 34
      locations:
        lineNumbers: A=45+1*33
        columnNumbers: A=9*34
     -
      pack: codeql/java-all#1
      relativePath: ext/generated/javax.sound.midi.model.yml
      index: 0
      firstRowId: 15082
      rowCount: 57
      locations:
        lineNumbers: A=7+1*56
        columnNumbers: A=9*57
     -
      pack: codeql/java-all#1
      relativePath: ext/generated/javax.sound.midi.model.yml
      index: 1
      firstRowId: 15139
      rowCount: 56
      locations:
        lineNumbers: A=68+1*55
        columnNumbers: A=9*56
     -
      pack: codeql/java-all#1
      relativePath: ext/generated/javax.sound.midi.spi.model.yml
      index: 0
      firstRowId: 15195
      rowCount: 3
      locations:
        lineNumbers: A=7+1*2
        columnNumbers: A=9*3
     -
      pack: codeql/java-all#1
      relativePath: ext/generated/javax.sound.midi.spi.model.yml
      index: 1
      firstRowId: 15198
      rowCount: 15
      locations:
        lineNumbers: A=14+1*14
        columnNumbers: A=9*15
     -
      pack: codeql/java-all#1
      relativePath: ext/generated/javax.sound.sampled.model.yml
      index: 0
      firstRowId: 15213
      rowCount: 84
      locations:
        lineNumbers: A=7+1*83
        columnNumbers: A=9*84
     -
      pack: codeql/java-all#1
      relativePath: ext/generated/javax.sound.sampled.model.yml
      index: 1
      firstRowId: 15297
      rowCount: 63
      locations:
        lineNumbers: A=95+1*62
        columnNumbers: A=9*63
     -
      pack: codeql/java-all#1
      relativePath: ext/generated/javax.sound.sampled.spi.model.yml
      index: 0
      firstRowId: 15360
      rowCount: 6
      locations:
        lineNumbers: A=7+1*5
        columnNumbers: A=9*6
     -
      pack: codeql/java-all#1
      relativePath: ext/generated/javax.sound.sampled.spi.model.yml
      index: 1
      firstRowId: 15366
      rowCount: 19
      locations:
        lineNumbers: A=17+1*18
        columnNumbers: A=9*19
     -
      pack: codeql/java-all#1
      relativePath: ext/generated/javax.sql.model.yml
      index: 0
      firstRowId: 15385
      rowCount: 14
      locations:
        lineNumbers: A=7+1*13
        columnNumbers: A=9*14
     -
      pack: codeql/java-all#1
      relativePath: ext/generated/javax.sql.model.yml
      index: 1
      firstRowId: 15399
      rowCount: 4
      locations:
        lineNumbers: A=25+1*3
        columnNumbers: A=9*4
     -
      pack: codeql/java-all#1
      relativePath: ext/generated/javax.sql.rowset.model.yml
      index: 0
      firstRowId: 15403
      rowCount: 63
      locations:
        lineNumbers: A=7+1*62
        columnNumbers: A=9*63
     -
      pack: codeql/java-all#1
      relativePath: ext/generated/javax.sql.rowset.model.yml
      index: 1
      firstRowId: 15466
      rowCount: 140
      locations:
        lineNumbers: A=74+1*139
        columnNumbers: A=9*140
     -
      pack: codeql/java-all#1
      relativePath: ext/generated/javax.sql.rowset.serial.model.yml
      index: 0
      firstRowId: 15606
      rowCount: 36
      locations:
        lineNumbers: A=7+1*35
        columnNumbers: A=9*36
     -
      pack: codeql/java-all#1
      relativePath: ext/generated/javax.sql.rowset.serial.model.yml
      index: 1
      firstRowId: 15642
      rowCount: 54
      locations:
        lineNumbers: A=47+1*53
        columnNumbers: A=9*54
     -
      pack: codeql/java-all#1
      relativePath: ext/generated/javax.sql.rowset.spi.model.yml
      index: 0
      firstRowId: 15696
      rowCount: 13
      locations:
        lineNumbers: A=7+1*12
        columnNumbers: A=9*13
     -
      pack: codeql/java-all#1
      relativePath: ext/generated/javax.sql.rowset.spi.model.yml
      index: 1
      firstRowId: 15709
      rowCount: 12
      locations:
        lineNumbers: A=24+1*11
        columnNumbers: A=9*12
     -
      pack: codeql/java-all#1
      relativePath: ext/generated/javax.tools.model.yml
      index: 0
      firstRowId: 15721
      rowCount: 66
      locations:
        lineNumbers: A=7+1*65
        columnNumbers: A=9*66
     -
      pack: codeql/java-all#1
      relativePath: ext/generated/javax.tools.model.yml
      index: 1
      firstRowId: 15787
      rowCount: 36
      locations:
        lineNumbers: A=77+1*35
        columnNumbers: A=9*36
     -
      pack: codeql/java-all#1
      relativePath: ext/generated/javax.transaction.xa.model.yml
      index: 0
      firstRowId: 15823
      rowCount: 1
      locations:
        lineNumbers: A=7
        columnNumbers: A=9
     -
      pack: codeql/java-all#1
      relativePath: ext/generated/javax.transaction.xa.model.yml
      index: 1
      firstRowId: 15824
      rowCount: 1
      locations:
        lineNumbers: A=12
        columnNumbers: A=9
     -
      pack: codeql/java-all#1
      relativePath: ext/generated/javax.xml.catalog.model.yml
      index: 0
      firstRowId: 15825
      rowCount: 12
      locations:
        lineNumbers: A=7+1*11
        columnNumbers: A=9*12
     -
      pack: codeql/java-all#1
      relativePath: ext/generated/javax.xml.catalog.model.yml
      index: 1
      firstRowId: 15837
      rowCount: 8
      locations:
        lineNumbers: A=23+1*7
        columnNumbers: A=9*8
     -
      pack: codeql/java-all#1
      relativePath: ext/generated/javax.xml.crypto.dom.model.yml
      index: 0
      firstRowId: 15845
      rowCount: 27
      locations:
        lineNumbers: A=7+1*26
        columnNumbers: A=9*27
     -
      pack: codeql/java-all#1
      relativePath: ext/generated/javax.xml.crypto.dom.model.yml
      index: 1
      firstRowId: 15872
      rowCount: 1
      locations:
        lineNumbers: A=38
        columnNumbers: A=9
     -
      pack: codeql/java-all#1
      relativePath: ext/generated/javax.xml.crypto.dsig.dom.model.yml
      index: 0
      firstRowId: 15873
      rowCount: 14
      locations:
        lineNumbers: A=7+1*13
        columnNumbers: A=9*14
     -
      pack: codeql/java-all#1
      relativePath: ext/generated/javax.xml.crypto.dsig.keyinfo.model.yml
      index: 0
      firstRowId: 15887
      rowCount: 35
      locations:
        lineNumbers: A=7+1*34
        columnNumbers: A=9*35
     -
      pack: codeql/java-all#1
      relativePath: ext/generated/javax.xml.crypto.dsig.keyinfo.model.yml
      index: 1
      firstRowId: 15922
      rowCount: 4
      locations:
        lineNumbers: A=46+1*3
        columnNumbers: A=9*4
     -
      pack: codeql/java-all#1
      relativePath: ext/generated/javax.xml.crypto.dsig.model.yml
      index: 0
      firstRowId: 15926
      rowCount: 137
      locations:
        lineNumbers: A=7+1*136
        columnNumbers: A=9*137
     -
      pack: codeql/java-all#1
      relativePath: ext/generated/javax.xml.crypto.dsig.model.yml
      index: 1
      firstRowId: 16063
      rowCount: 3
      locations:
        lineNumbers: A=148+1*2
        columnNumbers: A=9*3
     -
      pack: codeql/java-all#1
      relativePath: ext/generated/javax.xml.crypto.dsig.spec.model.yml
      index: 0
      firstRowId: 16066
      rowCount: 23
      locations:
        lineNumbers: A=7+1*22
        columnNumbers: A=9*23
     -
      pack: codeql/java-all#1
      relativePath: ext/generated/javax.xml.crypto.dsig.spec.model.yml
      index: 1
      firstRowId: 16089
      rowCount: 2
      locations:
        lineNumbers: A=34+1
        columnNumbers: A=9*2
     -
      pack: codeql/java-all#1
      relativePath: ext/generated/javax.xml.crypto.model.yml
      index: 0
      firstRowId: 16091
      rowCount: 33
      locations:
        lineNumbers: A=7+1*32
        columnNumbers: A=9*33
     -
      pack: codeql/java-all#1
      relativePath: ext/generated/javax.xml.crypto.model.yml
      index: 1
      firstRowId: 16124
      rowCount: 1
      locations:
        lineNumbers: A=44
        columnNumbers: A=9
     -
      pack: codeql/java-all#1
      relativePath: ext/generated/javax.xml.datatype.model.yml
      index: 0
      firstRowId: 16125
      rowCount: 6
      locations:
        lineNumbers: A=7+1*5
        columnNumbers: A=9*6
     -
      pack: codeql/java-all#1
      relativePath: ext/generated/javax.xml.datatype.model.yml
      index: 1
      firstRowId: 16131
      rowCount: 81
      locations:
        lineNumbers: A=17+1*80
        columnNumbers: A=9*81
     -
      pack: codeql/java-all#1
      relativePath: ext/generated/javax.xml.namespace.model.yml
      index: 0
      firstRowId: 16212
      rowCount: 15
      locations:
        lineNumbers: A=7+1*14
        columnNumbers: A=9*15
     -
      pack: codeql/java-all#1
      relativePath: ext/generated/javax.xml.parsers.model.yml
      index: 0
      firstRowId: 16227
      rowCount: 37
      locations:
        lineNumbers: A=7+1*36
        columnNumbers: A=9*37
     -
      pack: codeql/java-all#1
      relativePath: ext/generated/javax.xml.parsers.model.yml
      index: 1
      firstRowId: 16264
      rowCount: 46
      locations:
        lineNumbers: A=48+1*45
        columnNumbers: A=9*46
     -
      pack: codeql/java-all#1
      relativePath: ext/generated/javax.xml.stream.events.model.yml
      index: 0
      firstRowId: 16310
      rowCount: 38
      locations:
        lineNumbers: A=7+1*37
        columnNumbers: A=9*38
     -
      pack: codeql/java-all#1
      relativePath: ext/generated/javax.xml.stream.model.yml
      index: 0
      firstRowId: 16348
      rowCount: 175
      locations:
        lineNumbers: A=7+1*174
        columnNumbers: A=9*175
     -
      pack: codeql/java-all#1
      relativePath: ext/generated/javax.xml.stream.model.yml
      index: 1
      firstRowId: 16523
      rowCount: 21
      locations:
        lineNumbers: A=186+1*20
        columnNumbers: A=9*21
     -
      pack: codeql/java-all#1
      relativePath: ext/generated/javax.xml.stream.util.model.yml
      index: 0
      firstRowId: 16544
      rowCount: 8
      locations:
        lineNumbers: A=7+1*7
        columnNumbers: A=9*8
     -
      pack: codeql/java-all#1
      relativePath: ext/generated/javax.xml.stream.util.model.yml
      index: 1
      firstRowId: 16552
      rowCount: 40
      locations:
        lineNumbers: A=19+1*39
        columnNumbers: A=9*40
     -
      pack: codeql/java-all#1
      relativePath: ext/generated/javax.xml.transform.dom.model.yml
      index: 0
      firstRowId: 16592
      rowCount: 21
      locations:
        lineNumbers: A=7+1*20
        columnNumbers: A=9*21
     -
      pack: codeql/java-all#1
      relativePath: ext/generated/javax.xml.transform.dom.model.yml
      index: 1
      firstRowId: 16613
      rowCount: 1
      locations:
        lineNumbers: A=32
        columnNumbers: A=9
     -
      pack: codeql/java-all#1
      relativePath: ext/generated/javax.xml.transform.model.yml
      index: 0
      firstRowId: 16614
      rowCount: 54
      locations:
        lineNumbers: A=7+1*53
        columnNumbers: A=9*54
     -
      pack: codeql/java-all#1
      relativePath: ext/generated/javax.xml.transform.model.yml
      index: 1
      firstRowId: 16668
      rowCount: 10
      locations:
        lineNumbers: A=65+1*9
        columnNumbers: A=9*10
     -
      pack: codeql/java-all#1
      relativePath: ext/generated/javax.xml.transform.sax.model.yml
      index: 0
      firstRowId: 16678
      rowCount: 26
      locations:
        lineNumbers: A=7+1*25
        columnNumbers: A=9*26
     -
      pack: codeql/java-all#1
      relativePath: ext/generated/javax.xml.transform.sax.model.yml
      index: 1
      firstRowId: 16704
      rowCount: 1
      locations:
        lineNumbers: A=37
        columnNumbers: A=9
     -
      pack: codeql/java-all#1
      relativePath: ext/generated/javax.xml.transform.stax.model.yml
      index: 0
      firstRowId: 16705
      rowCount: 8
      locations:
        lineNumbers: A=7+1*7
        columnNumbers: A=9*8
     -
      pack: codeql/java-all#1
      relativePath: ext/generated/javax.xml.transform.stax.model.yml
      index: 1
      firstRowId: 16713
      rowCount: 3
      locations:
        lineNumbers: A=19+1*2
        columnNumbers: A=9*3
     -
      pack: codeql/java-all#1
      relativePath: ext/generated/javax.xml.transform.stream.model.yml
      index: 0
      firstRowId: 16716
      rowCount: 19
      locations:
        lineNumbers: A=7+1*18
        columnNumbers: A=9*19
     -
      pack: codeql/java-all#1
      relativePath: ext/generated/javax.xml.transform.stream.model.yml
      index: 1
      firstRowId: 16735
      rowCount: 1
      locations:
        lineNumbers: A=30
        columnNumbers: A=9
     -
      pack: codeql/java-all#1
      relativePath: ext/generated/javax.xml.validation.model.yml
      index: 0
      firstRowId: 16736
      rowCount: 29
      locations:
        lineNumbers: A=7+1*28
        columnNumbers: A=9*29
     -
      pack: codeql/java-all#1
      relativePath: ext/generated/javax.xml.validation.model.yml
      index: 1
      firstRowId: 16765
      rowCount: 22
      locations:
        lineNumbers: A=40+1*21
        columnNumbers: A=9*22
     -
      pack: codeql/java-all#1
      relativePath: ext/generated/javax.xml.xpath.model.yml
      index: 0
      firstRowId: 16787
      rowCount: 26
      locations:
        lineNumbers: A=7+1*25
        columnNumbers: A=9*26
     -
      pack: codeql/java-all#1
      relativePath: ext/generated/javax.xml.xpath.model.yml
      index: 1
      firstRowId: 16813
      rowCount: 12
      locations:
        lineNumbers: A=37+1*11
        columnNumbers: A=9*12
     -
      pack: codeql/java-all#1
      relativePath: ext/generated/jenkins-json-lib.model.yml
      index: 0
      firstRowId: 16825
      rowCount: 2
      locations:
        lineNumbers: A=8+1
        columnNumbers: A=9*2
     -
      pack: codeql/java-all#1
      relativePath: ext/generated/jenkins-json-lib.model.yml
      index: 1
      firstRowId: 16827
      rowCount: 338
      locations:
        lineNumbers: A=14+1*337
        columnNumbers: A=9*338
     -
      pack: codeql/java-all#1
      relativePath: ext/generated/jenkins-json-lib.model.yml
      index: 2
      firstRowId: 17165
      rowCount: 243
      locations:
        lineNumbers: A=356+1*242
        columnNumbers: A=9*243
     -
      pack: codeql/java-all#1
      relativePath: ext/generated/jenkins.model.yml
      index: 0
      firstRowId: 17408
      rowCount: 3251
      locations:
        lineNumbers: A=8+1*3250
        columnNumbers: A=9*3251
     -
      pack: codeql/java-all#1
      relativePath: ext/generated/jenkins.model.yml
      index: 1
      firstRowId: 20659
      rowCount: 5200
      locations:
        lineNumbers: A=3263+1*5199
        columnNumbers: A=9*5200
     -
      pack: codeql/java-all#1
      relativePath: ext/generated/kotlinstdlib.model.yml
      index: 0
      firstRowId: 25859
      rowCount: 12
      locations:
        lineNumbers: A=9+1*11
        columnNumbers: A=9*12
     -
      pack: codeql/java-all#1
      relativePath: ext/generated/kotlinstdlib.model.yml
      index: 1
      firstRowId: 25871
      rowCount: 1833
      locations:
        lineNumbers: A=27+1*1832
        columnNumbers: A=9*1833
     -
      pack: codeql/java-all#1
      relativePath: ext/generated/kotlinstdlib.model.yml
      index: 2
      firstRowId: 27704
      rowCount: 4608
      locations:
        lineNumbers: A=1866+1*4607
        columnNumbers: A=9*4608
     -
      pack: codeql/java-all#1
      relativePath: ext/generated/org.apache.commons.io.model.yml
      index: 0
      firstRowId: 32312
      rowCount: 106
      locations:
        lineNumbers: A=9+1*105
        columnNumbers: A=9*106
     -
      pack: codeql/java-all#1
      relativePath: ext/generated/org.apache.commons.io.model.yml
      index: 1
      firstRowId: 32418
      rowCount: 555
      locations:
        lineNumbers: A=121+1*554
        columnNumbers: A=9*555
     -
      pack: codeql/java-all#1
      relativePath: ext/generated/org.apache.commons.io.model.yml
      index: 2
      firstRowId: 32973
      rowCount: 750
      locations:
        lineNumbers: A=681+1*749
        columnNumbers: A=9*750
     -
      pack: codeql/java-all#1
      relativePath: ext/generated/org.apache.commons.lang.model.yml
      index: 0
      firstRowId: 33723
      rowCount: 765
      locations:
        lineNumbers: A=9+1*764
        columnNumbers: A=9*765
     -
      pack: codeql/java-all#1
      relativePath: ext/generated/org.apache.commons.lang.model.yml
      index: 1
      firstRowId: 34488
      rowCount: 914
      locations:
        lineNumbers: A=780+1*913
        columnNumbers: A=9*914
     -
      pack: codeql/java-all#1
      relativePath: ext/generated/stapler.model.yml
      index: 0
      firstRowId: 35402
      rowCount: 362
      locations:
        lineNumbers: A=8+1*361
        columnNumbers: A=9*362
     -
      pack: codeql/java-all#1
      relativePath: ext/generated/stapler.model.yml
      index: 1
      firstRowId: 35764
      rowCount: 316
      locations:
        lineNumbers: A=374+1*315
        columnNumbers: A=9*316
     -
      pack: codeql/java-all#1
      relativePath: ext/generated/struts2.model.yml
      index: 0
      firstRowId: 36080
      rowCount: 4844
      locations:
        lineNumbers: A=8+1*4843
        columnNumbers: A=9*4844
     -
      pack: codeql/java-all#1
      relativePath: ext/generated/struts2.model.yml
      index: 1
      firstRowId: 40924
      rowCount: 2026
      locations:
        lineNumbers: A=4856+1*2025
        columnNumbers: A=9*2026
     -
      pack: codeql/java-all#1
      relativePath: ext/groovy.lang.model.yml
      index: 0
      firstRowId: 42950
      rowCount: 27
      locations:
        lineNumbers: A=6+1*26
        columnNumbers: A=9*27
     -
      pack: codeql/java-all#1
      relativePath: ext/groovy.util.model.yml
      index: 0
      firstRowId: 42977
      rowCount: 5
      locations:
        lineNumbers: A=6+1*4
        columnNumbers: A=9*5
     -
      pack: codeql/java-all#1
      relativePath: ext/hudson.cli.model.yml
      index: 0
      firstRowId: 42982
      rowCount: 2
      locations:
        lineNumbers: A=6+1
        columnNumbers: A=9*2
     -
      pack: codeql/java-all#1
      relativePath: ext/hudson.console.model.yml
      index: 0
      firstRowId: 42984
      rowCount: 1
      locations:
        lineNumbers: A=6
        columnNumbers: A=9
     -
      pack: codeql/java-all#1
      relativePath: ext/hudson.lifecycle.model.yml
      index: 0
      firstRowId: 42985
      rowCount: 1
      locations:
        lineNumbers: A=6
        columnNumbers: A=9
     -
      pack: codeql/java-all#1
      relativePath: ext/hudson.model.model.yml
      index: 0
      firstRowId: 42986
      rowCount: 7
      locations:
        lineNumbers: A=6+1*6
        columnNumbers: A=9*7
     -
      pack: codeql/java-all#1
      relativePath: ext/hudson.model.model.yml
      index: 1
      firstRowId: 42993
      rowCount: 2
      locations:
        lineNumbers: A=17+1
        columnNumbers: A=9*2
     -
      pack: codeql/java-all#1
      relativePath: ext/hudson.model.model.yml
      index: 2
      firstRowId: 42995
      rowCount: 2
      locations:
        lineNumbers: A=23+1
        columnNumbers: A=9*2
     -
      pack: codeql/java-all#1
      relativePath: ext/hudson.model.yml
      index: 0
      firstRowId: 42997
      rowCount: 36
      locations:
        lineNumbers: A=6+1*35
        columnNumbers: A=9*36
     -
      pack: codeql/java-all#1
      relativePath: ext/hudson.model.yml
      index: 1
      firstRowId: 43033
      rowCount: 7
      locations:
        lineNumbers: A=46+1*6
        columnNumbers: A=9*7
     -
      pack: codeql/java-all#1
      relativePath: ext/hudson.model.yml
      index: 2
      firstRowId: 43040
      rowCount: 26
      locations:
        lineNumbers: A=57+1*25
        columnNumbers: A=9*26
     -
      pack: codeql/java-all#1
      relativePath: ext/hudson.os.model.yml
      index: 0
      firstRowId: 43066
      rowCount: 1
      locations:
        lineNumbers: A=6
        columnNumbers: A=9
     -
      pack: codeql/java-all#1
      relativePath: ext/hudson.remoting.model.yml
      index: 0
      firstRowId: 43067
      rowCount: 1
      locations:
        lineNumbers: A=6
        columnNumbers: A=9
     -
      pack: codeql/java-all#1
      relativePath: ext/hudson.scm.model.yml
      index: 0
      firstRowId: 43068
      rowCount: 5
      locations:
        lineNumbers: A=6+1*4
        columnNumbers: A=9*5
     -
      pack: codeql/java-all#1
      relativePath: ext/hudson.scm.model.yml
      index: 1
      firstRowId: 43073
      rowCount: 4
      locations:
        lineNumbers: A=15+1*3
        columnNumbers: A=9*4
     -
      pack: codeql/java-all#1
      relativePath: ext/hudson.util.io.model.yml
      index: 0
      firstRowId: 43077
      rowCount: 2
      locations:
        lineNumbers: A=6+1
        columnNumbers: A=9*2
     -
      pack: codeql/java-all#1
      relativePath: ext/hudson.util.jna.model.yml
      index: 0
      firstRowId: 43079
      rowCount: 3
      locations:
        lineNumbers: A=6+1*2
        columnNumbers: A=9*3
     -
      pack: codeql/java-all#1
      relativePath: ext/hudson.util.model.yml
      index: 0
      firstRowId: 43082
      rowCount: 19
      locations:
        lineNumbers: A=6+1*18
        columnNumbers: A=9*19
     -
      pack: codeql/java-all#1
      relativePath: ext/hudson.util.model.yml
      index: 1
      firstRowId: 43101
      rowCount: 17
      locations:
        lineNumbers: A=29+1*6+2+1*9
        columnNumbers: A=9*17
     -
      pack: codeql/java-all#1
      relativePath: ext/io.jsonwebtoken.model.yml
      index: 0
      firstRowId: 43118
      rowCount: 4
      locations:
        lineNumbers: A=6+1*3
        columnNumbers: A=9*4
     -
      pack: codeql/java-all#1
      relativePath: ext/io.jsonwebtoken.model.yml
      index: 1
      firstRowId: 43122
      rowCount: 2
      locations:
        lineNumbers: A=14+1
        columnNumbers: A=9*2
     -
      pack: codeql/java-all#1
      relativePath: ext/io.netty.bootstrap.model.yml
      index: 0
      firstRowId: 43124
      rowCount: 3
      locations:
        lineNumbers: A=6+1*2
        columnNumbers: A=9*3
     -
      pack: codeql/java-all#1
      relativePath: ext/io.netty.buffer.model.yml
      index: 0
      firstRowId: 43127
      rowCount: 207
      locations:
        lineNumbers: A=6+1*206
        columnNumbers: A=9*207
     -
      pack: codeql/java-all#1
      relativePath: ext/io.netty.channel.model.yml
      index: 0
      firstRowId: 43334
      rowCount: 9
      locations:
        lineNumbers: A=6+1*8
        columnNumbers: A=9*9
     -
      pack: codeql/java-all#1
      relativePath: ext/io.netty.channel.model.yml
      index: 1
      firstRowId: 43343
      rowCount: 2
      locations:
        lineNumbers: A=19+1
        columnNumbers: A=9*2
     -
      pack: codeql/java-all#1
      relativePath: ext/io.netty.handler.codec.base64.model.yml
      index: 0
      firstRowId: 43345
      rowCount: 2
      locations:
        lineNumbers: A=6+1
        columnNumbers: A=7*2
     -
      pack: codeql/java-all#1
      relativePath: ext/io.netty.handler.codec.http.cookie.model.yml
      index: 0
      firstRowId: 43347
      rowCount: 14
      locations:
        lineNumbers: A=6+1*13
        columnNumbers: A=7*14
     -
      pack: codeql/java-all#1
      relativePath: ext/io.netty.handler.codec.http.model.yml
      index: 0
      firstRowId: 43361
      rowCount: 3
      locations:
        lineNumbers: A=6+1*2
        columnNumbers: A=7*3
     -
      pack: codeql/java-all#1
      relativePath: ext/io.netty.handler.codec.http.model.yml
      index: 1
      firstRowId: 43364
      rowCount: 70
      locations:
        lineNumbers: A=13+1*57+2+1*11
        columnNumbers: A=7*70
     -
      pack: codeql/java-all#1
      relativePath: ext/io.netty.handler.codec.http.multipart.model.yml
      index: 0
      firstRowId: 43434
      rowCount: 1
      locations:
        lineNumbers: A=6
        columnNumbers: A=9
     -
      pack: codeql/java-all#1
      relativePath: ext/io.netty.handler.codec.http.multipart.model.yml
      index: 1
      firstRowId: 43435
      rowCount: 33
      locations:
        lineNumbers: A=11+1*32
        columnNumbers: A=9*33
     -
      pack: codeql/java-all#1
      relativePath: ext/io.netty.handler.codec.http.websocketx.model.yml
      index: 0
      firstRowId: 43468
      rowCount: 20
      locations:
        lineNumbers: A=6+1*19
        columnNumbers: A=7*20
     -
      pack: codeql/java-all#1
      relativePath: ext/io.netty.handler.codec.http2.model.yml
      index: 0
      firstRowId: 43488
      rowCount: 4
      locations:
        lineNumbers: A=6+1*3
        columnNumbers: A=7*4
     -
      pack: codeql/java-all#1
      relativePath: ext/io.netty.handler.codec.http2.model.yml
      index: 1
      firstRowId: 43492
      rowCount: 36
      locations:
        lineNumbers: A=14+1*35
        columnNumbers: A=7*36
     -
      pack: codeql/java-all#1
      relativePath: ext/io.netty.handler.codec.model.yml
      index: 0
      firstRowId: 43528
      rowCount: 9
      locations:
        lineNumbers: A=6+1*8
        columnNumbers: A=9*9
     -
      pack: codeql/java-all#1
      relativePath: ext/io.netty.handler.codec.model.yml
      index: 1
      firstRowId: 43537
      rowCount: 85
      locations:
        lineNumbers: A=19+1*84
        columnNumbers: A=9*85
     -
      pack: codeql/java-all#1
      relativePath: ext/io.netty.handler.ssl.model.yml
      index: 0
      firstRowId: 43622
      rowCount: 4
      locations:
        lineNumbers: A=6+1*3
        columnNumbers: A=9*4
     -
      pack: codeql/java-all#1
      relativePath: ext/io.netty.handler.stream.model.yml
      index: 0
      firstRowId: 43626
      rowCount: 1
      locations:
        lineNumbers: A=6
        columnNumbers: A=9
     -
      pack: codeql/java-all#1
      relativePath: ext/io.netty.resolver.model.yml
      index: 0
      firstRowId: 43627
      rowCount: 1
      locations:
        lineNumbers: A=6
        columnNumbers: A=9
     -
      pack: codeql/java-all#1
      relativePath: ext/io.netty.util.internal.model.yml
      index: 0
      firstRowId: 43628
      rowCount: 2
      locations:
        lineNumbers: A=6+1
        columnNumbers: A=9*2
     -
      pack: codeql/java-all#1
      relativePath: ext/io.netty.util.internal.model.yml
      index: 1
      firstRowId: 43630
      rowCount: 2
      locations:
        lineNumbers: A=12+1
        columnNumbers: A=9*2
     -
      pack: codeql/java-all#1
      relativePath: ext/io.netty.util.model.yml
      index: 0
      firstRowId: 43632
      rowCount: 22
      locations:
        lineNumbers: A=6+1*21
        columnNumbers: A=9*22
     -
      pack: codeql/java-all#1
      relativePath: ext/io.undertow.server.handlers.resource.model.yml
      index: 0
      firstRowId: 43654
      rowCount: 1
      locations:
        lineNumbers: A=6
        columnNumbers: A=9
     -
      pack: codeql/java-all#1
      relativePath: ext/io.undertow.server.handlers.resource.model.yml
      index: 1
      firstRowId: 43655
      rowCount: 3
      locations:
        lineNumbers: A=12+1*2
        columnNumbers: A=9*3
     -
      pack: codeql/java-all#1
      relativePath: ext/jakarta.activation.model.yml
      index: 0
      firstRowId: 43658
      rowCount: 2
      locations:
        lineNumbers: A=6+1
        columnNumbers: A=9*2
     -
      pack: codeql/java-all#1
      relativePath: ext/jakarta.activation.model.yml
      index: 1
      firstRowId: 43660
      rowCount: 2
      locations:
        lineNumbers: A=12+1
        columnNumbers: A=9*2
     -
      pack: codeql/java-all#1
      relativePath: ext/jakarta.faces.context.model.yml
      index: 0
      firstRowId: 43662
      rowCount: 7
      locations:
        lineNumbers: A=6+1*6
        columnNumbers: A=9*7
     -
      pack: codeql/java-all#1
      relativePath: ext/jakarta.faces.context.model.yml
      index: 1
      firstRowId: 43669
      rowCount: 4
      locations:
        lineNumbers: A=17+1*3
        columnNumbers: A=9*4
     -
      pack: codeql/java-all#1
      relativePath: ext/jakarta.json.model.yml
      index: 0
      firstRowId: 43673
      rowCount: 122
      locations:
        lineNumbers: A=6+1*121
        columnNumbers: A=9*122
     -
      pack: codeql/java-all#1
      relativePath: ext/jakarta.json.stream.model.yml
      index: 0
      firstRowId: 43795
      rowCount: 1
      locations:
        lineNumbers: A=6
        columnNumbers: A=9
     -
      pack: codeql/java-all#1
      relativePath: ext/jakarta.persistence.criteria.model.yml
      index: 0
      firstRowId: 43796
      rowCount: 1
      locations:
        lineNumbers: A=6
        columnNumbers: A=9
     -
      pack: codeql/java-all#1
      relativePath: ext/jakarta.persistence.model.yml
      index: 0
      firstRowId: 43797
      rowCount: 2
      locations:
        lineNumbers: A=6+1
        columnNumbers: A=9*2
     -
      pack: codeql/java-all#1
      relativePath: ext/jakarta.servlet.http.model.yml
      index: 0
      firstRowId: 43799
      rowCount: 1
      locations:
        lineNumbers: A=6
        columnNumbers: A=9
     -
      pack: codeql/java-all#1
      relativePath: ext/jakarta.servlet.model.yml
      index: 0
      firstRowId: 43800
      rowCount: 2
      locations:
        lineNumbers: A=6+1
        columnNumbers: A=9*2
     -
      pack: codeql/java-all#1
      relativePath: ext/jakarta.ws.rs.client.model.yml
      index: 0
      firstRowId: 43802
      rowCount: 1
      locations:
        lineNumbers: A=6
        columnNumbers: A=9
     -
      pack: codeql/java-all#1
      relativePath: ext/jakarta.ws.rs.container.model.yml
      index: 0
      firstRowId: 43803
      rowCount: 9
      locations:
        lineNumbers: A=6+1*8
        columnNumbers: A=9*9
     -
      pack: codeql/java-all#1
      relativePath: ext/jakarta.ws.rs.core.model.yml
      index: 0
      firstRowId: 43812
      rowCount: 2
      locations:
        lineNumbers: A=6+1
        columnNumbers: A=9*2
     -
      pack: codeql/java-all#1
      relativePath: ext/jakarta.ws.rs.core.model.yml
      index: 1
      firstRowId: 43814
      rowCount: 149
      locations:
        lineNumbers: A=12+1*17+4+1*35+2+1*2+4+1*91
        columnNumbers: A=9*149
     -
      pack: codeql/java-all#1
      relativePath: ext/jakarta.xml.bind.attachment.model.yml
      index: 0
      firstRowId: 43963
      rowCount: 2
      locations:
        lineNumbers: A=6+1
        columnNumbers: A=9*2
     -
      pack: codeql/java-all#1
      relativePath: ext/java.awt.model.yml
      index: 0
      firstRowId: 43965
      rowCount: 3
      locations:
        lineNumbers: A=6+1*2
        columnNumbers: A=9*3
     -
      pack: codeql/java-all#1
      relativePath: ext/java.awt.model.yml
      index: 1
      firstRowId: 43968
      rowCount: 1
      locations:
        lineNumbers: A=15
        columnNumbers: A=9
     -
      pack: codeql/java-all#1
      relativePath: ext/java.awt.model.yml
      index: 2
      firstRowId: 43969
      rowCount: 1
      locations:
        lineNumbers: A=20
        columnNumbers: A=9
     -
      pack: codeql/java-all#1
      relativePath: ext/java.beans.model.yml
      index: 0
      firstRowId: 43970
      rowCount: 1
      locations:
        lineNumbers: A=6
        columnNumbers: A=9
     -
      pack: codeql/java-all#1
      relativePath: ext/java.beans.model.yml
      index: 1
      firstRowId: 43971
      rowCount: 4
      locations:
        lineNumbers: A=12+1*3
        columnNumbers: A=9*4
     -
      pack: codeql/java-all#1
      relativePath: ext/java.io.model.yml
      index: 0
      firstRowId: 43975
      rowCount: 66
      locations:
        lineNumbers: A=6+1*65
        columnNumbers: A=9*66
     -
      pack: codeql/java-all#1
      relativePath: ext/java.io.model.yml
      index: 1
      firstRowId: 44041
      rowCount: 52
      locations:
        lineNumbers: A=76+1*51
        columnNumbers: A=9*52
     -
      pack: codeql/java-all#1
      relativePath: ext/java.io.model.yml
      index: 2
      firstRowId: 44093
      rowCount: 20
      locations:
        lineNumbers: A=133+1*14+3+1*3+2
        columnNumbers: A=9*20
     -
      pack: codeql/java-all#1
      relativePath: ext/java.io.model.yml
      index: 3
      firstRowId: 44113
      rowCount: 1
      locations:
        lineNumbers: A=160
        columnNumbers: A=9
     -
      pack: codeql/java-all#1
      relativePath: ext/java.lang.invoke.model.yml
      index: 0
      firstRowId: 44114
      rowCount: 1
      locations:
        lineNumbers: A=6
        columnNumbers: A=9
     -
      pack: codeql/java-all#1
      relativePath: ext/java.lang.model.yml
      index: 0
      firstRowId: 44115
      rowCount: 38
      locations:
        lineNumbers: A=6+1*23+2+4+1*4+4+1*7
        columnNumbers: A=9*38
     -
      pack: codeql/java-all#1
      relativePath: ext/java.lang.model.yml
      index: 1
      firstRowId: 44153
      rowCount: 3
      locations:
        lineNumbers: A=55+1*2
        columnNumbers: A=9*3
     -
      pack: codeql/java-all#1
      relativePath: ext/java.lang.model.yml
      index: 2
      firstRowId: 44156
      rowCount: 98
      locations:
        lineNumbers: A=62+1*3+2+1*93
        columnNumbers: A=9*98
     -
      pack: codeql/java-all#1
      relativePath: ext/java.lang.model.yml
      index: 3
      firstRowId: 44254
      rowCount: 109
      locations:
        lineNumbers: A=165+1*86+3+1*21
        columnNumbers: A=9*109
     -
      pack: codeql/java-all#1
      relativePath: ext/java.lang.module.model.yml
      index: 0
      firstRowId: 44363
      rowCount: 1
      locations:
        lineNumbers: A=6
        columnNumbers: A=9
     -
      pack: codeql/java-all#1
      relativePath: ext/java.lang.reflect.model.yml
      index: 0
      firstRowId: 44364
      rowCount: 4
      locations:
        lineNumbers: A=7+1*3
        columnNumbers: A=9*4
     -
      pack: codeql/java-all#1
      relativePath: ext/java.math.model.yml
      index: 0
      firstRowId: 44368
      rowCount: 14
      locations:
        lineNumbers: A=6+4+1*12
        columnNumbers: A=9*14
     -
      pack: codeql/java-all#1
      relativePath: ext/java.net.http.model.yml
      index: 0
      firstRowId: 44382
      rowCount: 1
      locations:
        lineNumbers: A=6
        columnNumbers: A=9
     -
      pack: codeql/java-all#1
      relativePath: ext/java.net.http.model.yml
      index: 1
      firstRowId: 44383
      rowCount: 3
      locations:
        lineNumbers: A=11+1*2
        columnNumbers: A=9*3
     -
      pack: codeql/java-all#1
      relativePath: ext/java.net.model.yml
      index: 0
      firstRowId: 44386
      rowCount: 2
      locations:
        lineNumbers: A=6+1
        columnNumbers: A=9*2
     -
      pack: codeql/java-all#1
      relativePath: ext/java.net.model.yml
      index: 1
      firstRowId: 44388
      rowCount: 25
      locations:
        lineNumbers: A=12+1*24
        columnNumbers: A=9*25
     -
      pack: codeql/java-all#1
      relativePath: ext/java.net.model.yml
      index: 2
      firstRowId: 44413
      rowCount: 39
      locations:
        lineNumbers: A=41+1*38
        columnNumbers: A=9*39
     -
      pack: codeql/java-all#1
      relativePath: ext/java.net.model.yml
      index: 3
      firstRowId: 44452
      rowCount: 9
      locations:
        lineNumbers: A=85+1*8
        columnNumbers: A=9*9
     -
      pack: codeql/java-all#1
      relativePath: ext/java.nio.channels.model.yml
      index: 0
      firstRowId: 44461
      rowCount: 2
      locations:
        lineNumbers: A=6+1
        columnNumbers: A=9*2
     -
      pack: codeql/java-all#1
      relativePath: ext/java.nio.channels.model.yml
      index: 1
      firstRowId: 44463
      rowCount: 4
      locations:
        lineNumbers: A=12+1*3
        columnNumbers: A=9*4
     -
      pack: codeql/java-all#1
      relativePath: ext/java.nio.charset.model.yml
      index: 0
      firstRowId: 44467
      rowCount: 1
      locations:
        lineNumbers: A=6
        columnNumbers: A=9
     -
      pack: codeql/java-all#1
      relativePath: ext/java.nio.file.model.yml
      index: 0
      firstRowId: 44468
      rowCount: 40
      locations:
        lineNumbers: A=6+1*39
        columnNumbers: A=9*40
     -
      pack: codeql/java-all#1
      relativePath: ext/java.nio.file.model.yml
      index: 1
      firstRowId: 44508
      rowCount: 33
      locations:
        lineNumbers: A=50+1*32
        columnNumbers: A=9*33
     -
      pack: codeql/java-all#1
      relativePath: ext/java.nio.file.model.yml
      index: 2
      firstRowId: 44541
      rowCount: 38
      locations:
        lineNumbers: A=93+1*24+2+1*12
        columnNumbers: A=9*38
     -
      pack: codeql/java-all#1
      relativePath: ext/java.nio.file.spi.model.yml
      index: 0
      firstRowId: 44579
      rowCount: 2
      locations:
        lineNumbers: A=7+1
        columnNumbers: A=9*2
     -
      pack: codeql/java-all#1
      relativePath: ext/java.nio.model.yml
      index: 0
      firstRowId: 44581
      rowCount: 15
      locations:
        lineNumbers: A=6+1*14
        columnNumbers: A=9*15
     -
      pack: codeql/java-all#1
      relativePath: ext/java.nio.model.yml
      index: 1
      firstRowId: 44596
      rowCount: 3
      locations:
        lineNumbers: A=27+1*2
        columnNumbers: A=9*3
     -
      pack: codeql/java-all#1
      relativePath: ext/java.security.cert.model.yml
      index: 0
      firstRowId: 44599
      rowCount: 1
      locations:
        lineNumbers: A=6
        columnNumbers: A=9
     -
      pack: codeql/java-all#1
      relativePath: ext/java.security.cert.model.yml
      index: 1
      firstRowId: 44600
      rowCount: 2
      locations:
        lineNumbers: A=12+1
        columnNumbers: A=9*2
     -
      pack: codeql/java-all#1
      relativePath: ext/java.security.cert.model.yml
      index: 2
      firstRowId: 44602
      rowCount: 36
      locations:
        lineNumbers: A=19+1*35
        columnNumbers: A=9*36
     -
      pack: codeql/java-all#1
      relativePath: ext/java.security.model.yml
      index: 0
      firstRowId: 44638
      rowCount: 12
      locations:
        lineNumbers: A=6+1*11
        columnNumbers: A=9*12
     -
      pack: codeql/java-all#1
      relativePath: ext/java.security.model.yml
      index: 1
      firstRowId: 44650
      rowCount: 9
      locations:
        lineNumbers: A=22+1*8
        columnNumbers: A=9*9
     -
      pack: codeql/java-all#1
      relativePath: ext/java.security.model.yml
      index: 2
      firstRowId: 44659
      rowCount: 3
      locations:
        lineNumbers: A=36+1*2
        columnNumbers: A=9*3
     -
      pack: codeql/java-all#1
      relativePath: ext/java.security.spec.model.yml
      index: 0
      firstRowId: 44662
      rowCount: 8
      locations:
        lineNumbers: A=6+1*7
        columnNumbers: A=9*8
     -
      pack: codeql/java-all#1
      relativePath: ext/java.sql.model.yml
      index: 0
      firstRowId: 44670
      rowCount: 15
      locations:
        lineNumbers: A=6+1*14
        columnNumbers: A=9*15
     -
      pack: codeql/java-all#1
      relativePath: ext/java.sql.model.yml
      index: 1
      firstRowId: 44685
      rowCount: 2
      locations:
        lineNumbers: A=25+1
        columnNumbers: A=9*2
     -
      pack: codeql/java-all#1
      relativePath: ext/java.sql.model.yml
      index: 2
      firstRowId: 44687
      rowCount: 15
      locations:
        lineNumbers: A=32+1*7+4+1*6
        columnNumbers: A=9*15
     -
      pack: codeql/java-all#1
      relativePath: ext/java.sql.model.yml
      index: 3
      firstRowId: 44702
      rowCount: 1
      locations:
        lineNumbers: A=54
        columnNumbers: A=9
     -
      pack: codeql/java-all#1
      relativePath: ext/java.text.model.yml
      index: 0
      firstRowId: 44703
      rowCount: 8
      locations:
        lineNumbers: A=7+1+4+1*2+3+1*2
        columnNumbers: A=9*8
     -
      pack: codeql/java-all#1
      relativePath: ext/java.time.chrono.model.yml
      index: 0
      firstRowId: 44711
      rowCount: 50
      locations:
        lineNumbers: A=6+3+1*48
        columnNumbers: A=9*50
     -
      pack: codeql/java-all#1
      relativePath: ext/java.time.format.model.yml
      index: 0
      firstRowId: 44761
      rowCount: 2
      locations:
        lineNumbers: A=6+1
        columnNumbers: A=9*2
     -
      pack: codeql/java-all#1
      relativePath: ext/java.time.model.yml
      index: 0
      firstRowId: 44763
      rowCount: 265
      locations:
        lineNumbers: A=6+1*5+4+1*10+3+1*247
        columnNumbers: A=9*265
     -
      pack: codeql/java-all#1
      relativePath: ext/java.time.temporal.model.yml
      index: 0
      firstRowId: 45028
      rowCount: 26
      locations:
        lineNumbers: A=7+1*25
        columnNumbers: A=9*26
     -
      pack: codeql/java-all#1
      relativePath: ext/java.time.zone.model.yml
      index: 0
      firstRowId: 45054
      rowCount: 30
      locations:
        lineNumbers: A=7+1*29
        columnNumbers: A=9*30
     -
      pack: codeql/java-all#1
      relativePath: ext/java.util.concurrent.atomic.model.yml
      index: 0
      firstRowId: 45084
      rowCount: 3
      locations:
        lineNumbers: A=6+1*2
        columnNumbers: A=9*3
     -
      pack: codeql/java-all#1
      relativePath: ext/java.util.concurrent.atomic.model.yml
      index: 1
      firstRowId: 45087
      rowCount: 11
      locations:
        lineNumbers: A=14+1*3+4+1*6
        columnNumbers: A=9*11
     -
      pack: codeql/java-all#1
      relativePath: ext/java.util.concurrent.locks.model.yml
      index: 0
      firstRowId: 45098
      rowCount: 2
      locations:
        lineNumbers: A=6+1
        columnNumbers: A=9*2
     -
      pack: codeql/java-all#1
      relativePath: ext/java.util.concurrent.model.yml
      index: 0
      firstRowId: 45100
      rowCount: 24
      locations:
        lineNumbers: A=6+1*23
        columnNumbers: A=9*24
     -
      pack: codeql/java-all#1
      relativePath: ext/java.util.concurrent.model.yml
      index: 1
      firstRowId: 45124
      rowCount: 9
      locations:
        lineNumbers: A=35+1*5+4+1*2
        columnNumbers: A=9*9
     -
      pack: codeql/java-all#1
      relativePath: ext/java.util.function.model.yml
      index: 0
      firstRowId: 45133
      rowCount: 1
      locations:
        lineNumbers: A=6
        columnNumbers: A=9
     -
      pack: codeql/java-all#1
      relativePath: ext/java.util.function.model.yml
      index: 1
      firstRowId: 45134
      rowCount: 1
      locations:
        lineNumbers: A=12
        columnNumbers: A=9
     -
      pack: codeql/java-all#1
      relativePath: ext/java.util.logging.model.yml
      index: 0
      firstRowId: 45135
      rowCount: 36
      locations:
        lineNumbers: A=6+1*35
        columnNumbers: A=9*36
     -
      pack: codeql/java-all#1
      relativePath: ext/java.util.logging.model.yml
      index: 1
      firstRowId: 45171
      rowCount: 6
      locations:
        lineNumbers: A=46+1*5
        columnNumbers: A=9*6
     -
      pack: codeql/java-all#1
      relativePath: ext/java.util.logging.model.yml
      index: 2
      firstRowId: 45177
      rowCount: 3
      locations:
        lineNumbers: A=56+1*2
        columnNumbers: A=9*3
     -
      pack: codeql/java-all#1
      relativePath: ext/java.util.model.yml
      index: 0
      firstRowId: 45180
      rowCount: 2
      locations:
        lineNumbers: A=6+1
        columnNumbers: A=9*2
     -
      pack: codeql/java-all#1
      relativePath: ext/java.util.model.yml
      index: 1
      firstRowId: 45182
      rowCount: 406
      locations:
        lineNumbers: A=13+1*405
        columnNumbers: A=9*406
     -
      pack: codeql/java-all#1
      relativePath: ext/java.util.model.yml
      index: 2
      firstRowId: 45588
      rowCount: 140
      locations:
        lineNumbers: A=424+1*128+3+4+1*9
        columnNumbers: A=9*140
     -
      pack: codeql/java-all#1
      relativePath: ext/java.util.prefs.model.yml
      index: 0
      firstRowId: 45728
      rowCount: 16
      locations:
        lineNumbers: A=7+1*13+2+1
        columnNumbers: A=9*16
     -
      pack: codeql/java-all#1
      relativePath: ext/java.util.regex.model.yml
      index: 0
      firstRowId: 45744
      rowCount: 9
      locations:
        lineNumbers: A=6+1*8
        columnNumbers: A=9*9
     -
      pack: codeql/java-all#1
      relativePath: ext/java.util.regex.model.yml
      index: 1
      firstRowId: 45753
      rowCount: 9
      locations:
        lineNumbers: A=19+1*8
        columnNumbers: A=9*9
     -
      pack: codeql/java-all#1
      relativePath: ext/java.util.regex.model.yml
      index: 2
      firstRowId: 45762
      rowCount: 6
      locations:
        lineNumbers: A=33+1*5
        columnNumbers: A=9*6
     -
      pack: codeql/java-all#1
      relativePath: ext/java.util.stream.model.yml
      index: 0
      firstRowId: 45768
      rowCount: 83
      locations:
        lineNumbers: A=6+1*15+2+1*26+4+1*39
        columnNumbers: A=9*83
     -
      pack: codeql/java-all#1
      relativePath: ext/java.util.stream.model.yml
      index: 1
      firstRowId: 45851
      rowCount: 7
      locations:
        lineNumbers: A=98+1*5+4
        columnNumbers: A=9*7
     -
      pack: codeql/java-all#1
      relativePath: ext/java.util.zip.model.yml
      index: 0
      firstRowId: 45858
      rowCount: 17
      locations:
        lineNumbers: A=6+1*16
        columnNumbers: A=9*17
     -
      pack: codeql/java-all#1
      relativePath: ext/java.util.zip.model.yml
      index: 1
      firstRowId: 45875
      rowCount: 1
      locations:
        lineNumbers: A=27
        columnNumbers: A=9
     -
      pack: codeql/java-all#1
      relativePath: ext/javafx.scene.web.model.yml
      index: 0
      firstRowId: 45876
      rowCount: 1
      locations:
        lineNumbers: A=6
        columnNumbers: A=9
     -
      pack: codeql/java-all#1
      relativePath: ext/javax.activation.model.yml
      index: 0
      firstRowId: 45877
      rowCount: 2
      locations:
        lineNumbers: A=6+1
        columnNumbers: A=9*2
     -
      pack: codeql/java-all#1
      relativePath: ext/javax.activation.model.yml
      index: 1
      firstRowId: 45879
      rowCount: 7
      locations:
        lineNumbers: A=12+1*6
        columnNumbers: A=9*7
     -
      pack: codeql/java-all#1
      relativePath: ext/javax.crypto.model.yml
      index: 0
      firstRowId: 45886
      rowCount: 4
      locations:
        lineNumbers: A=6+1*3
        columnNumbers: A=9*4
     -
      pack: codeql/java-all#1
      relativePath: ext/javax.crypto.model.yml
      index: 1
      firstRowId: 45890
      rowCount: 15
      locations:
        lineNumbers: A=14+1*14
        columnNumbers: A=9*15
     -
      pack: codeql/java-all#1
      relativePath: ext/javax.crypto.spec.model.yml
      index: 0
      firstRowId: 45905
      rowCount: 4
      locations:
        lineNumbers: A=6+1*3
        columnNumbers: A=9*4
     -
      pack: codeql/java-all#1
      relativePath: ext/javax.crypto.spec.model.yml
      index: 1
      firstRowId: 45909
      rowCount: 15
      locations:
        lineNumbers: A=14+1*14
        columnNumbers: A=9*15
     -
      pack: codeql/java-all#1
      relativePath: ext/javax.crypto.spec.model.yml
      index: 2
      firstRowId: 45924
      rowCount: 2
      locations:
        lineNumbers: A=33+1
        columnNumbers: A=9*2
     -
      pack: codeql/java-all#1
      relativePath: ext/javax.faces.context.model.yml
      index: 0
      firstRowId: 45926
      rowCount: 7
      locations:
        lineNumbers: A=6+1*6
        columnNumbers: A=9*7
     -
      pack: codeql/java-all#1
      relativePath: ext/javax.faces.context.model.yml
      index: 1
      firstRowId: 45933
      rowCount: 4
      locations:
        lineNumbers: A=17+1*3
        columnNumbers: A=9*4
     -
      pack: codeql/java-all#1
      relativePath: ext/javax.imageio.stream.model.yml
      index: 0
      firstRowId: 45937
      rowCount: 1
      locations:
        lineNumbers: A=6
        columnNumbers: A=9
     -
      pack: codeql/java-all#1
      relativePath: ext/javax.imageio.stream.model.yml
      index: 1
      firstRowId: 45938
      rowCount: 1
      locations:
        lineNumbers: A=11
        columnNumbers: A=9
     -
      pack: codeql/java-all#1
      relativePath: ext/javax.jms.model.yml
      index: 0
      firstRowId: 45939
      rowCount: 9
      locations:
        lineNumbers: A=11+1*8
        columnNumbers: A=9*9
     -
      pack: codeql/java-all#1
      relativePath: ext/javax.jms.model.yml
      index: 1
      firstRowId: 45948
      rowCount: 57
      locations:
        lineNumbers: A=24+1*56
        columnNumbers: A=9*57
     -
      pack: codeql/java-all#1
      relativePath: ext/javax.json.model.yml
      index: 0
      firstRowId: 46005
      rowCount: 122
      locations:
        lineNumbers: A=6+1*121
        columnNumbers: A=9*122
     -
      pack: codeql/java-all#1
      relativePath: ext/javax.json.stream.model.yml
      index: 0
      firstRowId: 46127
      rowCount: 1
      locations:
        lineNumbers: A=6
        columnNumbers: A=9
     -
      pack: codeql/java-all#1
      relativePath: ext/javax.management.model.yml
      index: 0
      firstRowId: 46128
      rowCount: 4
      locations:
        lineNumbers: A=6+1*3
        columnNumbers: A=9*4
     -
      pack: codeql/java-all#1
      relativePath: ext/javax.management.remote.model.yml
      index: 0
      firstRowId: 46132
      rowCount: 2
      locations:
        lineNumbers: A=6+1
        columnNumbers: A=9*2
     -
      pack: codeql/java-all#1
      relativePath: ext/javax.naming.directory.model.yml
      index: 0
      firstRowId: 46134
      rowCount: 8
      locations:
        lineNumbers: A=6+1*7
        columnNumbers: A=9*8
     -
      pack: codeql/java-all#1
      relativePath: ext/javax.naming.directory.model.yml
      index: 1
      firstRowId: 46142
      rowCount: 1
      locations:
        lineNumbers: A=19
        columnNumbers: A=9
     -
      pack: codeql/java-all#1
      relativePath: ext/javax.naming.model.yml
      index: 0
      firstRowId: 46143
      rowCount: 6
      locations:
        lineNumbers: A=6+1*5
        columnNumbers: A=9*6
     -
      pack: codeql/java-all#1
      relativePath: ext/javax.naming.model.yml
      index: 1
      firstRowId: 46149
      rowCount: 1
      locations:
        lineNumbers: A=17
        columnNumbers: A=9
     -
      pack: codeql/java-all#1
      relativePath: ext/javax.net.ssl.model.yml
      index: 0
      firstRowId: 46150
      rowCount: 4
      locations:
        lineNumbers: A=6+1*3
        columnNumbers: A=9*4
     -
      pack: codeql/java-all#1
      relativePath: ext/javax.portlet.model.yml
      index: 0
      firstRowId: 46154
      rowCount: 1
      locations:
        lineNumbers: A=6
        columnNumbers: A=9
     -
      pack: codeql/java-all#1
      relativePath: ext/javax.print.attribute.standard.model.yml
      index: 0
      firstRowId: 46155
      rowCount: 2
      locations:
        lineNumbers: A=6+1
        columnNumbers: A=9*2
     -
      pack: codeql/java-all#1
      relativePath: ext/javax.script.model.yml
      index: 0
      firstRowId: 46157
      rowCount: 1
      locations:
        lineNumbers: A=6
        columnNumbers: A=9
     -
      pack: codeql/java-all#1
      relativePath: ext/javax.security.auth.callback.model.yml
      index: 0
      firstRowId: 46158
      rowCount: 1
      locations:
        lineNumbers: A=6
        columnNumbers: A=9
     -
      pack: codeql/java-all#1
      relativePath: ext/javax.security.auth.kerberos.model.yml
      index: 0
      firstRowId: 46159
      rowCount: 6
      locations:
        lineNumbers: A=6+1*5
        columnNumbers: A=9*6
     -
      pack: codeql/java-all#1
      relativePath: ext/javax.servlet.http.model.yml
      index: 0
      firstRowId: 46165
      rowCount: 16
      locations:
        lineNumbers: A=6+1*15
        columnNumbers: A=9*16
     -
      pack: codeql/java-all#1
      relativePath: ext/javax.servlet.http.model.yml
      index: 1
      firstRowId: 46181
      rowCount: 6
      locations:
        lineNumbers: A=27+1*3+2+1
        columnNumbers: A=9*6
     -
      pack: codeql/java-all#1
      relativePath: ext/javax.servlet.http.model.yml
      index: 2
      firstRowId: 46187
      rowCount: 2
      locations:
        lineNumbers: A=38+1
        columnNumbers: A=9*2
     -
      pack: codeql/java-all#1
      relativePath: ext/javax.servlet.model.yml
      index: 0
      firstRowId: 46189
      rowCount: 6
      locations:
        lineNumbers: A=6+1*5
        columnNumbers: A=9*6
     -
      pack: codeql/java-all#1
      relativePath: ext/javax.servlet.model.yml
      index: 1
      firstRowId: 46195
      rowCount: 4
      locations:
        lineNumbers: A=16+1*3
        columnNumbers: A=9*4
     -
      pack: codeql/java-all#1
      relativePath: ext/javax.servlet.model.yml
      index: 2
      firstRowId: 46199
      rowCount: 1
      locations:
        lineNumbers: A=24
        columnNumbers: A=9
     -
      pack: codeql/java-all#1
      relativePath: ext/javax.sql.model.yml
      index: 0
      firstRowId: 46200
      rowCount: 7
      locations:
        lineNumbers: A=6+1*6
        columnNumbers: A=9*7
     -
      pack: codeql/java-all#1
      relativePath: ext/javax.validation.model.yml
      index: 0
      firstRowId: 46207
      rowCount: 1
      locations:
        lineNumbers: A=6
        columnNumbers: A=9
     -
      pack: codeql/java-all#1
      relativePath: ext/javax.validation.model.yml
      index: 1
      firstRowId: 46208
      rowCount: 1
      locations:
        lineNumbers: A=11
        columnNumbers: A=9
     -
      pack: codeql/java-all#1
      relativePath: ext/javax.ws.rs.client.model.yml
      index: 0
      firstRowId: 46209
      rowCount: 1
      locations:
        lineNumbers: A=6
        columnNumbers: A=9
     -
      pack: codeql/java-all#1
      relativePath: ext/javax.ws.rs.container.model.yml
      index: 0
      firstRowId: 46210
      rowCount: 9
      locations:
        lineNumbers: A=6+1*8
        columnNumbers: A=9*9
     -
      pack: codeql/java-all#1
      relativePath: ext/javax.ws.rs.core.model.yml
      index: 0
      firstRowId: 46219
      rowCount: 3
      locations:
        lineNumbers: A=6+1*2
        columnNumbers: A=9*3
     -
      pack: codeql/java-all#1
      relativePath: ext/javax.ws.rs.core.model.yml
      index: 1
      firstRowId: 46222
      rowCount: 149
      locations:
        lineNumbers: A=13+1*17+4+1*35+2+1*2+4+1*91
        columnNumbers: A=9*149
     -
      pack: codeql/java-all#1
      relativePath: ext/javax.xml.bind.attachment.model.yml
      index: 0
      firstRowId: 46371
      rowCount: 2
      locations:
        lineNumbers: A=6+1
        columnNumbers: A=9*2
     -
      pack: codeql/java-all#1
      relativePath: ext/javax.xml.transform.model.yml
      index: 0
      firstRowId: 46373
      rowCount: 1
      locations:
        lineNumbers: A=6
        columnNumbers: A=9
     -
      pack: codeql/java-all#1
      relativePath: ext/javax.xml.transform.sax.model.yml
      index: 0
      firstRowId: 46374
      rowCount: 4
      locations:
        lineNumbers: A=6+1*3
        columnNumbers: A=9*4
     -
      pack: codeql/java-all#1
      relativePath: ext/javax.xml.transform.stream.model.yml
      index: 0
      firstRowId: 46378
      rowCount: 2
      locations:
        lineNumbers: A=6+1
        columnNumbers: A=9*2
     -
      pack: codeql/java-all#1
      relativePath: ext/javax.xml.transform.stream.model.yml
      index: 1
      firstRowId: 46380
      rowCount: 1
      locations:
        lineNumbers: A=12
        columnNumbers: A=9
     -
      pack: codeql/java-all#1
      relativePath: ext/javax.xml.xpath.model.yml
      index: 0
      firstRowId: 46381
      rowCount: 3
      locations:
        lineNumbers: A=6+1*2
        columnNumbers: A=9*3
     -
      pack: codeql/java-all#1
      relativePath: ext/jodd.json.model.yml
      index: 0
      firstRowId: 46384
      rowCount: 10
      locations:
        lineNumbers: A=12+1*9
        columnNumbers: A=9*10
     -
      pack: codeql/java-all#1
      relativePath: ext/kotlin.collections.model.yml
      index: 0
      firstRowId: 46394
      rowCount: 1
      locations:
        lineNumbers: A=6
        columnNumbers: A=9
     -
      pack: codeql/java-all#1
      relativePath: ext/kotlin.io.model.yml
      index: 0
      firstRowId: 46395
      rowCount: 4
      locations:
        lineNumbers: A=6+1*3
        columnNumbers: A=9*4
     -
      pack: codeql/java-all#1
      relativePath: ext/kotlin.io.model.yml
      index: 1
      firstRowId: 46399
      rowCount: 10
      locations:
        lineNumbers: A=14+1*9
        columnNumbers: A=9*10
     -
      pack: codeql/java-all#1
      relativePath: ext/kotlin.jvm.internal.model.yml
      index: 0
      firstRowId: 46409
      rowCount: 1
      locations:
        lineNumbers: A=6
        columnNumbers: A=9
     -
      pack: codeql/java-all#1
      relativePath: ext/kotlin.model.yml
      index: 0
      firstRowId: 46410
      rowCount: 4
      locations:
        lineNumbers: A=6+1*3
        columnNumbers: A=9*4
     -
      pack: codeql/java-all#1
      relativePath: ext/liquibase.database.jvm.model.yml
      index: 0
      firstRowId: 46414
      rowCount: 1
      locations:
        lineNumbers: A=6
        columnNumbers: A=9
     -
      pack: codeql/java-all#1
      relativePath: ext/liquibase.statement.core.model.yml
      index: 0
      firstRowId: 46415
      rowCount: 1
      locations:
        lineNumbers: A=6
        columnNumbers: A=9
     -
      pack: codeql/java-all#1
      relativePath: ext/net.schmizz.sshj.model.yml
      index: 0
      firstRowId: 46416
      rowCount: 4
      locations:
        lineNumbers: A=6+1*3
        columnNumbers: A=9*4
     -
      pack: codeql/java-all#1
      relativePath: ext/net.sf.saxon.s9api.model.yml
      index: 0
      firstRowId: 46420
      rowCount: 5
      locations:
        lineNumbers: A=6+1*4
        columnNumbers: A=9*5
     -
      pack: codeql/java-all#1
      relativePath: ext/ognl.enhance.model.yml
      index: 0
      firstRowId: 46425
      rowCount: 2
      locations:
        lineNumbers: A=6+1
        columnNumbers: A=9*2
     -
      pack: codeql/java-all#1
      relativePath: ext/ognl.model.yml
      index: 0
      firstRowId: 46427
      rowCount: 4
      locations:
        lineNumbers: A=6+1*3
        columnNumbers: A=9*4
     -
      pack: codeql/java-all#1
      relativePath: ext/okhttp3.model.yml
      index: 0
      firstRowId: 46431
      rowCount: 4
      locations:
        lineNumbers: A=6+1*3
        columnNumbers: A=9*4
     -
      pack: codeql/java-all#1
      relativePath: ext/okhttp3.model.yml
      index: 1
      firstRowId: 46435
      rowCount: 50
      locations:
        lineNumbers: A=14+1*49
        columnNumbers: A=9*50
     -
      pack: codeql/java-all#1
      relativePath: ext/org.antlr.runtime.model.yml
      index: 0
      firstRowId: 46485
      rowCount: 1
      locations:
        lineNumbers: A=6
        columnNumbers: A=9
     -
      pack: codeql/java-all#1
      relativePath: ext/org.apache.commons.codec.model.yml
      index: 0
      firstRowId: 46486
      rowCount: 6
      locations:
        lineNumbers: A=6+1*5
        columnNumbers: A=9*6
     -
      pack: codeql/java-all#1
      relativePath: ext/org.apache.commons.collections.bag.model.yml
      index: 0
      firstRowId: 46492
      rowCount: 18
      locations:
        lineNumbers: A=7+1*17
        columnNumbers: A=9*18
     -
      pack: codeql/java-all#1
      relativePath: ext/org.apache.commons.collections.bidimap.model.yml
      index: 0
      firstRowId: 46510
      rowCount: 32
      locations:
        lineNumbers: A=6+1*31
        columnNumbers: A=9*32
     -
      pack: codeql/java-all#1
      relativePath: ext/org.apache.commons.collections.collection.model.yml
      index: 0
      firstRowId: 46542
      rowCount: 40
      locations:
        lineNumbers: A=7+1*39
        columnNumbers: A=9*40
     -
      pack: codeql/java-all#1
      relativePath: ext/org.apache.commons.collections.iterators.model.yml
      index: 0
      firstRowId: 46582
      rowCount: 75
      locations:
        lineNumbers: A=7+1*74
        columnNumbers: A=9*75
     -
      pack: codeql/java-all#1
      relativePath: ext/org.apache.commons.collections.keyvalue.model.yml
      index: 0
      firstRowId: 46657
      rowCount: 52
      locations:
        lineNumbers: A=9+1*51
        columnNumbers: A=9*52
     -
      pack: codeql/java-all#1
      relativePath: ext/org.apache.commons.collections.list.model.yml
      index: 0
      firstRowId: 46709
      rowCount: 22
      locations:
        lineNumbers: A=7+1*21
        columnNumbers: A=9*22
     -
      pack: codeql/java-all#1
      relativePath: ext/org.apache.commons.collections.map.model.yml
      index: 0
      firstRowId: 46731
      rowCount: 128
      locations:
        lineNumbers: A=7+1*127
        columnNumbers: A=9*128
     -
      pack: codeql/java-all#1
      relativePath: ext/org.apache.commons.collections.model.yml
      index: 0
      firstRowId: 46859
      rowCount: 360
      locations:
        lineNumbers: A=13+1*56+2+1*130+2+1*16+2+1*3+3+1*150
        columnNumbers: A=9*360
     -
      pack: codeql/java-all#1
      relativePath: ext/org.apache.commons.collections.multimap.model.yml
      index: 0
      firstRowId: 47219
      rowCount: 12
      locations:
        lineNumbers: A=7+1*11
        columnNumbers: A=9*12
     -
      pack: codeql/java-all#1
      relativePath: ext/org.apache.commons.collections.multiset.model.yml
      index: 0
      firstRowId: 47231
      rowCount: 4
      locations:
        lineNumbers: A=6+1*3
        columnNumbers: A=9*4
     -
      pack: codeql/java-all#1
      relativePath: ext/org.apache.commons.collections.properties.model.yml
      index: 0
      firstRowId: 47235
      rowCount: 8
      locations:
        lineNumbers: A=6+1*7
        columnNumbers: A=9*8
     -
      pack: codeql/java-all#1
      relativePath: ext/org.apache.commons.collections.queue.model.yml
      index: 0
      firstRowId: 47243
      rowCount: 6
      locations:
        lineNumbers: A=7+1*5
        columnNumbers: A=9*6
     -
      pack: codeql/java-all#1
      relativePath: ext/org.apache.commons.collections.set.model.yml
      index: 0
      firstRowId: 47249
      rowCount: 31
      locations:
        lineNumbers: A=7+1*30
        columnNumbers: A=9*31
     -
      pack: codeql/java-all#1
      relativePath: ext/org.apache.commons.collections.splitmap.model.yml
      index: 0
      firstRowId: 47280
      rowCount: 4
      locations:
        lineNumbers: A=7+1*3
        columnNumbers: A=9*4
     -
      pack: codeql/java-all#1
      relativePath: ext/org.apache.commons.collections.trie.model.yml
      index: 0
      firstRowId: 47284
      rowCount: 8
      locations:
        lineNumbers: A=7+1*7
        columnNumbers: A=9*8
     -
      pack: codeql/java-all#1
      relativePath: ext/org.apache.commons.collections4.bag.model.yml
      index: 0
      firstRowId: 47292
      rowCount: 18
      locations:
        lineNumbers: A=7+1*17
        columnNumbers: A=9*18
     -
      pack: codeql/java-all#1
      relativePath: ext/org.apache.commons.collections4.bidimap.model.yml
      index: 0
      firstRowId: 47310
      rowCount: 32
      locations:
        lineNumbers: A=6+1*31
        columnNumbers: A=9*32
     -
      pack: codeql/java-all#1
      relativePath: ext/org.apache.commons.collections4.collection.model.yml
      index: 0
      firstRowId: 47342
      rowCount: 40
      locations:
        lineNumbers: A=7+1*39
        columnNumbers: A=9*40
     -
      pack: codeql/java-all#1
      relativePath: ext/org.apache.commons.collections4.iterators.model.yml
      index: 0
      firstRowId: 47382
      rowCount: 75
      locations:
        lineNumbers: A=7+1*74
        columnNumbers: A=9*75
     -
      pack: codeql/java-all#1
      relativePath: ext/org.apache.commons.collections4.keyvalue.model.yml
      index: 0
      firstRowId: 47457
      rowCount: 52
      locations:
        lineNumbers: A=9+1*51
        columnNumbers: A=9*52
     -
      pack: codeql/java-all#1
      relativePath: ext/org.apache.commons.collections4.list.model.yml
      index: 0
      firstRowId: 47509
      rowCount: 22
      locations:
        lineNumbers: A=7+1*21
        columnNumbers: A=9*22
     -
      pack: codeql/java-all#1
      relativePath: ext/org.apache.commons.collections4.map.model.yml
      index: 0
      firstRowId: 47531
      rowCount: 128
      locations:
        lineNumbers: A=7+1*127
        columnNumbers: A=9*128
     -
      pack: codeql/java-all#1
      relativePath: ext/org.apache.commons.collections4.model.yml
      index: 0
      firstRowId: 47659
      rowCount: 360
      locations:
        lineNumbers: A=13+1*56+2+1*130+2+1*16+2+1*3+3+1*150
        columnNumbers: A=9*360
     -
      pack: codeql/java-all#1
      relativePath: ext/org.apache.commons.collections4.multimap.model.yml
      index: 0
      firstRowId: 48019
      rowCount: 12
      locations:
        lineNumbers: A=7+1*11
        columnNumbers: A=9*12
     -
      pack: codeql/java-all#1
      relativePath: ext/org.apache.commons.collections4.multiset.model.yml
      index: 0
      firstRowId: 48031
      rowCount: 4
      locations:
        lineNumbers: A=6+1*3
        columnNumbers: A=9*4
     -
      pack: codeql/java-all#1
      relativePath: ext/org.apache.commons.collections4.properties.model.yml
      index: 0
      firstRowId: 48035
      rowCount: 8
      locations:
        lineNumbers: A=6+1*7
        columnNumbers: A=9*8
     -
      pack: codeql/java-all#1
      relativePath: ext/org.apache.commons.collections4.queue.model.yml
      index: 0
      firstRowId: 48043
      rowCount: 6
      locations:
        lineNumbers: A=7+1*5
        columnNumbers: A=9*6
     -
      pack: codeql/java-all#1
      relativePath: ext/org.apache.commons.collections4.set.model.yml
      index: 0
      firstRowId: 48049
      rowCount: 31
      locations:
        lineNumbers: A=7+1*30
        columnNumbers: A=9*31
     -
      pack: codeql/java-all#1
      relativePath: ext/org.apache.commons.collections4.splitmap.model.yml
      index: 0
      firstRowId: 48080
      rowCount: 4
      locations:
        lineNumbers: A=7+1*3
        columnNumbers: A=9*4
     -
      pack: codeql/java-all#1
      relativePath: ext/org.apache.commons.collections4.trie.model.yml
      index: 0
      firstRowId: 48084
      rowCount: 8
      locations:
        lineNumbers: A=7+1*7
        columnNumbers: A=9*8
     -
      pack: codeql/java-all#1
      relativePath: ext/org.apache.commons.compress.archivers.tar.model.yml
      index: 0
      firstRowId: 48092
      rowCount: 4
      locations:
        lineNumbers: A=6+1*3
        columnNumbers: A=9*4
     -
      pack: codeql/java-all#1
      relativePath: ext/org.apache.commons.exec.environment.model.yml
      index: 0
      firstRowId: 48096
      rowCount: 1
      locations:
        lineNumbers: A=6
        columnNumbers: A=9
     -
      pack: codeql/java-all#1
      relativePath: ext/org.apache.commons.exec.launcher.model.yml
      index: 0
      firstRowId: 48097
      rowCount: 1
      locations:
        lineNumbers: A=6
        columnNumbers: A=9
     -
      pack: codeql/java-all#1
      relativePath: ext/org.apache.commons.exec.model.yml
      index: 0
      firstRowId: 48098
      rowCount: 8
      locations:
        lineNumbers: A=6+1*7
        columnNumbers: A=9*8
     -
      pack: codeql/java-all#1
      relativePath: ext/org.apache.commons.httpclient.util.model.yml
      index: 0
      firstRowId: 48106
      rowCount: 1
      locations:
        lineNumbers: A=6
        columnNumbers: A=9
     -
      pack: codeql/java-all#1
      relativePath: ext/org.apache.commons.io.model.yml
      index: 0
      firstRowId: 48107
      rowCount: 15
      locations:
        lineNumbers: A=6+1+5+1*12
        columnNumbers: A=9*15
     -
      pack: codeql/java-all#1
      relativePath: ext/org.apache.commons.io.model.yml
      index: 1
      firstRowId: 48122
      rowCount: 18
      locations:
        lineNumbers: A=29+1*17
        columnNumbers: A=9*18
     -
      pack: codeql/java-all#1
      relativePath: ext/org.apache.commons.jelly.model.yml
      index: 0
      firstRowId: 48140
      rowCount: 6
      locations:
        lineNumbers: A=6+1*5
        columnNumbers: A=9*6
     -
      pack: codeql/java-all#1
      relativePath: ext/org.apache.commons.jexl2.model.yml
      index: 0
      firstRowId: 48146
      rowCount: 15
      locations:
        lineNumbers: A=6+1*14
        columnNumbers: A=9*15
     -
      pack: codeql/java-all#1
      relativePath: ext/org.apache.commons.jexl3.model.yml
      index: 0
      firstRowId: 48161
      rowCount: 15
      locations:
        lineNumbers: A=6+1*14
        columnNumbers: A=9*15
     -
      pack: codeql/java-all#1
      relativePath: ext/org.apache.commons.lang.model.yml
      index: 0
      firstRowId: 48176
      rowCount: 2
      locations:
        lineNumbers: A=6+1
        columnNumbers: A=9*2
     -
      pack: codeql/java-all#1
      relativePath: ext/org.apache.commons.lang3.builder.model.yml
      index: 0
      firstRowId: 48178
      rowCount: 18
      locations:
        lineNumbers: A=6+1*17
        columnNumbers: A=9*18
     -
      pack: codeql/java-all#1
      relativePath: ext/org.apache.commons.lang3.model.yml
      index: 0
      firstRowId: 48196
      rowCount: 6
      locations:
        lineNumbers: A=9+1*5
        columnNumbers: A=9*6
     -
      pack: codeql/java-all#1
      relativePath: ext/org.apache.commons.lang3.model.yml
      index: 1
      firstRowId: 48202
      rowCount: 202
      locations:
        lineNumbers: A=19+1*201
        columnNumbers: A=9*202
     -
      pack: codeql/java-all#1
      relativePath: ext/org.apache.commons.lang3.mutable.model.yml
      index: 0
      firstRowId: 48404
      rowCount: 3
      locations:
        lineNumbers: A=6+1*2
        columnNumbers: A=9*3
     -
      pack: codeql/java-all#1
      relativePath: ext/org.apache.commons.lang3.text.model.yml
      index: 0
      firstRowId: 48407
      rowCount: 155
      locations:
        lineNumbers: A=6+1*154
        columnNumbers: A=9*155
     -
      pack: codeql/java-all#1
      relativePath: ext/org.apache.commons.lang3.tuple.model.yml
      index: 0
      firstRowId: 48562
      rowCount: 47
      locations:
        lineNumbers: A=6+1*46
        columnNumbers: A=9*47
     -
      pack: codeql/java-all#1
      relativePath: ext/org.apache.commons.logging.model.yml
      index: 0
      firstRowId: 48609
      rowCount: 6
      locations:
        lineNumbers: A=6+1*5
        columnNumbers: A=9*6
     -
      pack: codeql/java-all#1
      relativePath: ext/org.apache.commons.net.ftp.model.yml
      index: 0
      firstRowId: 48615
      rowCount: 4
      locations:
        lineNumbers: A=6+1*3
        columnNumbers: A=9*4
     -
      pack: codeql/java-all#1
      relativePath: ext/org.apache.commons.net.model.yml
      index: 0
      firstRowId: 48619
      rowCount: 9
      locations:
        lineNumbers: A=6+1*8
        columnNumbers: A=9*9
     -
      pack: codeql/java-all#1
      relativePath: ext/org.apache.commons.net.model.yml
      index: 1
      firstRowId: 48628
      rowCount: 12
      locations:
        lineNumbers: A=19+1*11
        columnNumbers: A=9*12
     -
      pack: codeql/java-all#1
      relativePath: ext/org.apache.commons.ognl.enhance.model.yml
      index: 0
      firstRowId: 48640
      rowCount: 2
      locations:
        lineNumbers: A=6+1
        columnNumbers: A=9*2
     -
      pack: codeql/java-all#1
      relativePath: ext/org.apache.commons.ognl.model.yml
      index: 0
      firstRowId: 48642
      rowCount: 4
      locations:
        lineNumbers: A=6+1*3
        columnNumbers: A=9*4
     -
      pack: codeql/java-all#1
      relativePath: ext/org.apache.commons.text.lookup.model.yml
      index: 0
      firstRowId: 48646
      rowCount: 2
      locations:
        lineNumbers: A=6+1
        columnNumbers: A=9*2
     -
      pack: codeql/java-all#1
      relativePath: ext/org.apache.commons.text.model.yml
      index: 0
      firstRowId: 48648
      rowCount: 270
      locations:
        lineNumbers: A=6+1*269
        columnNumbers: A=9*270
     -
      pack: codeql/java-all#1
      relativePath: ext/org.apache.cxf.catalog.model.yml
      index: 0
      firstRowId: 48918
      rowCount: 1
      locations:
        lineNumbers: A=6
        columnNumbers: A=9
     -
      pack: codeql/java-all#1
      relativePath: ext/org.apache.cxf.common.classloader.model.yml
      index: 0
      firstRowId: 48919
      rowCount: 3
      locations:
        lineNumbers: A=6+1*2
        columnNumbers: A=9*3
     -
      pack: codeql/java-all#1
      relativePath: ext/org.apache.cxf.common.jaxb.model.yml
      index: 0
      firstRowId: 48922
      rowCount: 1
      locations:
        lineNumbers: A=6
        columnNumbers: A=9
     -
      pack: codeql/java-all#1
      relativePath: ext/org.apache.cxf.common.logging.model.yml
      index: 0
      firstRowId: 48923
      rowCount: 6
      locations:
        lineNumbers: A=6+1*5
        columnNumbers: A=9*6
     -
      pack: codeql/java-all#1
      relativePath: ext/org.apache.cxf.configuration.jsse.model.yml
      index: 0
      firstRowId: 48929
      rowCount: 2
      locations:
        lineNumbers: A=6+1
        columnNumbers: A=9*2
     -
      pack: codeql/java-all#1
      relativePath: ext/org.apache.cxf.feature.transform.model.yml
      index: 0
      firstRowId: 48931
      rowCount: 3
      locations:
        lineNumbers: A=6+1*2
        columnNumbers: A=9*3
     -
      pack: codeql/java-all#1
      relativePath: ext/org.apache.cxf.helpers.model.yml
      index: 0
      firstRowId: 48934
      rowCount: 10
      locations:
        lineNumbers: A=6+1*9
        columnNumbers: A=9*10
     -
      pack: codeql/java-all#1
      relativePath: ext/org.apache.cxf.resource.model.yml
      index: 0
      firstRowId: 48944
      rowCount: 9
      locations:
        lineNumbers: A=6+1*8
        columnNumbers: A=9*9
     -
      pack: codeql/java-all#1
      relativePath: ext/org.apache.cxf.staxutils.model.yml
      index: 0
      firstRowId: 48953
      rowCount: 1
      locations:
        lineNumbers: A=6
        columnNumbers: A=9
     -
      pack: codeql/java-all#1
      relativePath: ext/org.apache.cxf.tools.corba.utils.model.yml
      index: 0
      firstRowId: 48954
      rowCount: 4
      locations:
        lineNumbers: A=6+1*3
        columnNumbers: A=9*4
     -
      pack: codeql/java-all#1
      relativePath: ext/org.apache.cxf.tools.util.model.yml
      index: 0
      firstRowId: 48958
      rowCount: 10
      locations:
        lineNumbers: A=6+1*9
        columnNumbers: A=9*10
     -
      pack: codeql/java-all#1
      relativePath: ext/org.apache.directory.ldap.client.api.model.yml
      index: 0
      firstRowId: 48968
      rowCount: 1
      locations:
        lineNumbers: A=6
        columnNumbers: A=9
     -
      pack: codeql/java-all#1
      relativePath: ext/org.apache.hadoop.fs.model.yml
      index: 0
      firstRowId: 48969
      rowCount: 11
      locations:
        lineNumbers: A=6+1*10
        columnNumbers: A=9*11
     -
      pack: codeql/java-all#1
      relativePath: ext/org.apache.hadoop.fs.model.yml
      index: 1
      firstRowId: 48980
      rowCount: 2
      locations:
        lineNumbers: A=21+1
        columnNumbers: A=9*2
     -
      pack: codeql/java-all#1
      relativePath: ext/org.apache.hadoop.fs.s3a.model.yml
      index: 0
      firstRowId: 48982
      rowCount: 1
      locations:
        lineNumbers: A=6
        columnNumbers: A=9
     -
      pack: codeql/java-all#1
      relativePath: ext/org.apache.hadoop.hive.metastore.api.model.yml
      index: 0
      firstRowId: 48983
      rowCount: 1
      locations:
        lineNumbers: A=6
        columnNumbers: A=9
     -
      pack: codeql/java-all#1
      relativePath: ext/org.apache.hadoop.hive.metastore.model.yml
      index: 0
      firstRowId: 48984
      rowCount: 2
      locations:
        lineNumbers: A=6+1
        columnNumbers: A=9*2
     -
      pack: codeql/java-all#1
      relativePath: ext/org.apache.hadoop.hive.ql.exec.model.yml
      index: 0
      firstRowId: 48986
      rowCount: 1
      locations:
        lineNumbers: A=6
        columnNumbers: A=9
     -
      pack: codeql/java-all#1
      relativePath: ext/org.apache.hadoop.hive.ql.exec.model.yml
      index: 1
      firstRowId: 48987
      rowCount: 1
      locations:
        lineNumbers: A=11
        columnNumbers: A=9
     -
      pack: codeql/java-all#1
      relativePath: ext/org.apache.hadoop.hive.ql.metadata.model.yml
      index: 0
      firstRowId: 48988
      rowCount: 1
      locations:
        lineNumbers: A=6
        columnNumbers: A=9
     -
      pack: codeql/java-all#1
      relativePath: ext/org.apache.hc.client5.http.async.methods.model.yml
      index: 0
      firstRowId: 48989
      rowCount: 84
      locations:
        lineNumbers: A=6+1*83
        columnNumbers: A=9*84
     -
      pack: codeql/java-all#1
      relativePath: ext/org.apache.hc.client5.http.classic.methods.model.yml
      index: 0
      firstRowId: 49073
      rowCount: 37
      locations:
        lineNumbers: A=6+1*36
        columnNumbers: A=9*37
     -
      pack: codeql/java-all#1
      relativePath: ext/org.apache.hc.client5.http.fluent.model.yml
      index: 0
      firstRowId: 49110
      rowCount: 19
      locations:
        lineNumbers: A=6+1*18
        columnNumbers: A=9*19
     -
      pack: codeql/java-all#1
      relativePath: ext/org.apache.hc.client5.http.protocol.model.yml
      index: 0
      firstRowId: 49129
      rowCount: 1
      locations:
        lineNumbers: A=7
        columnNumbers: A=9
     -
      pack: codeql/java-all#1
      relativePath: ext/org.apache.hc.core5.benchmark.model.yml
      index: 0
      firstRowId: 49130
      rowCount: 1
      locations:
        lineNumbers: A=6
        columnNumbers: A=9
     -
      pack: codeql/java-all#1
      relativePath: ext/org.apache.hc.core5.function.model.yml
      index: 0
      firstRowId: 49131
      rowCount: 1
      locations:
        lineNumbers: A=6
        columnNumbers: A=9
     -
      pack: codeql/java-all#1
      relativePath: ext/org.apache.hc.core5.http.impl.bootstrap.model.yml
      index: 0
      firstRowId: 49132
      rowCount: 2
      locations:
        lineNumbers: A=6+1
        columnNumbers: A=9*2
     -
      pack: codeql/java-all#1
      relativePath: ext/org.apache.hc.core5.http.io.entity.model.yml
      index: 0
      firstRowId: 49134
      rowCount: 14
      locations:
        lineNumbers: A=6+1*13
        columnNumbers: A=9*14
     -
      pack: codeql/java-all#1
      relativePath: ext/org.apache.hc.core5.http.io.model.yml
      index: 0
      firstRowId: 49148
      rowCount: 2
      locations:
        lineNumbers: A=6+1
        columnNumbers: A=9*2
     -
      pack: codeql/java-all#1
      relativePath: ext/org.apache.hc.core5.http.io.support.model.yml
      index: 0
      firstRowId: 49150
      rowCount: 16
      locations:
        lineNumbers: A=6+1*15
        columnNumbers: A=9*16
     -
      pack: codeql/java-all#1
      relativePath: ext/org.apache.hc.core5.http.message.model.yml
      index: 0
      firstRowId: 49166
      rowCount: 8
      locations:
        lineNumbers: A=6+1*7
        columnNumbers: A=9*8
     -
      pack: codeql/java-all#1
      relativePath: ext/org.apache.hc.core5.http.message.model.yml
      index: 1
      firstRowId: 49174
      rowCount: 5
      locations:
        lineNumbers: A=19+1*4
        columnNumbers: A=9*5
     -
      pack: codeql/java-all#1
      relativePath: ext/org.apache.hc.core5.http.model.yml
      index: 0
      firstRowId: 49179
      rowCount: 4
      locations:
        lineNumbers: A=6+1*3
        columnNumbers: A=9*4
     -
      pack: codeql/java-all#1
      relativePath: ext/org.apache.hc.core5.http.model.yml
      index: 1
      firstRowId: 49183
      rowCount: 26
      locations:
        lineNumbers: A=14+1*25
        columnNumbers: A=9*26
     -
      pack: codeql/java-all#1
      relativePath: ext/org.apache.hc.core5.http.nio.support.model.yml
      index: 0
      firstRowId: 49209
      rowCount: 24
      locations:
        lineNumbers: A=6+1*23
        columnNumbers: A=9*24
     -
      pack: codeql/java-all#1
      relativePath: ext/org.apache.hc.core5.http.support.model.yml
      index: 0
      firstRowId: 49233
      rowCount: 19
      locations:
        lineNumbers: A=6+1*18
        columnNumbers: A=9*19
     -
      pack: codeql/java-all#1
      relativePath: ext/org.apache.hc.core5.net.model.yml
      index: 0
      firstRowId: 49252
      rowCount: 18
      locations:
        lineNumbers: A=6+1*17
        columnNumbers: A=9*18
     -
      pack: codeql/java-all#1
      relativePath: ext/org.apache.hc.core5.util.model.yml
      index: 0
      firstRowId: 49270
      rowCount: 24
      locations:
        lineNumbers: A=6+1*23
        columnNumbers: A=9*24
     -
      pack: codeql/java-all#1
      relativePath: ext/org.apache.hive.hcatalog.templeton.model.yml
      index: 0
      firstRowId: 49294
      rowCount: 1
      locations:
        lineNumbers: A=6
        columnNumbers: A=9
     -
      pack: codeql/java-all#1
      relativePath: ext/org.apache.http.client.fluent.model.yml
      index: 0
      firstRowId: 49295
      rowCount: 16
      locations:
        lineNumbers: A=6+1*15
        columnNumbers: A=9*16
     -
      pack: codeql/java-all#1
      relativePath: ext/org.apache.http.client.methods.model.yml
      index: 0
      firstRowId: 49311
      rowCount: 19
      locations:
        lineNumbers: A=6+1*18
        columnNumbers: A=9*19
     -
      pack: codeql/java-all#1
      relativePath: ext/org.apache.http.client.model.yml
      index: 0
      firstRowId: 49330
      rowCount: 3
      locations:
        lineNumbers: A=6+1*2
        columnNumbers: A=9*3
     -
      pack: codeql/java-all#1
      relativePath: ext/org.apache.http.client.utils.model.yml
      index: 0
      firstRowId: 49333
      rowCount: 20
      locations:
        lineNumbers: A=6+1*19
        columnNumbers: A=9*20
     -
      pack: codeql/java-all#1
      relativePath: ext/org.apache.http.entity.model.yml
      index: 0
      firstRowId: 49353
      rowCount: 6
      locations:
        lineNumbers: A=6+1*5
        columnNumbers: A=9*6
     -
      pack: codeql/java-all#1
      relativePath: ext/org.apache.http.impl.client.model.yml
      index: 0
      firstRowId: 49359
      rowCount: 1
      locations:
        lineNumbers: A=6
        columnNumbers: A=9
     -
      pack: codeql/java-all#1
      relativePath: ext/org.apache.http.message.model.yml
      index: 0
      firstRowId: 49360
      rowCount: 6
      locations:
        lineNumbers: A=6+1*5
        columnNumbers: A=9*6
     -
      pack: codeql/java-all#1
      relativePath: ext/org.apache.http.message.model.yml
      index: 1
      firstRowId: 49366
      rowCount: 1
      locations:
        lineNumbers: A=16
        columnNumbers: A=9
     -
      pack: codeql/java-all#1
      relativePath: ext/org.apache.http.model.yml
      index: 0
      firstRowId: 49367
      rowCount: 2
      locations:
        lineNumbers: A=6+1
        columnNumbers: A=9*2
     -
      pack: codeql/java-all#1
      relativePath: ext/org.apache.http.model.yml
      index: 1
      firstRowId: 49369
      rowCount: 2
      locations:
        lineNumbers: A=12+1
        columnNumbers: A=9*2
     -
      pack: codeql/java-all#1
      relativePath: ext/org.apache.http.model.yml
      index: 2
      firstRowId: 49371
      rowCount: 30
      locations:
        lineNumbers: A=18+1*29
        columnNumbers: A=9*30
     -
      pack: codeql/java-all#1
      relativePath: ext/org.apache.http.params.model.yml
      index: 0
      firstRowId: 49401
      rowCount: 7
      locations:
        lineNumbers: A=6+1*6
        columnNumbers: A=9*7
     -
      pack: codeql/java-all#1
      relativePath: ext/org.apache.http.protocol.model.yml
      index: 0
      firstRowId: 49408
      rowCount: 1
      locations:
        lineNumbers: A=6
        columnNumbers: A=9
     -
      pack: codeql/java-all#1
      relativePath: ext/org.apache.http.util.model.yml
      index: 0
      firstRowId: 49409
      rowCount: 1
      locations:
        lineNumbers: A=6
        columnNumbers: A=9
     -
      pack: codeql/java-all#1
      relativePath: ext/org.apache.http.util.model.yml
      index: 1
      firstRowId: 49410
      rowCount: 31
      locations:
        lineNumbers: A=11+1*30
        columnNumbers: A=9*31
     -
      pack: codeql/java-all#1
      relativePath: ext/org.apache.ibatis.jdbc.model.yml
      index: 0
      firstRowId: 49441
      rowCount: 6
      locations:
        lineNumbers: A=6+1*5
        columnNumbers: A=9*6
     -
      pack: codeql/java-all#1
      relativePath: ext/org.apache.ibatis.jdbc.model.yml
      index: 1
      firstRowId: 49447
      rowCount: 57
      locations:
        lineNumbers: A=16+1*56
        columnNumbers: A=9*57
     -
      pack: codeql/java-all#1
      relativePath: ext/org.apache.ibatis.mapping.model.yml
      index: 0
      firstRowId: 49504
      rowCount: 1
      locations:
        lineNumbers: A=6
        columnNumbers: A=9
     -
      pack: codeql/java-all#1
      relativePath: ext/org.apache.log4j.model.yml
      index: 0
      firstRowId: 49505
      rowCount: 11
      locations:
        lineNumbers: A=6+1*10
        columnNumbers: A=9*11
     -
      pack: codeql/java-all#1
      relativePath: ext/org.apache.logging.log4j.model.yml
      index: 0
      firstRowId: 49516
      rowCount: 359
      locations:
        lineNumbers: A=6+1*358
        columnNumbers: A=9*359
     -
      pack: codeql/java-all#1
      relativePath: ext/org.apache.logging.log4j.model.yml
      index: 1
      firstRowId: 49875
      rowCount: 8
      locations:
        lineNumbers: A=369+1*7
        columnNumbers: A=9*8
     -
      pack: codeql/java-all#1
      relativePath: ext/org.apache.shiro.codec.model.yml
      index: 0
      firstRowId: 49883
      rowCount: 1
      locations:
        lineNumbers: A=6
        columnNumbers: A=9
     -
      pack: codeql/java-all#1
      relativePath: ext/org.apache.shiro.jndi.model.yml
      index: 0
      firstRowId: 49884
      rowCount: 1
      locations:
        lineNumbers: A=6
        columnNumbers: A=9
     -
      pack: codeql/java-all#1
      relativePath: ext/org.apache.shiro.mgt.model.yml
      index: 0
      firstRowId: 49885
      rowCount: 1
      locations:
        lineNumbers: A=6
        columnNumbers: A=9
     -
      pack: codeql/java-all#1
      relativePath: ext/org.apache.sshd.client.session.model.yml
      index: 0
      firstRowId: 49886
      rowCount: 3
      locations:
        lineNumbers: A=6+1*2
        columnNumbers: A=9*3
     -
      pack: codeql/java-all#1
      relativePath: ext/org.apache.struts2.dispatcher.model.yml
      index: 0
      firstRowId: 49889
      rowCount: 1
      locations:
        lineNumbers: A=6
        columnNumbers: A=7
     -
      pack: codeql/java-all#1
      relativePath: ext/org.apache.struts2.interceptor.model.yml
      index: 0
      firstRowId: 49890
      rowCount: 2
      locations:
        lineNumbers: A=6+1
        columnNumbers: A=7*2
     -
      pack: codeql/java-all#1
      relativePath: ext/org.apache.tools.ant.model.yml
      index: 0
      firstRowId: 49892
      rowCount: 5
      locations:
        lineNumbers: A=6+1*4
        columnNumbers: A=9*5
     -
      pack: codeql/java-all#1
      relativePath: ext/org.apache.tools.ant.taskdefs.model.yml
      index: 0
      firstRowId: 49897
      rowCount: 9
      locations:
        lineNumbers: A=6+1*8
        columnNumbers: A=9*9
     -
      pack: codeql/java-all#1
      relativePath: ext/org.apache.tools.zip.model.yml
      index: 0
      firstRowId: 49906
      rowCount: 1
      locations:
        lineNumbers: A=6
        columnNumbers: A=9
     -
      pack: codeql/java-all#1
      relativePath: ext/org.apache.velocity.app.model.yml
      index: 0
      firstRowId: 49907
      rowCount: 4
      locations:
        lineNumbers: A=6+1*3
        columnNumbers: A=9*4
     -
      pack: codeql/java-all#1
      relativePath: ext/org.apache.velocity.runtime.model.yml
      index: 0
      firstRowId: 49911
      rowCount: 3
      locations:
        lineNumbers: A=6+1*2
        columnNumbers: A=9*3
     -
      pack: codeql/java-all#1
      relativePath: ext/org.apache.velocity.runtime.resource.util.model.yml
      index: 0
      firstRowId: 49914
      rowCount: 1
      locations:
        lineNumbers: A=6
        columnNumbers: A=9
     -
      pack: codeql/java-all#1
      relativePath: ext/org.codehaus.cargo.container.installer.model.yml
      index: 0
      firstRowId: 49915
      rowCount: 3
      locations:
        lineNumbers: A=6+1*2
        columnNumbers: A=9*3
     -
      pack: codeql/java-all#1
      relativePath: ext/org.codehaus.groovy.control.model.yml
      index: 0
      firstRowId: 49918
      rowCount: 1
      locations:
        lineNumbers: A=6
        columnNumbers: A=9
     -
      pack: codeql/java-all#1
      relativePath: ext/org.dom4j.model.yml
      index: 0
      firstRowId: 49919
      rowCount: 15
      locations:
        lineNumbers: A=6+1*14
        columnNumbers: A=9*15
     -
      pack: codeql/java-all#1
      relativePath: ext/org.dom4j.tree.model.yml
      index: 0
      firstRowId: 49934
      rowCount: 2
      locations:
        lineNumbers: A=6+1
        columnNumbers: A=9*2
     -
      pack: codeql/java-all#1
      relativePath: ext/org.dom4j.util.model.yml
      index: 0
      firstRowId: 49936
      rowCount: 3
      locations:
        lineNumbers: A=6+1*2
        columnNumbers: A=9*3
     -
      pack: codeql/java-all#1
      relativePath: ext/org.eclipse.jetty.client.model.yml
      index: 0
      firstRowId: 49939
      rowCount: 2
      locations:
        lineNumbers: A=6+1
        columnNumbers: A=9*2
     -
      pack: codeql/java-all#1
      relativePath: ext/org.fusesource.leveldbjni.model.yml
      index: 0
      firstRowId: 49941
      rowCount: 1
      locations:
        lineNumbers: A=6
        columnNumbers: A=9
     -
      pack: codeql/java-all#1
      relativePath: ext/org.geogebra.web.full.main.model.yml
      index: 0
      firstRowId: 49942
      rowCount: 1
      locations:
        lineNumbers: A=7
        columnNumbers: A=9
     -
      pack: codeql/java-all#1
      relativePath: ext/org.gradle.api.file.model.yml
      index: 0
      firstRowId: 49943
      rowCount: 3
      locations:
        lineNumbers: A=6+1*2
        columnNumbers: A=9*3
     -
      pack: codeql/java-all#1
      relativePath: ext/org.hibernate.model.yml
      index: 0
      firstRowId: 49946
      rowCount: 4
      locations:
        lineNumbers: A=6+1*3
        columnNumbers: A=9*4
     -
      pack: codeql/java-all#1
      relativePath: ext/org.hibernate.query.model.yml
      index: 0
      firstRowId: 49950
      rowCount: 3
      locations:
        lineNumbers: A=6+1*2
        columnNumbers: A=9*3
     -
      pack: codeql/java-all#1
      relativePath: ext/org.influxdb.model.yml
      index: 0
      firstRowId: 49953
      rowCount: 1
      locations:
        lineNumbers: A=6
        columnNumbers: A=9
     -
      pack: codeql/java-all#1
      relativePath: ext/org.jboss.logging.model.yml
      index: 0
      firstRowId: 49954
      rowCount: 324
      locations:
        lineNumbers: A=6+1*323
        columnNumbers: A=9*324
     -
      pack: codeql/java-all#1
      relativePath: ext/org.jboss.vfs.model.yml
      index: 0
      firstRowId: 50278
      rowCount: 1
      locations:
        lineNumbers: A=6
        columnNumbers: A=9
     -
      pack: codeql/java-all#1
      relativePath: ext/org.jdbi.v3.core.model.yml
      index: 0
      firstRowId: 50279
      rowCount: 6
      locations:
        lineNumbers: A=6+1*5
        columnNumbers: A=9*6
     -
      pack: codeql/java-all#1
      relativePath: ext/org.jooq.model.yml
      index: 0
      firstRowId: 50285
      rowCount: 1
      locations:
        lineNumbers: A=6
        columnNumbers: A=9
     -
      pack: codeql/java-all#1
      relativePath: ext/org.json.model.yml
      index: 0
      firstRowId: 50286
      rowCount: 236
      locations:
        lineNumbers: A=6+1*235
        columnNumbers: A=9*236
     -
      pack: codeql/java-all#1
      relativePath: ext/org.keycloak.models.map.storage.model.yml
      index: 0
      firstRowId: 50522
      rowCount: 1
      locations:
        lineNumbers: A=6
        columnNumbers: A=9
     -
      pack: codeql/java-all#1
      relativePath: ext/org.kohsuke.stapler.bind.model.yml
      index: 0
      firstRowId: 50523
      rowCount: 1
      locations:
        lineNumbers: A=6
        columnNumbers: A=9
     -
      pack: codeql/java-all#1
      relativePath: ext/org.kohsuke.stapler.framework.adjunct.model.yml
      index: 0
      firstRowId: 50524
      rowCount: 1
      locations:
        lineNumbers: A=6
        columnNumbers: A=9
     -
      pack: codeql/java-all#1
      relativePath: ext/org.kohsuke.stapler.framework.io.model.yml
      index: 0
      firstRowId: 50525
      rowCount: 1
      locations:
        lineNumbers: A=6
        columnNumbers: A=9
     -
      pack: codeql/java-all#1
      relativePath: ext/org.kohsuke.stapler.json.model.yml
      index: 0
      firstRowId: 50526
      rowCount: 2
      locations:
        lineNumbers: A=6+1
        columnNumbers: A=9*2
     -
      pack: codeql/java-all#1
      relativePath: ext/org.kohsuke.stapler.model.yml
      index: 0
      firstRowId: 50528
      rowCount: 19
      locations:
        lineNumbers: A=6+1*18
        columnNumbers: A=9*19
     -
      pack: codeql/java-all#1
      relativePath: ext/org.kohsuke.stapler.model.yml
      index: 1
      firstRowId: 50547
      rowCount: 21
      locations:
        lineNumbers: A=29+1*20
        columnNumbers: A=9*21
     -
      pack: codeql/java-all#1
      relativePath: ext/org.lastaflute.web.model.yml
      index: 0
      firstRowId: 50568
      rowCount: 1
      locations:
        lineNumbers: A=6
        columnNumbers: A=9
     -
      pack: codeql/java-all#1
      relativePath: ext/org.lastaflute.web.ruts.multipart.model.yml
      index: 0
      firstRowId: 50569
      rowCount: 4
      locations:
        lineNumbers: A=6+1*3
        columnNumbers: A=9*4
     -
      pack: codeql/java-all#1
      relativePath: ext/org.mvel2.compiler.model.yml
      index: 0
      firstRowId: 50573
      rowCount: 4
      locations:
        lineNumbers: A=6+1*3
        columnNumbers: A=9*4
     -
      pack: codeql/java-all#1
      relativePath: ext/org.mvel2.jsr223.model.yml
      index: 0
      firstRowId: 50577
      rowCount: 3
      locations:
        lineNumbers: A=6+1*2
        columnNumbers: A=9*3
     -
      pack: codeql/java-all#1
      relativePath: ext/org.mvel2.model.yml
      index: 0
      firstRowId: 50580
      rowCount: 7
      locations:
        lineNumbers: A=6+1*6
        columnNumbers: A=9*7
     -
      pack: codeql/java-all#1
      relativePath: ext/org.mvel2.templates.model.yml
      index: 0
      firstRowId: 50587
      rowCount: 2
      locations:
        lineNumbers: A=6+1
        columnNumbers: A=9*2
     -
      pack: codeql/java-all#1
      relativePath: ext/org.openjdk.jmh.runner.options.model.yml
      index: 0
      firstRowId: 50589
      rowCount: 1
      locations:
        lineNumbers: A=6
        columnNumbers: A=9
     -
      pack: codeql/java-all#1
      relativePath: ext/org.owasp.esapi.model.yml
      index: 0
      firstRowId: 50590
      rowCount: 1
      locations:
        lineNumbers: A=6
        columnNumbers: A=9
     -
      pack: codeql/java-all#1
      relativePath: ext/org.pac4j.jwt.config.encryption.model.yml
      index: 0
      firstRowId: 50591
      rowCount: 4
      locations:
        lineNumbers: A=6+1*3
        columnNumbers: A=9*4
     -
      pack: codeql/java-all#1
      relativePath: ext/org.pac4j.jwt.config.signature.model.yml
      index: 0
      firstRowId: 50595
      rowCount: 4
      locations:
        lineNumbers: A=6+1*3
        columnNumbers: A=9*4
     -
      pack: codeql/java-all#1
      relativePath: ext/org.scijava.log.model.yml
      index: 0
      firstRowId: 50599
      rowCount: 13
      locations:
        lineNumbers: A=6+1*12
        columnNumbers: A=9*13
     -
      pack: codeql/java-all#1
      relativePath: ext/org.slf4j.model.yml
      index: 0
      firstRowId: 50612
      rowCount: 50
      locations:
        lineNumbers: A=6+1*49
        columnNumbers: A=9*50
     -
      pack: codeql/java-all#1
      relativePath: ext/org.slf4j.spi.model.yml
      index: 0
      firstRowId: 50662
      rowCount: 5
      locations:
        lineNumbers: A=6+1*4
        columnNumbers: A=9*5
     -
      pack: codeql/java-all#1
      relativePath: ext/org.slf4j.spi.model.yml
      index: 1
      firstRowId: 50667
      rowCount: 6
      locations:
        lineNumbers: A=15+1*5
        columnNumbers: A=9*6
     -
      pack: codeql/java-all#1
      relativePath: ext/org.springframework.beans.model.yml
      index: 0
      firstRowId: 50673
      rowCount: 30
      locations:
        lineNumbers: A=6+1*29
        columnNumbers: A=9*30
     -
      pack: codeql/java-all#1
      relativePath: ext/org.springframework.boot.jdbc.model.yml
      index: 0
      firstRowId: 50703
      rowCount: 1
      locations:
        lineNumbers: A=6
        columnNumbers: A=9
     -
      pack: codeql/java-all#1
      relativePath: ext/org.springframework.cache.model.yml
      index: 0
      firstRowId: 50704
      rowCount: 13
      locations:
        lineNumbers: A=6+1*12
        columnNumbers: A=9*13
     -
      pack: codeql/java-all#1
      relativePath: ext/org.springframework.context.model.yml
      index: 0
      firstRowId: 50717
      rowCount: 3
      locations:
        lineNumbers: A=6+1*2
        columnNumbers: A=9*3
     -
      pack: codeql/java-all#1
      relativePath: ext/org.springframework.core.io.model.yml
      index: 0
      firstRowId: 50720
      rowCount: 3
      locations:
        lineNumbers: A=6+1*2
        columnNumbers: A=9*3
     -
      pack: codeql/java-all#1
      relativePath: ext/org.springframework.core.io.model.yml
      index: 1
      firstRowId: 50723
      rowCount: 6
      locations:
        lineNumbers: A=13+1*5
        columnNumbers: A=9*6
     -
      pack: codeql/java-all#1
      relativePath: ext/org.springframework.data.repository.model.yml
      index: 0
      firstRowId: 50729
      rowCount: 1
      locations:
        lineNumbers: A=6
        columnNumbers: A=9
     -
      pack: codeql/java-all#1
      relativePath: ext/org.springframework.http.model.yml
      index: 0
      firstRowId: 50730
      rowCount: 14
      locations:
        lineNumbers: A=6+1*13
        columnNumbers: A=9*14
     -
      pack: codeql/java-all#1
      relativePath: ext/org.springframework.http.model.yml
      index: 1
      firstRowId: 50744
      rowCount: 77
      locations:
        lineNumbers: A=24+1*76
        columnNumbers: A=9*77
     -
      pack: codeql/java-all#1
      relativePath: ext/org.springframework.jdbc.core.model.yml
      index: 0
      firstRowId: 50821
      rowCount: 10
      locations:
        lineNumbers: A=6+1*9
        columnNumbers: A=9*10
     -
      pack: codeql/java-all#1
      relativePath: ext/org.springframework.jdbc.core.namedparam.model.yml
      index: 0
      firstRowId: 50831
      rowCount: 9
      locations:
        lineNumbers: A=6+1*8
        columnNumbers: A=9*9
     -
      pack: codeql/java-all#1
      relativePath: ext/org.springframework.jdbc.datasource.model.yml
      index: 0
      firstRowId: 50840
      rowCount: 4
      locations:
        lineNumbers: A=6+1*3
        columnNumbers: A=9*4
     -
      pack: codeql/java-all#1
      relativePath: ext/org.springframework.jdbc.object.model.yml
      index: 0
      firstRowId: 50844
      rowCount: 9
      locations:
        lineNumbers: A=6+1*8
        columnNumbers: A=9*9
     -
      pack: codeql/java-all#1
      relativePath: ext/org.springframework.jndi.model.yml
      index: 0
      firstRowId: 50853
      rowCount: 1
      locations:
        lineNumbers: A=6
        columnNumbers: A=9
     -
      pack: codeql/java-all#1
      relativePath: ext/org.springframework.ldap.core.model.yml
      index: 0
      firstRowId: 50854
      rowCount: 33
      locations:
        lineNumbers: A=6+1*32
        columnNumbers: A=9*33
     -
      pack: codeql/java-all#1
      relativePath: ext/org.springframework.ldap.model.yml
      index: 0
      firstRowId: 50887
      rowCount: 14
      locations:
        lineNumbers: A=6+1*13
        columnNumbers: A=9*14
     -
      pack: codeql/java-all#1
      relativePath: ext/org.springframework.security.core.userdetails.model.yml
      index: 0
      firstRowId: 50901
      rowCount: 2
      locations:
        lineNumbers: A=6+1
        columnNumbers: A=9*2
     -
      pack: codeql/java-all#1
      relativePath: ext/org.springframework.security.web.savedrequest.model.yml
      index: 0
      firstRowId: 50903
      rowCount: 6
      locations:
        lineNumbers: A=6+1*5
        columnNumbers: A=9*6
     -
      pack: codeql/java-all#1
      relativePath: ext/org.springframework.ui.model.yml
      index: 0
      firstRowId: 50909
      rowCount: 32
      locations:
        lineNumbers: A=6+1*31
        columnNumbers: A=9*32
     -
      pack: codeql/java-all#1
      relativePath: ext/org.springframework.util.model.yml
      index: 0
      firstRowId: 50941
      rowCount: 3
      locations:
        lineNumbers: A=6+1*2
        columnNumbers: A=7*3
     -
      pack: codeql/java-all#1
      relativePath: ext/org.springframework.util.model.yml
      index: 1
      firstRowId: 50944
      rowCount: 142
      locations:
        lineNumbers: A=14+1*141
        columnNumbers: A=9*142
     -
      pack: codeql/java-all#1
      relativePath: ext/org.springframework.validation.model.yml
      index: 0
      firstRowId: 51086
      rowCount: 13
      locations:
        lineNumbers: A=6+1*12
        columnNumbers: A=9*13
     -
      pack: codeql/java-all#1
      relativePath: ext/org.springframework.web.client.model.yml
      index: 0
      firstRowId: 51099
      rowCount: 3
      locations:
        lineNumbers: A=6+1*2
        columnNumbers: A=9*3
     -
      pack: codeql/java-all#1
      relativePath: ext/org.springframework.web.client.model.yml
      index: 1
      firstRowId: 51102
      rowCount: 13
      locations:
        lineNumbers: A=13+1*12
        columnNumbers: A=9*13
     -
      pack: codeql/java-all#1
      relativePath: ext/org.springframework.web.context.request.model.yml
      index: 0
      firstRowId: 51115
      rowCount: 8
      locations:
        lineNumbers: A=6+1*7
        columnNumbers: A=9*8
     -
      pack: codeql/java-all#1
      relativePath: ext/org.springframework.web.multipart.model.yml
      index: 0
      firstRowId: 51123
      rowCount: 12
      locations:
        lineNumbers: A=6+1*11
        columnNumbers: A=9*12
     -
      pack: codeql/java-all#1
      relativePath: ext/org.springframework.web.multipart.model.yml
      index: 1
      firstRowId: 51135
      rowCount: 12
      locations:
        lineNumbers: A=22+1*11
        columnNumbers: A=9*12
     -
      pack: codeql/java-all#1
      relativePath: ext/org.springframework.web.portlet.model.yml
      index: 0
      firstRowId: 51147
      rowCount: 2
      locations:
        lineNumbers: A=6+1
        columnNumbers: A=9*2
     -
      pack: codeql/java-all#1
      relativePath: ext/org.springframework.web.reactive.function.client.model.yml
      index: 0
      firstRowId: 51149
      rowCount: 2
      locations:
        lineNumbers: A=6+1
        columnNumbers: A=9*2
     -
      pack: codeql/java-all#1
      relativePath: ext/org.springframework.web.servlet.model.yml
      index: 0
      firstRowId: 51151
      rowCount: 2
      locations:
        lineNumbers: A=6+1
        columnNumbers: A=9*2
     -
      pack: codeql/java-all#1
      relativePath: ext/org.springframework.web.util.model.yml
      index: 0
      firstRowId: 51153
      rowCount: 9
      locations:
        lineNumbers: A=6+1*8
        columnNumbers: A=9*9
     -
      pack: codeql/java-all#1
      relativePath: ext/org.springframework.web.util.model.yml
      index: 1
      firstRowId: 51162
      rowCount: 157
      locations:
        lineNumbers: A=20+1*2+2+1*153
        columnNumbers: A=9*157
     -
      pack: codeql/java-all#1
      relativePath: ext/org.thymeleaf.model.yml
      index: 0
      firstRowId: 51319
      rowCount: 2
      locations:
        lineNumbers: A=6+1
        columnNumbers: A=9*2
     -
      pack: codeql/java-all#1
      relativePath: ext/org.thymeleaf.model.yml
      index: 1
      firstRowId: 51321
      rowCount: 2
      locations:
        lineNumbers: A=12+1
        columnNumbers: A=9*2
     -
      pack: codeql/java-all#1
      relativePath: ext/org.xml.sax.model.yml
      index: 0
      firstRowId: 51323
      rowCount: 1
      locations:
        lineNumbers: A=6
        columnNumbers: A=9
     -
      pack: codeql/java-all#1
      relativePath: ext/org.xmlpull.v1.model.yml
      index: 0
      firstRowId: 51324
      rowCount: 3
      locations:
        lineNumbers: A=6+1*2
        columnNumbers: A=9*3
     -
      pack: codeql/java-all#1
      relativePath: ext/org.yaml.snakeyaml.model.yml
      index: 0
      firstRowId: 51327
      rowCount: 1
      locations:
        lineNumbers: A=6
        columnNumbers: A=9
     -
      pack: codeql/java-all#1
      relativePath: ext/play.libs.ws.model.yml
      index: 0
      firstRowId: 51328
      rowCount: 2
      locations:
        lineNumbers: A=6+1
        columnNumbers: A=9*2
     -
      pack: codeql/java-all#1
      relativePath: ext/play.mvc.model.yml
      index: 0
      firstRowId: 51330
      rowCount: 13
      locations:
        lineNumbers: A=6+1*12
        columnNumbers: A=9*13
     -
      pack: codeql/java-all#1
      relativePath: ext/play.mvc.model.yml
      index: 1
      firstRowId: 51343
      rowCount: 1
      locations:
        lineNumbers: A=23
        columnNumbers: A=9
     -
      pack: codeql/java-all#1
      relativePath: ext/play.mvc.model.yml
      index: 2
      firstRowId: 51344
      rowCount: 24
      locations:
        lineNumbers: A=28+1*23
        columnNumbers: A=9*24
     -
      pack: codeql/java-all#1
      relativePath: ext/ratpack.core.form.model.yml
      index: 0
      firstRowId: 51368
      rowCount: 3
      locations:
        lineNumbers: A=6+1*2
        columnNumbers: A=9*3
     -
      pack: codeql/java-all#1
      relativePath: ext/ratpack.core.handling.model.yml
      index: 0
      firstRowId: 51371
      rowCount: 6
      locations:
        lineNumbers: A=7+1*5
        columnNumbers: A=9*6
     -
      pack: codeql/java-all#1
      relativePath: ext/ratpack.core.handling.model.yml
      index: 1
      firstRowId: 51377
      rowCount: 4
      locations:
        lineNumbers: A=17+1*3
        columnNumbers: A=9*4
     -
      pack: codeql/java-all#1
      relativePath: ext/ratpack.core.http.model.yml
      index: 0
      firstRowId: 51381
      rowCount: 10
      locations:
        lineNumbers: A=6+1*9
        columnNumbers: A=9*10
     -
      pack: codeql/java-all#1
      relativePath: ext/ratpack.core.http.model.yml
      index: 1
      firstRowId: 51391
      rowCount: 10
      locations:
        lineNumbers: A=20+1*9
        columnNumbers: A=9*10
     -
      pack: codeql/java-all#1
      relativePath: ext/ratpack.exec.model.yml
      index: 0
      firstRowId: 51401
      rowCount: 48
      locations:
        lineNumbers: A=6+1*47
        columnNumbers: A=9*48
     -
      pack: codeql/java-all#1
      relativePath: ext/ratpack.form.model.yml
      index: 0
      firstRowId: 51449
      rowCount: 3
      locations:
        lineNumbers: A=6+1*2
        columnNumbers: A=9*3
     -
      pack: codeql/java-all#1
      relativePath: ext/ratpack.func.model.yml
      index: 0
      firstRowId: 51452
      rowCount: 35
      locations:
        lineNumbers: A=6+1*9+2+1+2+1*5+2+1*2+2+1*13
        columnNumbers: A=9*35
     -
      pack: codeql/java-all#1
      relativePath: ext/ratpack.handling.model.yml
      index: 0
      firstRowId: 51487
      rowCount: 6
      locations:
        lineNumbers: A=7+1*5
        columnNumbers: A=9*6
     -
      pack: codeql/java-all#1
      relativePath: ext/ratpack.handling.model.yml
      index: 1
      firstRowId: 51493
      rowCount: 4
      locations:
        lineNumbers: A=17+1*3
        columnNumbers: A=9*4
     -
      pack: codeql/java-all#1
      relativePath: ext/ratpack.http.model.yml
      index: 0
      firstRowId: 51497
      rowCount: 10
      locations:
        lineNumbers: A=6+1*9
        columnNumbers: A=9*10
     -
      pack: codeql/java-all#1
      relativePath: ext/ratpack.http.model.yml
      index: 1
      firstRowId: 51507
      rowCount: 10
      locations:
        lineNumbers: A=20+1*9
        columnNumbers: A=9*10
     -
      pack: codeql/java-all#1
      relativePath: ext/ratpack.util.model.yml
      index: 0
      firstRowId: 51517
      rowCount: 35
      locations:
        lineNumbers: A=6+1*9+2+1+2+1*5+2+1*2+2+1*13
        columnNumbers: A=9*35
     -
      pack: codeql/java-all#1
      relativePath: ext/retrofit2.model.yml
      index: 0
      firstRowId: 51552
      rowCount: 1
      locations:
        lineNumbers: A=6
        columnNumbers: A=9
     -
      pack: codeql/java-all#1
      relativePath: ext/retrofit2.model.yml
      index: 1
      firstRowId: 51553
      rowCount: 1
      locations:
        lineNumbers: A=11
        columnNumbers: A=9
     -
      pack: codeql/java-all#1
      relativePath: ext/struts2.model.yml
      index: 0
      firstRowId: 51554
      rowCount: 64
      locations:
        lineNumbers: A=6+1*63
        columnNumbers: A=9*64
     -
      pack: codeql/java-all#1
      relativePath: ext/sun.jvmstat.perfdata.monitor.protocol.local.model.yml
      index: 0
      firstRowId: 51618
      rowCount: 3
      locations:
        lineNumbers: A=6+1*2
        columnNumbers: A=9*3
     -
      pack: codeql/java-all#1
      relativePath: ext/sun.jvmstat.perfdata.monitor.protocol.rmi.model.yml
      index: 0
      firstRowId: 51621
      rowCount: 1
      locations:
        lineNumbers: A=6
        columnNumbers: A=9
     -
      pack: codeql/java-all#1
      relativePath: ext/sun.misc.model.yml
      index: 0
      firstRowId: 51622
      rowCount: 3
      locations:
        lineNumbers: A=6+1*2
        columnNumbers: A=9*3
     -
      pack: codeql/java-all#1
      relativePath: ext/sun.net.ftp.model.yml
      index: 0
      firstRowId: 51625
      rowCount: 5
      locations:
        lineNumbers: A=6+1*4
        columnNumbers: A=9*5
     -
      pack: codeql/java-all#1
      relativePath: ext/sun.net.www.protocol.http.model.yml
      index: 0
      firstRowId: 51630
      rowCount: 3
      locations:
        lineNumbers: A=6+1*2
        columnNumbers: A=9*3
     -
      pack: codeql/java-all#1
      relativePath: ext/sun.security.acl.model.yml
      index: 0
      firstRowId: 51633
      rowCount: 1
      locations:
        lineNumbers: A=6
        columnNumbers: A=9
     -
      pack: codeql/java-all#1
      relativePath: ext/sun.security.jgss.krb5.model.yml
      index: 0
      firstRowId: 51634
      rowCount: 2
      locations:
        lineNumbers: A=6+1
        columnNumbers: A=9*2
     -
      pack: codeql/java-all#1
      relativePath: ext/sun.security.krb5.model.yml
      index: 0
      firstRowId: 51636
      rowCount: 9
      locations:
        lineNumbers: A=6+1*8
        columnNumbers: A=9*9
     -
      pack: codeql/java-all#1
      relativePath: ext/sun.security.pkcs.model.yml
      index: 0
      firstRowId: 51645
      rowCount: 4
      locations:
        lineNumbers: A=6+1*3
        columnNumbers: A=9*4
     -
      pack: codeql/java-all#1
      relativePath: ext/sun.security.pkcs11.model.yml
      index: 0
      firstRowId: 51649
      rowCount: 3
      locations:
        lineNumbers: A=6+1*2
        columnNumbers: A=9*3
     -
      pack: codeql/java-all#1
      relativePath: ext/sun.security.provider.model.yml
      index: 0
      firstRowId: 51652
      rowCount: 2
      locations:
        lineNumbers: A=6+1
        columnNumbers: A=9*2
     -
      pack: codeql/java-all#1
      relativePath: ext/sun.security.ssl.model.yml
      index: 0
      firstRowId: 51654
      rowCount: 3
      locations:
        lineNumbers: A=6+1*2
        columnNumbers: A=9*3
     -
      pack: codeql/java-all#1
      relativePath: ext/sun.security.x509.model.yml
      index: 0
      firstRowId: 51657
      rowCount: 1
      locations:
        lineNumbers: A=6
        columnNumbers: A=9
     -
      pack: codeql/java-all#1
      relativePath: ext/sun.tools.jconsole.model.yml
      index: 0
      firstRowId: 51658
      rowCount: 28
      locations:
        lineNumbers: A=6+1*27
        columnNumbers: A=9*28
     -
      pack: codeql/threat-models#2
      relativePath: ext/supported-threat-models.model.yml
      index: 0
      firstRowId: 51686
      rowCount: 1
      locations:
        lineNumbers: A=6
        columnNumbers: A=9
     -
      pack: codeql/threat-models#2
      relativePath: ext/threat-model-grouping.model.yml
      index: 0
      firstRowId: 51687
      rowCount: 14
      locations:
        lineNumbers: A=8+3+1+3+1*5+3+1+5+1*2
        columnNumbers: A=9*14
